<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unreal C++ 工具开发最小实践]]></title>
    <url>%2Fposts%2Fcab0d099.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Unreal 的学习浩瀚且博杂，有时候一个最小 Demo 就是很好的学习起点。&emsp;&emsp;想起我以前翻阅 UE 的源码一大堆的文件，看得我是无比头疼。&emsp;&emsp;偶然间发现 CSDN YakSue 写了好多篇 Unreal 工具开发的 介绍。&emsp;&emsp;虽然没有配上 Github 链接，但是源码都在文章里面体现了。&emsp;&emsp;对于工具开发的不同模块都大有裨益。&emsp;&emsp;于是我将这些内容整合到一起，并且详细讲解其中实现的核心点。 Custom Assethttps://yaksue.blog.csdn.net/article/details/107646900https://github.com/FXTD-ODYSSEY/Unreal-Playground/tree/main/Plugins/Yaksue/TestAssetEditorPlg &emsp;&emsp;创建一个自定义的 Asset 需要有三个类 Asset (UObject) AssetFactory (UFactory) AssetTypeActions (FAssetTypeActions_Base) &emsp;&emsp;Asset 描述对象本身的数据&emsp;&emsp;AssetFactory 描述如何创建对象&emsp;&emsp;AssetTypeActions 返回对象显示的信息 &emsp;&emsp;AssetTypeActions 包含方法 GetName GetTypeColor GetSupportedClass GetCategories 用来描述对应的信息。&emsp;&emsp;GetCategories 会分配 Asset 所属的位置。 &emsp;&emsp;这个方式默认打开的窗口是 Details Panel.&emsp;&emsp;如果想要自定义打开的窗口需要添加 FAssetEditorToolkit 类&emsp;&emsp;AssetTypeActions 添加 OpenAssetEditor 方法将 Toolkit 生成并初始化。 1234567FAssetEditorToolkit GetToolkitFName GetBaseToolkitName GetWorldCentricTabPrefix GetWorldCentricTabColorScale Initialize RegisterTabSpawners &emsp;&emsp;RegisterTabSpawners 通过这个方法注册生产 Tab 的 ID&emsp;&emsp;后续通过 Initialize 方法调用 AddTab 将 Register 的 Tab 生成。&emsp;&emsp;最后通过 FAssetEditorToolkit::InitAssetEditor 完成 Toolkit 的初始化 &emsp;&emsp;如果不想将 Asset 放到 EAssetTypeCategories::Misc 的分类中。&emsp;&emsp;也可以构建一个新的标签附上去。&emsp;&emsp;只是需要将 factory 相关的 GetMenuCategories 放入去掉。&emsp;&emsp;我之前没有去掉，一直很疑惑为啥自定义菜单没有生效。 1234567891011FYaksueTestAssetTypeActions::FYaksueTestAssetTypeActions()&#123; // NOTE: 注册新的分类 IAssetTools &amp;AssetTools = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;("AssetTools").Get(); AssetCategory = AssetTools.RegisterAdvancedAssetCategory(FName(TEXT("Custom Assets")), LOCTEXT("CustomAssetCategory", "Custom Assets"));&#125;uint32 FYaksueTestAssetTypeActions::GetCategories()&#123; return AssetCategory;&#125; &emsp;&emsp;构造函数注册新的分类，头文件需要添加上定义 FYaksueTestAssetTypeActions(); EAssetTypeCategories::Type AssetCategory; Custom Filterhttps://yaksue.blog.csdn.net/article/details/120929455https://github.com/FXTD-ODYSSEY/Unreal-Playground/tree/main/Plugins/Yaksue/TestCustomFilter &emsp;&emsp;继承 UContentBrowserFrontEndFilterExtension 可以通过 override AddFrontEndFilterExtensions 方法扩展 filter。&emsp;&emsp;生成一个 FFrontendFilter 子类，然后通过 AddFrontEndFilterExtensions 将过滤对象添加到过滤列表里面。&emsp;&emsp;FFrontendFilter 最核心的方法就是 PassesFilter 它会将每个 item 传到这个函数返回 bool 来决定是否显示。 Slatehttps://yaksue.blog.csdn.net/article/details/110084013 12345678910111213141516171819202122232425262728293031323334353637383940414243// Put your tab content here!SNew(SOverlay)+ SOverlay::Slot()//底层[ SNew(SHorizontalBox) + SHorizontalBox::Slot().FillWidth(0.3f)//占30% [ SNew(SButton)1 ] + SHorizontalBox::Slot().FillWidth(0.7f)//占70% [ SNew(SVerticalBox) + SVerticalBox::Slot().FillHeight(0.5f)//占50% [ SNew(SButton) ] + SVerticalBox::Slot().FillHeight(0.5f)//占50% [ SNew(SButton) ] ]]+ SOverlay::Slot()//顶层[ SNew(SHorizontalBox) + SHorizontalBox::Slot().FillWidth(1.0f)//占满剩余空间 + SHorizontalBox::Slot().AutoWidth() [ SNew(SVerticalBox) + SVerticalBox::Slot().FillHeight(1.0f)//占满剩余空间 + SVerticalBox::Slot().AutoHeight() [ SNew(SBox) .HeightOverride(128) .WidthOverride(128) [ SNew(SButton) ] ] + SVerticalBox::Slot().FillHeight(1.0f)//占满剩余空间 ] + SHorizontalBox::Slot().FillWidth(1.0f)//占满剩余空间] &emsp;&emsp;使用 Unreal Slate 构建窗口，通过代码的属性结构来描述 UI 的构成和配置。 DockTab Layouthttps://yaksue.blog.csdn.net/article/details/109321869 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void FTestLayoutWindowModule::StartupModule()&#123; // This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module FTestLayoutWindowStyle::Initialize(); FTestLayoutWindowStyle::ReloadTextures(); FTestLayoutWindowCommands::Register(); PluginCommands = MakeShareable(new FUICommandList); PluginCommands-&gt;MapAction( FTestLayoutWindowCommands::Get().OpenLayoutWindow, FExecuteAction::CreateRaw(this, &amp;FTestLayoutWindowModule::PluginButtonClicked), FCanExecuteAction()); FLevelEditorModule&amp; LevelEditorModule = FModuleManager::LoadModuleChecked&lt;FLevelEditorModule&gt;("LevelEditor"); &#123; TSharedPtr&lt;FExtender&gt; MenuExtender = MakeShareable(new FExtender()); MenuExtender-&gt;AddMenuExtension("WindowLayout", EExtensionHook::After, PluginCommands, FMenuExtensionDelegate::CreateRaw(this, &amp;FTestLayoutWindowModule::AddMenuExtension)); LevelEditorModule.GetMenuExtensibilityManager()-&gt;AddExtender(MenuExtender); &#125; &#123; TSharedPtr&lt;FExtender&gt; ToolbarExtender = MakeShareable(new FExtender); ToolbarExtender-&gt;AddToolBarExtension("Settings", EExtensionHook::After, PluginCommands, FToolBarExtensionDelegate::CreateRaw(this, &amp;FTestLayoutWindowModule::AddToolbarExtension)); LevelEditorModule.GetToolBarExtensibilityManager()-&gt;AddExtender(ToolbarExtender); &#125; FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(TestLayoutWindowTabName, FOnSpawnTab::CreateRaw(this, &amp;FTestLayoutWindowModule::OnSpawnPluginTab)) .SetDisplayName(LOCTEXT("FTestLayoutWindowTabTitle", "TestLayoutWindow")) .SetMenuType(ETabSpawnerMenuType::Hidden); // ! InnerTab的内容： FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(InnerTabName, FOnSpawnTab::CreateLambda([](const FSpawnTabArgs&amp; SpawnTabArgs) &#123; return SNew(SDockTab) .TabRole(ETabRole::NomadTab) [ SNew(STextBlock) .Text(FText::FromString("InnerTab")) ]; &#125;)) .SetDisplayName(LOCTEXT("InnerTab", "InnerTab")) .SetMenuType(ETabSpawnerMenuType::Hidden); // ! InnerTab2的内容： FGlobalTabmanager::Get()-&gt;RegisterNomadTabSpawner(InnerTabName2, FOnSpawnTab::CreateLambda([](const FSpawnTabArgs&amp; SpawnTabArgs) &#123; return SNew(SDockTab) .TabRole(ETabRole::NomadTab) [ SNew(STextBlock) .Text(FText::FromString("InnerTab2")) ]; &#125;)) .SetDisplayName(LOCTEXT("InnerTab2", "InnerTab2")) .SetMenuType(ETabSpawnerMenuType::Hidden);&#125; &emsp;&emsp;核心处理是在插件加载的时候 StartupModule 调用 RegisterNomadTabSpawner 注册 Tab 1234void FTestLayoutWindowModule::PluginButtonClicked()&#123; FGlobalTabmanager::Get()-&gt;InvokeTab(TestLayoutWindowTabName);&#125; &emsp;&emsp;点击 GUI 会触发 Tab 生成，调用 OnSpawnPluginTab 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546TSharedRef&lt;SDockTab&gt; FTestLayoutWindowModule::OnSpawnPluginTab(const FSpawnTabArgs&amp; SpawnTabArgs)&#123; //原来的分页： const TSharedRef&lt;SDockTab&gt; NomadTab = SNew(SDockTab) .TabRole(ETabRole::NomadTab); //创建TabManager if (!TabManager.IsValid()) &#123; TabManager = FGlobalTabmanager::Get()-&gt;NewTabManager(NomadTab); &#125; //创建布局： if (!TabManagerLayout.IsValid()) &#123; TabManagerLayout = FTabManager::NewLayout("TestLayoutWindow") -&gt;AddArea ( FTabManager::NewPrimaryArea() -&gt;SetOrientation(Orient_Vertical) -&gt;Split ( FTabManager::NewStack() -&gt;SetSizeCoefficient(.4f) -&gt;AddTab(InnerTabName, ETabState::OpenedTab) ) -&gt;Split ( FTabManager::NewStack() -&gt;SetSizeCoefficient(.4f) -&gt;AddTab(InnerTabName2, ETabState::OpenedTab) ) ); &#125; //从布局中恢复得到控件 TSharedRef&lt;SWidget&gt; TabContents = TabManager-&gt;RestoreFrom(TabManagerLayout.ToSharedRef(), TSharedPtr&lt;SWindow&gt;()).ToSharedRef(); //设置内容控件 NomadTab-&gt;SetContent( TabContents ); return NomadTab;&#125; &emsp;&emsp;这里将之前注册的 Tab 唤起。 Viewporthttps://yaksue.blog.csdn.net/article/details/109258860 &emsp;&emsp;引入默认的 SEditorViewport 类&emsp;&emsp;然后 override 方法 MakeEditorViewportClient 12345TSharedRef&lt;FEditorViewportClient&gt; STestLevelEditorViewport::MakeEditorViewportClient()&#123; TSharedPtr&lt;FEditorViewportClient&gt; EditorViewportClient = MakeShareable(new FEditorViewportClient(nullptr)); return EditorViewportClient.ToSharedRef();&#125; &emsp;&emsp;然后Slate 代码直接使用 SNew(STestLevelEditorViewport) 初始化界面即可。&emsp;&emsp;不过这个方式沿用了 Viewport ，如何构建一个自定义 Viewport 呢？ 12345678910111213141516171819TSharedRef&lt;FEditorViewportClient&gt; STestEditorViewport::MakeEditorViewportClient()&#123; PreviewScene = MakeShareable(new FPreviewScene()); //向预览场景中加一个测试模型 &#123; //读取模型 UStaticMesh* SM = LoadObject&lt;UStaticMesh&gt;(NULL, TEXT("StaticMesh'/Engine/EngineMeshes/Cube.Cube'"), NULL, LOAD_None, NULL); //创建组件 UStaticMeshComponent* SMC = NewObject&lt;UStaticMeshComponent&gt;(); SMC-&gt;SetStaticMesh(SM); //向预览场景中增加组件 PreviewScene-&gt;AddComponent(SMC, FTransform::Identity); &#125; TSharedPtr&lt;FEditorViewportClient&gt; EditorViewportClient = MakeShareable(new FEditorViewportClient(nullptr, PreviewScene.Get())); return EditorViewportClient.ToSharedRef();&#125; &emsp;&emsp;新建一个自定义的 FPreviewScene ，可以将物体实例化添加到场景当中。&emsp;&emsp;将 PreviewScene 传入到 FEditorViewportClient 中，这样 Viewport 就显示独立的场景。 1234TSharedPtr&lt;SWidget&gt; STestEditorViewport::MakeViewportToolbar()&#123; return SNew(SCommonEditorViewportToolbarBase, SharedThis(this));&#125; &emsp;&emsp;使用上面的代码可以构建出默认 Viewport 的 Toolbar。 GraphEditorhttps://yaksue.blog.csdn.net/article/details/107945507https://yaksue.blog.csdn.net/article/details/108020797https://yaksue.blog.csdn.net/article/details/108227439https://yaksue.blog.csdn.net/article/details/109347063 EditorMode]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya C++ pyd 模块开发]]></title>
    <url>%2Fposts%2Fce449c32.html</url>
    <content type="text"><![CDATA[前言作者: [[👨‍💻sonictk]] https://github.com/sonictk/maya_python_c_extension &emsp;&emsp;这篇文章也是参考 sonictk 大佬的提供的 pyd 开发文章。&emsp;&emsp;文章也提到之前的 hot reload 方案已经解决了很多 C++ 开发困难的问题。&emsp;&emsp;然而还是有很多情况需要开发一个 python 的 C++ 模块实现 Maya C++ API 的 调用。&emsp;&emsp;这个情况有点像是 Unreal 暴露 C++ API 到 Python 一样。 [[17_Maya 编译 c 相关 Python 库 &amp; pyd 编译]] &emsp;&emsp;之前我也写过关于 Maya pyd 编译的文章，但是这个文章是用 Cython 自动生成 C 代码编译实现的，这次是手写 pyd。 什么是 pyd &emsp;&emsp;pyd 本质上也是一个 dll 文件，就像 Maya 插件的 mll 一样。&emsp;&emsp;只是 pyd 规定了一些暴露规则，从而让 python 解释器可以读取。&emsp;&emsp;这也是 Python 称之为胶水语言的一大特点，它可以无缝和 C++ 编译的模块进行交互。&emsp;&emsp;因此很多 C++ 的包 比如 Qt 等可以暴露接口到 Python 实现调用。 pyd hello world 案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;Python.h&gt;#include &lt;maya/MGlobal.h&gt;#include &lt;stdio.h&gt;static const char MAYA_PYTHON_C_EXT_DOCSTRING[] = "An example Python C extension that makes use of Maya functionality.";static const char HELLO_WORLD_MAYA_DOCSTRING[] = "Says hello world!";// NOTE(timmyliang): 调用 MGlobal API 打印 Python 传递的字符串static PyObject *pyHelloWorldMaya(PyObject *module, PyObject *args)&#123; const char *inputString; if (!PyArg_ParseTuple(args, "s", &amp;inputString)) &#123; return NULL; &#125; PyGILState_STATE pyGILState = PyGILState_Ensure(); MGlobal::displayInfo(inputString); PyObject *result = Py_BuildValue("s", inputString); PyGILState_Release(pyGILState); return result;&#125;// NOTE(timmyliang): 定义模块的函数列表static PyMethodDef mayaPythonCExtMethods[] = &#123; &#123;"hello_world_maya", pyHelloWorldMaya, METH_VARARGS, HELLO_WORLD_MAYA_DOCSTRING&#125;, &#123;NULL, NULL, 0, NULL&#125; // NOTE: (sonictk) Sentinel value for Python&#125;;// NOTE(timmyliang): python2 初始化函数规范 init&lt;module_name&gt; #if PY_MAJOR_VERSION == 2extern "C" PyMODINIT_FUNC initpy_hello()&#123; return Py_InitModule3("py_hello", mayaPythonCExtMethods, MAYA_PYTHON_C_EXT_DOCSTRING);&#125;// NOTE(timmyliang): python3 初始化函数规范 PyInit_&lt;module_name&gt; #elif PY_MAJOR_VERSION == 3extern "C" PyMODINIT_FUNC PyInit_py_hello()&#123; static PyModuleDef hello_module = &#123; PyModuleDef_HEAD_INIT, "py_hello", // Module name to use with Python import statements MAYA_PYTHON_C_EXT_DOCSTRING, // Module description 0, mayaPythonCExtMethods // Structure that defines the methods of the module &#125;; return PyModule_Create(&amp;hello_module);&#125;#endif &emsp;&emsp;上面的代码就是一个小案例，将 C++ 编译成 pyd 给 python 调用。&emsp;&emsp;并且这里引用了 Maya 的 API ，因此只能使用 Maya 的 Python Interpreter (mayapy.exe) 进行加载。&emsp;&emsp;如果使用其他 Python 导入这个模块会出现如下的错误 1234Traceback (most recent call last): File "d:/Obsidian/Personal/2_Area/📝Blog/CG/Maya/C++/test_load.py", line 5, in &lt;module&gt; import py_helloImportError: DLL load failed while importing py_hello: 找不到指定的程序。 &emsp;&emsp;pyd 的 C++ 代码包含三个部分 python 定义的函数 函数列表定义 (需要传入上面的 C++ 编写的 Python 函数) 模块定义 (传入上面的 函数列表) &emsp;&emsp;最后生成模块部分，Python2 和 Python3 暴露的 API 不一致，可以用宏来区分。 &emsp;&emsp;编译这个 cpp 需要加上 Maya include 目录的头文件，以及链接 Maya lib 的静态库文件。&emsp;&emsp;另外编译 pyd 需要特别注意的是，它也需要想 mll 一样暴露出初始化的函数。&emsp;&emsp;在 python2 下是 init&lt;module_name&gt; 开头，在 python3 下是 PyInit_&lt;module_name&gt; 开头。&emsp;&emsp;在 cpp 里面配置编译环境是个相当让人头疼的问题。&emsp;&emsp;我在自己的 CMakeMaya 库里面已经配置好了编译用的环境，&emsp;&emsp;具体的使用方法可以看 readme 或者参考我的文章 [[01_Maya CMake 构建 C++ 插件编译环境]] &emsp;&emsp;在我提供的环境下执行 doit c -p pyd -v 2020 即可编译出 pyd 到 plug-ins\Release\maya2022\pyd\py_hello.pyd&emsp;&emsp;需要注意 pyd 在不同的平台不同Maya版本都需要单独编译。这里我提供了编译好给 Windows64 Maya2020 的 pyd 导入 pyd 引入 Maya C++ 节点 &emsp;&emsp;在相应的版本执行就可以看到如期触发了 maya API 的方法。&emsp;&emsp;也可以用这个方式注册 Maya 的节点和 Mel 命令，具体可以看 pyDeformer 的代码。&emsp;&emsp;只是由于没有 initializePlugin 拿不到传进来的 MObject 实例化 MFnPlugin。&emsp;&emsp;我测试的 py_deformer 用了 MFnPlugin::findPlug 拿到内置插件 matrixNodes 提供的 MObject 来注册节点。&emsp;&emsp;答案是可以实现的，而且新加入的节点也会显示在 matrixNodes 上。 &emsp;&emsp;这种骚操作不建议使用，而且也不知道会不会有什么 BUG 导致 Maya 崩溃。&emsp;&emsp;另外没有办法触发 uninitializePlugin 来注销这个节点的注册。 pyd mll 缝合怪 &emsp;&emsp;基于上面的测试我发现还可以生成出既是 Maya 插件又是 Python 模块的 缝合怪文件。&emsp;&emsp;因为 C++ 只要编译的时候 export 出对应的方法就可以加载。 &emsp;&emsp;只是 Python 加载二进制包要求文件后缀为 pyd ，Maya 加载二进制插件要求文件命名为 mll 才可以。&emsp;&emsp;解决这个问题，可以用软连接或者拆分成两个文件来实现，经过测试是可以的，具体可以看 pyCommand 的 测试代码 。 使用 mll 嵌入 python 模块 &emsp;&emsp;上面主要实现按照 python 的规范加载包的操作，sonitck 的文章还提供了一个方案，加载 mll 获取到 python 包的方式。&emsp;&emsp;做法也不复杂，就是在 initializePlugin 的时候加上加上 C++ 的模块。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;Python.h&gt;#include &lt;maya/MFnPlugin.h&gt;#include &lt;maya/MGlobal.h&gt;const char *kAUTHOR = "TimmyLiang";const char *kVERSION = "1.0.0";const char *kREQUIRED_API_VERSION = "Any";static const char HELLO_WORLD_MAYA_DOCSTRING[] = "Says hello world!";static const char MAYA_PYTHON_C_EXT_DOCSTRING[] = "An example Python C extension that makes use of Maya functionality.";PyObject *module = NULL;static PyObject *pyHelloWorldMaya(PyObject *module, PyObject *args)&#123; const char *inputString; if (!PyArg_ParseTuple(args, "s", &amp;inputString)) &#123; return NULL; &#125; PyGILState_STATE pyGILState = PyGILState_Ensure(); MGlobal::displayInfo(inputString); PyObject *result = Py_BuildValue("s", inputString); PyGILState_Release(pyGILState); return result;&#125;static PyMethodDef mayaPythonCExtMethods[] = &#123; &#123;"hello_world_maya", pyHelloWorldMaya, METH_VARARGS, HELLO_WORLD_MAYA_DOCSTRING&#125;, &#123;NULL, NULL, 0, NULL&#125;&#125;;MStatus initializePlugin(MObject obj)&#123; MFnPlugin plugin(obj, kAUTHOR, kVERSION, kREQUIRED_API_VERSION); if (!Py_IsInitialized()) Py_Initialize(); if (Py_IsInitialized()) &#123; PyGILState_STATE pyGILState = PyGILState_Ensure();// NOTE(TimmyLiang): python2 直接初始化模块就不会变成 built-in 模块#if PY_MAJOR_VERSION == 2 module = Py_InitModule3("mll_py", mayaPythonCExtMethods, MAYA_PYTHON_C_EXT_DOCSTRING);// NOTE(TimmyLiang): python3 用官方的方式添加模块不行，可能是因为 Py_Initialize 已经执行了#elif PY_MAJOR_VERSION == 3 // NOTE(TimmyLiang): 参考 https://github.com/LinuxCNC/linuxcnc/issues/825 将模块加到 sys.modules 里面 static PyModuleDef hello_module = &#123; PyModuleDef_HEAD_INIT, "mll_py", // Module name to use with Python import statements MAYA_PYTHON_C_EXT_DOCSTRING, // Module description 0, mayaPythonCExtMethods // Structure that defines the methods of the module &#125;; module = PyModule_Create(&amp;hello_module); PyObject *sys_modules = PyImport_GetModuleDict(); PyDict_SetItemString(sys_modules, "mll_py", module);#endif MGlobal::displayInfo("Registered Python bindings!"); if (module == NULL) &#123; return MStatus::kFailure; &#125; // NOTE(timmyliang): 增加引用计数(确保不会 gc) Py_INCREF(module); PyGILState_Release(pyGILState); &#125; return MStatus::kSuccess;&#125;MStatus uninitializePlugin(MObject obj)&#123; MStatus status; // NOTE(timmyliang): 减少引用计数 Py_DECREF(module); return status;&#125; &emsp;&emsp;上面的代码兼容 python2 python3 版本。&emsp;&emsp;python2 直接用默认的 Py_InitModule 方法就可以添加，如果在 Python 打印模块会提示 &lt;module &#39;mll_py&#39; (built-in)&gt;&emsp;&emsp;但是 python3 下面不行，后来查找了 Github 的 issue 通过将模块添加到 sys.modules 下面解决问题。&emsp;&emsp;只是模块打印就是普通的模块。&emsp;&emsp;那为什么将模块放到 sys.modules 就可以了，这 Python 的 import 机制有关。 [[01_Python Import 模块机制]] &emsp;&emsp;这个方式可以将一些 C++ 的 API 暴露给 Python，只是这个操作需要更多的说明。&emsp;&emsp;否则没人知道这个 mll 居然添加一个 Python 模块。 总结 &emsp;&emsp;以上就是 pyd 编译的各种折腾结果。&emsp;&emsp;社区里面值得说道的有 cmdc 基于 pybind11 编译的二次封装 C++ API 库。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal C++ VScode 配置]]></title>
    <url>%2Fposts%2F51c731db.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这次尝试在 VScode 进行引擎编译。&emsp;&emsp;网上一查发现，官方其实有做支持的，具体可以参考这篇文章 链接&emsp;&emsp;这篇文章传播甚广，可以参照和这个方式配置 VScode 编译。 https://www.youtube.com/watch?v=fydvKedIxKkhttps://github.com/boocs/ue4-tellisense-fixes C++ 编译过程深度参考学习这边文章 https://ericlemes.com/2018/11/21/compiling-c-code/鉴于本人的 C++ 水平一般，建议阅读原文 编译步骤 &emsp;&emsp;C++ 编译可能会用到下面的文件。 .cpp 文件编译成 .obj 生成静态库 .lib 生成动态库 .dll 生成可执行文件 executable VS 工具链 &emsp;&emsp;.sln 全称是 solution 解决方案，是 VS 的项目配置文件。 (整合了 .vcxproj .csproj)&emsp;&emsp;他可以同时配置多个项目，最后通过 MSBuild 来构建&emsp;&emsp;sln 包含了项目的各种头文件依赖，库引用等描述，执行顺序，通过这个 IDE 就知道怎么编译你的项目。 &emsp;&emsp;Xcode 的情况也是类似的。&emsp;&emsp;其中比较特别的时 CMake ，通过 CMakeLists.txt 文件可以根据不同平台生成工程配置文件。 第一步 编译输入: Defines Include 文件夹路径Include directories 预编译头文件 (如果有用到的话) 源代码 输出: .obj 文件 &emsp;&emsp;MSBuild 使用 CL.exe 进行 C++ 编译。 可能的路径 C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\bin\Hostx64\x64\cl.exe&emsp;&emsp;需要安装 VS 或者用 choco 来安装 &emsp;&emsp;编译的时候会根据 宏定义(比如 #ifdef)动态 改变编译行为&emsp;&emsp;通过这个方式可以在不同的平台编译出不同的行为。&emsp;&emsp;C++ 最终编译成对应平台的二进制，这个设计和 Java C# 都不同。 &emsp;&emsp;头文件最终会拼接到 C++ 里面进行编译，所以需要加上 #pragma once 或者 #if 来避免多次定义。&emsp;&emsp;预编译头则可以生成 .pch 文件实现头文件复用。 第二步 链接输入: 一些源码生成 .obj 文件 一些源码生成 .lib 文件 第三方的 lib 和 obj 文件 输出: .dll 或者 .exe &emsp;&emsp;这一步会将生成的中间文件合并成 dll 或者 exe&emsp;&emsp;这个过程会完成很多优化的步骤，把不运行的部分清理掉。&emsp;&emsp;最后会将一些平台的 lib 引入确保它在平台上可以运行，比如 wincrt (Windows C Runtime library) 等等&emsp;&emsp;并且 lib 也有很多种类，有 release 版本和 debug 版本等等。 Unreal Build Toolhttps://ericlemes.com/2018/11/23/understanding-unreal-build-tool/ CS 配置文件说明https://www.bilibili.com/read/cv15297017/ &emsp;&emsp;Unreal 使用自己开发的 UnrealBuildTool 来编译自己的 C++ 代码&emsp;&emsp;与 [[💾CMake]] 类似的，UnrealBuildTool 会引用你需要在相应的模块添加 .build.cs 的代码文件来描述仓库链接的东西。&emsp;&emsp;.build.cs 之上配套了 Private Public 文件夹分别放置暴露和不暴露的代码。&emsp;&emsp;.target.cs 则可以用来定义输出的类型，有 Game Editor Client Server 几种类型。 生成工程文件 &emsp;&emsp;当我们对 uproject 文件右键生成 project 的时候背后执行就是 UnrealBuildTool 1C:&#x2F;EpicGames&#x2F;git&#x2F;UnrealEngine-4.27&#x2F;Engine&#x2F;Binaries&#x2F;DotNET&#x2F;UnrealBuildTool.exe -projectfiles -project&#x3D;&quot;D:&#x2F;EpicGames&#x2F;test_plugin&#x2F;test_plugin.uproject&quot; -game -engine -progress -log&#x3D;&quot;D:\EpicGames\test_plugin&#x2F;Saved&#x2F;Logs&#x2F;UnrealVersionSelector-2022.07.12-15.50.08.log&quot; &emsp;&emsp;UnrealBuildTool 会根据 .build.cs 和 .target.cs 里面配置模块路径生成 sln 工程文件。 编译 C++ 1D:&#x2F;EpicGames&#x2F;UE_4.27&#x2F;Engine&#x2F;Binaries&#x2F;DotNET&#x2F;UnrealBuildTool.exe Development Win64 -Project&#x3D;&quot;D:&#x2F;EpicGames&#x2F;Unreal_Playground&#x2F;Unreal_Playground.uproject&quot; -TargetType&#x3D;Editor -Progress -NoEngineChanges -NoHotReloadFromIDE &emsp;&emsp;这个 Build.bat 背后还是调用 UnrealBuildTool.exe 通过它来编译 C++&emsp;&emsp;上面生成工程时候 .build.cs 和 .target.cs 只是收集了路径。&emsp;&emsp;现在会再次读取这两个文件来获取一些编译用的属性。&emsp;&emsp;然根据配置解决各个模块的依赖关系。 &emsp;&emsp;最后会运行 UnrealHeaderTool 将 UObject 的一些特性注入到 UObject 的 cpp 文件当中。&emsp;&emsp;这也说明了为什么需要引入 .generated.h 的头文件。&emsp;&emsp;准备好了所有代码之后再调用相应的编译工具去构建 C++。 VScode 编译配置 &emsp;&emsp;了解了 C++ 编译和 Unreal 全家桶的编译逻辑之后。&emsp;&emsp;我们终于可以回归到本篇文章的正题。 http://jollymonsterstudio.com/2018/11/02/unreal-c-with-visual-studio-code/ &emsp;&emsp;按照这里提供的文章就可以用 Unreal 官方的方式配置好 .vscode 目录的编译配置。&emsp;&emsp;后续只要 Ctrl + shift + B 就可以触发编译。&emsp;&emsp;编译背后的逻辑就在上面解释了。 &emsp;&emsp;相应的我也可以用 python 脚本来触发编译。&emsp;&emsp;sln 工程并不是必须的，不过 VS 有 VA 查找代码比较快。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya C++ mll hot reload 研究]]></title>
    <url>%2Fposts%2Fe6dc9087.html</url>
    <content type="text"><![CDATA[前言作者: [[👨‍💻sonictk]] https://sonictk.github.io/maya_hot_reload_example_public/ &emsp;&emsp;详细的说明 &amp; 教程在上面的链接。 &emsp;&emsp;Maya 用写 C++ 开发会比较痛苦，一方面是编译问题总是让人烦躁，另一方面加载了 mll 会导致占用，测试起来很不方便。&emsp;&emsp;所以我之前推崇用 Python OpenMaya 做原型设计再转 C++&emsp;&emsp;当然 sonictk 也提到 Fabric Engine 和 Maya Bifrost 使用的时 LLVM IR 的方案来实现 JIT 编译。&emsp;&emsp;具体可以参考另一个项目 giordi91/babycpp LLVM 热加载 &emsp;&emsp;babycpp 基于 LLVM 的解决方案我编译没有通过，代码报类型错误，因此也没有测试成功。&emsp;&emsp;不过也了解了 LLVM 是怎么实现热更新的，运行逻辑和 Python 有点像，但是从本质上不一样。 &emsp;&emsp;传统的编译器需要有 前端 优化器 后端组成，一般前端是语言，通过 tokenize 和 AST 等方案将语言解析然后通过优化器生成后端的二进制文件。&emsp;&emsp;LLVM 推出了 LLVM IR 中间语言，这样不管前端用什么语言开发，只要有对应的解析工具生成出 LLVM IR ，j就可以利用 LLVM IR 的优化生成 二进制机器语言高效运行。&emsp;&emsp;babycpp 项目就基于 LLVM IR 的机制开发了一个自己的简化版 C++ 语言，通过 LLVM IR JIT 编译动态改变运行逻辑。 &emsp;&emsp;我目前个人理解来看，LLVM IR 模式和 Python 模式还是不一样的，Python 是调用自己编译好的模块来运行的，而 LLVM IR 是直接运行时(JIT)生成机器语言，JIT模式的运行效率有时候比 C++ 的静态编译还要高，因为 JIT 可以根据运行过程推断程序下一步的执行来优化非必要的运行逻辑，所以 LLVM IR 的性能要比 Python 好得多。其实我后面了解了一下 numba 提速 Python 的原理就是利用 LLVM 标准实现的。 &emsp;&emsp;不过也正如 sonictk 的文章所提到的，这个方案只能调用暴露的东西，无法对内存的细节进行处理。 基于 dll 加载https://github.com/FXTD-ODYSSEY/CMakeMaya/tree/master/projects/sonictk/hot_reload &emsp;&emsp;如果使用作者提供的 github 仓库的代码编译会有问题，作者的 thirdparty 仓库编译不通过。&emsp;&emsp;所以我后面是根据作者文章的代码稍微调整组装到一起实现的。 &emsp;&emsp;详细讲解之前，我先用最简单的话说明这个 hotreload 方案。 编译一个变形器的 mll 插件 和 带逻辑的 dll 文件 mll 加载之后会调用 dll 的function进行计算 修改逻辑之后重新编译 dll mll 会重新健在最新的 dll 实现热更新。 实现思路https://sonictk.github.io/maya_hot_reload_example_public/getting_started/ &emsp;&emsp;这篇文章非常好，不仅仅讲解了作者 hot reload 的思路，还附带了 windows lib dll 之间的运行逻辑等知识。 目录结构 &emsp;&emsp;代码结构上需要将插件分成两个部分，一个是调用 logic 生成 dll&emsp;&emsp;另一个是 deformer 的代码生成 mll&emsp;&emsp;具体编译配置通过 cmake 配置两个 project 实现。 123456789101112131415.├── logic│ ├── logic.cpp dll 代码逻辑│ └── logic.h├── maya_deformer│ ├── deformer_platform.cpp 调用 &lt;windows.h&gt; API 加载 dll│ ├── deformer_platform.h│ ├── deformer.cpp Maya 变形器 deform 调用 deform_platform 提供的方法│ ├── deformer.h│ ├── plugin_main.cpp Maya mll 插件初始化函数│ └── plugin_main.h├── scripts│ └── test_deformer.py 测试插件是否修改├── CMakeLists.txt└── readme.md dll 加载方案 &emsp;&emsp;上面三个函数调用了 window API 提供的 LoadLibrary FreeLibrary GetProcAddress 加载 dll &emsp;&emsp;然后将分装到 loadDeformerLogicDLL 和 unloadDeformerLogicDLL 方法里面。&emsp;&emsp;deformer 在触发计算的时候调用加载 dll。 &emsp;&emsp;这样每次触发节点运算的时候会自动按照 dll 的路径进行加载。 &emsp;&emsp;问题是怎么在 C++ 动态获取到当前 dll 的路径呢？ &emsp;&emsp;在插件加载的时候通过 plugin.loadPath 可以拿到当前 mll 加载的路径。&emsp;&emsp;只要在同一个路径找 logic.dll 路径即可。 遇到的坑编译 dll 占用问题 &emsp;&emsp;需要注意的是，mll 被 Maya 加载会产生占用，mll 去加载 dll 也会造成占用。&emsp;&emsp;只有执行 unloadDeformerLogicDLL 才会解除 dll 的占用&emsp;&emsp;但是占用会造成编译失败。 &emsp;&emsp;于是我用 CMake 的 API 将旧的 logic.dll 改名叫 logic_old.dll&emsp;&emsp;windows 下被占用的文件还是可以改名的。&emsp;&emsp;然后执行编译生成新的 logic.dll&emsp;&emsp;这时候需要手动触发 Maya 节点的更新，这样就会按照原来的路径加载新的 dll。 &emsp;&emsp;CMake 怎么判断 dll 是否占用，我也没有找到合适方法，于是我想到直接删除这个 dll 在判断 dll 是否存在的方法。 extern 问题12static MString kPluginLogicLibraryPath;static DeformerLogicLibrary kLogicLibrary; &emsp;&emsp;源码这两个变量用的是 static 静态变量。&emsp;&emsp;但是不知道为什么在其他 cpp 文件里面调动得到的是不同的 内存 地址。 https://blog.csdn.net/sksukai/article/details/105612235 12extern MString kPluginLogicLibraryPath;extern DeformerLogicLibrary kLogicLibrary; &emsp;&emsp;后续是改成 extern&emsp;&emsp;然后在 plugin_main.cpp 里面初始化变量解决问题。 总结 &emsp;&emsp;这个方法切实解决了 节点热加载的问题，不需要 unloadPlugin 清空场景之类的操作，测试起来方便了许多。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya CMake 构建 C++ 插件编译环境]]></title>
    <url>%2Fposts%2F5875a169.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;过去构建 Maya C++ 插件是按照 Autodesk 官方提供的流程，在 VS 里面配置项目工程。 参考链接&emsp;&emsp;通过配置 devkit 的 pluginwizard 来构建项目。&emsp;&emsp;但是使用 VS 配置 Maya 依赖的头文件和 lib 其实挺不方便的。 &emsp;&emsp;依赖和修改都在不同选项里面，配置起来要搞半天。&emsp;&emsp;而且这个工程配置只能兼容 Windows ，如果我们要在 Linux 环境下编译，整个流程又完全不一样了。&emsp;&emsp;其实解决这种问题，有专门的工具去做。&emsp;&emsp;这就是 CMake&emsp;&emsp;通过 cmake 配置可以生成不同平台的工程文件，不需要打开 IDE 就可以调用 compiler 编译结果。 https://github.com/volodinroman/CMakeMaya &emsp;&emsp;这个仓库是别人配置好的基于 CMake 构建 Maya 插件的仓库。 Doit 自动构建环境 &emsp;&emsp;但是构建编译环境还是挺麻烦的，一方面需要下载 VS 和 CMake&emsp;&emsp;另外还要配置好 Maya 提供的 SDK https://github.com/FXTD-ODYSSEY/CMakeMaya &emsp;&emsp;我这个仓库提供了懒人包环境，只需要配置有 Python 环境和poetry 库。&emsp;&emsp;在仓库的目录，执行 poetry install 和 poetry shell 就可以进入开发虚拟环境。(注: 需要管理员权限)&emsp;&emsp;poetry 会自动安装配置好的依赖，包括 doit 框架&emsp;&emsp;执行 doit init 会调用 choco 安装 VS 的依赖，以及 CMake&emsp;&emsp;这个过程需要等待一段时间。 &emsp;&emsp;执行完之后 VS Build Tool 就添加到系统了。&emsp;&emsp;但还是找不到 C++ compiler ，需要手动打开 installer 下载 C++ CMake 开发包。 &emsp;&emsp;使用 doit SDK -v 2020 会下载 Maya 官方的 devkit 到仓库的 SDK 目录。&emsp;&emsp;准备好环境之后，还需要安装好 maya 2020&emsp;&emsp;如此就是完备的编译环境，只需要用 doit c 执行 cmake 编译命令来编译 C++ 插件。 1doit c -p weightDriver -v 2020 &emsp;&emsp;使用 -p 可以指定编译的项目，-v 可以指定编译的 Maya 版本，默认不指定会编译全部项目的 2020 版本&emsp;&emsp;-p 支持完整的projects 相对路径或者最终目录指定 12doit c -p IngoClemens&#x2F;weightDriverdoit c -p weightDriver &emsp;&emsp;执行 doit 的时候会用 python 识别将末端目录变成完整的相对目录 &emsp;&emsp;下面是完整执行编译的流程 &emsp;&emsp;doit 背后执行的是 拼接输入 执行 cmake 命令 1cmake -Wno-dev -G &quot;Visual Studio 16 2019&quot; -DMAYA_VERSION&#x3D;&#123;version&#125; -DMAYA_PROJECT&#x3D;&#123;project&#125;. -B build &emsp;&emsp;DMAYA_VERSION 指定 Maya 版本号&emsp;&emsp;DMAYA_PROJECT 指定 Maya 项目，多个项目可以用 ; 分割。&emsp;&emsp;这个命令会读取根目录的 CMakeLists.txt 根据 VS2019 的配置生成 sln 文件到 Build 目录。&emsp;&emsp;windows 下如果需要 Debug 也可以用 VS 打开 sln 去配置 Debug 工具。 1cmake --build build --config Release &emsp;&emsp;后面会执行 build 命令根据配置编译输出到指定目录。 中文乱码坑[[💡Vscode terminal 中文乱码]] &emsp;&emsp;Window Terminal 默认不支持 MSBuild 的字符输出。 &emsp;&emsp;需要在 terminal 上执行 chcp 65001 切换字符集。 添加新工程 &emsp;&emsp;如果需要添加自己的 mll 需要自己填充 CMakeLists.txt 配置&emsp;&emsp;使用 doit new 可以快速生成 插件 编译模板 cmake 配置说明projects 下每个项目目录都有对应的 CMakeLists.txt 1234567891011121314151617181920# 设置输出目录set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE $&#123;CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE&#125;/maya$&#123;MAYA_VERSION&#125;)# 设置项目名称 (一般编译的文件名取项目名)project(&#123;&#123;cookiecutter.project_name&#125;&#125;)# 添加编译的文件file(GLOB SRCS "*.cpp" "*.h")# 添加头文件依赖include_directories($&#123;MAYA_INCLUDE_DIR&#125;) # 添加 lib 库目录link_directories($&#123;MAYA_LIBRARY_DIR&#125;) # 链接源码add_library($&#123;PROJECT_NAME&#125; SHARED $&#123;SRCS&#125;) # 链接 libtarget_link_libraries($&#123;PROJECT_NAME&#125; $&#123;MAYA_LIBRARIES&#125;) # mll 输出配置MAYA_PLUGIN($&#123;PROJECT_NAME&#125;) &emsp;&emsp;大部分的结构如上图，默认模板如上。&emsp;&emsp;我加上了注释说明。 &emsp;&emsp;MAYA_PLUGIN方法将 mll 的 initializePlugin uninitializePlugin 两个方法暴露出来(Maya 加载用)，并且将 dll 的后缀改为 mll。 总结 &emsp;&emsp;这个环境我通过 虚拟机 测试过，在 win10 环境是没有问题。&emsp;&emsp;通过 cmake 配置可以快速构建好 C++ 编译环境，比起以前折腾 VS 来方便太多了。&emsp;&emsp;利用 choco 来安装依赖也解决了各种缺库导致起不来的问题。&emsp;&emsp;通过这个人懒人包可以极大降低 Maya 写 C++ 的难度。 2022-7-8 补充说明 &emsp;&emsp;最近利用 submodule 添加了很多社区的 C++ 库。&emsp;&emsp;clone 仓库之后需要用执行 git submodule update --init 来拉取 submodule &emsp;&emsp;一些注意事项请参阅 readme 文档]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 导出 MetaHuman 控制器关键帧]]></title>
    <url>%2Fposts%2F1b238b83.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;MetaHuman 已经在数字人领域里面相当成熟的解决方案。&emsp;&emsp;并且 UE 官方开发了源码工程。&emsp;&emsp;目前 github 上有不少人演示自己套用 MetaHuman 动画的效果。&emsp;&emsp;于是我自己也尝试着想将它 UE 里面的控制器动画导出来。&emsp;&emsp;然而却发现行不通。 &emsp;&emsp;它的控制器关键帧是在 sequencer 里面。&emsp;&emsp;最初是尝试将 sequencer 的资源全部导出成 FBX。&emsp;&emsp;然而控制器的关键帧并没有跟随导入到 FBX 当中。 &emsp;&emsp;于是我想到可以用 unreal python 读取关键帧数据导出 json&emsp;&emsp; Maya 再读取数据设置关键帧到控制器上。 unreal python 导出关键帧 &emsp;&emsp;有思路之后就好办。&emsp;&emsp;之前我也写过脚本来获取 sequencer 关键帧的。&emsp;&emsp;需要注意如果想要使用 unreal python 的 API 需要开启相应的 C++ 插件。 &emsp;&emsp;否则 python 会获取不到相应的 API 报错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Import built-in modulesfrom collections import defaultdictimport jsonimport os# Import local modulesimport unrealDIR = os.path.dirname(os.path.abspath(__file__))def unreal_progress(tasks, label="进度", total=None): total = total if total else len(tasks) with unreal.ScopedSlowTask(total, label) as task: task.make_dialog(True) for i, item in enumerate(tasks): if task.should_cancel(): break task.enter_progress_frame(1, "%s %s/%s" % (label, i, total)) yield itemdef main(): # NOTE: 读取 sequence sequence = unreal.load_asset('/Game/Sequencer/MetaHumanSample_Sequence.MetaHumanSample_Sequence') # NOTE: 收集 sequence 里面所有的 binding binding_dict = defaultdict(list) for binding in sequence.get_bindings(): binding_dict[binding.get_name()].append(binding) # NOTE: 遍历命名为 Face 的 binding for binding in unreal_progress(binding_dict.get("Face", []), "导出 Face 数据"): # NOTE: 获取关键帧 channel 数据 keys_dict = &#123;&#125; for track in binding.get_tracks(): for section in track.get_sections(): for channel in unreal_progress(section.get_channels(), "导出关键帧"): if not channel.get_num_keys(): continue keys = [] for key in channel.get_keys(): frame_time = key.get_time() frame = frame_time.frame_number.value + frame_time.sub_frame keys.append(&#123;"frame": frame, "value": key.get_value()&#125;) keys_dict[channel.get_name()] = keys # NOTE: 导出 json name = binding.get_parent().get_name() export_path = os.path.join(DIR, "&#123;0&#125;.json".format(name)) with open(export_path, "w") as wf: json.dump(keys_dict, wf, indent=4) &emsp;&emsp;上面的脚本会定位 MetaHuman 的 sequence 资源，然后导出关键帧的信息为 json &emsp;&emsp;导出会在脚本目录输出两个 json 文件。&emsp;&emsp;Maya 可以解析这个这两个 json 将关键帧设置到 控制器上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Import built-in modulesimport jsonimport osimport traceback# Import third-party modulesimport pymel.core as pmDIR = os.path.dirname(os.path.abspath(__file__))def progress(seq, status="", title=""): pm.progressWindow(status=status, title=title, progress=0.0, isInterruptable=True) total = len(seq) for i, item in enumerate(seq): try: if pm.progressWindow(query=True, isCancelled=True): break pm.progressWindow(e=True, progress=float(i) / total * 100) yield item # with body executes here except: traceback.print_exc() pm.progressWindow(ep=1) pm.progressWindow(ep=1)def main(): # NOTE: 读取数据 with open(os.path.join(DIR, "BP_metahuman_001.json"), "r") as rf: data = json.load(rf) attr_map = &#123;"location": "t", "rotation": "r"&#125; status = "Import Keyframe to metahuman controller" # NOTE: undo 支持 pm.undoInfo(ock=1) for channel, frame_list in progress(data.items(), status=status): # NOTE: 解析 channel_name has_attr = channel.count(".") if not has_attr: # NOTE: 处理 `CTRL_C_eye_parallelLook_4311` 格式 ctrl_name = channel.rsplit("_", 1)[0] attr = "ty" else: parts = iter(channel.split(".")) ctrl_name = next(parts, "") param = next(parts, "") axis = next(parts, "") if not axis: # NOTE: 处理 `CTRL_C_teethD.Y_4330` 格式 attr = "t" axis = param else: # NOTE: 处理 `CTRL_L_eyeAim.Rotation.Y_4387` 格式 attr = attr_map.get(param.lower()) attr += axis.split("_")[0].lower() # NOTE: 解析出控制器属性设置关键帧 attribute = pm.PyNode(".".join([ctrl_name, attr])) for frame_data in frame_list: frame = frame_data.get("frame") value = frame_data.get("value") attribute.setKey(t=frame, v=value) pm.undoInfo(cck=1) &emsp;&emsp;加载 unreal 导出的数据。 总结 &emsp;&emsp;其实整个流程不复杂，有思路就很好处理。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TA 工具人知乎分享]]></title>
    <url>%2Fposts%2F4831b5c7.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 提示(神秘号码 + 光子) 85c8dc85f236c9e5e43fa3a88206ece367efe1807202c568a78236d645d5fa88cb7ae1198e30573ca67dd6ba919f99061c3d77f0824d236a376e842f5144b9861fa76ab9eb7b0c6d6284d05498526d74186446ef0a25e208ea6fa9228b0b8894bccad51d568ffbccd41535ec49cde69ea1a66498f37978d04b3d0c79a22f93508ea513dc9fe1263875da7294bc78453f39c8766bdaf98cd1e101fd13d272549e0898105b8b0d983db2e75736a39f7439ee83c6a08cab0216132af67ff14fd7e3d5be7d7f4464b7a98ccd83b36f4995945414f520bbd7dd1ef39b9e7869e5599a7a0e94b53f45561fde9ae84d5a93d43827737c8dbe4b2f665e9c9dd7e21e9e1ac1d8adabaca0d5d5695bc6939e821941bcd890f19ba7a1d3f04191247225074c3d8c0f7cd06784ccdae27c52b0b5c895c4c2aafa7c59de43358ca36503ed3090f93fe419308bd6e23d0a94309a27d84b314273d9682235430f99cb341c96a6caa768771ece40a17ee2dd761ba9197bcfa361caa5ee21b16f23c55cce2020cb9276544b0316daca3f24c32cfbf7e6768f95efb3e945f25ff852f66eca488f64f2b87f690439d342d44f2ca5f33f50e7e6aa86b88752a583359f6d6f6eba706ca04696551004abe3abab9ddfd82a40903ffdf87c2bc2f7f095f50e5c4a3f312959e23259dda72372cf5eaf1a82a3757bbaa76da1c89c69ce07e9811fcdb4586a9018dd47c03ffe8a9e1903f76f8c1e6bd131f10b53e11eb370394bda8f349424a6f268531cb7360b2df66c3e7b29b026c48dd542c638e84fff952955d5179c7f0f342d031820dab0ef561af4b99a20096f0dbb10c26a3e47ebe06a5a985506c89a4d049d646444a245dcdc04a071fecca3fece3177ec4f0fa4ad50dc19007190b86707c1e3f4d60ca32a1d9934d604813b1dd6f4740dc263886a812f20b9ece04a5b2491cea5439c4aec519b72abb47684aa578957f34564d5b87a884f8e9f0ffeea8abd1d420b4bcc728a4049d9ac38b2d006934e0187d971b03fa525eef0b7507a5bebf100247d6294c2fa6abcbdf394c6f37e4cbcb5b1b3c1a11ce05c2f18d3d89dbd9aeebd4d968422fd53f19040c4373231ff97cd14ce24c6a4b02c484f383cddfb4844608bdeb6d73129193101ee2ba576754673ffdf91a836c82264253837f113e250a01aef5ee096db9133f88ff5de2ea5f420f8ca559466582a4c74bec1c4533d8c4395e48c72438fa55a14a98bd351dd488025d9f25186ca028515c9740b0798cce012be9f8f219557f53f9725712fa9f8012af19b34d8d7a37eb904eec07ca6a0bf8c7ed579aa85f3e11e76832d995f5a0ad750e360d7f25dc6df771f14640ad53aff77aaefe6f7ba48794cc6ebbb576e47469a3a0d21210b00f149fb47f458fc7091e759c288a385f06479f745c3ac1c755facb84ab13eb0eb66b365fab107a348252719151b5af898c66b37fca1721282eb8ad5636b18d7526f361b0d4e014c68cad2f0c6f9e3303cfb1c675c562d7c2417b9246b77caecccf829c2cbdd6eadd54cc4ff82313510f7045d7d8343c773958df3a86ae956037c6f4d169231dbf27f19241cd96bff58df3283b587118874d9635c018a9c60accf2dab147dd11d881aad3bd42f36f28ec5043270dd631927ef333305a29d223fcf6839c554cff8683dde6c95fa1f1a3e6c17ef719ff2bcb11ea686f25a1251ccdc78445c8c7cb2e1cb4f964ea3446b25496b878c30c8d4d28214803e04beb80cbba9db4e294cc13750b1a67829dfb7a029bd418efdf1c396f35af9f07227d97084596b82bb283fe41031a593f9d7e8336a5d2a23987ed4485eb4f9507e7d5536fd6e81e1b651692a9fec6aecf5ac245e5f884ccda2b6b980ef240ae15eb6f530f33dbdae9cf3a791858f2b6e90783ad0e5ae47417390952cab4b9fd8d6f1e50a0f2b29b1e3cea69c15c75c4f451e3d65eb8c27a9bf69c1f3d8a2d4442aafb8eefd217156c4e8c48e93bffb4e0d2193a87118d5d9cf0fcdc151582da8180fb9dc80bd4b602ffc2e7eb83e1697a692c093771f55b54137271a13cd1dbf37922d2f6d4fcde6bc2ebad0c198b63be18ca588a4beb005739cacd720c0eb459e52bb3a0b2e001eb0c79a321cff03c98c6fc4b0a7f3f2a83a42094ccf06575446b853b37c63c9021d88a12e3b7c7a8bd7962804d001ad642daecb114b1f1f52516ac9e6c1f69350c97320713f34daa0c03b86c87ad3c4220db4103cb9df03c4a13ccd73920dace18b31710c8e59e68cac4d3b5dab847aac84195820a6606fa10abaa67aadaafe9480d555e3e1dfaf5088e83e9035ad5cc228d8241d538e84e6f08d681490129eb0181893eeb10f92c7a45942aa6c625c169f3d2860ca51eb38bd422f705ff5f739c5afae1b6c39728abcc26507c2df89715784847413a9470c2a17da9af7c1e49ee6a926c790909cfca17c3a07d5311cb60943e64c5a8e134c534da483db5bf43cffa1ca89f23eb2ee509593d31b1c114b979272d443cd323389f68711bbdfeb4dc108c0c524cf5e6f911a75161142484f007804c533fc4cb83152d816666ec8823a69be39ed2406df525e0bc554ead448cfaed18fbc5691d57f14d697fabdb45b0cfa275adb6cb455007db015e01d766d7488a1cb100c240c2e321cbc93cff4c118fd6d2654a24829982f696b012c0228b11ab09112fdc222f2ff78900db725ea017b9942e0fb1b7ce33e2bfd9444267a0dc82863cef38634b18d9ad55d67a3cff1dc82942ffcb8176700c196b99263a9b490f467f0a9151674c22319633fc40bbfa49a35d1fcf31dd85c426862fb6ec3a48abd4d031b737c6dceaa5b3490ebe098e9054f0bd9adceb049e510829d10b234dcf49e39491ea5a263dd82f8dddecd6cffee1926b4731c33d0b98231236413b95a05d1fcc183ade4e1e1a1577e5ca0fb32535f40678c86730ff1cf39302e9d210da4b721d620530508244ce71d8c60e3361ccd1f5bbef3529148906a878c1f70af8462c654116f04e5162f9add6dd0b867a46c806dc5997cb3843e0d99b8503ec0fbbe89a65834b6180076fc0cd181280de9a4bb04acf637704217ba474460538eb2d8ddae62d15aefe77b5205806bf60d704d752c91af43abec51d07f8465ca7158497a1365f4168baa3366fa43267868180c6e82bca1cc049cd80af2bcd492e9cac9b5942ec8ffe375ac21402a7a42cc55a5c1ef3e2ae92ecdbfd86cc080b08644b50b554325b3af2676f05b4ae639ca8139725e97ffba709196a8009560dfb991680141b7ecc2065c746a63527509c65e29f8c03240227d42179b6ca971e869d23862652a28bb511545d510f9068ee8746ce4a927ca3a205dd081b9dd19f00ee18d6c5dd882350e1090c52f441d1817ce05fd9d217fd07d8aaea072c5b6a81ce08cbbc2ceb901fb30528d4b0a70084aec295a89485c16969fb5f65a28f896af345c404c82840a2d02f0a0f70c7e1259d73afc753850da900d2f18dbde39e973eee3f2dede01510f08aa2e4199c4cd78c5d6931be8ebc92db8bf26c5782788e56efbb000e17142a27d24ebed50f7ad7ca4b34067e3001c5e28ceb6f65383fa17664de1acf1ab6ce2e5ff12c6f3d7b37abd91def25278613cf50d96e12748b6e9fa47734dd30d11b166f1d3c1eb499cbdcb37e0075bcf90a95411a9bcc74417d8119be0531ae8ab0080b911c5ddc8d0ef55b00eb69f0f8d8a3d4f355b02bef44d97838081acd118537a4768b0ea19e2594e1f21153444d2bf10bb1c95322b17db52a6c27276f08e24d3c5c5d36c57dcc6b0db5853350045a95ff4897f56990c7aa07c6e45c86d9b97bd9a59c4c01bb0dab3d3214e2b4981fd568ccd5be82a736627d31f8cffad98d0eaeb01839ccb4762cb4aab461c6e3fcb8efdb953abc1802a635809552bed18d590cb974fb093d49b3e5b5130360e2ab7b4e2a7c03836582bb8dafc83939dd3224fe99ac6ef298e7bc91ad24b75ca65d9db273db1bf2233e0ee75495ccdb8b0281be3c4f43b8b2b7964123abe72ce25a166bb38ef9701d6445299b7f5eec7edc146223ce170c9a6ed8b3ba95033706831e4a72a7a2331676ff1c8c775834d684ae32692f61e45d327a3ff9c745dc5a9210217609ead26f10a305aee1daad8b14744a8b173fc0db6d423afb3ba12d934e10206bc798ac630409cec3f30c934663c023d84ff7ac405b36c60d81ec6341f04221b96f3b6eb2c1a00f7c494b7f6343a390a502e10c302b20b4311449b3b59e89f6a95c982357012cbff89cee048f241b7cbce3b5b29fb3f805ae4d10f42bc60cd7f5ac0facad74315a0e7c8f2471410477f46a4ad699ebbcd8e014b20b00e57a813804d9317816d963cc5d0a2a18319400d2deef893562b961610f8fc0c1d815cf020a053bd9c1900e305b6f8d0fea9abd79fb6a09978c0217ab88afd4f3056b9ef3699de43d75b982e79be3c227be2f6bae6cef1683914e0483d9dc190c97c235e1d4840fb0ee983ed3e376e46888db686f5b43eebfb45734f7ae91ffd2730a3af2a90b7b96be2aac306dc32020e7d999b9e9241102ce79829fd44094807e62d503e7452d305542540310d2747c7c44b571122390961c3670654138c1550436f81fe7988c65405351dd26eade251e2d95073d74f0cc3494f634a1a6616fbf832f07d7c67757dea7a629ed4170452d5f5684454c38fb5e36ea79fc14d9208636730fbe32323f3d3229edf5b9ad3ccbbf89bf0236012cef608c13c25d34edf06b4bc17d66edd40184a83e9a5a45820d4f552c0c31ae4e149949965003b84923f1d6a2ca54e7274182b6f9b03d91c9c685c6591c6222e4de488d747105929c6584844fd26220627ca36cb89efabc6d10f821e50c9c4e6bb52b4efb6d64df7d5b957a9b0ba1bbb5995cf84c9d2263acdd5512a51687a01f9cae2a7b8e13de7b9c534272e002dd0bb0ecf7228cff2719e08bb643a3c7449eb25ad2c89ee96d3347326652d72e52453b57134cf34e77c5af2f086a797c95412ab7bef2e5a3c56001e00806ce9efd7033e87f6e4092fef7f440d559ea9e5fc9490669b5bfabdd3d137fe8677eab68ada43180d0720ca706610493f1b642088ae2ec14ee92ead01698f3c50cc0e11d667ef8c0b5b3e162d92613ac753f4933ff6b8b865ce8fac8e10239c45630a4ce0e17fd4e5de471319e6ea0cd063af949ee9052f8edef9002e753dc494ca62ee9c423250cf5e9e3913b3ae89e7cb1b0b40946f66aa4fca232a6b7f3cf89891649a8db8c48adf2aeaf81832f779a8c7190cc48a219f7fe02702c6626c6502e817b97837d71713409ea62e9e432a44284ea74d5baa939b46fd9aea430765f7b3680aa77b73788c14214ae6aa330aeef24bc475b4f5326c63151d7990d647430f653fc5cc8c706fcb7ced6a8745e19d371287614f6e490d374445bf77457f07370a7079873d1a7e7df2259ed4c770f10027ae36d7fe321d39b1c4095476a548b0f7165035cc7fd12e380de64d1b7dcf96003342b38e7668c22399b9dfb60984c64c742260e7cf0223f7298d9e41808535b48e452ec4707ff2aae574abc645d791d1dc7379572eaeb0291dfc74fa1d3a3db4e15c9420dd71d696f25dfded736a7d02efe8ffcd7f4c58425eac39136494e887536047c6ea0d42791e87a7344ddf5fa1a2718aa0450562f59ab6a94d6107ff4d5d0edb38a7bec692e50e51adec36f43baaffe77da23d48c00be8e455dabdfeb2f674cb7a1873c52aba69fb53c3d8f83b661dde24da87be327e75299e7395a6b342dc0f96c4d050c3d8f664d8b38efe8bef605eb957477ab056719f1e2b291e5dc3146d8209f7ecd2ec074138c2878a686978302a77a231c31bf7f801631e27fe74243843dcb811c689b286bbfd8b7ce5c62766507fd05ec99751f29ab38ab264bbe8d7b08ef3488b70770195577b1e8d8b75bee810185dea2ca77b203d365f7596914a2b164f56f91c9db5ec3627552c6a52362f6b2b698df67260fb7cf838ac34dc51d307b25aed0ec4cadd6685524eceba6f799be464c6d3c8a0b68d9d14e4457ebb8590f3a80a40f02fa0f285cd926c9fb8120efae59389d7e917379338cc6ad5b1bd84a4e19d3b1e6cc18d872193cca884346c5d614cc3a690e41dbcc1479f980971510bac84d36d0476e038ef854a0b70d8640cbb68b20308e3878ae61a36abb4667a43658d6211235334172fc690a87b34e5a911cb1fabbbd712540e8b18b0e011ced33e2f825ef801e63105024dbe1190db6cf3266b120bbbe8d48aa407091bc86b58232ac17c0e554500f090b0dab73e8b57b3228f4b1c85817cd41823b40652305c7cbfdeca62cb55cf7df0c36d00c4ef66bd674845f4bbd2db739f3338dd4e2a5698cdf6b325efeb8bb60add09a8d6ef80cbaa4e323d67a9f129151e6fa2ad5d0bfea449a79e631e7d723f01226393e495142b2e39782175bf57fd643665b0ee54672148d31049bb9f36932a739f29641f8e01de2aef1bc5fb16ee4af5031a6745880a68c98a470af95d2535de9e1beac7319c184983ab173ca9cfead0406bb4845fae6f8489d87a31c557343eea9624a74d8edc47e9a001e6aa4949c6b37d1f6dd8cf6b31abf5f5def3eee6c7907e3eda722fc4c00287d2b415878878c5c387b04fd55d75f828ce616d0caac822a6d9c8f97bd8b3e6f800f341b294ae3626ec008b7dbc6682cb3a25a5bd900257281f9df2e78d62c000151c67049dc2dabf1b6f7a2fbb22ff08a40f1959376a7b57915b68b132981c30aadd6d00e0afe7d552c33cc86dfc4378e54d521ea08f584c2529b74c05e909db6ce0ee4d75d5fe57b25393fc04eb3952f8182c86afcf1ec920d0571ee40a3c6564bd3f6c0109fd532bca0bd123d51bebe9cc329ff0f1cc147b59b73f03d2fae221fd0ef703e0673404b96595a4190715b5cd21a561312f7d2517f8f8f4bf776fa40e150d99e4c117d3c5defa26c33f5f09b8d3a95311c9bac826617c1fc49898ffc478cc2c05e3f0e3060d13d48275e09a56276d3c78fe45ded2f88764b66d40d8d95ced487501db5fe1a2f4d0651d89c5277a3111956aadc16ba9ed0a8d58ab1b1b0a666081265eb1f3763e8664d424b7d0dfea95bad788452d15673c2b6d990a30e7b1d1fcc0d7175a7fb5f73fbb0c2892ed32c986adbf741e7436ca9c1ec149a0e1a8ef143611555bf92b0a2f77bec4e681bed4734398f3e0d78d171d89113f86856bd5be023b310891a44cbdb0c7c7857bd72d5da4f8e5d16e71a2b013b82b0722e6abb2e5d775d21c18da741c3cb1f2117c1b3cf64d98248cfa7e793ee4790b7a6945969d1762cac553028991ba9fc1f2d1a66cbd565ec6ae67808629cdf1f2ad36c8a9dc2c01b188a994222fb22a36601fa8fab949685b39cf4404c0d095bd460b6aac2bcd2b2e7573c5b54fac6c420a7ae80eafc2cdd49fa47289488bae0fbc4dc99cfff28edfe698cedfe415f2abf6354eac8d599f0fd0e09db580e70e412d4bcd4ca6ed072878e0c8cc27e1bb992d0f4ca2945ded4e1bdeae4858f9781a57d905e9d3ed985934ee9d4fa6909e39a29b4aa83862a31251a8fd3f2cb8f7d67d7ccf7d0f1cf1925bbb8c7521a06e0b564942bc85e3829758890a078ec33c112e9a845c06466eacb410409a2ff045e7d995ddb6635843ca2139eb2962544240692d5f9129ffedeae7facdd3526fff4e6be5e57cc06f32472807dd4726a395ee8781ff31ebcf8bd94551a1a574e94ab5ab578c1d0339debc71b6220ca1b77b74c215156db9f7ea1ac059e8c8329b21ed169480040bcfd1564db1cbc3ff50e829a8db52699663a5eef69fe75d5eb333ab293623b5523cc28b5d25fe232cc979ca4376c9fbee686a0819a1944ae4b7aa79fcd1f67bcba846a2d03951158402110c19e2f210ccd8c9b75c284a54c80d87b870c36b3d3ecac30c9f6cb777785e285d89bc0dae1b6ae735498d060f11ef504e71fcff1477261c8e883e473435f190c5bc3e6887590e51fb3185b5e18d94d268271c0746be68b233914168d053edda35e01b1798780fe84925db1dbbcd8b59da423730d7d8525bd33ff6799c6ad1f739a59aedb8d6299512db88a5f4739125b076527ab862550e88ce1775f2aeaef51c30a5faaefb15096b22cb6f0b74ab7ab80dfc24e0bab9c6cc23a0215a027b4b739232fb5ba2cdc4316a3ef8209a13afdcb969c9fd05f95a99cd414b89d2e9ccc6589e8f7e3025baa869c68fd16a23010e553175ccb9d5a1bde94ead68f3a75afa3e2619f7c4be14734186b6dc7eb315fafdbce91e6d98545a6ee16d35fb83646af02bd2955de5df3899dc04fedd394b462e70a4470396468fd4ad40a49f8749b8235256aaae4d82086e88cbeddc855ba3fb41fc7c4f05dba1821fb35b52012847a7e4e2dfce405462b3bdd23cdd43c42a4e1aaf32972c78aec04b3e856fd6f3045ee5366ae23857aa9ca2ce92b0bcc13bc7a6f3e62705f656287ae684f2c79aaddb6e4d811703f5b3a02bad6f1095e469033a67165604ffd347470db3d11552fa662c0e7369a12eb038e6314bde776622302b0f6813c16e6dc4886d95d9bf39093c895c0cd7328c45c524773f0498cb15a364f649d743ad8b0ad29330591deb90fd45407dbe61a34d75eefaf743c864aeabaf434f0a045c82d17e35e446eb3bafa081f3c5d1e37cdd294ec4dd08979df2968b8b9d7f270b55b4147c8ebf7eb67caa637dfff5e35e69ddd231cfe47921b877dd1723c77d549d8c5a4e56c92eda3ba73262b445da4b8bcea6896648d6d43a942da14c5f00d9c7913da16be624248ae1ad5a35808fe5d0a01d64b94efd911c7a04333d05b592ae5c73ba985cb92fbecfb081c9ed0983cab71678493e4614f91c76465c2019b3fa4c98886cf1446b702c17e627442dca6a03538758aac1e2fe8206f4efed899bc56635fc616c6c71fb35dadaae2a1df30e6999083f802afe2e514012f4bd9df9b8d5a3c0284fc244225fef97e026e0bc0fbf42870871b63f300741ee9f5b082710eb5e2b34faf3e7081ede25db020c6b6a614c7636877958e05597400ef56646d4b14c6f11f032083ed81c73e33a1fe6b853f3f379fbf565e5d71e6cea64cc50384ded31b66cdff2b8acd0bb1c4963fbbdbaa135a4877be17227da1b9bd265b2395672042e65982f82a19e4047c844903a59f547f57ed4acea99de5e8879ef59739c72def291218aec3c336f22c70b94889e485b6e93cfe27444a367beb8890d2e5c6ad1c623c42aca7c14d0861b11ecf8c17a586eeff5bc54bbaf3dcae90add7ccd20a15a2abc8906b20abc0ea8bdfeeb4f213468a5a70b66099acbe7c27be10e836a035c351c64fc931db21fcef08e6c16702d670c1e841d00700739679273c59528d69fdc09a246af73002dc54cdb00aefed6e0dcd980e15c9e96647f30df22bc3405ed33a2e133ef585beb5af9bc25696c16f51081aa8c481074e64e2c5310e80687396a4e9e85ea4e96476d690b8f741b1852a2a4cbb16381fea5838bc02a1f23e9dc6f6601b25249149db35733fbf20a8cb4e6c618e191842c6ce6d5ae9b2942ba6d0c1d63fb451003d1f13484f4f266ecc8dcda94bbf6a2e86037ac982a868826f0340980e3c4d113580bdbb284c654782c4cde54437bef2aac4768a4e3430bdbc1721648b279c2818ca881f5ffaff3fbad7e85ce96d6369f494a174aba08e7ef35a291aff3cb347a3bb400a23095182fa1585796b25baba70048d8ec00876ee47618fc2d7ffe959b7f009108140a5b734042c92787eb45868ce15a43dbc4f321faf83430a7b30842227dd3278366740ddec97ccbb106bafcccd04a36f23637729e5bb36c48789d33c267e5e4383067ddf1a0ffc3147af53cdc01efe688dd894e93536e9548a2985d422d31cd10e2d447e29d02ae97d73327b2871380f053021e393e24b0caddb32a6bff7c21385d7450f46c802d5bfb0a48ba8721fac3b06acfb057af2df8594e860e9b6f13ac219691f28041fa4e995473da435785b3a9831b24c12740709a10e287764804ce0ab97b9b39b35e21235d7b011c81a385e1b7da0a339ad03d5be0844d17b54dcd1807284350483e0b2901d408ec69596e32b09c888a90e59734cf99e23d91631cb75d116b3cfc05425a891f61ce313876cbbd7102871f44ed5a5892610d033906a555d4445c917c7c4401567fe16fb7be23e7fb37b236a5d75841bbe4818bbd75dc05d70abd24f508bc822e18a37bbd8bcacaa35764b3306fd313d7e48f2d3f0aa9ad295bc2c90ddabf1c87799da07cd92c4884c5a156da3f51d21b5a8e17fb36a1d06e11e2a8c48356e6cf4d7a8e99d6dc0796684ea9dd3c184d54b8fb7399fbd8048e7d6ac7c21f1bb89f7a18d4188c790a49b2d15cd6021603c623de2cf6c93ab78d49db497b262de06f47cf6cf21326f452f5e7246e90390a866fff0eaca9b410f60acafa1004c33914f4471acef1f07212e46d7f58bbe40f8c69363455849825e2c93c74b7dfc65e42592f6a82d6fbc8de9568ff1f42dc4b99594dc602f70a0da580cff1a40cbac3e4529081fac7f9affde69a60ef0274aa5c0728eb987441b665905a0baa7360c10435664c6806acf96592ebc877a0f26e8ea351f5432f391de208a6d97b040af0784ae290405149e3dfefce040aeeb95b3f4ab7395a91119625656cc2b4474b63d2f981f33c6778e3a2a8ca4367a759cd07c941fde40f4087994c053e3c365d84cc1be1ac320097f9c987477042ef737a3ed0b2c00adc4c542f6f5c1bf6c396f66d2edbf4f130980f5a514cff1d2169d6c137a2fc8e3372ec0c547b21e1e3a0a2eb8e90483102c9123f9a549344eae32c5f80e05b4b1d675264008a29484c257c51cd87ad89a093ff2daef6e3d819a890fabf295c9455f08f4edd0c59843e34ae19bdac5416250ea892f4cfba30e6a1d8fdd5be4fd5a228b31e9aeabc9c05ea14a62b016a57adba1811b36169c12321813f733c17a4a87f296363be380901a2b02cfe7e46675fd1bd42fa5f60bdd9e0e89aab8c6174cb5b4d2071fc0aef2c486dba8886e5ce426acb203b925c5114b516f6ba121e34412a46da421900352b6d1a1d12d1bd43a82830907472acc5061298665f146ca59e6a310a2af28bdc7709e4e6768457244d2cce3a16423d464d155ed977de3cf84f59792c28ee62c0bb7a8eb6030eeb6a785b3053c74a21443bb0d1e555b415d9554b96ca87062714b71a32104d53c4e5d914b669f9939627bd3e0fe7df0b72defe7f4bb7e1eb4ab2a25669e2aa39dd005ceca24c03d0e987f6d755b4ea25caa11e026ced582ce0054327ba2f32b9e8e25d136c65f003b6f648f824b71160941fa1ef1aeccf3bfdef7413cf2163d95364b2a229ee0956d1b90931dd595294deda4fe97bfcab54e90927d40c3a770b7d260d962c9b1934a0e531186c55781ee99c208f7650ea34e735cf83f8a1b4720e65c5ae88bdbb0b46949b506b5dc2805ea3f5a5d343847ebc713af27a4bb58cd9c18c92d73a105f5e44106d1ac49ea98f8f6a5a250f0fbc3f8723d9afbd211f396c11c16ac7aefeb7fb58a3d7d2e9b95243d924d8d2af0d5db3f8eda3fceea3b326789a3332d9bd15ea9309d945c70c390e7615535ed6e2215ffb7361428471ad3e37ee4b8a270b598e2045a452e83a9b9cd82ea9659b16ad201e18ff23379eef6d7f95b30662ea0ff6d624efb209aa67d7a6c47edc80667a1b7545382406ed9bb099caca7021ec73e7331208066975c02636a7f27c1a6222a67ce22c031cdbf06fff4bf70f6ef9a81b2f1b258fc30b0f5373c34ec1a0771394ca098576ba0426ab491cb002674ac471b4cbacca9cc7d74ee3f207db0664dea7078976a1442e002956159e915c10bfeed6ce84c1f872be3a75995c35e361a7aa090c3db0f1b6079edfdbb84fe4030a79fe6280a7bc41cf66bf54cec84c453ae14cbcab3150543cc3247eaa0353e339acb34e0ae338ddfb7203133782387995d3c51bd0f3f0a3555c805210c24c9c53b6fe889d69591a4f4f2339e4896d114c2a03e0ff70571db8caa3b2cf83b7df2b05d861fba6254b4047218d49f2ecc8dd7c73c7bad8928ca6011bfb709ff816ae98114efa1d2c6160dbcada0818cd444607837b894416c506c0003254ebdf867265b6c1aed025b1a6a3c32ae3febb0cb0014253c96160ad661b6dfae00909db7247e83a297590956c8816a48161a84322512daddb636d94b6a8391d9fa58875025c93dea22d7d09288bc16aa33406c8bf47a54c27f4e3c7f8ab50b9f1de88c9b73c1ad1ee1df2fdd48947a08d166cfea9f19d288de035c0bb74cf94fbd10b4e993fde919fde9fe13b9343680e23b38fddfbea3baa8f24f23a27b1c0d5cbefe0345cbda06f93f21b48d373bcd9af2b5baa754a7c91bd38794778e43d4498015c7aa48a796bb929997fabb094ab2bce36944b39095d841a089e2eebf85569a456941efdbed04b4ec4f8aa5a9b3948721ac93b325d8c92d02137d7c120ebc7906d64131b0eb2a657c219eba68da2c23ca00d2005150c2ad41de2431ec6ffe638445496c6b120a2c2faca2c61f90c7c581f2a2bce074c7fc20fdc77b395e4fbff8d8f1bd9d590ba4e0cfb112651bafe5277afdec2196b96f3813bdd784e7a1f0cabc2013857ecf7b6653e0f32a450e000f88134ce5652cb423582036db143ee9f561b4722b2af13e1aaa515ad955f1e129f6e5916ba43eff58fc5a99456632520938015eb7347f77bf0c24dadaf31954ab838eb661f145125d0f4f4952e93827918f706902defdf13766fe7e51e0014e33e77728ee2be1e98f65fafc66b942ba7ee5f0a7ba908545707607af8c1734262804b212e4b66cda25502b3ee7dbfc10508e4ef4e92a8359422dc813bfe292f016268806b7bf698d609771bb704501f8e5f0c16c00ce228142a7dedb42db1431f3ffe584e403e4a4758b763c3363f6f28474a5263bce56b44db7fc7d4236e9953e5c1def782bd17a9bba75d1a139ad3d8741435c2b78a4308f914dd5a463a94b82d4dc630a18f86a1f08cecfffb07396a56649e914675cd83394c148d65a6a3b1672d7f38e5d6a0a4456dc05b74a3db58fae4fba2795624f6ef6bf5419e9e156c1d22144abde39734a8714587e9ee1829dcd69397e963f7644e09027b86dd825b9d5cbbd7c40e51fd039184fa826d334b128c869a81ceb0810d6b99271be257aa92f041cd95e36224ceb2bd05c07074df2ccb43c91b3c97678e45dd7506bc410048319fde4cd31d8eed3bf06f637205956460ea1a9e2e12f6cb5415e72c970b9d85be544fde18142a06a8dcb71a52d4cf9fbe24cd078cd49e38855c3affa4ef0a4178ef1c40cd3bba37c33cc448e14c8905bf079f487e4bfff13e81af8c7b6fa5e705d5dd1d8bbc3aaf8c9925e9de2c2c57659716622953e239fa50c7ed25e83f579bf0e369cf3a6f84fcc10320047e2d0362e6d7eba28512ed534bac3c9f1cbc9a1b6b761055706c0700d440dee9a81acb65c856bb05f867de05166f0750cf20a51f5473ca5121637f40df9313df8950483bc2421fcb111fe48036134af810e3324726c086d52945cfdcd9e06df32683ff5b3f413cdd92fb94cfd8bf14bf2d0ec24c297c53b02c6a711f7d4382e2ef4436c60147bd1e397a45b9dcbd2592893230e2fa6fb73bd2cc785affa27f6a7e8ec02136c52262b7516432f70a6d9eeb0a0361f8eb85b119c77021bdd8bb691e7d315bd84721a2f5ddd1581d9e9fb3b11a1a28a98f1bece9a0b206eb0395b66a174da940a50bf46a0500cecf59c7b313ea47a835844db373ddac515aad7d7f4755c7df0b77cb24eff1e6b80b7b3503cfcdd1f4d58baf578680361b28aed684eca6ac6d33ccbe70de7a7b6fa1a5290b2e6b5ef7b4eceef35f91848d5d347149f2b3eee1900a472d54c95ea46d52a2902097ace28833532afe4e3aad379684c8e20b9a67dcbe97bf6d28e87cc1689d48e5a02eb977f87305d41533b54b1a7b7f2fafef8fdbc3f48fb1af95f3352d12a5127e8de4720c0883764367b31b7542e573d717eed7c74802b8dca0ae3d32b7e97fb6ab9cf427b0ae6e2826ba95aa178eeee1f5f5701f716a682f5b54c2d2f8fba7a543956930b07b29c3a8a7f5329c2578d85e0e708fc7541521e37d75855f05e1944408d12e1f548744942a6a55c6db6772796f2836d4b8e570f4c1f17c97b3ca106ccb11eb2b95da23946396abbbd356e1c93f999e66eb6e4336120d96f8b2ed85391830ebc1a8a41edb666004621ba0c958dca102915621e73e15a1d1fba5d9a9ce1a02ccb5543ceb25e87089fbb4b39148b42be9e4f4d544c24f548caa6240bcc10586e7a8c42820b7d0c903ef5a80ee9361e4df2d19488773c2a426f3008fde8ba9ae4676e1979b060fef803c6a6e83631635fe614c6c20975306be85bb59bfe1febab2814388d052b997df17624800cbaba18e3eae71976de98d056d83d73d07b657e8b5e1f78d79f72bc25486348d58f2c8a5d6809a06aeff2071a984e8d4c5a7c087ae1b581ad0277a518f939b05b3404cf63849b63bc329a732161f18fd6856168c0205ff80af9754108598681969dda263a6a86e1ab056e0ee6c4e2cc6312670c3f6dbf0db2fa96d2cdead6b24d2f3230c03a4c8651fb818583fe63d3a2abec4c32891b0621e3907430c1d9013d07f5051ff5abecd69ad1472f08469bdba9aeadba0ffa5255cf815abd6f105c601189308678197d7cd2df4f816c890784a869a51ab11721ab1c5ccc7ea45ed5f10a2d16009dba5efe99d0782c41c4d51410c5854bcfb242d216675d885df4a1e01ff0258263227218f12d4acac5076e6b2ef64c0e283d947c1dbed3f3f7e4443df4f9d233e0b26c5211c0944b200d01ca3947b7cfd5f2c34fec73e0d53a9c52281e3cacb78d88e13ed74b4e0029fca6b04dd5acc8aca8cf6a875bfbe6e8075c50ac4b0bc17c66c894f8dff50b982289de610d53b17888a8dbdbaf68aee94c55a7f1f6fd4c33532ab365fd0cf6f826c94607f605685b9e5bc9d0934b13c9ed85e25651ad873bfd70e273b3151b1257443c34bbbfa466c3b51633a13a48aca109881244be351be8e280cde86e0284c11d6e8747fbcd33941927150ca0bdccf2eb03963d90be122740edd0cf5692eea5a92eb6eca9d46561f171838e1a5a137f1da15d7081b70059002d79f81d71a28ee04ed4dd230abda6275fbd68f868aa36b8ed68c57868503f36ee4a5764197286bef821f3f765942161fe166769e9684de001a54c4a5da5c3af22681e62568997e0c5a138337fe7f1c66a61525c0a7595f74a7ff8e92b8afb4b62ffc2eea876053e7e908fcba6e0e9dc5f286f2af6b2827c390a35dac1cd907cc5c6def80d8f9421e4db799a90f516beb7805f52f43bf82abf2d6167983bb9f0e04aa296c05db238022c70c9121735ca7026994058e862a08b3ea27b763ace536c42f6e83ae316e97cede4e6d811c9263938567544246164ad4fc63c9d0988cb8753387d8a94bf0b534e48473b4187ceac701842a74e7546167815a5868f4d5aca1b1682d84ff3d032356c6cb4dbe556aab8db2ed35b17408010d41edd55c771e85dd277709038c06863b08b40026711273b108749abd61224d481229056a176a64273cd8601984ad32aa31bc05f48c38f983495ed5f8c2a2e63555e02b8e446a6b64c3d49a39d636614c14b92bbe6c4ccc403b516c4970ab7f1fd4755a47ff539495004ce2b41d2580b490cb6f55aa1b100fdbc76442c04902eae8cf266615d93ad92e765d767e3abce19d3ea22ae634b442368d0f5745bc6b1360282b0eedc3c516acca4cfea0a336f5d06b3ca6944ca8cf2ecbfc9c0bc7e68871c40634f2a9b9f31d77c55ffbee78d0b4b2aa70158b48371f8015fdb38824ec5b4fdca0250d67c7749ba4297ebfdfb48ab21df90010294e4a4238308e45c9e1f4a32832a88c758f709d0b047ea2bd3db3994ecdd520638405a3e3e2f6f969ac97f539531e73b105648633b6ef4d68bf484089e76921232520135ffb2ced01d0d76185259a92bf1a455640a5ce34edafea1c6d16d8cd67ebdc727ecab98d6083de829ccc4ab84ac1ad08f40c9d9590f268801a3b92052277edaa5211fd33b45645a5b6e6f06c9b88fdac49fd52ea4e1c485ccac2d8932df5795899a4920b8ba079f7507c3c0db1deb78fb099bc89128da34c82dd9392bca146a20aea565ef1102e2ab25f188dd635f94215025f015fb3b1ee6dd4ab46a1fbefbbfcd0acbb3ed1c6bb5e28e059057ab95c574646564fc844ef69e34577cc17d602aa0384dae862e411ab2b9a769e2ba4581abb326196e35d0acc101a5b4f597941b11d6cc87e4de0af68a277d32d6bad4c7a2f0ab47153f311fc3de39324e820f52b6a8340b0b43771679d269714078c1c634efcb72853844881d820c9f31a852911a009d7b0460ee3e3c4c1608263ba8b51c1aa477f9040f89ed486f5f88b3afae2374ef3216ff5bafbc9c93f6cc4ff05c459426227dfd856571df652ebe655a97618dbb37b1323e2e1b87d1b914107f3239077cf039b7f0b2d9e05fc1a96592f04779476807ddd873cf36292dfdda5de036ac11f6ee118753780711523cb619ed7076a253c15c38e9c717a66a9fd0d042486fc1b0ea388e99e5f3cbb906a96bcbf3f3101c194cd5c03767978cf7f73d146fcd65cf302469c10a4a739e586352aa3ecbf3bc3d9eb3eb273f07c08a45a100885d718378e06f7c2d67b2c8d76390345d12930b037869b927ccc3c51943e99350bf0ce4faa157970886fe64eb9653057e1586c50667c288c61e6f40717863e8c1f37b500dadd3f13a131436ede5192dbfe0f90372a70e12f039789cf15ef6067684e77ea810908ff9f7191877f4670a9e71e858bf54a67b2e6adfe2ea8fa12a8d4b7cf5139ee0479c31c9d20f81a09be02155ff0b5958e34a66edcb2b78687fea14ab0bb58abfcaea47f2673d93a50d1dbdc46a95ef8adf980ad076ac1598094bbb0a348328c7d429177bbcbcd2de117db34f9b0bf3bc703cad3e3ae3a768afb627befae57a886209cf36a7185e003ea7fb24679bfd7fba4a90ad4dcd025a683c63677bdb35fd85fde8da9d5f2604ab7fa49058b9b606dca1273fe693ad0d47b440efd030fd15158e2f94d75ee660f7d177e1df89c255ad201fcd730b7a1f8505ef86c8c758aa29eee0a9a530e5e8a3d1856a44c51fed89147c58305509217a7c65edabc39ba9f16c62b2034c72f441f073b705b9ae721a4091fecfe1da3dde4c9aab2137a303bc31d286481cbd277709b07869692fcd17d725a655f15b0900ae0dc4fdfd704d7d111f7506dee53796d7731f74558af7b578e8fb3688515b5b91904c9c020fa5ec6248c175d6572293765d8da2aa7fa33730447eb3bbd93e5d54e41324e78cf70403684c6195d24cd299d748887c32cea1b98e7a45f43beea23d85ae50c69f410a1b8ae4b43aa49cd90ffbc43d0e781606509b9358ef37a8fc91b692de8c309db861fe33b1008daa1253c463f5173de58d8716c84f9b283c8fbc3cbfecea14ed427c8601ff40a6b02dca8f792e33ccdf0094b573303f1e95ff911986445015c5716c31fc6758aa76fc44360edbed6070d8b24ad6a3937da665a7e7fef519c750c1feccd8eaa8db66bde5d633648c733fe07749ac49b52c27406ef7f5e0007095a407f40c581486c86107124276beff3d0cac6244c26031408a7a3d41cb4d924224097073af8af23a5338de8b1d6db9e2c83a415e0e42f49b6510db553517b6a03a0aa82dcc661c36a6d374bcdcf7d15544cc759720214c903def926b42ae08c960993d927e45321c54fe1e5f796df9227480678300f516af44bd2e6c97b07a8ea77dc9936faa7bb9948dd360e0d17282d0af670d2ec836e29ba6142b54ee8bb1c2451927a8da1172bad725043c794754577e528e1c90499c262e3bb4ee8ceebe35582b2475faaca5a984902773527621a1e91db7f7cf3691e1b998b9248ed2d61f33862fa509446163636aa9c7f65274640656c28287f327f87c2ca941728dc1c45b4eb64647e86c316b946a9e25f029c8a5e24a38516bc34837ee551041554a3ec5bb394465389b6068b438dc87d1a3529706927653af6574d8ed27f60477a165099f451457d3a8acbf4f1026dcfb75e8b8ae31a07d77319c4398653b8502d6998ad81d4238d19209d87cbdbd8dca22a9b51d15fad64f3f178cb05928878574ffa6392f47ffe73173213f56378ab3407b81e21ba45c3dbba41297aa0cc7990627476a93a5852c91107fd2f25f9c2b951901bcfbd528d6d50ff76451180583788f2b337e50c093aac9994def8767e36a0f288bf2f04292cb7a79d80eec6d87e4eb2f1526051ab3809eb323f58b523e93b40a2554d0bb9347d283a3a4ffc542b3478ff07f11db27ac3ad876ee949e0770214b971c9693836bd9b8a0667d49191bce1923331bbc6ced36715e8ebcbd5c392aa9af5b421f31f2e3309a433767b1260524bc6e35881d668d479ddee3b13ad494cbf66357195cbb733bd62468635f36ffa54fb9105ceb9209fb738faa5b2a7ef13d7305d97cbed360f82bec1fb9215473f55b6721794b16b90a16d1ba4858f30d19666833f0d53b2496ab0534f6cbb148db205a1ae716857f66b6fecdb30618ee62c6dfe990a25b43209c74628a4c859afa96b486bc5e0d2ee021d1526040b72794246a83cdca219e5246e9c0f97598f30780090126649da474c8f0e6a707ab5c803f0f5bfd7cc005abeb352517077a38034bea66134b0ebc84aa989b9b46bd52f2919be346ce1ae30eae871bc1f511ee63a10a6ef2307dc55367197656e0c0d808ebacae693ea2b648cc5677a5e847c00c3d6bbc76a8390735c02564ab05e438262ab19f81072d0cbb3d5a7914d639a0a6924bcaaa4a0083ae6860648070a4a60656fbcc1bc24a6bb3300e82a170444f12ce71202c8a043c7e40d8c6be21c30527cbe78adf64372c7e07c8bd41d49e223cb8600accc2d49c1a730ba17f09e8a7977e67b318341a84baaf32f1bc2ded3ef2ce49c6b9de59cde6f3ad5123e10d923a4dcd1f35a9fee8cdb011044b84b137b3eef29dba89c3825234651a4d8381fab5bc18894af8e05431dc92822060d92d7ccd81931abfda029dc80734a2e61fba57fa7dac064d679ba9cc78692a32f600d5edd22db34aef66118580c274cf4ded4be28360defabf2a14dbe06296380364567a295b798f86e5a7b2b706f5518d2f9f69ccbd81ab547c1ad2b997c5d8e0483cf45b34b3ae01766206ea612c3d9702448a394d3d9c7b0997e3269aa1f6baa39d3e588ab2b9b9730d7c9f0a32cd6862cfb02cfbdfcbea5d7e3416b40725ea5cc600676c079fa435a053d0779b3c5182c05479b8bf0ecc0d030c7c1063a32a3fb41e32bfbc5b76860dfc010b8245a72e3d862816c7e8eacdb346c9c0dce169d1ea8e96911296dd174fd3fcfd84ef04c1b6cad4a45c04bbd407d468b271fdc6356bd3bbfb9859694cdcfd0473a3c0862369390804208a376f1feb0475bc40d8855c4490e29f5f1a0dd410ab6c6a71c29ece651b129bd5d30eee3454d2b76b0390fc32ef35a9451e387704cd4c46ce28a432397e5a02af1f1b75ffe44a0708aed1dfccf09b1e68b130650dfd4ae8da0f2b5192420da8b321602737ed1e8bbefddc7189df3a14a0ea959cc3c3f35f9709195768851d45e7f168cdad98e539b67b50e58f4543418501c4a19f24fa074d127a71b4363673f6eade0bb0d92a6cd38d38482fa77f2baceb6c2f63cbeb50ea3ea47e71f47ac4bd8d6ceecfaa563ca931161fd452b182b9ab67c8d624bb3fdd4f4d6fb4ca222725fd41866e00d058a3c02064c21d945aa5dc1b5346e9e0e12e2561a3222bf4b76dbbea09bace9f03621f421d395822e8a0da4a5c8e0f12e5a0306cf0a84b572a0398261cc61e3c3be4f569e6d682410554627adfb14b15be792b4b6d9b79ccf83fa8bc35e5d6de6d22cb710036a97886c43a70f93d5cedc6997b1cf606d699dba92b5beda5061e81c5e102205cafa63d96868dbac3d91e1732be09334c48f6b0570ce99bc26c950f5738edba73722b0c648d7af0f4405efc775183db681260ec6244e9f566acad270d8c42d79ebd0ba3acc8054bd22b4232e5f35b53293af6de41e26b0e5f87d8bc609d89835f9b20779073b2062f2c0af610386955adad796dd886f43d6c76576b75bc28211cdef9829e42a0dd64dd05448e16482c03022a23284d890336da71a81782ea8c2efd3f493a995107fc4845405bc7d425cba70264dde0ee90600d3dd1e7dd4e4cab0ea4817a2f12a9d470839b009609e6318260ac53e374905b3d094ea7db879c3c953d8ecc746ef4ef7fe584361138f17580c92f50641735646c8b6165f0089bc3ad36c1a558d091e4cf9a7d7c7cf67170357fdf7a6128b7d467d77663129d8e5dff40c845c509dbe793eb8cf118fc6b1cb1cbbf104b4f6b1858cedf9a89fa8e3b7ec34a403d0ea2bc063c9cc9e5d317520653623113ed6a3a6c17320b774003669742f37f5f2e1d1f923c67c7fd705731978323da1e84e318acc8e21c6a5e4779e6e9f139497bf6037d503e1152134ead3e910a8efae7040388a2cf1d42ebce0da16212eecdb885e3ffd48d286946f16832f9d726fb881a9c1c24bfb1ced2832c512f47ee7d9d826f8040cec3b7d7d97a699b4b022e87e4cf5de97ee556cc95fba14e9e372425efdde98fb6d11c72deaee1153fbaedeac63e81e0ab23d6d679c099783ffc49456cd72d2055c85971dbf3f2471350f38e0531582424406ab445f59caca3fca6f3f1eb36306f5cd53124400a35e69ac64f9d1b6a349a451ee4f8b00e12531781572a14761e26242a111c0b718159c7e2e10db310b8e1b1834abffb15927caca0a47c322daedf92c38c1f224d0b4c29b31ed160c3f58d94d27e2b43672361e240ecffc30b9a58b7b07aeab67d71d66ccc73c0eed55a53d84340dcc66a984252806400a88f571217c6f3aa1e4863dfff9977f7fbd29971c80b0659d6dd0629132820ad66a392d05b38fa8246f0c7ace763e3ea6c25aa851639ecc47a6d30a686ab2674eddf20891d87b88f9499b439a2150eb414f2391471cb74b0659f8519bf45801ae250bbe75f578cebf7e5655e04e43e1fc5c4dd0401a976aa4ae4906792020e7fc87bf1b325101edbe54c44482a93beb455852035cec5fb40681ba3564b4dac46911474e449ca0c3511469a76eeef503a27ce820e7323c8efc195349ab3ef08686754222bfbc2c1a9d26700633842fb19c5bfc0c7a6909c199ae01ab6b36531c1ea12e9efcbdcd5ffb8984e9dcc060808a552134f7f86d2ee5a6b6bbfaaf9ef6314546f542eaa8084b68fc21f4c0e10d12528c679e0271e425bb99561cbbe05ea699ef3137ca10dd0477ba0ec6a032e67d6a6dd40658fff40d52b434d6707828c37b4f93924c5b9501284cd796d6243172bd0056d99f1c01adfa39145cbc7f7d304d62ad6d71e89c0752260145aabeb06694517bc45c03c515a725087ee475a6b00829472c6a3745c1b856e15b36046ba0f0479f9a1fa37e74e8a016062b623bb26a5d47b640efe650c6963c870fc622c8f8ecf904c3430cb6ab5edfcc6dafdca011953e264614152f82cf00ce006648077de1f0d19ad2073dcfe67d61a975cd667339c996415983f52b7a813a584601555a280b3bd68cd663aaa3e066b95a9365e42e748409193856689ef90d3debefec3a79d0f63723f5a3d93d928fd424477f89fcd1fd241fecd9268ac8ae2dd56b730f55684b083adc9cbce8e39860646382aea31f24f0695f1741056a1401b5160c647f31fc66c4ad92d607561e384d48a8fe404388ab4529281fea508e4cd50eb268ccae7a0c6990733449e88442512920471eb21f689958d70ea8cde6dfa7b32bd3b2cb74e8206eb4dffce1fea5927e91ca7cda09de68848a6db6c7f257d1a9f8364e14d449039c1b55aa2d89d26f876c2e81af61f2d7f0c702c74f05449dfa9f949292fbbfc39fb7b2520d14bbc5c360bab47b8a03daca123707bd6e46f4f1024a4c1e0b0249883e41f1b041efb26fa6fec72827183fa1f00b6b8e3e99647e5ff9c38d96e55cf448da656251966c2f06c012574f0809fac84ccf2441173c952aa2ebe9a0ff8827ed96ccc92d7e4612b5188a9e71b83e8f109e4ef3b0d46670ec57faefa442d074f23fc67ae3d2555782145daf0cacc7e6cf196d5f6946367f62a3e704c684581725274fa7de8d89cd00158d777829abb08c225136513cc78ded52d5491b0ed64d4ed650a18e1956eeddf8c1e5198b23734526628e400a2c6f8e3d85787e357c463fe22984772a36f4701079b7e8d46fe8e7acfb87fc213c6b5a2e8f21fe0e0bcac062b012f898207b46cf13e815718468b9fd115c12d68534ea2968fe35cfeedba02559b33791af164ded54128148ea61466743b453fc26d632dd7a14a5c0b9cdd3b67b92777875eea04ebb80f32f75aec06681667a0d643b27bfe6de94417d539fcadce22c5455af8438b2e3ffd4dbcaaa6df3fda5f08049bfcf127752e98b17e70122880ba9aff68f4b959e2c00788181a00537b4fd4093a71138b54cf392f9aae93666dfc454b338fd3cd884f448f60a1e43c619a97ce362f11dfef8e9b4d68878d50c10a8fbd1a332ad3b071854a9a026e48515daafa505c4c78909f5ac9faa5f930f949f905532d6ca518741e1a791]]></content>
      <categories>
        <category>光子</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Import 机制]]></title>
    <url>%2Fposts%2F5e6e2bc7.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;你是否也会为 reload Python 的模块干到烦恼。&emsp;&emsp;需要在不同的脚本加上 reload 导入的模块确保可以看到代码的更新。&emsp;&emsp;Python 是怎么缓存 import 的模块的。 TLDR; &emsp;&emsp;我后来了解了 Python 的加载机制之后弄了一个函数，只要将我们开发的包命名加上，就可以实现整个开发包 reload 。 12345678910111213141516def module_cleanup(module_name): """Cleanup module_name in sys.modules cache. Args: module_name (str): Module Name """ if module_name in sys.builtin_module_names: return packages = [mod for mod in sys.modules if mod.startswith("%s." % module_name)] for package in packages + [module_name]: module = sys.modules.get(package) if module is not None: del sys.modules[package] # noqa:WPS420# NOTES(timmyliang): 这个操作等同于对 test_module 下所有的 module 进行 reloadmodule_cleanup("test_module") &emsp;&emsp;如果我们的 test_module 下有众多脚本就不需要逐个去添加 reload 了。&emsp;&emsp;万一不小心把 reload 发布出去了也会稍微降低脚本运行的性能。 Python Importhttps://docs.python.org/3/reference/import.html &emsp;&emsp;上面是 Python 的官方文档讲述 Python的 import 的时候背后的运行机理，也可以切换成中文进行阅读。&emsp;&emsp;这里我将上面的文章结合自己的实践总结一番。 &emsp;&emsp;Python import 模块可以用关键字 import 或者 importlib.import_module()备注: 关键字调用无法放到 lambda 函数里面，这也是为什么 Python2 下默认 print 无法放入 lambda 里面， python3 print 不再是关键字可以放入 lambda&emsp;&emsp;使用 import 关键字其实别后执行的时 __import__() 内置方法。&emsp;&emsp;import 触发之后会从 sys.modules 查找缓存，找不到就从 sys.path 里面匹配模块 (这个过程也会触发 meta_path 等触发自定义的 import 行为)&emsp;&emsp;找到匹配的模块就会创建模块 否则 raise ModuleNotFoundError&emsp;&emsp;生成的模块会放入到 sys.modules 进行缓存。 import 执行操作(不考虑自定义 import 情况) 从 sys.modules 查找模块缓存 从 sys.path 匹配脚本 生成模块 放入 sys.modules 缓存 sys.modules &emsp;&emsp;由于 sys.modules 的缓存机制，Python 下次导入就从已经加载的缓存中获取模块，导致模块用的还是旧的代码逻辑。&emsp;&emsp;相应的也可以修改 sys.modules 的字典实现骚操作 12345import syssys.modules['a'] = 1import aprint(a) # 打印 1 &emsp;&emsp;当然这种骚操作不推荐使用就是了。&emsp;&emsp;另外还有一些危险的操作，比如 del sys.modules[&quot;builtins&quot;] 会让 Python 变得不正常(:з」∠) 12345del sys.modules["builtins"] map# Traceback (most recent call last):# File "&lt;stdin&gt;", line 1, in &lt;module&gt;# RuntimeError: lost builtins module &emsp;&emsp;基于这个原理，如果将缓存清理了，下次 Python import 就会重新加载这个模块，实现 reload 的效果。&emsp;&emsp;我最初也是在 mGear 的代码里面学习它们的 reload 方法学习到的。 &emsp;&emsp;它背后实现的代码就是 del sys.modules[&quot;mgear&quot;] 等相关的模块 https://docs.python.org/3/reference/import.html#the-module-cache &emsp;&emsp;根据官方文档的说明，如果一个大模块下有很多子模块，都是单独键值缓存的。&emsp;&emsp;所以要 reload 所有的子模块需要编译键值将匹配的都删除掉。 12345678910111213141516def module_cleanup(module_name): """Cleanup module_name in sys.modules cache. Args: module_name (str): Module Name """ if module_name in sys.builtin_module_names: return packages = [mod for mod in sys.modules if mod.startswith("%s." % module_name)] for package in packages + [module_name]: module = sys.modules.get(package) if module is not None: del sys.modules[package] # noqa:WPS420# NOTES(timmyliang): 这个操作等同于对 test_module 下所有的 module 进行 reloadmodule_cleanup("test_module") &emsp;&emsp;这个就是我整理的遍历所有匹配的模块进行缓存删除的函数，sys.builtin_module_names 通过规避对内置模块的清理。&emsp;&emsp;这样源代码不需要添加 reload ，我们只在开发用的调试脚本添加这个函数执行 reload 即可。&emsp;&emsp;另外有一个小小注意点，用这个删除缓存的方式 reload 会将之前的 module 删除生成新的 module 对象，但是如果用 reload 的话是沿用之前的 module 对象。&emsp;&emsp;目前我实践上还没遇到过因为这个导致出现问题的情况。 packages 命名空间包https://packaging.python.org/en/latest/guides/packaging-namespace-packages/ &emsp;&emsp;按照上面链接提供的目录结构 123456789101112mynamespace-subpackage-a&#x2F; setup.py mynamespace&#x2F; subpackage_a&#x2F; __init__.pymynamespace-subpackage-b&#x2F; setup.py mynamespace&#x2F; subpackage_b&#x2F; __init__.py module_b.py &emsp;&emsp;然后就可以 from mynamespace import subpackage_b from mynamespace import subpackage_a&emsp;&emsp;用同一个 mynamespace 包导入两个不同路径的模块。 &emsp;&emsp;但是上面的链接也提到 命名空间包并不适用所有的情况，反而是用前缀包会更好。 模块遍历查找123456789101112131415161718192021222324252627import pkgutilimport xmlfor finder,name,ispkg in pkgutil.walk_packages(xml.__path__,xml.__name__+'.'): print(finder,name,ispkg)# 输出如下# FileFinder('C:\\tools\\Anaconda3\\lib\\xml') xml.dom True# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.NodeFilter False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.domreg False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.expatbuilder False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.minicompat False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.minidom False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.pulldom False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\dom') xml.dom.xmlbuilder False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml') xml.etree True# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\etree') xml.etree.ElementInclude False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\etree') xml.etree.ElementPath False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\etree') xml.etree.ElementTree False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\etree') xml.etree.cElementTree False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml') xml.parsers True# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\parsers') xml.parsers.expat False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml') xml.sax True# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\sax') xml.sax._exceptions False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\sax') xml.sax.expatreader False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\sax') xml.sax.handler False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\sax') xml.sax.saxutils False# FileFinder('C:\\tools\\Anaconda3\\lib\\xml\\sax') xml.sax.xmlreader False &emsp;&emsp;通过 pkgutil.walk_packages 可以遍历一个模块所有的子模块。&emsp;&emsp;from setuptools import find_packages 也可以实现类似的功能&emsp;&emsp;但是 find_packages 面对命名空间模块不好使，但是 walk_packages 好使。(原因是 find_packages 通过 os.walk 去查找路径的)&emsp;&emsp;也可以通过这个方式将对应模块的缓存进行删除~ 判断模块是否存在123456def importable(module_name) try: __import__(module_name) return True except ImportError: return False &emsp;&emsp;过去判断一模块是否可以 import 通常使用异常进行处理。&emsp;&emsp;其实 pkgutil.find_loader 也可以返回模块是否可以 import 1234import pkgutilloader = pkgutil.find_loader("os")maya = loader.load_module("os") if loader else Noneprint(maya) &emsp;&emsp;如果模块可以导入会返回对应的 loader，使用 load_module 可以进行加载。注: py2 的 load_module 必须要传参。 自定义 import 行为 &emsp;&emsp;除了 sys.path 通过系统路径查找 python 包进行加载之外。&emsp;&emsp;Python 还有 sys.meta_path 存储一系列 Finder 类 (Py3还需要 Loader 类) 来自定义 import 逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import sysimport typesclass CustomFinder(object): def __init__(self): self.submodule_search_locations = [] self.has_location = False self.origin = None def create_module(self, spec): return self.load_module(spec.name) def exec_module(self, module): """Execute the given module in its own namespace This method is required to be present by importlib.abc.Loader, but since we know our module object is already fully-formed, this method merely no-ops. """ def find_spec(self, fullname,*args): self.name = fullname self.loader = self return self.find_module() # NOTES(timmyliang): compat with Python2 def find_module(self,*args): return self def load_module(self, fullname): module = sys.modules.get(fullname) if module: return module new_module = types.ModuleType(fullname) sys.modules[fullname] = new_module new_module.__name__ = fullname new_module.__loader__ = self return new_moduleif __name__ == "__main__": sys.meta_path.append(CustomFinder()) import myapp print(myapp) # Py3: &lt;module 'myapp' (&lt;__main__.CustomFinder object at 0x000002A2A2904808&gt;)&gt; # Py2: &lt;module 'myapp' (built-in)&gt; &emsp;&emsp;上面的代码实现了 py2 py3 的 Finder 兼容。&emsp;&emsp;可以实现加载任意名称的模块都能成功返回而不会引发 ImportError&emsp;&emsp;当然这种操作如果用到项目里面，肯定会被人打死 😄 &emsp;&emsp;在 Py2 环境下 Finder 需要实现 find_module 和 load_module 方法&emsp;&emsp;Py3 环境可以参考下面的链接。 https://stackoverflow.com/a/58275573/13452951 &emsp;&emsp;需要有 Finder 需要实现 find_spec 返回 ModuleSpec 类，这个类需要有 Loader 进行加载逻辑 &emsp;&emsp;官方提供的 zipimport.zipimporter 在 Py2 下是 Finder ，在 Py3 下是 Loader。&emsp;&emsp;可以从下面官方文档的类方法中看出来。 https://docs.python.org/2.7/library/zipimport.html?highlight=zip#module-zipimporthttps://docs.python.org/3.10/library/zipimport.html?highlight=zip#module-zipimport &emsp;&emsp;通过需改 import 机制，可以实现很多黑科技，但是推荐使用侵入性较小的使用方式。&emsp;&emsp;这个机制可以让，某个模块可以虚空导入不报错，这不符合正常使用 Python 的逻辑，可能会让团队其他人很懵逼的。&emsp;&emsp;如果某个 BUG 是因为这个机制导致的，其他人又不熟悉这块的话，那这问题查半天也不一定有结果 😢 总结 &emsp;&emsp;本次深入浅出地学习了 Python Import 的各种底层逻辑。&emsp;&emsp;以后有机会的话也想好好学习一下 CPython 的底层实现。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python doit 库]]></title>
    <url>%2Fposts%2Fb552c0c3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;代码开发的过程中可能遇到一些情况想要通过 代码 来自动执行命令行生成一些东西的情况。&emsp;&emsp;如果不使用框架进行管理，这些代码脚本就很零碎地散落在各个地方。&emsp;&emsp;因此就找到这个框架可以很方便管理多个任务，实现 Github 地址官方说明文档 doit 的基本用法 &emsp;&emsp;在 doit 执行命令的地方添加一个 dodo.py 的脚本&emsp;&emsp;doit 会去读取 dodo.py 里面命名开头为 task_ 的方法作为执行的命令。 1234567891011def task_hello(): """hello""" def python_hello(targets): with open(targets[0], "a") as output: output.write("Python says Hello World!!!\n") return &#123; 'actions': [python_hello], 'targets': ["hello.txt"], &#125; &emsp;&emsp;比如添加上面的方法到 dodo.py 里面&emsp;&emsp;执行 doit list 可以罗列出当前的可执行的命令 1234F:\thm_git\adam_pose_editor&gt;doit listhello helloF:\thm_git\adam_pose_editor&gt;doit hello. hello &emsp;&emsp;执行 doit hello 就会在 dodo.py 缩在目录下输出一个 hello.txt 的文件。&emsp;&emsp;这个就是 doit 的基本用法。 dodo.py 配置https://pydoit.org/configuration.html &emsp;&emsp;可以使用 doit -f xxx/dodo.py 配置 dodo.py 的路径&emsp;&emsp;也可以使用 pyproject.toml 进行配置 12[tool.doit]dodoFile = "scripts/dodo.py" task 配置 &emsp;&emsp;dodo.py 的 task 支持导入&emsp;&emsp;只要是 task_ 前缀的方法就会自动识别。&emsp;&emsp;也可以给函数添加 create_doit_tasks 属性，这样就可以自动生成了。 文档链接 &emsp;&emsp;利用这些机制，我搞了一个装饰器可以给 task 添加一个短名的方案。 12345678910111213141516171819202122232425def add_short_name(short_name): """Doit for short decorator. Args: short_name (str): short alias name. Returns: callable: decoartor function. """ def decorator(func): globals()["task_&#123;0&#125;".format(short_name)] = func # noqa: WPS421 return func return decorator@add_short_name("pf")def task_preflight(): """Run pre commit for all files. Returns: dict: doit config. """ command = ["poetry", "run", "pre-commit", "run", "-a"] return &#123;"actions": [command], "verbosity": 2&#125; &emsp;&emsp;这样运行 doit 会识别到两个 task ，可以分别通过 doit pf 或者 doit preflight 触发指令 123&gt;doit list pf Run pre commit for all files.preflight Run pre commit for all files. &emsp;&emsp;但是默认排序是按命名来的，如果命令很多就会混在一起 12345678910111213141516171819&gt;doit list b Run black format all python files.black Run black format all python files.d Run mkdocs serve.dd Run mike to deploy docs.docs Run mkdocs serve.docs_deploy Run mike to deploy docs.f Run `black` `isort`.format Run `black` `isort`.i Run isort format all python files.isort Run isort format all python files.l Run flakehell lint for all python files.lint Run flakehell lint for all python files.m Run mike serve.mike Run mike serve.pf Run pre commit for all files.preflight Run pre commit for all files.pt Run pytest.pytest Run pytest. &emsp;&emsp;可以使用 doit list –sort=definition 的方式让排序变成创建顺序。 12345678910111213141516171819&gt;doit list --sort=definitionf Run `black` `isort`.format Run `black` `isort`.pf Run pre commit for all files.preflight Run pre commit for all files.b Run black format all python files.black Run black format all python files.i Run isort format all python files.isort Run isort format all python files.l Run flakehell lint for all python files.lint Run flakehell lint for all python files.pt Run pytest.pytest Run pytest.d Run mkdocs serve.docs Run mkdocs serve.m Run mike serve.mike Run mike serve.dd Run mike to deploy docs.docs_deploy Run mike to deploy docs. &emsp;&emsp;但是每次使用都要加一个参数配置，那是相当的麻烦。&emsp;&emsp;我们可以利用 DOIT_CONFIG 进行配置 文档链接 123DOIT_CONFIG = &#123; "sort": "definition",&#125; task group &emsp;&emsp;可以使用 task_dep 的方式执行多个定义好的 task 文档链接 1234567891011121314151617181920212223242526272829303132import globDIR = os.path.dirname(__file__)PY_FILES = glob.glob(os.path.join(DIR, "**/*.py"), recursive=True)@add_short_name("f")def task_format(): """Run `black` `isort`. Returns: dict: doit config. """ return &#123;"actions": None, "task_dep": ["black", "isort"]&#125;@add_short_name("b")def task_black(): """Run black format all python files. Returns: dict: doit config. """ command = ["poetry", "run", "black"] + PY_FILES return &#123;"actions": [command], "verbosity": 2&#125;@add_short_name("i")def task_isort(): """Run isort format all python files. Returns: dict: doit config. """ command = ["poetry", "run", "isort"] + PY_FILES return &#123;"actions": [command], "verbosity": 2&#125; &emsp;&emsp;通过上面的配置就可以快速给所有的 python 脚本运行 black 和 isort task 传参文档链接 1234567891011121314151617181920212223242526272829303132333435363738def gen_api(api): """Generate API docs. Args: api (bool): flag to generate docs Returns: str: running command """ # NOTES(timmyliang): remove reference api rmtree(os.path.join(DIR, "docs", "reference"), ignore_errors=True) script_path = os.path.join(DIR, "docs", "gen_api_nav.py") api_command = " ".join(["poetry", "run", "python", script_path]) serve_command = " ".join(["poetry", "run", "mkdocs", "serve"]) return f"&#123;api_command&#125; &amp; &#123;serve_command&#125;" if api else serve_command@add_short_name("d")def task_docs(): """Run mkdocs serve. Returns: dict: doit config. """ return &#123; "actions": [CmdAction(gen_api)], "params": [ &#123; "name": "api", "short": "a", "type": bool, "default": False, "inverse": "flagoff", "help": "generate api docs", &#125;, ], "verbosity": 2, &#125; &emsp;&emsp;通过 params 定义传入的参数，就可以控制 mkdocs 是否自动生成 api 的 markdown 脚本。 总结 &emsp;&emsp;目前我使用上面的写法已经很够用了，其实它还有很多其他的配置可以用来做 C 编译。&emsp;&emsp;还可以定义 task 依赖 和 文件依赖，确保 task 的执行顺序。&emsp;&emsp;整体而言，doit 是个非常简单而是用的框架，配置 tox 等工具可谓是锦上添花。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python dependencies 库]]></title>
    <url>%2Fposts%2F7aa50252.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在 Java Spring Boot 等等的后端领域，会大量使用依赖注入的方式来简化复杂的设计模式。&emsp;&emsp;实现参数的自动化注入。&emsp;&emsp;这些设计方式在 Python 的世界里使用不多，因为 Python 语言足够灵活。&emsp;&emsp;倘若需要开发复杂的框架，使用 依赖注入 框架可以简化很多代码。 Github 地址官方说明文档 依赖注入解决的问题参考文章 &emsp;&emsp;在日常开发中，我们的方法调用可能会越来越深。 123456789def create_robot(robot_name): create_robot_hand() def create_robot_hand(): create_robot_finger()def create_robot_finger(): print("create_robot_finger") &emsp;&emsp;上面是一个简单的机器人创建调用函数。&emsp;&emsp;调用方式会伴随则系统的复杂程度逐层深入。&emsp;&emsp;到了 create_robot_finger 深度的时候，可能会需要在上层传入参数控制 finger 的数量 123456789def create_robot(robot_name,finger_num=10): create_robot_hand(finger_num=finger_num) def create_robot_hand(finger_num=10): create_robot_finger(finger_num=finger_num)def create_robot_finger(finger_num=10): print("create_robot_finger finder_number:&#123;0&#125;".format(finger_num)) &emsp;&emsp;这需要将参数补充到 调用链条 的每一个函数当中。&emsp;&emsp;如果只是上面的 三层 调用深度，那可能手动修改维护还不是什么问题。&emsp;&emsp;但倘若调用深度很深，那这个代码修改量就会非常庞大。&emsp;&emsp;不利于代码的扩展和维护。 &emsp;&emsp;在 Python 的世界里，解决这个问题的方法有很多。 导入 配置 模块，外部获取参数配置 面向对象 注入依赖，从实例化中获取参数配置 方案一 导入模块1234567"""settings.py"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_importROBOT_FINGER_NUM = 10 12345678910import settingsdef create_robot(robot_name): create_robot_hand() def create_robot_hand(): create_robot_finger()def create_robot_finger(): print("create_robot_finger finder_number:&#123;0&#125;".format(settings.ROBOT_FINGER_NUM)) &emsp;&emsp;通过模块的方式将参数转移到外部，进行配置。&emsp;&emsp;这个做法可以解决参数传递的问题。 &emsp;&emsp;缺点就是参数管理会比较麻烦，通常是将全局配置的参数都放到一个文件方便集中管理。&emsp;&emsp;但是这样会导致不同的逻辑调用的参数都会塞到一个文件里面，并不是十分整洁。 方案二 注入依赖123456789101112131415161718192021222324252627from dependencies import Injectorimport attr@attr.sclass Robot(object): finger_num = attr.ib(default=10) def create_robot(self,robot_name): self.create_robot_hand() def create_robot_hand(self): self.create_robot_finger() def create_robot_finger(self): print("create_robot_finger finder_number:&#123;0&#125;".format(self.finger_num))class Container(Injector): finger_num = 10 robot = RobotContainer.robot.create_robot("robot name")# 打印 create_robot_finger finder_number:10# `dependencies` 的实现等价于下面的代码robot = Robot(finger_num=10)robot.create_robot("robot name") &emsp;&emsp;使用 dependencies 库实现依赖注入，自动将容器内的数据填充到 类的实例化过程中。&emsp;&emsp;通过类的属性实现参数传递。 dependencies 介绍 &emsp;&emsp;通过上面的案例可以看到。&emsp;&emsp;dependencies 可以自动实例化类，填充类初始化需要的参数。&emsp;&emsp;但它的功能还远不止这么简单。&emsp;&emsp;它还可以实现多个类实例化的自动填充，只要参数变量名命名配置好即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243from dependencies import Injectorimport attr@attr.sclass Robot(object): servo = attr.ib() controller = attr.ib() settings = attr.ib() di_environment = attr.ib() def run(self): print("controller di_environment",self.controller.di_environment) print("self di_environment",self.di_environment) print("settings threshold",self.settings.threshold) print("servo threshold",self.servo.threshold)@attr.sclass Servo(object): threshold = attr.ib() @attr.sclass Controller(object): di_environment = attr.ib()@attr.sclass Settings(object): threshold = attr.ib()class Container(Injector): threshold = 1 di_environment = "production" robot = Robot servo = Servo settings = Settings controller = ControllerContainer.robot.run()# 打印: # controller di_environment production# self di_environment production# settings threshold 1# servo threshold 1 &emsp;&emsp;通过 dependencies 可以根据属性命名自动填充多个类的参数数据。&emsp;&emsp;container 的逻辑等价于下面的代码 123456789101112threshold = 1di_environment = "production"servo = Servo(threshold)settings = Settings(threshold)controller = Controller(di_environment)robot = Robot(servo,controller,settings,di_environment)robot.run()# 打印: # controller di_environment production# self di_environment production# settings threshold 1# servo threshold 1 &emsp;&emsp;但是 dependencies 库根据参数的命名自动实例化对象，参数的调整变得简单可控。 dependencies 实现 caller 方法参考文章 &emsp;&emsp;利用 依赖注入 可以分离 依赖 和 业务 逻辑 1234567891011121314151617181920212223import attrfrom dependencies import Injectorclass Editor(object): def install_language(self,lang): print("install language:&#123;0&#125;".format(lang))editor = Editor()@attr.s(frozen=True, slots=True)class ChangeLanguage(object): editor = attr.ib() def __call__(self,lang): self.editor.install_language(lang)class Container(Injector): editor = editor change_language = ChangeLanguageContainer.change_language("en_US")# 打印: install language:en_US &emsp;&emsp;利用 dependencies 可以构建出 caller 对象。&emsp;&emsp;caller 虽然用类构建，但是调用方式和方法一致，可以方法需要用到的依赖用类实例化的方式进行注入。&emsp;&emsp;实现依赖和传参的分离。 总结 &emsp;&emsp;依赖注入可以很好解决函数调用过深的问题，让代码结构更加清晰。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python blinker 库]]></title>
    <url>%2Fposts%2F9ad5ab39.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Qt 内置了非常棒的 信号槽的函数。&emsp;&emsp;可以让 UI 进行异步调用。&emsp;&emsp;但是有些时候，并不想依赖 Qt 框架同时又能实现信号槽的功能。&emsp;&emsp;这里可以使用 blinker 库来完成。 Github 地址官方说明文档 blinker 基本用法12345from blinker import signal,Signalinitialized = signal('initialized')initialized is signal('initialized')sig = Signal() &emsp;&emsp;可以使用匿名信号槽，也可以使用带名称的信号槽。 123456789from blinker import signalsend_data = signal('send-data')@send_data.connectdef receive_data(sender, **kw): print("Caught signal from %r, data %r" % (sender, kw)) return 'received!'result = send_data.send('anonymous', abc=123)print(result) # 打印 [(&lt;function receive_data at 0x000002A3328D4DC8&gt;, 'received!')]# 打印 Caught signal from 'anonymous', data &#123;'abc': 123&#125; &emsp;&emsp;可以用装饰器的方式连接信号槽&emsp;&emsp;触发信号槽使用 send 方法&emsp;&emsp;并且信号槽执行完可以拿到函数触发的返回值。 123456789from blinker import signaldice_roll = signal('dice_roll')@dice_roll.connect_via(1)@dice_roll.connect_via(3)@dice_roll.connect_via(5)def odd_subscriber(sender): print("Observed dice roll %r." % sender)result = dice_roll.send(3) &emsp;&emsp;另外一个特点就是可以根据触发的参数去触发相应注册的函数。&emsp;&emsp;Qt 因为要使用 C++，这种注册方式会非常麻烦。 12345678910111213141516171819202122232425262728from blinker import signalinitialized = signal("initialized")@initialized.connectdef initialize_call1(): print("initialize_call1")@initialized.connectdef initialize_call2(): print("initialize_call2")@initialized.connectdef initialize_call3(): print("initialize_call3")for key, weakref in initialized.receivers.items(): func = weakref() func()# 打印: # initialize_call1# initialize_call2# initialize_call3 &emsp;&emsp;通过信号槽的 receivers 方法可以获取到注册到信号槽的所有函数。 总结 &emsp;&emsp;这个库可以摆脱 Qt 的依赖实现函数的异步调用。&emsp;&emsp;如果是 Qt 的环境建议还是使用 Qt 内置的 信号槽，这样可以支持 Qt 的多线程等处理。&emsp;&emsp;但如果是 Python 环境下想要摆脱 Qt 的依赖，则推荐 blinker 来完成信号触发。&emsp;&emsp;blinker 还有个好处是可以获取到注册的函数列表，而 Qt 基于 C++ 的并没有提供这个功能，只能通过 Meta 对象来判断这个信号槽是否有函数连接。 参考实现]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python marshmallow 库]]></title>
    <url>%2Fposts%2F2c8022e3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;使用 Python 经常需要将一些数据序列化存储到本地&emsp;&emsp;同时又想要反序列化将本地的 json 数据转换为对象。&emsp;&emsp;通常的解决方案是使用数据库的 orm 方案，用 orm 对象来同步数据库。&emsp;&emsp;数据全部附着在 orm 上，当 orm 上的数据改变时直接修改到数据库上。 &emsp;&emsp;但是在我的工作使用场景中，Data Centric 的流程更为推崇，因此输出一个 json 文件会更好一点。&emsp;&emsp;那么 marshmallow 库就是一个很不错的选项。 &emsp;&emsp;另外这个库可以和 之前提到的 attrs 库可以结合使用。 文章 Github 地址官方说明文档 什么是序列化 什么是 orm &emsp;&emsp;序列化就是将代码对象转换为纯数据进行存储&emsp;&emsp;反序列化就是将纯数据重新转换为 代码对象&emsp;&emsp;代码对象可以拥有特定的方法，可以直接触发对数据的处理。 &emsp;&emsp;orm 全称是 Object-relational Mappers&emsp;&emsp;通常是一个定义了对象实例化规则的类。&emsp;&emsp;通过操作这个类的实例就可以用代码的方式将数据进行互相转换。 &emsp;&emsp;上面的图片就是传统 orm 实现的效果，可以用 orm 对象来执行 sql 语句从而简化数据库同步的操作，同时也增加了代码的安全性。&emsp;&emsp;这个操作实现了内存到硬盘桥梁，管理更加清晰方便。 marshmallow 介绍marshmallow 基本用法 &emsp;&emsp;和其他 orm 库一样，marshmallow 需要定义 Schema 类作为数据约束。 1234567891011121314151617181920212223242526272829303132333435363738import attr@attr.sclass Album(object): title = attr.ib() artist = attr.ib() @attr.sclass Artist(object): name = attr.ib()# NOTE 生成 Python 对象bowie = Artist(name="David Bowie")album = Album(artist=bowie, title="Hunky Dory")from marshmallow import Schema, fields# NOTE 定义 Schema 来约束数据转换class ArtistSchema(Schema): name = fields.Str()class AlbumSchema(Schema): title = fields.Str() artist = fields.Nested(ArtistSchema())# NOTE 通过 Schema 将对象转换为字典schema = AlbumSchema()result = schema.dump(album)print(type(result)) # &lt;class 'dict'&gt;print(result) # &#123;'artist': &#123;'name': 'David Bowie'&#125;, 'title': 'Hunky Dory'&#125;result = schema.dumps(album)print(type(result)) # &lt;class 'str'&gt;print(result) # '&#123;"artist": &#123;"name": "David Bowie"&#125;, "title": "Hunky Dory"&#125;'album = schema.loads(result)print(type(album)) # &lt;class 'dict'&gt;print(album) # &#123;'artist': &#123;'name': 'David Bowie'&#125;, 'title': 'Hunky Dory'&#125; &emsp;&emsp;通过 Schema 定义好数据对象的转换方式。&emsp;&emsp;dump 可以将对象数据转换为字典，dumps 则是转换为 字符串&emsp;&emsp;load 可以将字典转换为对象(默认是字典，需要额外的处理才可以)，loads 可以将字符串转换为对象。 反序列化为对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import attrfrom marshmallow import Schema, fields, post_load@attr.sclass Album(object): title = attr.ib() artist = attr.ib()@attr.sclass Artist(object): name = attr.ib()class ArtistSchema(Schema): name = fields.Str()class ArtistSchema(Schema): name = fields.Str() @post_load def make_artist(self, data, **kwargs): return Artist(**data)class AlbumSchema(Schema): title = fields.Str() artist = fields.Nested(ArtistSchema()) @post_load def make_album(self, data, **kwargs): return Album(**data)bowie = Artist(name="David Bowie")album = Album(artist=bowie, title="Hunky Dory")# NOTE 通过 Schema 将对象转换为字典schema = AlbumSchema()result = schema.dumps(album)album = schema.loads(result)print(album) # Album(title='Hunky Dory', artist=Artist(name='David Bowie'))print(album.title) # Hunky Doryprint(album.artist) # Artist(name='David Bowie')print(album.artist.name) # David Bowie &emsp;&emsp;通过加入 post_load 装饰器可以将字典数据做进一步的转换。&emsp;&emsp;使用 attrs 库就不需要在 __init__ 函数中写入大量传参和初始化数据的信息了。 嵌套 Schema官方文档 &emsp;&emsp;通过 fields.Nested 的方法定义嵌套的对象，从而序列化和反序列化可以复用 Schema。 123456789101112131415161718192021222324252627282930313233import attrfrom marshmallow import Schema, fields@attr.sclass Book(Dict): title = attr.ib() author = attr.ib()@attr.sclass Author(Dict): name = attr.ib() books = attr.ib()potter = Book("potter", "JK")JK = Author("JK", [potter])potter.author = JKclass BookSchema(Schema): title = fields.Str() author = fields.Nested("AuthorSchema", only=("name",))class AuthorSchema(Schema): name = fields.Str() books = fields.List(fields.Nested("BookSchema", exclude=("author",)))schema = BookSchema()res = schema.dump(potter)print(res) # &#123;'title': 'potter', 'author': &#123;'name': 'JK'&#125;&#125; 自定义 Field官方文档 &emsp;&emsp;默认提供的 field 可能不能满足需求。&emsp;&emsp;有些库的 field 需要自定义复杂的 序列化 和 反序列化操作。&emsp;&emsp;这个时候就可以定义自己的 field 来解决问题。 &emsp;&emsp;简单的情况可以使用 Method 和 Function 来解决问题 12345678class UserSchema(Schema): name = fields.String() email = fields.String() created_at = fields.DateTime() since_created = fields.Method("get_days_since_created") def get_days_since_created(self, obj): return dt.datetime.now().day - obj.created_at.day 12345class UserSchema(Schema): name = fields.String() email = fields.String() created_at = fields.DateTime() uppername = fields.Function(lambda obj: obj.name.upper()) &emsp;&emsp;默认情况下是 serialize 函数，如果要自定义 deserialize 可以使用 Method 和 Function 传入 deserialize 参数进行指定。 &emsp;&emsp;复杂的情况就需要 fields.Field 类。 12345678910111213141516171819202122232425from marshmallow import fields, ValidationErrorclass PinCode(fields.Field): """Field that serializes to a string of numbers and deserializes to a list of numbers. """ def _serialize(self, value, attr, obj, **kwargs): if value is None: return "" return "".join(str(d) for d in value) def _deserialize(self, value, attr, data, **kwargs): try: return [int(c) for c in value] except ValueError as error: raise ValidationError("Pin codes must contain only digits.") from errorclass UserSchema(Schema): name = fields.String() email = fields.String() created_at = fields.DateTime() pin_code = PinCode() 踩过的坑双向嵌套数据 &emsp;&emsp;如果数据存在相互嵌套引用的关系，是无法通过原生的 json 内置库进行序列化的。 1234567891011121314151617181920212223242526272829303132import attrimport jsonfrom addict import Dictfrom marshmallow import Schema, fields@attr.sclass Book(Dict): title = attr.ib() author = attr.ib()@attr.sclass Author(Dict): name = attr.ib() books = attr.ib()potter = Book("potter", "JK")JK = Author("JK", [potter])potter.author = JKprint(json.dumps(potter))# Traceback (most recent call last):# File "f:/repo/_blog/source/_posts/Python/pacakge/02_marshmallow.py", line 22, in &lt;module&gt;# print(json.dumps(potter))# File "C:\tools\Anaconda3\lib\json\__init__.py", line 231, in dumps# return _default_encoder.encode(obj)# File "C:\tools\Anaconda3\lib\json\encoder.py", line 199, in encode# chunks = self.iterencode(o, _one_shot=True)# File "C:\tools\Anaconda3\lib\json\encoder.py", line 257, in iterencode# return _iterencode(o, 0)# ValueError: Circular reference detected &emsp;&emsp;marshmallow 则需要通过 Schema 的定义过滤掉特定的嵌套键值才可用。&emsp;&emsp;并且加载数据的时候并不能还原它们原有的关联关系。&emsp;&emsp;需要自己的手动去定义反序列化之后的操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import attrimport jsonfrom addict import Dictfrom marshmallow import Schema, fields,post_load@attr.sclass Book(Dict): title = attr.ib() author = attr.ib(default="")@attr.sclass Author(Dict): name = attr.ib() books = attr.ib(factory=list)potter = Book("potter", "JK")JK = Author("JK", [potter])potter.author = JKclass BookSchema(Schema): title = fields.Str() author = fields.Nested("AuthorSchema", only=("name",)) @post_load def make_object(self, data, **kwargs): book = Book(**data) if 'author' in data: books = book.author.books if book not in books: books.append(book) return bookclass AuthorSchema(Schema): name = fields.Str() books = fields.List(fields.Nested("BookSchema", exclude=("author",))) @post_load def make_object(self, data, **kwargs): author = Author(**data) for book in author.books: book.author = author return authorschema = BookSchema()res = schema.dumps(potter).datanew_potter = schema.loads(res).dataprint(potter) # Book(title='potter', author=Author(name='JK', books=[...]))print(new_potter) # Book(title='potter', author=Author(name='JK', books=[...]))schema = AuthorSchema()res = schema.dumps(JK).datanew_JK = schema.loads(res).dataprint(JK) # Author(name='JK', books=[Book(title='potter', author=...)])print(new_JK) # Author(name='JK', books=[Book(title='potter', author=...)]) &emsp;&emsp;关系重建需要手动处理。 总结 &emsp;&emsp;使用 marshmallow 可以很方便实现数据序列化。&emsp;&emsp;使用的时候可以配合 addict 以及下一篇文章要介绍的 cerberus 结合使用。&emsp;&emsp;可以让使用体验更上一层楼。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python cerberus 库]]></title>
    <url>%2Fposts%2F8a7956b2.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;cerberus 翻译为地狱犬，是地狱的看门狗，比喻做数据的校验者。&emsp;&emsp;这个库是专门用来校验做数据校验。&emsp;&emsp;可以通过定义一个 schema 文件来快速校验数据是否复合 schema。 Github 地址官方说明文档 cerberus 介绍cerberus 基本用法123456789101112131415from cerberus import Validatorschema = &#123; "name": &#123;"type": "string"&#125;, "member": &#123; "type": "dict", "require_all": True, "schema": &#123;"address": &#123;"type": "string"&#125;&#125;, &#125;,&#125;v = Validator(schema)document = &#123;"name": "john doe", "member": &#123;&#125;&#125;result = v.validate(document)print(result) # 打印 Falseprint(v.errors) # 打印 &#123;'member': [&#123;'address': ['required field']&#125;]&#125; &emsp;&emsp;主要用法就是定义一个规范。&emsp;&emsp;cerberus 会根据这个规范对数据进行校验。&emsp;&emsp;这其中的规则既可以根据官方文档添加，也可以继承 Validator 实现自定义的规则。 cerberus 嵌套检查1234567from cerberus import schema_registryschema_registry.add("non-system user", &#123;"uid": &#123;"min": 1000, "max": 0xFFFF&#125;&#125;)schema = &#123; "sender": &#123;"schema": "non-system user", "allow_unknown": True&#125;, "receiver": &#123;"schema": "non-system user", "allow_unknown": True&#125;,&#125; &emsp;&emsp;导入 schema_registry 添加到里面的 schema 可以被别的地方复用。&emsp;&emsp;别的 schema 只要输入相应的字符串就可以复用 schema&emsp;&emsp;或者也可以通过接入字典变量的方式来复用 schema cerberus 自定义检查功能 &emsp;&emsp;扩展检查规则可以通过继承 Validator 来实现，非常简单方便。 123456789101112131415from cerberus import Validatorclass MyValidator(Validator): def _validate_is_odd(self, constraint, field, value): """ Test the oddity of a value. The rule's arguments are validated against this schema: &#123;'type': 'boolean'&#125; """ if constraint is True and not bool(value &amp; 1): self._error(field, "Must be an odd number")schema = &#123;'amount': &#123;'is odd': True, 'type': 'integer'&#125;&#125;v = MyValidator(schema)v.validate(&#123;'amount': 10&#125;) # 打印 False 结合 marshmallow 使用 &emsp;&emsp;使用 cerberus 的 schema 可以让校验规则统一到一个地方进行配置。&emsp;&emsp;配置更加清晰，查找也比较方便。&emsp;&emsp;相较于使用 attrs 或者 marshmallow 提供校验功能。&emsp;&emsp;cerberus 可以更加清晰地配置和修改。 &emsp;&emsp;我上一篇文章介绍了使用 marshmallow 可以很方便地对数据进行序列化。&emsp;&emsp;同时它也可以对每一个 field 编写函数进行数据校验，但是如果使用 嵌套 Schema 的话&emsp;&emsp;这些校验方法东一块西一块，配置和修改都非常繁琐。&emsp;&emsp;这个使用可以结合 marshmallow 的 validates_schema 装饰器通过函数调用 cerberus 进行数据校验。 marshmallow 文档 12345678910111213141516171819202122232425262728293031from marshmallow import Schema, fields, validates_schema, ValidationErrorfrom cerberus import Validatorschema = &#123; "field_a": &#123; "required": True, "type": "integer", "min": 0, "max": 5, &#125;&#125;validator = Validator(schema)class MySchema(Schema): field_a = fields.Int(required=True) field_b = fields.Int(required=True) @validates_schema(pass_original=True) def validate_schema(self, data, original_data): if not validator.validate(original_data): raise ValidationError(validator.errors)schema = MySchema()document = &#123; "field_a": -1, "field_b": -1,&#125;res, err = schema.load(document)print(err) # 打印 &#123;'_schema': [&#123;'field_a': ['min value is 0'], 'field_b': ['unknown field']&#125;]&#125; &emsp;&emsp;这样就可以实现反序列化数据的同时进行数据校验。 总结 &emsp;&emsp;cerberus 其实也可以做数据的 coerce ，实现一定程度的序列化功能。&emsp;&emsp;不过如果需要嵌套的话，还是用 marshmallow 进行处理比较方便。&emsp;&emsp;而且 marshmallow 嵌套调用也可以配合着 cerberus 顺便进行数据校验。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python decorator & wrapt 库]]></title>
    <url>%2Fposts%2Fb9593ce4.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Python 的装饰器是个好东西，自从加入了语法糖 @ 之后。&emsp;&emsp;装饰器方法可以实现很多功能，同时又不会把代码给弄乱。&emsp;&emsp;这里会剖析何为装饰器，并且推荐两个简化装饰器的库 什么是装饰器 &emsp;&emsp;装饰器可以在函数裹上一层壳，在函数调度前和调度后触发新的逻辑。&emsp;&emsp;这样可以在原有的逻辑不动的情况下，添加新的逻辑。&emsp;&emsp;比如修改函数的传参，修改函数的返回值。&emsp;&emsp;也可以通过装饰器给原来简单的函数添加新的功能。 123456789101112131415161718192021def deco_func(func): def decorator(*args, **kwargs): print("before call") res = func(*args, **kwargs) print("after call") return res return decorator@deco_funcdef call_func(): print("on running")call_func()# 打印如下# before call# on running# after call &emsp;&emsp;装饰器的本质其实下面这种写法的语法糖。 12345def call_func(): print("on running")call_func = deco_func(call_func) &emsp;&emsp;两者的本质是一样的，但是用语法糖可以更加清晰看到这个函数被什么所包裹。&emsp;&emsp;另外实现装饰器的方法还可以用类来实现。 123456789class DecoratorClass(object): def __init__(self,func): self.func = func def __call__(self,*args, **kwargs): print("before call") result= self.func(*args, **kwargs) print("after call") return result &emsp;&emsp;上面实现的装饰器不能携带参数，如果需要传入参数需要返回一个装饰器 12345678910111213141516171819202122def deco_func(arg1=1,arg2=2): def decorator(func): def wrapper(*args, **kwargs): print(arg1,arg2) print("before call") res = func(*args, **kwargs) print("after call") return res return wrapper return decorator@deco_func(arg1=3)def call_func(): print("on running")call_func()# 3 2# before call# on running# after call &emsp;&emsp;这里需要三重函数嵌套会让装饰器繁琐且复杂。&emsp;&emsp;而且由于装饰器返回的函数和源函数是不一致的，默认情况下无法继承 __doc__ 等函数属性。&emsp;&emsp;解决这个问题需要给嵌套里面的函数加上 `@functools.wraps(func)` 的装饰器来同步才行。 1234567import functoolsdef deco_func(func): @functools.wraps(func) def decorator(*args, **kwargs): return func(*args, **kwargs) return decorator decorator 库介绍 &emsp;&emsp;想要解决这个问题有两个库可以推荐 decorator &amp; wrapt Python 库 wrapt decorator 类装饰 ✔ ❌ 受欢迎程度 ✔ ❌ 简洁 ❌ ✔ 性能 ❌ ✔ &emsp;&emsp;wrapt 解决的问题更多，比 decorator 更加流行。&emsp;&emsp;decorator 则使用简单且方便，而且性能比 wrapt 要好。&emsp;&emsp;可以根据实际的使用情况来选择。 装饰案例123456789101112131415161718192021import timeitfrom decorator import decorator@decoratordef warn_slow(func, timelimit=60, *args, **kw): t0 = time.time() result = func(*args, **kw) dt = time.time() - t0 if dt &gt; timelimit: logging.warn('%s took %d seconds', func.__name__, dt) else: logging.info('%s took %d seconds', func.__name__, dt) return result@warn_slow # warn if it takes more than 1 minutedef preprocess_input_files(inputdir, tempdir): ...@warn_slow(timelimit=600) # warn if it takes more than 10 minutesdef run_calculation(tempdir, outdir): ... 12345678from decorator import decorator@decoratordef with_arguments(func, myarg1=2, myarg2=3, *args, **kwargs): return func(*args, **kwargs)@with_arguments(myarg1=1,myarg2=2)def function(): pass &emsp;&emsp;decorator 库只需要一个装饰器就可以让函数同时支持带参数和不带参数。 1234567891011import wraptdef with_arguments(myarg1, myarg2): @wrapt.decorator def wrapper(wrapped, instance, args, kwargs): return wrapped(*args, **kwargs) return wrapper@with_arguments(1, 2)def function(): pass &emsp;&emsp;wrapt 库则还是需要使用嵌套函数才能实现，但是可以简化一个函数嵌套。 注意事项12345678910111213141516171819202122from decorator import decorator@decoratordef pass_through(func, timelimit=60, *args, **kw): return func(*args, **kw)@pass_throughclass Class(object): @staticmethod def function_im(cls, *args): print(cls)# Traceback (most recent call last):# File "&lt;stdin&gt;", line 2, in &lt;module&gt;# File "&lt;decorator-gen-1&gt;", line 3, in pass_through# File "c:\_thm\rez_local_cache\ext\decorator\4.4.2\site-packages\decorator.py", line 252, in decorate # evaldict, __wrapped__=func)# File "c:\_thm\rez_local_cache\ext\decorator\4.4.2\site-packages\decorator.py", line 213, in create# self = cls(func, name, signature, defaults, doc, module)# File "c:\_thm\rez_local_cache\ext\decorator\4.4.2\site-packages\decorator.py", line 143, in __init__ # raise TypeError('You are decorating a non function: %s' % func)# TypeError: You are decorating a non function: &lt;class '__main__.Class'&gt; &emsp;&emsp;decorator 不能装饰类，但是 wrapt 可以做到 1234567891011121314151617181920212223import wrapt@wrapt.decoratordef pass_through(wrapped, instance, args, kwargs): print(wrapped,instance) res = wrapped(*args, **kwargs) return resclass Base(object): def __init__(self): print("call Base")@pass_throughclass Class(Base): def __init__(self): super(Class.__wrapped__, self).__init__() def function_im(self, *args): print(self)print(type(Class)) # &lt;class 'FunctionWrapper'&gt;a = Class()a.function_im(1) &emsp;&emsp;wrapt 可以装饰类，但是装饰返回一个 FunctionWrapper 类型&emsp;&emsp;会影响到 super 传参调用，需要调用 wrapped 才正常。&emsp;&emsp;如果是 Python3 则直接使用 super() 可以生效 总结 &emsp;&emsp;wrapt 库更加通用，但是如果不是复杂的情况， decorator 库就已经够用了。&emsp;&emsp;wrapt 可以解决装饰类的时候，类信息的同步。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python pluggy 库]]></title>
    <url>%2Fposts%2F7beafa88.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp; 什么是 pluggy &emsp;&emsp;pluggy 是 pytest 团队开发的库，&emsp;&emsp;用来解决给 pytest 写扩展插件的。&emsp;&emsp;pluggy 提供了方便的 API 可以很轻松的扩展框架的逻辑。 Github仓库文档地址 pluggy 的调度方式 draw.io链接 pluggy 有三大要素 HookspecMarker(hookspec) 定义HookimplMarker(hookimpl) 实现PluginManager(pm) 插件管理器 &emsp;&emsp;spec 定义了可以暴露的方法，可以通过 pm.hook 去调用对应的方法&emsp;&emsp;调用的时候会逐个执行 impl 注册的插件，按 LIFO 后进先出的方式进行。 pluggy 案例代码1234567891011121314151617181920212223242526272829303132333435363738394041import pluggyhookspec = pluggy.HookspecMarker("myproject")hookimpl = pluggy.HookimplMarker("myproject")class MySpec: """A hook specification namespace.""" @hookspec def myhook(self, arg1, arg2): """My special little hook that you can customize."""class Plugin_1: """A hook implementation namespace.""" @hookimpl def myhook(self, arg1, arg2): print("inside Plugin_1.myhook()") return arg1 + arg2class Plugin_2: """A 2nd hook implementation namespace.""" @hookimpl def myhook(self, arg1, arg2): print("inside Plugin_2.myhook()") return arg1 - arg2# create a manager and add the specpm = pluggy.PluginManager("myproject")pm.add_hookspecs(MySpec)# register pluginspm.register(Plugin_1())pm.register(Plugin_2())# call our `myhook` hookresults = pm.hook.myhook(arg1=1, arg2=2)print(results) &emsp;&emsp;代码来自官方文档&emsp;&emsp;执行会先触发 Plugin_2 再触发 Plugin_1 &emsp;&emsp;上述是 pluggy 最简单的用法&emsp;&emsp;还有 firstresult hookwrapper 等用法&emsp;&emsp;可以参照文档说明学习，用法非常灵活。 &emsp;&emsp;pm.hook.myhook 就是在源代码中的 代码桩。&emsp;&emsp;之前注册的插件都会在这个代码桩中逐一触发。&emsp;&emsp;pluggy 是可配置的，可以用代码动态地修改注册地插件，实时改变运行的逻辑。 总结 &emsp;&emsp;使用 pluggy 可以将功能拆分成小文件 更好适配代码规范 逻辑更加简洁清晰，查找方便 功能扩展简单 启用禁用功能很方便]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python addict 库]]></title>
    <url>%2Fposts%2F531dbb5a.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp; attrs 介绍总结 &emsp;&emsp;]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python attrs 库]]></title>
    <url>%2Fposts%2F1f4cc7d1.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;作为 TA 工具人，已经用 Python 很长一段时间，很多内置库都使用得得心应手了。&emsp;&emsp;最近开始尝试了解一些第三方库，从而能够更好解决一些实际运用遇到的问题。&emsp;&emsp;attrs 这个库是一个非常不错的代码优化方案。&emsp;&emsp;可以简略了很多类描述的方法。 Github 地址官方说明文档 attrs 解决的问题 &emsp;&emsp;attrs 统一了类属性描述，让代码更加简洁可读。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class ArtisanalClass(object): def __init__(self, a, b): self.a = a self.b = b def __repr__(self): return "ArtisanalClass(a=&#123;&#125;, b=&#123;&#125;)".format(self.a, self.b) def __eq__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) == (other.a, other.b) else: return NotImplemented def __ne__(self, other): result = self.__eq__(other) if result is NotImplemented: return NotImplemented else: return not result def __lt__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) &lt; (other.a, other.b) else: return NotImplemented def __le__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) &lt;= (other.a, other.b) else: return NotImplemented def __gt__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) &gt; (other.a, other.b) else: return NotImplemented def __ge__(self, other): if other.__class__ is self.__class__: return (self.a, self.b) &gt;= (other.a, other.b) else: return NotImplemented def __hash__(self): return hash((self.__class__, self.a, self.b)) &emsp;&emsp;如果要写一个完整的类需要加上很多内置方法的实现。&emsp;&emsp;这会导致大量的重复工作，而且代码会非常冗长。 12345import attr@attr.sclass SmartClass(object): a = attr.ib() b = attr.ib() 代码例子来源于 文档 &emsp;&emsp;attrs 只需要简单的描述就可以帮你完成上面一大堆的功能，非常有用。 1234567891011121314151617181920212223class SM_Controller(object): def __init__(self,polyName,col,row,conPre,size,shape,color,shape): self.start = start self.polyName = polyName self.col = col self.row = row self.conPre = conPre self.size = size self.shape = shape self.color = colorimport attr@attr.sclass SM_Controller(object): polyName = attr.ib() col = attr.ib() row = attr.ib() conPre = attr.ib() size = attr.ib() shape = attr.ib() color = attr.ib() shape = attr.ib() &emsp;&emsp;上面就是实战中的例子 &emsp;&emsp;打印对象的时候使用 attrs 也会变得清晰。 attrs 介绍不可变类构建12345678910111213import attr@attr.s(frozen=True)class SmartClass(object): a = attr.ib() b = attr.ib()smart = SmartClass(1,2)smart.a = 3# Traceback (most recent call last):# File "&lt;stdin&gt;", line 1, in &lt;module&gt;# File "c:\_thm\rez_local_cache\ext\attrs\21.4.0\site-packages\attr\_make.py", line 642, in _frozen_setattrs# raise FrozenInstanceError()# attr.exceptions.FrozenInstanceError &emsp;&emsp;加入 frozen 参数可以让类初始化之后不可改变。 验证数据123456789101112131415@attr.sclass SmartClass(object): a = attr.ib() b = attr.ib() @a.validator def must_be_str(self,attribute,value): if not isinstance(value,str): raise ValueError("must be a string type")smart = SmartClass(1,2)# Traceback (most recent call last):# File "&lt;stdin&gt;", line 1, in &lt;module&gt;# File "&lt;attrs generated init __main__.SmartClass-2&gt;", line 5, in __init__# File "&lt;stdin&gt;", line 8, in must_be_str# ValueError: must be a string type &emsp;&emsp;支持对初始化的数据进行校验。 参数默认值12345678@attr.sclass SmartClass(object): a = attr.ib(default=1) b = attr.ib(factory=list)smart = SmartClass()print(smart) # SmartClass(a=1, b=[])smart = SmartClass(b=2,a='a')print(smart) # SmartClass(a='a', b=2) &emsp;&emsp;参数添加默认值之后可以不进行传参，也可以用键值进行传参。&emsp;&emsp;使用 attrs 构建类就变得更加灵活。 踩过的坑mutable 容器 &emsp;&emsp;构建 mutable 容器的时候，需要用 factory 参数或者 attr.ib(default=attr.factory(list))&emsp;&emsp;参数默认值使用数组和字典这类 mutable 容器会导致很多问题 12345678def return_list(a=[]): a.append(1) return aa = return_list()print(a) # [1]a = return_list()print(a) # [1, 1] 这里的结果预期是 [1] 才对 &emsp;&emsp;虽然我们想要进入函数的时候 a 的默认值都是这个数组。&emsp;&emsp;然而实际运行的时候赋值只发生了一次，并不会每次函数运行都重置默认值的。&emsp;&emsp;所以参数不能使用 [] {} 这些容器，而是推荐使用 None，然后再函数中初始化 12345678def return_list(a=None): a = a if a else [] a.append(1) return aa = return_list()print(a) # [1]a = return_list()print(a) # [1] &emsp;&emsp;所以如果默认值想要为 数组 之类的，需要用 attrs 提供的 factory 方法。 hash 值1234567891011121314import attr@attr.sclass SmartClass(object): a = attr.ib(default=1) b = attr.ib(factory=list)smart = SmartClass()a = &#123;smart: 1&#125;# Traceback (most recent call last):# File "f:/repo/_blog/source/_posts/Python/pacakge/01_attrs.py", line 11, in &lt;module&gt;# a = &#123;smart: 1&#125;# TypeError: unhashable type: 'SmartClass' &emsp;&emsp;attrs 默认处理 __hash__ 方法，所以无法把它当成键值使用。&emsp;&emsp;然而不使用 attrs 装饰的话是可以的。&emsp;&emsp;解决方法就是加上 `@attr.s(hash=False)` 就可以了。 参考文档 Hashing 的部分 init 初始化123456789101112import attr@attr.sclass SmartClass(object): a = attr.ib(default=1) b = attr.ib(factory=list) def __init__(self,*args, **kwargs): super(SmartClass,self).__init__(*args, **kwargs) print(123) smart = SmartClass() # 子类并没有打印数据输出 &emsp;&emsp;依照文档 attrs 的装饰器会覆盖掉原有的 __init__&emsp;&emsp;但是如果我们确实要在 __init__ 进行数据处理，需要使用 __attrs_post_init__ 方法&emsp;&emsp;或者也可以使用继承的方式调用。 1234567891011121314151617181920import attr@attr.sclass SmartClass(object): a = attr.ib(default=1) b = attr.ib(factory=list) def __attrs_post_init__(self): print(123)class SuperClass(SmartClass): def __init__(self, *args, **kwargs): super(SuperClass, self).__init__(*args, **kwargs) print(456)smart = SmartClass() # 打印 123sup = SuperClass() # 打印 123 456 总结 &emsp;&emsp;Python3.7 加入了 dataclass 内置模块，基本上涵盖 attrs 大多数功能。&emsp;&emsp;attrs 的好处在于老版本完美兼容 Python2 可以在 Maya 等 DCC 里面使用。&emsp;&emsp;让代码编写更加紧凑和简洁。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021 年度总结]]></title>
    <url>%2Fposts%2F2dac7475.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近好长一段时间没有更新博客了&emsp;&emsp;这个年度终结也大部分都是 1月1日就更新了，我硬是拖到了1月中旬(:з」∠)&emsp;&emsp;最近发生了很多事，有很多东西可以记录，但又不知道从哪里下笔的迷之感觉。 年度大事汇总 活水去光子工作室 搭建 Unreal-PyToolkit 框架，博客大量更新自己的踩坑经历 折腾 PKM 的历程 具体可以看 PKM文章总结 基金理财 (华夏全球优选派) 交到第一个女朋友❤ 工作 &amp; 学习 &emsp;&emsp;一晃眼间，我已经毕业一年有余了，我是 2020 年毕业的，不过我从 2019 年年底就过来在魔方工作室实习。&emsp;&emsp;到2021年10月份活水到光子，在魔方也有快两年了。&emsp;&emsp;这个过程我们 TA 团队人员流失严重，在我活水同时还有其他人也选择了活水，仅仅2021年就基本走了一半的人(:з」∠)&emsp;&emsp;只能说这边根本留不住人，一方面 TA 比较抢手，这边的钱不够，另一方面是这边的团队建设真的不太行 &emsp;&emsp;关于这边的问题，其实我有很多话想要吐槽，但总归是在这里快两年了，虽有不愉快，也逼着自己成长了不少，我还是感谢的。 &emsp;&emsp;我来到魔方半年，还没有到毕业转正，我导师就跑去光子了。而且刚来两个星期就被分派到项目组里面，基本上都是靠自己自力更生解决问题为主。&emsp;&emsp;所以那会挺焦虑的，而且作为 TA 一直在干 TD 的活，也有点名不副实(:з」∠) &emsp;&emsp;不过我的遭遇已经算好了，项目组里有个校招的角色美术更惨，当时角色模型组就两个正编，年后都跑路了、&emsp;&emsp;刚过来导师没了，组里就他一个人(:з」∠)，所以这是什么神仙开局, 然后项目组之后调派另一个工作室的 6 级美术过来帮忙。&emsp;&emsp;因为这个美术之前实习的时候在这个项目组待过。&emsp;&emsp;所以紧靠两个人新人根本就没法把效果做好，对接好外包，把模型推到下游流程已经尽力了(:з」∠)&emsp;&emsp;而且由于项目是手绘风格，还一直招不到合适的人过来，最后好不容易招到了，整个组也就两人。&emsp;&emsp;考核的时候由于模型效果没有提升，组内必须有一个人背星，那位校招生也只能默默承担。&emsp;&emsp;ε=(´ο｀*)))，他的 2021 年开年是 2 星评价，年终大砍。我好歹还是拿了 4 星，所以有时候人比人比死人。 &emsp;&emsp;那为什么我能拿到 4 星呢？&emsp;&emsp;主要还是因为，2020年年中的时候从 Weta 来了一个 TD 转 TA 的大佬，leader 将他定位成我们组的组长。&emsp;&emsp;我当时转到中台做工具，支援多个项目，就在他身边学习了很多知识。&emsp;&emsp;虽然很多都是靠看他写的代码学习的，并没有怎么请教他，支援的项目也不一样，但还是很感激。&emsp;&emsp;他也能够理解我的工作，所以能够给我比较客观的评价。(因为组里的 leader 是个主美，忙项目组的事情就够呛了，基本不太了解我们的情况)&emsp;&emsp;然而 2021 年开年终究还是要 TA 组给名额背锅，也导致后面年中的时候有人因此流失了。 &emsp;&emsp;2021 年春节结束之后，首先是有两个 TA 晋级的，晋级完成就活水去光子了。&emsp;&emsp;到了 5 月份的时候，我们的组长也流失了，毕竟这边的流程很混乱，有很多流程根本推不动，也看不到头。&emsp;&emsp;年中的时候那位背锅的 TA 也找到下家，直接离职了，而且他家在上海，本来也不用过来深圳，结果过来还背锅，他也算是仁至义尽了。&emsp;&emsp;自从组长走了之后，组内就没了主心骨，我也觉得学不到东西，一直在干杂活，挺焦虑的。&emsp;&emsp;加上那个时候开始帮项目组的一个美术搭建美术工具，结果我们都把方案定好了，准备推行的时候，程序leader 觉得方案不可行，来回折腾。&emsp;&emsp;所以 5 月份非常难顶，当时有经验推动美术流程的是从天美过来的美术，我这个无能 TA 只能听他的建议来制定美术规范。&emsp;&emsp;可能有更好地做法，但是我也没有足够的经验，至少他提的方案的确比起当前混乱的规范要好，所以我也就接受了。&emsp;&emsp;当然为了做他的工具在 Unreal 里面调用 Qt 踩了非常多的坑，21年更新的很多博客都是和 Unreal Python Qt 开发相关的。&emsp;&emsp;我也顺手推出了 Unreal-PyToolkit 开源框架&emsp;&emsp;将我博客里面好一些的流程都整合到里面去了，只是由于离开魔方的原因，这个仓库目前就停更了。 &emsp;&emsp;基于上面的种种情况，加上我也快满一年可以活水了，所以我也非常想逃离(:з」∠)&emsp;&emsp;没想到有相同想法可不止我一个，我走了之后还有两个 TA 也跟着活水，魔方真的太难了。 &emsp;&emsp;最开始我联系我了前导师，想要他帮忙引荐一下，不过他已经挖了这边很多人了。&emsp;&emsp;而且我这个过去他那边太明显了，可能不太好，加上当时光子扩招，他的小组编制爆了，我过不去。&emsp;&emsp;所以最后是星哥主动找我聊，后续也就顺理去了星哥的组下。 &emsp;&emsp;曾经有一份搞 Houdini 的机会摆在我面前，我没有珍惜，毅然决然选择了光子，可能也是人生岔路的一种遗憾吧~&emsp;&emsp;当时虽然和星哥谈妥了，但是魔方中台的 Falcon 组组长还是想争取一下，让我过去他们组。&emsp;&emsp;那个时候我已经拿到了 光子 那边的活水邮件了，如果点确认就没有回头箭了。&emsp;&emsp;想到星哥给我争取这个机会也是挺不容易的(后来我才得知，他们组里有人活水了，我才有这个机会过去)&emsp;&emsp;加上光子比较国际化什么的，所以最后就放弃了去魔方中台，主要还是魔方太让我失望了(:з」∠)&emsp;&emsp;可能当时选择去那边，我的人生也会不一样吧，终究还是放不下 Houdini ，然而似乎和它没有什么缘分。 &emsp;&emsp;所以那段时间准备跑路了，就腾了一些时间来折腾 PKM 的事情，才有后面的 PKM文章总结 &emsp;&emsp;后来经过一些波折，我在 9 月底的时候就搬到了新的办公地点，去到光子下工作了。&emsp;&emsp;原本我过来是负责 Unreal 引擎工具开发的，我打算抱紧大佬的大腿，顺便深入学习一下 引擎 工具开发相关的知识。&emsp;&emsp;没想到我过去之后，组长改了方向，打算进军 Maya 绑定。&emsp;&emsp;恰好我也算是在华强的时候积累了不少相关的知识，可以派上用场，只是让我万万没有想到的是。&emsp;&emsp;这边很多人都是做 shader 出身的，他们对 Maya 的了解并不多，我反而成了他们的大腿。&emsp;&emsp;这个转变有点让我不知道哭还是笑(:з」∠) &emsp;&emsp;其实和我同期活水的，还有项目组的一个程序，当时他也对魔方的管理感到失望，加上钱给的不多，所以就去天美了。&emsp;&emsp;本来他那边的组长给他吹嘘一堆技术，让他以为很靠谱，其实过去之后也就那样，而且过去之后就变边缘人了，有很多东西不能主导。&emsp;&emsp;我这边的话可以主导很多东西，但我还是很担心自己的经验不足会把大家带到沟里去(:з」∠) &emsp;&emsp;恰好那个时候我从厂长那里拿到了 RBF Retarget 算法等等的一些源码，于是经过我自己摸索尝试提出了通过 RBF retarget 模型的方案。&emsp;&emsp;使用这个方案可以将不同脸的模型精准 retarget 过去，对于 BS 复用有非常好的效果。&emsp;&emsp;没想到，我误打误撞研究出的方案，发现正是目前业界比较前沿的用法，也算是这套方案的落地让我完成第一版的 demo&emsp;&emsp;但是制定绑定框架，整个流程是非常庞大而长期的事情，目前组内加上我也就 4 个人，我总感觉一眼望不到头(:з」∠)&emsp;&emsp;年底的时候又因为乘上了 元宇宙 的东风，发现公司内很多团队都想做类似的东西，着实让我压力山大。 &emsp;&emsp;由于又回到了 Maya ，所以我还是未能如愿以偿地用上 Houdini 的技术特性。看来还是得私下再抽时间去学习和研究了。&emsp;&emsp;RBF 等等算法由于自己的数学太菜了，还没有搞得很明白，还需要再花时间恶补一下自己的数学基础。 &emsp;&emsp;不过去了光子之后，倒是认识了 龙浩，在他那边学习到了很多代码规范，ci 工具构建等等的流程知识。&emsp;&emsp;总算是体会到大厂的规范化开发的感觉，之前在项目组的敏捷开发就非常离谱，没有单元测试，甚至没有代码审查。&emsp;&emsp;初期还能接受，随着项目越做越复杂，我感觉很多时间都浪费在无休止地调试 BUG 里面，浪费时间。&emsp;&emsp;在这边接触了一整套代码规范和开发工具，还有 Git 代码 Review 等等的知识，学习到了很多知识。&emsp;&emsp;所以这段时间周末会去抽时间把相应的知识补全，导致博客自此停更了很长一段时间。&emsp;&emsp;其实也有很大原因是我自己有点焦虑，也不知道从何处落笔比较好。 &emsp;&emsp;但是这段时间不仅仅没有好好写博客，之前立的 Flag 要把 Anki 和 Tiddlywiki 给用起来。&emsp;&emsp;也因为各种原因搁置了(:з」∠)&emsp;&emsp;知道最近才逐渐开始重新将 Tiddlywiki 给捡起来。 &emsp;&emsp;目前已经过渡到 2022 年了，目前的工作进度算是稳定了一点。 理财 &emsp;&emsp;2021年我开始将自己的工资投入到理财里面。&emsp;&emsp;可是没想到 2021 年开年就是高峰，然后就一路低迷走低。&emsp;&emsp;好在我的钱大头都在 百信银行 存着(百信银行有 3.2% 的回报，比微信和支付宝要高一点，也可以灵活支取) &emsp;&emsp;开年的时候我听我哥的说法，投了腾讯的一起投 华夏全球优选派 全球投资组合。&emsp;&emsp;这是一个非常高风险的组合，近一年下来已经跌到 负数(:з」∠)&emsp;&emsp;所以是没赚反而亏了。&emsp;&emsp;主要是港股年初原本预计是低洼地，没想到会因为各种因素一跌再跌，导致暴雷。&emsp;&emsp;再加上今年发生了好一些的事件，中概股打压、教育行业政策、国家反垄断等等政策都对互联网行业打击极大。&emsp;&emsp;以至于到了年底都说现在是互联网寒冬，市场不景气。 &emsp;&emsp;我这一年2/3的钱放到百信银行保本，1/3 投到了一起投。&emsp;&emsp;可以说是投资不太成功的样子(:з」∠)&emsp;&emsp;后续打算定投 中证500 沪深300 之类的指数基金，只要国家的经济没有出现大问题，这类基金长线投资基本都是赚的。&emsp;&emsp;只是目前的本钱比较少，还需要慢慢积累，华夏全球优选派 目前这个已经没有继续定投了。&emsp;&emsp;投这个基金之初也是说投入三年再取，所以先放在一边，等它的业绩慢慢恢复好了。 爱情2021 年圣诞我鼓起勇气告白，成功交到了我第一个女朋友。这算是我 2021 年最完美的收官和点睛之笔了❤。 总结 &emsp;&emsp;2021 年经历了很多事情，这是我毕业步入社会的第一个年头，在这里我只想感叹时光飞逝，岁月如梭。&emsp;&emsp;大学的时光仿佛还在昨日，但我已不再是过去的我了。 &emsp;&emsp;年底的时候看到这个视频，深受触动。&emsp;&emsp;当时 Up 组的 27 岁对话视频，我当时还在大三迷茫的时候看过，如今看这个对话视频，我仿佛看到当时的我自己。&emsp;&emsp;非常的有感触，物是人非，勿忘初心。&emsp;&emsp;所以我也想以文章的形式做一个小对话，如果以后有机会的话，也想要学习 Up 主一样做个 vlog&emsp;&emsp;这里我就给自己写一份信，希望明年的自己可以重拾现在的心境，勿忘初心。 链接]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicker 编辑器快捷键]]></title>
    <url>%2Fposts%2F190b1e59.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;工作一年有余了，一直不舍得在这些软件领域上面花钱。&emsp;&emsp;感觉自己还是学生，花钱总是省着花，只买一些刚需的产品。&emsp;&emsp;省下的钱先放到大部分到放到了百信银行的钱包 plus 里面了 (利率比 零钱通 支付宝 要高一点点)&emsp;&emsp;另外部分购买了基金，只是目前的市场行情不太好，只能说放着不管吧。 &emsp;&emsp;Quicker 我比较早就接触了，具体可以看我以前的效率提升指南的推荐。&emsp;&emsp;它的免费功能就已经支持多端同步，能够满足大部分使用情景，非常良心。&emsp;&emsp;也因为这样我一直不舍得花钱付费体验，而且部分付费的功能我也有其他软件作为辅助替代。&emsp;&emsp;无论如何，这个软件目前还在搞促销，年费着实不贵。 付费链接&emsp;&emsp;这么良心的软件，如果没人支持倒了，那确实就很可惜，所以就国产之光而言，也要支持一波。&emsp;&emsp;付费之后可以让我将多个软件整合成一个软件，使用体验提升了不少，而且多端同步非常方便，不用每台电脑都进行软件配置。 替代 WGesture &emsp;&emsp;之前我的手势滑动方案是用免费的 WGesture ，具体可以参考我这一篇文章 链接 &emsp;&emsp;Quicker 的付费功能也支持鼠标手势，因为我已经用惯了 WGesture ，所以直接将手势功能迁移到了 Quicker&emsp;&emsp;目前大部分功能都能很好支持，部分手势比如滑特定手势加滚轮调节音量之类就做不到了。&emsp;&emsp;不过这些小问题并不影响，quicker自带的屏幕上方滚动调节音量也非常方便。 &emsp;&emsp;另外通过 quicker 可以多端同步我自己定义的手势，这比 WGesture 要方便不少。&emsp;&emsp;虽然 WGesture 也可以导出配置文件，然后用坚果云同步配置文件，总结起来还是 Quicker 自动同步方便得多。 标点符号替换 &emsp;&emsp;以前我是用 capslock+ 基于 autohotkey 设计的一套 capslock 键键盘映射。&emsp;&emsp;并且利用 authotkey 的 hotstring 功能来输入中文标点，这样我可以将输入法的标点符号输入改为英文，避免我写代码的时候输入中文标点导致出错。&emsp;&emsp;具体的配置历程可以参照我魔改的 capslock+ 的仓库 链接&emsp;&emsp;不过如今可以利用 quicker 的文本指令来实现。 &emsp;&emsp;quicker 无法做到 autohotkey 的输入两个标点符号自动转换为中文符号的效果， &emsp;&emsp;设置里面只能选定按特定的按键来触发替换，只是多输入一个空格，我个人觉得还是没有问题的。&emsp;&emsp;使用了一段时间之后就是输入标点太快的话会有一定可能影响到后面输入的内容，通常不会有这么快的手速。 键盘映射 &emsp;&emsp;有了上面的体验之后，我就想进一步取代掉 capslock+ 的功能。&emsp;&emsp;恰巧前段时间看上了一款很神奇的带触控小键盘 prestigio 心动直接剁手了。&emsp;&emsp;买之前本来想用触控完全取代鼠标的，但是实际上使用 Maya 之类的软件还是不可能离开鼠标。&emsp;&emsp;所以买回来之后其实很少用到触控功能，毕竟已经用惯鼠标了，不过它的小巧轻便依旧成为我办公的日常利器。&emsp;&emsp;只是小键盘的一大问题就是 方向键 缩在右下角的角落里，使用起来非常不方便。&emsp;&emsp;于是我想到了 capslock+ 的键盘映射功能。 链接&emsp;&emsp;capslock+ 将方向键映射为 ESDF 四个键(配合 capslock 键一起按)&emsp;&emsp;经过我自己一番折腾体验之后，还是觉得游戏里面的 WASD 键比较顺手，所以我在 Quicker 里面复现了这一整套配置。 &emsp;&emsp;我也将键盘靠右的按键，比如回车键 del键 backspace键 映射到左边来，这样我就不用松开鼠标的右手了。&emsp;&emsp;经过了一个月的熟悉之后，我觉得这套键盘映射非常香，缺点就是在别人的电脑上会下意识用 capslock+WASD 去敲方向键，结果不起作用，着实让我很抓狂。 源按键 映射按键(配合 capslock 一起按) ↑ W ← A ↓ S → D Backspace Q Del R Home 1 End 3 &emsp;&emsp;基本的映射如图所示，配合 ctrl shift 的按键都需要单独配置，所以花了我不少时间。&emsp;&emsp;另外我买的键盘并不是全键无冲突的，这导致有些快捷键无法触发，比如我的 prestigio 键盘的 capslock+shift+S 就是无法不起作用，&emsp;&emsp;我当初还以为是 quicker 的 BUG ，还特意去 github 给他提了 issue ，然后才发现是键盘的问题，因为换了一个键盘就可以触发了。&emsp;&emsp;不过全键无冲突的键盘也是贵死，而且必要性很小，所以某些问题可以忍耐一下，比如说用其他的按键映射来解决问题。 编辑器功能键 &emsp;&emsp;有了上面的键盘映射之后，我有想到可以将 VScode 的部分编辑器特有的功能集成到按键里面。&emsp;&emsp;毕竟按键触发是可以调用 Quicker 动作的，我可以模拟部分 VScode 的输入功能，提升在外部输入的体验。&emsp;&emsp;所以我自己做了一个动作，输入参数实现一连串的输入，比如自动换行到下一行或者上一行，复制一行，粘贴一行 等等&emsp;&emsp;编辑器还有个非常实用的扩选功能，我也想通过 quicker 动作实现，只是每一次实现都要获取一下当前光标下的文本，然后才能解析扩选，效率有点低。&emsp;&emsp;目前还没有将相应的功能用 quicker 动作做好，以后做好了可以抽时间分享一下。 键盘控制鼠标 &emsp;&emsp;经过上面的摸索之后，我还发现键盘映射是有用户共享的 链接&emsp;&emsp;应为这个是付费功能，共享的用户并不多，看了一下共享的功能，发现还有人用键盘来控制鼠标的。&emsp;&emsp;于是我也基于别人的一些写法，做了独属于自己的一套键盘控制鼠标的逻辑。 鼠标控制共享 &emsp;&emsp;上面是我做的键盘映射共享。 组合键(按住 Tab 键) 标题 操作类型 3 鼠标右键 PlayKeyMouseData ← 向左移动 PlayKeyMouseData ↑ 向上移动 PlayKeyMouseData → 向右移动 PlayKeyMouseData ↓ 向下移动 PlayKeyMouseData 1 鼠标左键 PlayKeyMouseData 2 鼠标中键 PlayKeyMouseData 4 X1键 PlayKeyMouseData 5 X2键 PlayKeyMouseData A 向左移动 PlayKeyMouseData D 向右移动 PlayKeyMouseData E 向后滚动 PlayKeyMouseData Q 向前滚动 PlayKeyMouseData S 向下移动 PlayKeyMouseData W 向上移动 PlayKeyMouseData Space + ← 快速向左移动 PlayKeyMouseData Space + ↑ 快速向上移动 PlayKeyMouseData Space + → 快速向右移动 PlayKeyMouseData Space + ↓ 快速向下移动 PlayKeyMouseData Space + A 快速向左移动 PlayKeyMouseData Space + D 快速向右移动 PlayKeyMouseData Space + E 快速向后滚动 PlayKeyMouseData Space + Q 快速向前滚动 PlayKeyMouseData Space + S 快速向下移动 PlayKeyMouseData Space + W 快速向上移动 PlayKeyMouseData Space + F1 按下鼠标左键 PlayKeyMouseData Space + F2 按下鼠标中键 PlayKeyMouseData Space + F3 按下鼠标右键 PlayKeyMouseData LeftAlt + ← 轻微向左移动 PlayKeyMouseData LeftAlt + ↑ 轻微向上移动 PlayKeyMouseData LeftAlt + → 轻微向右移动 PlayKeyMouseData LeftAlt + ↓ 轻微向下移动 PlayKeyMouseData LeftAlt + A 轻微向左移动 PlayKeyMouseData LeftAlt + D 轻微向右移动 PlayKeyMouseData LeftAlt + E 轻微向后滚动 PlayKeyMouseData LeftAlt + Q 轻微向前滚动 PlayKeyMouseData LeftAlt + S 轻微向下移动 PlayKeyMouseData LeftAlt + W 轻微向上移动 PlayKeyMouseData LeftAlt + F1 松开鼠标左键 PlayKeyMouseData LeftAlt + F2 松开鼠标中键 PlayKeyMouseData LeftAlt + F3 松开鼠标右键 PlayKeyMouseData &emsp;&emsp;基本上思想也是 WASD 移动鼠标，12345 表示鼠标左中右键 + X1 X2 键，Q E 键做鼠标滚轮&emsp;&emsp;按住空格键是加速移动，按住 alt 键是略微移动。&emsp;&emsp;我还加了 F1 F2 F3 用来模拟按住鼠标按键的效果，只是用起来很不方便，很少会用到，并且我的 prestigio 键盘有实体的鼠标按键，按那个更方便一点。 粘贴板 &emsp;&emsp;以前的粘贴板我是网上推荐的 Ditto 进行记录的。&emsp;&emsp;现在可以结合 Quicker 的一个动作 粘贴板 来实现这个功能，付费之后就可以用 快捷键 触发动作，使用上更加方便。 &emsp;&emsp;日常体验已经完全可以替代 ditto 。&emsp;&emsp;ditto 还有分组之类的功能，其实使用并不多。 总结 &emsp;&emsp;quicker 价格便宜，购买之后便利提升了不少，强烈推荐。&emsp;&emsp;无论作者还是社区都在朝着 all in one 的道路迈进&emsp;&emsp;我已经找到了和 listary 相似的启动器动作 智搜&emsp;&emsp;可惜这个动作的全盘搜索是基于 everything 的，也不知道如何设定到当前目录下进行搜索，我体验了一段时间还是换回了 listary。&emsp;&emsp;listary 另一个切换目录的功能 也有 动作模拟 快速切换&emsp;&emsp;体验上虽然比 Quicker 要慢一点，但能够满足我的需求就已经谢天谢地了。 &emsp;&emsp;最后截图上，也有 Ever截图 神器&emsp;&emsp;可以使用 quicker 提供的截图功能，quicker 的快速截图做得很想 snipaste ，目前已经可以钉图了，只是还缺少图画功能，因此还尚未能取代 snipaste&emsp;&emsp;Ever截图的强大在于支持第三方截图功能，获取粘贴板的图片可以做后续的诸多操作，比如识别或者搜索 &emsp;&emsp;目前我的日常使用已经离不开 quicker ，希望 quicker 能够再接再厉，提供更好的体验~]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人 PKM 折腾记]]></title>
    <url>%2Fposts%2Fafa065b7.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近的文章的产出极大地降低了(:з」∠)&emsp;&emsp;过程的原因也是非常地复杂，因为我去折腾了 PKM (Personal Knowledge Management)。&emsp;&emsp;我是经过了一段时间折腾然后放弃，然后又捡起来的过程。&emsp;&emsp;但是这个过程实在是太过碎片化，然而又的确花费了我无数的时间，于是中途实在是没有一个很好的写长文的状态。&emsp;&emsp;说实话 PKM 是一个非常宏大的话题，这次的文章也只是对这三个多月的低产做一次回顾和总结。&emsp;&emsp;希望自己能够更好地梳理自己的知识框架。 上半年折腾回顾 &emsp;&emsp;关于知识的整理和总结，我之前是利用 Hexo 和 Hugo 来搭建静态博客网站。&emsp;&emsp;将自己整理的文章记录在这些平台上面，以完成自己的知识梳理和输出。&emsp;&emsp;后来又因为自己做框架需要一些文档记录，于是我有折腾了 docsify 来构建自己的文档。&emsp;&emsp;前前后后折腾了三个不同的平台，都是基于 Markdown 语法进行写作的。&emsp;&emsp;直到搭建 Hugo 的 HoudiniWiki 网站的时候我才感觉到知识串联的重要性。 二月份 Hugo &amp; HoudiniWiki &emsp;&emsp;于是我年初折腾 HoudiniWiki 的一个比较重要的目标就是再 Hugo 里面实现双向链接的 宏函数 将知识串联起来。&emsp;&emsp;具体的情况只是简单记录在 hou.l0v0.com 的 log 上 链接 &emsp;&emsp;当时的做法是利用 github ci 去跑一个写好的 Python 脚本。&emsp;&emsp;Python 会用正则表达式去匹配所有的文章，如果里面找到了 relink 的宏之后就会将其记录到一个 json 文件里面。&emsp;&emsp;然后 Hugo 构建的时候可以读取这个 json 文件获取到对应的 双向链接 关系。&emsp;&emsp;但是我自己搭建效果非常原始，而且工作量非常大，有点超过了我预期折腾阈值。 &emsp;&emsp;不过好歹自己是实现了这个效果，于是我过年的那段时间就打算将 Houdini 的教程看起来。&emsp;&emsp;然后将教程里面学习到的知识点全部汇总到 HoudiniWiki 网站里面。&emsp;&emsp;也真是因为这个原因，我整个 2 月份都没有了任何博客的产出，因为知识产出的时间都挪到了 HoudiniWiki 的内容输入上。&emsp;&emsp;那段时期看了不少的教程，但是距离我的心愿清单的完成依然是遥遥无期😔️ &emsp;&emsp;后来过完年投入工作之后，工作上用不上，于是教程计划又全面搁置了。&emsp;&emsp;所以根据工作的需要我从 3 月份开始又恢复了一定程度的 博客 更新(:з」∠) 三月份 Notion &amp; Wolai &emsp;&emsp;中间三月份的时候看了个 B站 视频，安利了 Notion 这框 All in one 强大的在线编辑 App&emsp;&emsp;其实我还真挺喜欢的，但是 Notion 不能完美兼容 Markdown 语法，以及它的服务器在国外，当时体验 Notion 的手机 App 那真的是体验太差，太过劝退了。&emsp;&emsp;基于这些原因，我又去国内搜索了类似的软件，然后找到了 wolai&emsp;&emsp;wolai 本土化更好，而且支持双向链接的图谱显示，在我看来都是非常 nice 的功能。&emsp;&emsp;于是我也体验了 wolai 一段时间，当时个人可使用的 block 数是有限，让我有种块数不够用的危机感。如今个人的 blocks 也和 Notion 无限使用了。&emsp;&emsp;只是 wolai 目前为止还没有支持 Notion 的数据库功能，无法给文章添加自定义的描述字段，进行过滤提取。&emsp;&emsp;于是就一直陷入了两个头疼的死循环里面，最后干脆两个都放弃 了(:з」∠) 四月份 最后的高产 &emsp;&emsp;四月份清明的时候还做了很多有意义的开发，比如开发了 Qt 的 overlay 功能&emsp;&emsp;解决了 Qt Designer 开发一个很痛的痛点。&emsp;&emsp;同时还输出了很多篇 Unreal 的文章作为自己的研究记录。 子进程监听 UMG 界面&emsp;&emsp;然而 4月份的高产可谓是 我最后的波纹 了(:з」∠) 五月份 颓废躺平 &emsp;&emsp;然而到了 5 月份之后，自从五一放假期间下载了 重生细胞 这个游戏到手机里面之后&emsp;&emsp;简直就打开了潘多拉魔盒，这个期间又下了很多款 app 游戏把 5 月份的时间都挥霍掉了(:з」∠)&emsp;&emsp;当然玩游戏还是挺有趣的比如 又下载了 月圆之夜 重温， 还有些 Google Store 上的小游戏。&emsp;&emsp;后来手机玩还不够，干脆在电脑上也装游戏了，于是又去 3DM 那里下载了很多游戏╮(╯_╰)╭&emsp;&emsp;这个过程下载了好多好多的游戏，比如 团战经理 银河笔与纸 魔王大人，击退勇者吧 暗黑地牢 竞速80年代&emsp;&emsp;我居然还花了不少时间把 竞速80年代 这个像素游戏给打通了(:з」∠)&emsp;&emsp;后来还下载了最新的 极品飞车21:热度 体验了几把赛车&emsp;&emsp;那段时间实在是太过颓废了，主要也是受了一些刺激，失去了学习的动力😪️ 下半年折腾回顾六月份 &emsp;&emsp;到了 6月份，痛定思痛，于是一次过把之前有的没的全部都删掉了。&emsp;&emsp;然后我打算开始静下心来看教程，尝试一下学习 OpenGL 学习 shader 编程&emsp;&emsp;看着看着又开始挂念起了之前做的 HoudiniWiki 网站&emsp;&emsp;打算也做一个 shader 版本用来做知识的整理和连接。自然而然就整了一个 ShaderWiki 网站&emsp;&emsp;基本上就是套一下之前弄好了，还重新搞了一遍 github ci 支持我自动部署到服务器的对应域名。 &emsp;&emsp;在这个过程我想起之前有找打一个 博客 用 Notion 做的，里面有很多 vfx 和 unreal 相关的记录&emsp;&emsp;做的让我非常印象深刻，但是我似乎忘记把它的链接给保存起来了。&emsp;&emsp;现在网上死活找不到它相关的身影，于是结合 notion 和 blog 几个关键字搜索没想到却意外搜索到了 obsidian (后来找到了这个 Notion 博客，在这里推荐一下 https://mycgdoc.com/) &emsp;&emsp;从此打开了新世界的大门。 Obsidian &emsp;&emsp;简睿软体频道 obsidian教程 B站上面有相当全面的教程展示了 obsidian 这个软件可以做到的不同功能。&emsp;&emsp;于是我就开始为这个软件着痴迷，用了我非常多的时间进行研究和学习。&emsp;&emsp;obsidian 最为人所知的就是提供了 [[wiki link]] 双向连接以及知识图谱的功能。&emsp;&emsp;并且它支持自定义插件的开发，可以实现类似 VScode 一样的社区插件生态。&emsp;&emsp;我花了很长的时间去看上面的 Obsidian 的教程，将各种功能都摸了一遍。 &emsp;&emsp;当时看到 Obsidian 有开放第三方插件,用了不少时间去研究&emsp;&emsp;感觉 Obsidian 不错，但是还是希望能够在 VScode 的生态下写文章&emsp;&emsp;毕竟我写博客这么久了，都是在 VScode 里面写的。&emsp;&emsp;如今又要我加多一个差不多的写作工具同时也没有带来太大的差异，让我感到非常的难受。 &emsp;&emsp;另外 Obsidian 让我最用不惯的地方就是没有命令行集成，导致需要外部进行 Git 命令 push 和 pull&emsp;&emsp;如果两个工具可以合二为一那就无比完美了，然而现实却是各自搞自己的生态，导致了极致的割裂。&emsp;&emsp;后来在在乎看 Obsiidian 的文章的时候，非常偶然地在评论里面别人推荐了 VScode 的 Dendron 插件&emsp;&emsp;于是新世界的大门又开了。 Dendron https://github.com/dendronhq/dendron &emsp;&emsp;Dendron 是在 VScode 实现双链笔记的插件，实际上实现这个功能不只是 Dendron 还有 Markdown Notes Foam 等插件。&emsp;&emsp;Dendron 是做得最硬核的，它提供了 npm 命令行工具可以将自己的笔记生成对应的网站，并且支持文章引用嵌入。&emsp;&emsp;Dendron 的作者推荐用扁平的目录结构来管理笔记，有点过于硬核。&emsp;&emsp;作者推荐不使用文件夹，而是在文件上用 . 进行区分，当作文件夹使用，这样文件夹也有文件信息进行描述。 说明 1234567891011|-- cli.tar.md|-- cli.tar.env.md|-- cli.curl.md|-- cli.dig.md文件目录|-- cli |-- dig |-- curl |-- tar |-- env &emsp;&emsp;这样做的好处是可以通过搜索，快速找到命名相近的功能, 利用 cli.*.env 之类的的通配符匹配。&emsp;&emsp;偏平结构也方便程序检索，查找笔记的时候也不用一层层点击去找(特别是目录结构很深的情况)&emsp;&emsp;作者还写了非常长的文章描述自己在 PKM 中查找的困惑 链接 &emsp;&emsp;于是我觉得这个插件可以解决我是用 Obsidian 面临的问题，特别是当时刚更新了基于 WebView 的 日历 等重要功能，&emsp;&emsp;对比其他几个插件， Dendron 显然在功能上更胜一筹。 P.A.R.A &amp; MOC &emsp;&emsp;在这个过程中，还有继续在学习 obsidian 大佬们的推荐的笔记思想。&emsp;&emsp;比如 B站 的 Struggle_with_me up主&emsp;&emsp;当时看 Tour | 一起看看Linan是怎么在Obsidian里记学术笔记和做日程管理的 重复提到了 P.A.R.A 笔记方法。&emsp;&emsp;上面推的 简睿软体频道 obsidian教程 其实也有提及。&emsp;&emsp;结合 MOC 地图索引可以发挥很强大的功能。 &emsp;&emsp;于是我的新世界大门又又打开， P.A.R.A 框架 Tiago Forte 最先推广的一种就有笔记的项目管理系统。&emsp;&emsp;只要是笔记工具都能使用，Tiago 是专门做高效能培训的，也会将自己的效能习惯迁移到新的软件当中，那么 P.A.R.A 框架 都能很好适用不同软件的情况。 &emsp;&emsp;毕竟 Tiago 是专门用 印象笔记 的 链接&emsp;&emsp;VScode Dendron 也是毫无疑问适用的 可以去看作者的视频介绍 链接 &emsp;&emsp;P.A.R.A 框架介绍可以看 Tiago 三篇入门文章 https://fortelabs.co/blog/para/ https://fortelabs.co/blog/p-a-r-a-ii-operations-manual/ https://fortelabs.co/blog/p-a-r-a-iii-building-an-idea-generator/ &emsp;&emsp;P.A.R.A 全称是 Project Area Resources Archive&emsp;&emsp;四个区域，这里面不仅仅是记笔记，同时也整合了传统的项目管理，并且将内容限制在简单的四个文件夹内，可以更好地梳理内容。 &emsp;&emsp;在使用这个方法之前需要明确自己的任务计划。&emsp;&emsp;一个任务计划应该有明确的目标以及时间节点，确保自己可以顺利执行。 &emsp;&emsp;至于 Area 则是存放自己感兴趣的东西，没有明确时间节点的内容。&emsp;&emsp;Area 是长线的计划应该讲具体实施放到 Project 当中。 &emsp;&emsp;Resources 则存放一些客观的资料，以便以后需要用到方便查找。 &emsp;&emsp;Archive 则是将上面那些已经完成的项目归档的目录，用来留作记录用。 &emsp;&emsp;以上就是 P.A.R.A 结构的大致用法，其实也可以自己在这个框架的基础上进行扩充。&emsp;&emsp;Tiago 就很喜欢将很多事物放到 Inbox 的容器里面，然后知道有空了再进行进一步的处理。 &emsp;&emsp;另外 MOC 导航也是非常有用的东西。&emsp;&emsp;MOC 全程是 Maps of Content ，用来作为网站的地图使用。&emsp;&emsp;使用 MOC 可以在另一个维度快速定位相关的资源。&emsp;&emsp;结合 Tag 分类来定位资源，可以让资源归类更加灵活。 https://www.masterhowtolearn.com/articles/ &emsp;&emsp;上面就是简单的 MOC 案例。 (不过后来我研究了 Tiddlywiki 之后，我觉得更好地资源归类还是在不同的分类下都有相关内容的副本可以显示，并且一处修改，多出同步，才是最好的解决方案。) Anki &emsp;&emsp;接触 Anki 也是非常意外的事情，最初也是因为 Obsidian 的插件支持 Anki 。&emsp;&emsp;我才知道原来有这么一款开源免费的 间隔重复 学习软件。&emsp;&emsp;Anki 音源来自于 日语 的 暗记 发音。&emsp;&emsp;大概了解了一下，发现和我以前用的 扇贝 背单词有着差不多的用法。&emsp;&emsp;只是 Anki 的好处在于不收单词书的限制，你可以完全自己制卡，而且卡片支持 HTML 语法。&emsp;&emsp;可以制作得非常精美，社区上也有很多免费的 卡组。 间隔重复说明间隔重复(Spaced Repetition) 就是按照学习遗忘曲线来对知识进行复习，确保知识的牢固程度。后来我在 喜马拉雅 学习了 Anki https://www.masterhowtolearn.com/2019-08-29-3-fatal-reasons-why-you-shouldnt-be-taking-notes-when-studying复习的技术间隔重复是一种很好的记忆方法，记忆不等于死记硬背，很多知识不用记，但其实知识不需要死记硬背为，不代表不需要记忆，如果只是记不住那就很难应用,,更别提更进一步学习。死记硬别只是记忆的一种方法，出了间隔重复度实现复习之外，还有联想 数字桩 记忆宫殿 等等记忆方法。间隔重复 (Spaced Repetition) 主动回忆 (Active Recall) 混合学习(Interleaving) 这三种方法已经被诸多论文验证，是最高效地学习方法。https://youtu.be/UEJmgaFQUH8https://www.masterhowtolearn.com/2019-08-29-3-fatal-reasons-why-you-shouldnt-be-taking-notes-when-studying &emsp;&emsp;Anki 最良心的地方在于提供了免费的 同步服务，只有 IOS 端进行收费。&emsp;&emsp;日常学习的 卡组 都可以通过它来实现多端同步。 &emsp;&emsp;后来为了更好地了解 Anki ，于是在知乎上看到了 叶峻峣 的文章 个人主页&emsp;&emsp;新世界的大门又又打开了。&emsp;&emsp;他的专栏里面有非常丰富的内容介绍了 认知科学 学习方法 的内容&emsp;&emsp;于是我有在提供的文章里面花了很长的时间去观看，虽然不少文章是翻译，但我受益匪浅。 &emsp;&emsp;这个过程中，我认识到间隔重复是一种很好的学习方法 间隔重复专栏&emsp;&emsp;并且还接触到 间隔重复 发明推广人 Woz ，了解到渐进学习这种全新的学习方法 SuperMemo—渐进学习最前沿！ &emsp;&emsp;于是我仔细拜读了 渐进学习导读的文章 &emsp;&emsp;也因此让我对 SuperMemo 产生了极大地兴趣。 SuperMemo &emsp;&emsp;SuperMemo 已经诞生了快有 40 年了，这真的是让我始料未及， Dr.Woz 居然是从 Windows95 就开始更新，不愧是计算机博士毕业的。&emsp;&emsp;不过也因为这样，SuperMemo 的历史包袱非常重。&emsp;&emsp;界面风格各方面堪称复古，并非这么多年了 博士 一个人坚持开发。&emsp;&emsp;封闭的软件生态也着实让人抓狂。&emsp;&emsp;但是看了 叶峻峣 的文章可以知道，Supermemo 用上了更好地 sm18 算法。&emsp;&emsp;支持 优先级队列 渐进学习 等多种更前沿的学习方法，这些都是 Anki 里面没有的。 在 Anki 制作 2.9 万张卡片，复习 33 万次之后，我转用了 SuperMemo &emsp;&emsp;Anki 的资深用户全方位的分析两款软件的优劣，并且详细回答了 SuperMemo 能够解决的问题。&emsp;&emsp;这进一步激发了我的兴趣，想要直接从 SuperMemo 入手。 &emsp;&emsp;SuperMemo 太过复杂了，教程说明都很少，基本上全是 Dr.Woz 写的文章和说明。&emsp;&emsp;后来我在 B 站上搜视频，刚好看到大佬上传了一系列视频介绍他如何结合各种工具在 Mac 上使用 SuperMemo 进行学习的 SuperMemo18 基础介绍(一) SuperMemo18 基础介绍(二) SuperMemo18 基础介绍(三) SuperMemo18 基础介绍(四) SuperMemo18 基础介绍(五) &emsp;&emsp;后来我还找到了他的知乎，在上面看到了很多视频的文本版 专栏&emsp;&emsp;整一套方案用了非常多折腾的方案，甚至在知乎的文章上看到他用 MPV 播放器用作 渐进视频 学习的。 链接 &emsp;&emsp;真的是不得不又奉上上面这张图。&emsp;&emsp;在这里有学习到了一个折腾的自定义播放器 MPV ，可谓是非常地极客，开源可高度自定义配置。&emsp;&emsp;结合脚本可以发挥无穷的威力&emsp;&emsp;只是现在还没有时间深入折腾，我之前找到了国人提供在 Github 上一套完整开箱即用的配置方案。 链接&emsp;&emsp;稍微再 windows 电脑上测试了一下，感觉还行，就是用不太惯。&emsp;&emsp;目前还是简单好用 PotPlayer 更加适合我(:з」∠) &emsp;&emsp;SuperMemo 实在是太复古太难用了，导入网页居然还用 IE 进行导入。&emsp;&emsp;还不支持 Chrome Edge ，也是够让人抓狂的，只是好在 Github 有提供 SuperMemo 助手。 官网链接&emsp;&emsp;然而蛋疼的是这个软件的下载居然没了。&emsp;&emsp;我在 SuperMemo 的 Q群找到了 老版本 的编译版本。&emsp;&emsp;但是不支持最新版，也让我很不爽。&emsp;&emsp;于是我选择了极致的折腾，自己 clone Github 仓库进行编译。&emsp;&emsp;这玩意还需要我 VS 里面配置 Windows 开发的环境，折腾了好久之后编译出了一堆问题。&emsp;&emsp;然后逐个问题排查解决，当中有不少是插件的锅，其中 PDF 的配置也是很迷。&emsp;&emsp;我也没有搞得很明白，总之修改了部分的代码总算是把新版本的 编译出来&emsp;&emsp;只是部分插件不能用了而已，编译完成只有，我发现这个软件是带有插件库的，可以通过线上插件库把我编译失败的几个插件给下载下来，简直完美。&emsp;&emsp;只可惜折腾这玩意耗费了我大半个周末，然后其实最后也并没有怎么将 SuperMemo 用起来。 补充说明后来学习了 Anki 复习的技术 之后作者说得很有道理，萌新根本不需要折腾算法的问题，先将 Anki 用好就已经很不错了。等到真正遇到了 Anki 的瓶颈之后再去切换。毕竟 SuperMemo 的使用门槛过高了，如果 Anki 都没有能用好，SuperMemo 就更加不用指望了。 七月份 TiddlyWiki &emsp;&emsp;本来我搞 SuperMemo 已经搞得相当累了。&emsp;&emsp;我还很手贱就是喜欢 Anki 能够多端同步，SuperMemo 没有这个功能简直就不是现代软件了。&emsp;&emsp;后来还蹦出了 mpv 进行渐进视频的方案，考虑到我 技术美术 的领域大部分知识其实都离不开视频教程。&emsp;&emsp;所以我打算花费更多时间来折腾，于是就这个东西的折腾就无休止的。&emsp;&emsp;在折腾的过程中我非常偶然找到了这位大佬的博客的文章 Linux下用mpv在B站看番（二）：you-get &emsp;&emsp;毕竟也是个博客，我自己也是写博客的，于是这些地方上充满了好奇，想要认识一下作者是干什么行业的，看看作者过往写过的文章，然后就非常偶然地看到 TiddlyWiki 这篇文章 TiddlyWiki 折腾记录——云端部署 &emsp;&emsp;TiddlyWiki 其实挺眼熟的，在认识 Hugo 之前，我有想过要用 Hexo 来搭建一个 Wiki 库。&emsp;&emsp;当时在网上搜索资料找到 v2ex 的文章介绍，那个时候作者就有提过 TiddlyWiki 用 Hexo 做个人 Wiki 知识管理系统&emsp;&emsp;当时文章里面介绍了各种 wiki 系统，我当时并没有什么概念。 &emsp;&emsp;但是作者经过总结还是决定用自己开发的 hexo-theme-Wikitten&emsp;&emsp;其实去年的时候有下载过空的 TiddlyWiki 进行查看，但是没明白这个到底是个什么玩意，最主要的是居然不支持 markdown，反而要用什么 wikitext 着实让我受不了，于是没有深入去研究。&emsp;&emsp;但是当我看完这篇文章 TiddlyWiki 折腾记录——云端部署&emsp;&emsp;新世界的大门又又又打开了。 &emsp;&emsp;TiddlyWiki 虽然已经问世快 20 年了，但是它的 Quine (自产生程式) 和 SPA (单页web应用) 结合的理念依旧非常超前。&emsp;&emsp;TiddlyWiki 将 Linux 的一切皆文件的理念运用到了浏览器上，它创建了 Tiddler 条目作为最小运行单元。条目可以类比为 Linux 上的文件概念，它既可以是一份笔记，也可以是内核里面的代码。&emsp;&emsp;TiddlyWiki 实现了自己的 boot 之后，会读取内部的 Core Tiddler 条目构建整个 TiddlyWiki 系统环境。&emsp;&emsp;因此 TiddlyWiki 内核代码也是可以用自己进行编辑，修改实现各种自定义。&emsp;&emsp;条目作为最小单元还提供了标签(tag)和字段(field)接口，可以给条目添加自定义字段和标签进行归类和自定义。 &emsp;&emsp;关于 TiddlyWiki 更多神奇的功能可以参考 用TiddlyWiki替代Notion和EverNote作为个人知识管理系统 文章&emsp;&emsp;他的功能强大以及它的可扩展性，都让他能够匹敌 Notion 的。 &emsp;&emsp;Notion 并没有将编程能力开发给用户，但是胜在界面优化做得很好，个人使用门槛很低，最重要的是个人使用完全免费，结合 Notion 的动态表格，简直是最强生产力。&emsp;&emsp;如今 Notion 也加上了 双链 的功能，如果不追求折腾的话，确实 Notion 才是普通用户的首选。 &emsp;&emsp;对比 Notion，TiddlyWiki 将编程能力开放给用户，它支持插件的 拖拽 安装，并且借助 node.js 还能实现更多的自动化操作。&emsp;&emsp;对于像我等喜欢折腾的人来说，可谓是致命的诱惑，毕竟大公司的软件不可能适合所有人，大部分的普通人只能接受别人的设计，无限的妥协。&emsp;&emsp;而 TiddlyWiki 保留了可编程能力，意味着哪里不爽可以完全自己修改，而且 TiddlyWiki 的内核也是完全开放的，几乎所有的地方都是可以自定义的。&emsp;&emsp;即便是官方默认提供的最干净的 TiddlyWiki 也已经提供了很多开放接口来自定义出属于你自己的 TiddlyWiki ，这些开放性的都让我印象深刻。 &emsp;&emsp;TiddlyWiki 提供了两种使用模式，一种是基于 Html 单文件的，一种是基于 node.js 的命令行模式。&emsp;&emsp;单文件的方式有诸多好处，一个是易用，便于修改，其次是一切依赖都可以索引自文件本身，这样不受依赖影响，即便过去 100 年，文件依然能够以当时的方式正确呈现。&emsp;&emsp;而依赖管理的方式不在文件外部，而全部通过 js 在文件内部进行管理了，这是一种很好的设计。&emsp;&emsp;Erlang 之父生前力推 TiddlyWiki 视频链接 ，通过他的博客可以知道，他之前别 Github 的 Jykell 博客引擎折腾得不少。&emsp;&emsp;因为 Markdown 语言规范的不统一，而付服务商可能会将旧的规范支持给放弃掉，导致之前写的文章全部显示错误。&emsp;&emsp;所以 Erlang 之父为了解决这个问题寻求 Hugo 等静态网页生成工具，但是最终都没能很好解决他的需求，他甚至想要自己开发一个 静态网站生成工具了，就在这个时候他遇见了 TiddlyWiki ，他知道这个设计就是他想要的东西了。&emsp;&emsp;所以我们才能看到上年的 Youtube 视频 Joe Armstrong &amp; Jeremy Ruston - Intertwingling the Tiddlywiki with Erlang &emsp;&emsp;然而 TiddlyWiki 虽然等到了大佬背书，却依然因为他的使用门槛让大家 望而却步。&emsp;&emsp;一方面浏览器的安全限制导致已经无法直接将 TiddlyWiki 一键保存了，单文件 HTML 在浏览器保存必须依赖相应的插件，导致体验不好。&emsp;&emsp;其次使用 TiddlyWiki 就得学习它所使用 wikitext 语法，而目前国内环境下还没有很好的教程，相较于 Notion 的易用，TiddlyWiki 又进一步增加了使用的门槛。&emsp;&emsp;所以综上所述，如果没有编程背景和一颗爱折腾的心的话，Notion 或者 思源笔记 才是目前我的推荐，&emsp;&emsp;默认的 TiddlyWiki 太过简陋，然而普通人要去 TiddlyWiki 的论坛上找合适的插件来增强自己的 Wiki 有非常困难 (官方已经推出了 插件网站 ，只是目前还是草根阶段吧，还不如社区提供的列表 Toolmap)&emsp;&emsp;经过我的搜集，还是有人有一些中文的说明 wiki (只是确实也是少得可怜) 中文教程 TiddlyWiki XP — 一份 TiddlyWiki 使用教程 TiddlyWiki 舞 — 基础文档简体中文版 英文教程 TiddlyWiki 官网 Grok TiddlyWiki -&gt; 强烈推荐 &emsp;&emsp;鉴于上面的种种原因，我以后会专门开一个新坑介绍 TiddlyWiki - TiddlyWiki 食用指南&emsp;&emsp;也算是为 TiddlyWiki 社区尽自己一份绵薄之力了。 八月份笔记软件对比 &emsp;&emsp;经过上面一番折腾，我又发现了新的大陆，如果对标 Notion 的话，国内有 Wolai ，之前也有试用过了。&emsp;&emsp;但是提到双链笔记，那可是自从 RoamResearch 出现之后一直在笔记软件里面大火的概念。&emsp;&emsp;同类型的软件也如雨后春笋般涌现，于是我又花了一些时间去收集和了解这些软件。 传统笔记软件 EverNote OneNote 有道云笔记 双链大纲 RoamResearch 葫芦笔记 RoamEdit Logseq (RoamResearch 本地版) RemNote (间隔重复) 幕布 双链笔记 obsidian VScode Dendron / Foam / Markdown Notes All In One Notion / Wolai 思源笔记 (Notion 本地版) TiddlyWiki &emsp;&emsp;以上是我收集到的最近大众用得比较多的软件，更多的知识管理工具对比可以参照这个网站 知识管理工具特性对比&emsp;&emsp;我并没有将上面的软件都体验，实在是没有那么多时间和经历再进行对比了，我就上面的摸索历程感觉就已经够折腾的了。&emsp;&emsp;其实从上面的文章长度来看就已经很明确，我最终决定选择最折腾的 TiddlyWiki&emsp;&emsp;尽管是够折腾的，但是从长远来看我觉得是值得的。 &emsp;&emsp;经过这么一番的比较之后，是时候来介绍说明一下我所了解到的 数字笔记 的变革了。&emsp;&emsp;早期的笔记软件其实比较简陋，真正能够用来写笔记的软件大都是编辑器 或者是 word 文档&emsp;&emsp;网页端的编辑体验也比较差，早期比较流行的有所见即所得的编辑器，比如我刚学前端的时候接触到百度出品的 UEditor&emsp;&emsp;随着 2010 年之后的移动端兴起。&emsp;&emsp;以剪藏为代表的的 EverNote OneNote 逐步起飞 ，成为新的移动端笔记软件的霸主。&emsp;&emsp;随后到 16 年左右 随着 MarkDown 的普及下方，有道云笔记 等一系列 以 Markdown 为核心体验 App 软件逐渐出现。 &emsp;&emsp;https://www.youtube.com/watch?v=_x54XJrECvk&amp;t=4s&amp;ab_channel=LinkingYourThinking&emsp;&emsp;传统笔记重在收集记录，但是缺少笔记的学习，最后只会把笔记本变成垃圾堆&emsp;&emsp;NoteTaking 笔记系统比起 大纲笔记能够承载更多的信息 &emsp;&emsp;在这之后出现了两个标志性软件 Notion 和 RoamResearch&emsp;&emsp;Notion 引入了块的概念，让网站构建如同搭建积木的一样简单方便。&emsp;&emsp;而 RoamResearch 则引入 双向链接 以及对卢曼 Zettelkasten 卡片盒方法的宣传，引来一波大热。 &emsp;&emsp;由于这些笔记形态都是从国外开发的，所以对中国市场的支持还有所欠缺。&emsp;&emsp;国内不少公司看到这篇领域的空白，纷纷仿照上面的方案推出国内平台。&emsp;&emsp;诸如 RoamEdit 葫芦笔记 都或多或少有 RoamResearch 的影子，而 wolai 也是经常被人诟病抄袭 Notion&emsp;&emsp;尽管国内公司缺少革新能力，但是本土化和微创新还是可以支持的，无论是 微博 还是 微信 都需要更多包容才能逐渐做起来。&emsp;&emsp;如果这些公司能够提供更好地服务，让我支持也是无妨的，只是本土化的革新软件如果能多点就更好了。 &emsp;&emsp;在这个基础上，因为上述的服务基于云端，于是出现了开源社区，希望构建离线笔记来确保数据安全。&emsp;&emsp;Obsidian Logseq 思源笔记 就是比较有代表性的软件。&emsp;&emsp;Obsidian 更像 VScode 或 Typora 的双链笔记版本，编写体验更贴近纯文本。&emsp;&emsp;Logseq 则是对标 RoamReserach 的双链大纲形式&emsp;&emsp;思源笔记 则是对标 Notion 的块编辑方式。 &emsp;&emsp;而 TiddlyWiki 是当中最为特立独行的存在，技术方案，问世时间都让人猜不出来，缺点就是太折腾了，大部人并不喜欢使用。 笔记软件个人推荐 &emsp;&emsp;上面提到的笔记软件里面，我个人不喜欢需要云端同步的黑箱软件，毕竟数据交到厂商手里，如果哪天数据出问题了，我就血崩了。&emsp;&emsp;当然数据交给厂商同步，也可以相对方便实现多端同步，我现在主力用的 滴答清单 其实就是其中之一，只是 知识笔记的管理 我个人还是倾向自己保管，就像我的 Hexo 博客一样，我可以利用 Github 来实现多端同步。 &emsp;&emsp;基于上述原因，Notion RoadResearch 等软件我都不再推荐了。&emsp;&emsp;RemNote Logseq 思源笔记 Obsidian 都支持不错的本地化。 &emsp;&emsp;RemNote 类似 RoamResearch 的大纲双链，有内置的间隔重复算法，部分进阶功能需要收费，我个人推荐学生党，只是目前国内缺少中文支持。 (间隔重复算法可以用 Anki 替代，只是存在一定的割裂)&emsp;&emsp;Logseq 仿 RoamResearch 的开源免费版，并且内置 query 语法用来提取相关内容的笔记，也是非常强大好用，做学术推荐。&emsp;&emsp;思源笔记 仿 Notion 进行块化编辑，同样开源免费，我在知乎上看到早期版本 BUG 很多，不过我之前下载体验感觉已经很不错了，毕竟是两个人的小团队，开源软件早期几乎是用爱发电，宣传也是全靠自来水，值得支持。&emsp;&emsp;Obsidian 纯笔记软件，编辑体验更类似于 VScode (和 Notion 的块状编辑区别很大)。借助插件生态系统，逐步起飞，通过插件既可以实现查询还能支持很多额外的功能，最重要的是付费支持将自己的文章发布成网站。 &emsp;&emsp;上面四款软件中 RemNote 和 Obsidian 推出了手机 App ，缺点是需要去谷歌商店才能下载到。 &emsp;&emsp;对于小白用户，上面四款都是推荐上手的，毕竟萝卜青菜而有所好，上面就是囊括了几种典型好用的笔记形态。&emsp;&emsp;Logseq 和 思源笔记 是纯 PC 本地，而 RemNote 和 Obsidian 在移动端更进一步。&emsp;&emsp;如果喜欢块状编辑可以去尝试 Notion ，结合数据库功能的体验确实是数一数二的，但是国内体验不够好，wolai 目前的功能还和 Notion 有些许差距，在中文环境下做了不少细节的优化，但是核心功能依旧缺席，期待以后能够更进一步。 &emsp;&emsp;回到我目前使用的 TiddlyWiki ，我真心不推荐小白使用，不过愿意折腾的话，确实不用花钱也能体验上述的所有功能。&emsp;&emsp;借助 TiddlyWiki 的插件生态可以实现 大纲效果 参考 TiddlyResearch&emsp;&emsp;query 查询可以借助 wikitext 来实现，甚至还能自定义 UI 组件。&emsp;&emsp;动态数据库实现也完全不在话下，参考 zettelkasten ，大部分文章都有 backlink 和 link 进行溯源，还有 TiddlyGraph 显示关联层级的文章。&emsp;&emsp;甚至于脑图效果，双向连接也能通过 TiddlyMap 来实现，参考 tiddlyroam&emsp;&emsp;确实 TiddlyWiki 能够实现上面软件提到的功能，但是社区的产品都是相互独立的，没有人将这些很好的功能进行整合，并且各个版本之前的功能有各种各样的瑕疵，使用体验还有待进步。&emsp;&emsp;这就是目前 TiddlyWiki 的大问题，尽管他很好，但是路还很长。 &emsp;&emsp;TiddlyWiki 能否在移动端使用，答案是不言而喻，毕竟他本身就是一个 HTML ，只要有浏览器的地方就能更新。&emsp;&emsp;只是同步起来是相当痛苦。&emsp;&emsp;如果想要移动端的 TiddlyWiki 有个更好的体验，就需要用 node.js 版本将 wiki 文件拆分成多个文件，并且通过 git 来进行版本管理。&emsp;&emsp;node.js 可以实时将修改存储到本地，使用体验会更上一层楼。&emsp;&emsp;但是 Android 平台能够有 PC 的 VScode 来同步 Git 部署 npm ，启动 TiddlyWiki 吗？&emsp;&emsp;看似很困难，其实借助神器，可以抚平所有的痛苦。&emsp;&emsp;只需要在安卓商店上安装 Aid Learning 这款 App ，启动之后就会给你配置好一个 带 VScode 的 Linux 系统。(这个神器本来是针对 AI 学习开发的，有了 Linux 和图形环境加持，能做的事情可就多得很了，什么是生产力，这就是生产力)&emsp;&emsp;启动命令行内置 npm ，只需要安装 TiddlyWiki 库，然后配置 ssh 从 Github 拉取自己的 wiki 仓库，就可以在 安卓 手机或者平板上 修改自己的 TiddlyWiki 了。&emsp;&emsp;缺点就是这个用法相当耗电，鉴于能够切实提升生产力，还要什么自行车。 &emsp;&emsp;经过我的一番讲解，TiddlyWiki 确实是神器，各种好功能都有社区大神实现，即便没有也可以自己动手。但是 TiddlyWiki 缺少商业公司运营来提升使用体验，社区的插件互相独立，导致体验非常割裂。&emsp;&emsp;社区的活跃程度也不太够，TiddlyWiki 的使用门槛将大部分普通用户劝退了。&emsp;&emsp;目前我自己的 TiddlyWiki 的了解也比较肤浅，需要大量前端知识来升级。 Rime 小狼毫输入法 &emsp;&emsp;你觉得前面已经够折腾了，其实还有更加折腾的。&emsp;&emsp;在使用 TiddlyWiki 的过程中，我发现输入颜文字表情会很麻烦，我想要有类似 VScode 插件 emoji 一样的输入体验 插件 经过我的长时间折腾之后。想要在 TiddlyWiki 实现比较困难，考虑到这些输入不只是 TiddlyWiki 需要用到的，我完全可以实现一种全局支持的表情方案。&emsp;&emsp;于是我想到了输入法，有没有可能让输入法玩出更多的花样出来。&emsp;&emsp;我到知乎搜索，才学习到原来有 小狼毫 这款自定义输入的输入法神器。 &emsp;&emsp;小狼毫输入法的最大特点是开源免费，而且不会别收集用户隐私数据，配置非常灵活。 Github&emsp;&emsp;缺点也非常明显，那就是足够折腾，词库需要自己配置，没有云端智能提示。&emsp;&emsp;但是它开放性就像 TiddlyWiki 一样，哪里不爽都可以自定义。 &emsp;&emsp;经过我的折腾可以让它支持自定义的表情输入，也可以输入颜文字。&emsp;&emsp;但是使用总会有些许不舒服的地方，比如输入某个词要找很久，打名字没有智能识别。&emsp;&emsp;这中间的小体验需要我费尽周折，实在是让我越用越不爽。 &emsp;&emsp;所以最后我还是用回了 搜狗输入法 ，并不是小狼毫的问题是我的问题。&emsp;&emsp;快捷短语输入等等简单的功能也可以利用 Anki 来解决，但是折腾 小狼毫 让我觉得有点得不偿失。&emsp;&emsp;如果以后有机会把 mpv 给用明白了，或者就能来抽空研究一下 小狼毫 应该怎么用。 Anki复习的技术 &emsp;&emsp;在折腾上面一系列问题的时候，间歇性的会觉得 SuperMemo 引入的渐进学习方案挺不错的。&emsp;&emsp;但是无奈 SuperMemo 的界面和使用各方面都让我感到很劝退，即便已经找到了 SuperMemo.wiki 这些不错的教程，还是觉得 Anki 这个软件更加适合萌新的我。&emsp;&emsp;于是我开始找 Anki 相关的教程， B 站上的视频教程给我感觉一般般。&emsp;&emsp;刚好有天晚上在用 喜马拉雅 听说，于是我就带着好奇心去找找 喜马拉雅 平台 有没有讲关于 Anki 如何使用的教程。&emsp;&emsp;睡前听听也是挺好的。 &emsp;&emsp;这么一搜索，发现比较靠谱的也就第一个音频 Anki复习的技术 桌面端视频链接 &emsp;&emsp;雷欧老师就是学习骇客本人了，这套音频是带视频版本的，只是视频是收费的，可以在淘宝上付费购买。 淘宝链接&emsp;&emsp;音频可以白嫖学习， 音频里相关的讲义资料也是全部免费提供 链接 ，真的很良心了。 &emsp;&emsp;雷欧 做 Anki 教程已经做到第四期了，中间积累了无数的知识，包括很多书籍的理论支持，我听音频都觉得很专业。&emsp;&emsp;其中理论篇很值得大家去听一听 学习学习 。 &emsp;&emsp;工欲善其事必先利器，器欲尽其能必先得其法。&emsp;&emsp;很多人只知道前半句，所以会在软件的选择上各种纠结，其实后半句也很重要，你需要有系统的理论知识，你才能把工具用好，否则选的工具再称手也无济于事。&emsp;&emsp;理论篇的内容已经是 雷欧 经历多次授课和知识储备留下的精华部分，我推荐大家都好好听一下，下面是我对其中内容重点的进一步提炼。 专注模式 &amp; 发散模式 长期记忆 &amp; 工作记忆 知识需要记忆 学习闭环 穿插学习 专注模式 &amp; 发散模式 &emsp;&emsp;这两个模式来源于 学习之道 这本书，我最近也在听。&emsp;&emsp;专注模式可以高效完成你目标明确的任务，典型的例子就是时间管理里面的 番茄钟。&emsp;&emsp;番茄钟通用的定义是 专注工作 25 分钟，然后休息 5 分钟。要求在专注的过程不能被别的东西打扰，注意力集中在重要的事情上。&emsp;&emsp;发散模式通常是不经意间的灵光一闪。典型的例子就是 洗澡、度假的时候突然把事情想明白了。 &emsp;&emsp;这两个模式是相辅相成的，都需要充分利用好，可以发挥无穷的力量。&emsp;&emsp;知识是需要储备的，通过专注模式可以快速完成知识的摄入部分。&emsp;&emsp;但是摄入的信息需要消化理解，这个过程可能在自己没有意识到的时候就开始进行了。&emsp;&emsp;需要有专注模式的摄入为前提，才能有发散模式的灵光咋现。&emsp;&emsp;有时候用专注模式死磕某些知识反而会一直卡在死胡同里面，这时候利用番茄钟的 5 分钟休息，反而可以把事情想得更加明白。 长期记忆 &amp; 工作记忆 &emsp;&emsp;长期记忆就基本属于自己的知识储备了，在需要的时候可以快速回想起来。&emsp;&emsp;而工作记忆是最常见的短期记忆，基本上都会稍纵即逝，因此一旦有什么灵感已经要第一时间记录下来，否则可能就想不起来了。&emsp;&emsp;工作记忆承载了我们日常生活的方方面面，而长期记忆会将短期记忆经常咀嚼消化重要的东西留下来。&emsp;&emsp;类比于当年电脑就是 长期记忆就是硬盘 工作记忆就是内存。&emsp;&emsp;将数据存入到硬盘里面才不会丢失，只是扩充自己的长期记忆是相当困难的。 知识需要记忆 &emsp;&emsp;以前在学校的时候，很多师兄师姐或者老师都会说这个知识点不用背。&emsp;&emsp;那么不用背是否就意味着这个知识点不重要需要记忆了呢？&emsp;&emsp;当然不是的，知识是需要掌握并且记住的，否则需要用到的时候就用不起来了。(当然如果非考试环境也可以利用搜素引擎来辅助记忆) &emsp;&emsp;但是很多人会混淆了，觉得记住某些知识就是要背诵才可以的。&emsp;&emsp;其实背诵只是记忆的其中一种方法，要记住某件东西，完全可以用更加高效且适合的方法来完成。&emsp;&emsp;比如传说中的记忆宫殿就是将需要记忆的内容映射到自己熟悉的意像中，人类对图像的记忆比起文字的记忆要好得多。&emsp;&emsp;从而可以更好地记住一些无意义的信息。&emsp;&emsp;比如圆周率或者电话号码都是无意义的一串数字，要记住它可以运用数字桩的方式，将每个数字绑定到自己熟悉的意像中，然后用这些意像在脑海中构建段视频，生动的视频很容易记住，从而可以反推出那一段数字是什么。 &emsp;&emsp;所以这里需要明确，知识都是需要记忆的，但是记忆有很多方法。&emsp;&emsp;那么经过科学验证过的，对于学习知识最好的记忆方法就是 间隔重复。&emsp;&emsp;间隔重复就是根据遗忘曲线间隔复习知识点，在知识快要被遗忘的时候进行巩固，可以极大提高知识的留存率，有助于将短期记忆转换为长期记忆。 学习闭环 &emsp;&emsp;雷欧 老师总结了学习闭环的四个阶段 学习 思考 记录 复习 &emsp;&emsp;四者缺一不可，四者融汇贯通，此乃绝世神功。&emsp;&emsp;现实生活中我们学习很难完成整个学习闭环，那么对知识的掌握程度会大打折扣。&emsp;&emsp;一定要避免 探险学习，一时的心潮澎湃决定多学一点，但是大部分人都是学习了很多却没有流转到后续的 思考 记录 复习 阶段。&emsp;&emsp;没有走完学习的闭环，学习的效率其实是很差的。&emsp;&emsp;无论是在短的时间也一定也走完整的学习闭环来学习。 穿插学习 &emsp;&emsp;当学习多个学科的时候，穿插学习比起拆开时间死磕对应的学习是要好的。&emsp;&emsp;比如说，我三天内需要学习 物理 化学 英语 三门学科。&emsp;&emsp;比起一天一门学科的学习方法，每天都安排这三门一起学是要更好的。&emsp;&emsp;首先拆开学习会导致前面的学科遗忘率增高，其次是穿插学习人为增加了学习难度，这有助于提高知识掌握的程度。 &emsp;&emsp;其实穿插学习的典型就是 渐进学习。&emsp;&emsp;穿插学习需要把握好学习的科目数量，建议使用 1难1易 的搭配&emsp;&emsp;如果穿插的知识太多，极有可能变成低效的多任务处理了，所以要量力而行。 总结 &emsp;&emsp;学习骇客的理论里面着实学到了很多东西，其中不少知识点我将自己之前看过的一些 youtube 视频串联到一起形成我自己的一套说法。&emsp;&emsp;之前花费了大量时间收集和测试 TiddlyWiki 的社区插件，我感觉也是没有掌握到 器欲尽其能必先得其法 的精髓。&emsp;&emsp;虽然完美主义，强迫症人人都有，我就想要将 TiddlyWiki 打磨到最完美的状态下再深入使用。&emsp;&emsp;但是回过头来看，坚持使用，并且将学习理论付诸实践才是目前我主要做的。&emsp;&emsp;重在道不在术 我应该在使用 TiddlyWiki 过程中逐渐把他优化到最好的状态。 我目前的学习方案 &emsp;&emsp;总结了上面这么多的东西，总算是将我一路来得折腾总结了大半。&emsp;&emsp;那么现在我的学习方案变更为下面三款软件为主了。 收集箱 滴答清单 知识管理 TiddlyWiki 复习工具 Anki &emsp;&emsp;滴答清单是一款 GTD 工作流的时间管理软件。&emsp;&emsp;其实用它也有好长一段时间了，但是中间用得断断续续吧。&emsp;&emsp;一直也没有申请会员，这款软件如果不是强迫症的话免费功能真的已经够用了。&emsp;&emsp;而且免费环境还能多端同步，实在是良心软件。 https://zhuanlan.zhihu.com/p/346606470 &emsp;&emsp;使用 TiddlyWiki 有选择了 滴答清单 的并非我一个，在知乎搜索 滴答清单 和 TiddlyWiki 就很容易搜出对应的文章 链接&emsp;&emsp;里面提到的问题其实我也有遇到类似的情况。&emsp;&emsp;TiddlyWiki 其实有任务管理的插件，叫做 projectify&emsp;&emsp;但是 TiddlyWiki 在移动端的体验可谓是糟糕得很，而且网页上无法联动收集内置的定时提醒。&emsp;&emsp;着实让 projectify 显得鸡肋。&emsp;&emsp;滴答清单就可以很好解决我上述的诸多烦恼，而且滴答清单接入了很棒的 Markdown 编辑器。&emsp;&emsp;任务描述的书写体验非常好，很适合将一些想法点子记录下来，后续再到 TiddlyWiki 中进一步加工。 &emsp;&emsp;Tiddlywiki 是我目前的知识管理工具，但是并没有深入的使用起来，因为这篇文章一直卡壳没有写完(:з」∠)&emsp;&emsp;待我将东西整理完毕之后，还有花很多时间来整理一下目前我瞎折腾的 TiddlyWiki&emsp;&emsp;之前捣鼓的插件加起来已经有 100 多个。&emsp;&emsp;目前我是将三个大佬的 TiddlyWiki 插件进行了整合。 tiddlywiki-xp 林一二的模因和想法 zettelkasten &emsp;&emsp;目前还在我的私人仓库里面躺着，还没有整理好公开发布的流程。&emsp;&emsp;总之这是一个宏大的计划，也说不定哪天就跳反到 Notion 去了。 &emsp;&emsp;Anki 复习，目前是使用 TiddlyRemember 插件来将 TiddlyWiki 的问题同步到 Anki 中进行复习。&emsp;&emsp;这样可以 Anki 点零碎找不到源头的问题。&emsp;&emsp;知识库的联动有助于提高复习的效率。 &emsp;&emsp;这套插件已经经过我测试可以用起来，只是还没有开学习的新坑，所以整套流程还没有推动起来。 总结 &emsp;&emsp;这一次 PKM 的折腾，消耗了我大量的个人时间，但我觉得这个是终生受益的。&emsp;&emsp;对比以前我的学习方法，其实是没有完成学习的闭环，不过因为我有做博客积累。&emsp;&emsp;所以我完成了 学习闭环 前三个步骤。&emsp;&emsp;然而最重要的复习却是一片空白，如果知识是在生产中落地的，那么还能不断重复从而加深印象。&emsp;&emsp;事实上有些东西我写了博客记录，也几乎不记得了。&emsp;&emsp;比如我以前的 shader 学习系列 和 Houdini 学习之路 系列。&emsp;&emsp;现在回过头来看，当时我看了教程学习，动手做了一遍进行思考，最后写了博客进行总结。&emsp;&emsp;又因为一直没有机会用上，导致现在几乎忘记，还是因为没有走完学习闭环导致的。 &emsp;&emsp;目前我已经掌握了部分理论基础，后面只差摸索出适合自己的学习之道了。]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>࠳tiddlywiki</tag>
        <tag>࠲Obsidian</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python UV 图自动渲染输出]]></title>
    <url>%2Fposts%2Fd197a8b3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近接到一个新需求，美术那边经常需要导出模型的 UV 快照进行流光等效果的制作&emsp;&emsp;但hexo是 Unreal 可以查看 UV 却无法把 UV 图导出来。&emsp;&emsp;所以他们只好将引擎的资源导出到 DCC 里面使用 UV 快照输出 UV 图信息。 &emsp;&emsp;经过我的研究，可以利用 shader 展开 uV 然后用 SceneCapture 获取展平 UV 的效果。&emsp;&emsp;最后用 Unreal 的 API 输出 UV 图即可~ 实现思路 &emsp;&emsp;首先需要实现一个 UV 平铺的材质，这是实现效果的关键。&emsp;&emsp;最初我也没有什么想法，后来咨询了 胡洋 之后，有个教程网站有相应的实现。 https://www.raywenderlich.com/6817-dynamic-mesh-painting-in-unreal-engine-4 &emsp;&emsp;文章里面通过 shader 可以将角色拆成 UV 平铺的形式。&emsp;&emsp;可以利用这个方法做一个简单的材质。 &emsp;&emsp;从材质的预览窗口也可以看到 UV 展平的效果很好地实现了。&emsp;&emsp;接下来只需要构建一个相机从上往下 Capture UV 图即可。 &emsp;&emsp;接下来需要构建一个用于拍屏的蓝图。 &emsp;&emsp;蓝图里面添加三个 component ， capture相机 StaticMeshComponent SkeletalMeshComponent &emsp;&emsp;相机需要设置为正交模式避免透视影响 &emsp;&emsp;创建一个 RenderTarget 获取相机 Capture 的信息。 &emsp;&emsp;最后需要注意，capture 组件的大小和材质的大小要保持一致，否则渲染出来的图片不会刚好占满了。 &emsp;&emsp;接下来我们已经可以在蓝图验证 Capture 的效果了 &emsp;&emsp;将模型附着，加上之前做好的展开 UV 的材质，就可以完美渲染出 UV 快照。&emsp;&emsp;下一步可以从 RenderTarget 创建一个 静态的贴图 然后将贴图导出到对应的目录即可~ 自动化 Capture &emsp;&emsp;上述的方案在蓝图即可完成，只是蓝图默认打开并不在 Viewport 的标签页下。导致无法触发界面的更新。&emsp;&emsp;于是我想到将蓝图放到场景里面进行渲染即可~ &emsp;&emsp;自动化输出需要解决一个问题，需要等待图片输出到 RenderTarget 才能进行到下一步的输出。&emsp;&emsp;因此需要用到 Python 的延时代码触发的功能，用原生的 Python 多线程就有 Timer 类可以用。&emsp;&emsp;不过 Qt 的 QTimer 用起来更加方便简单。 完整的代码在 PyToolkit 仓库里 链接 123456# NOTE 记录和隐藏所有 Actor 的显示vis_dict = &#123;&#125;for actor in level_lib.get_all_level_actors(): vis = actor.is_temporarily_hidden_in_editor() vis_dict[actor] = vis actor.set_is_temporarily_hidden_in_editor(True) &emsp;&emsp;Capture 之前需要将场景里所有的 Actor 隐藏起来，并且记录隐藏的状态， Capture 结束之后恢复显示。 123456defer = QtCore.QTimer.singleShotdelay_time = 1000for i, mesh in enumerate(meshes): defer(delay_time * i, partial(cls.capture, mesh))defer(delay_time * (i + 1), partial(cls.on_finished, vis_dict)) &emsp;&emsp;接着利用 singleShot 延时调用 capture ，等待 1000 毫秒基本就足够了。 1234567891011121314151617181920212223@classmethoddef capture(cls, mesh): capture_actor = level_lib.spawn_actor_from_object(BP, unreal.Vector()) capture_comp = capture_actor.get_editor_property("capture") if isinstance(mesh, unreal.StaticMesh): static_comp = capture_actor.get_editor_property("static") static_comp.set_editor_property("static_mesh", mesh) materials = get_static_materials(mesh) comp = capture_actor.get_editor_property("static") elif isinstance(mesh, unreal.SkeletalMesh): skeletal_comp = capture_actor.get_editor_property("skeletal") skeletal_comp.set_editor_property("skeletal_mesh", mesh) materials = get_skeletal_materials(mesh) # NOTE 重新获取才可以设置 override_materials comp = capture_actor.get_editor_property("skeletal") override_materials = [UV_MAT] * len(materials) comp.set_editor_property("override_materials", override_materials) capture_comp.capture_scene() # NOTE 等待资源更新 defer(delay_time / 2, partial(cls.on_capture_finish, mesh, capture_actor)) &emsp;&emsp;capture 函数会将内置的蓝图生成到 场景里面，并且将模型和材质配置到蓝图相应的 component 上&emsp;&emsp;然后调用 capture 组件的 capture_scene 来更新 RenderTarget&emsp;&emsp;最后还是要等待 半 秒，将获取的图输出到对应目录上。 123456789101112@classmethoddef on_capture_finish(cls, mesh, capture_actor): # NOTE 生成 2D 贴图 name = os.path.basename(mesh.get_outer().get_name()) texture = render_lib.render_target_create_static_texture2d_editor_only(RT, name) # NOTE 导出图片 exporter = unreal.TextureExporterTGA() output_path = os.path.join(cls.export_dir, "%s.tga" % name) export_asset(texture, output_path, exporter) capture_actor.destroy_actor() asset_lib.delete_asset(texture.get_path_name()) &emsp;&emsp;capture 完成的输出从 RenderTarget 生成静态图&emsp;&emsp;然后将贴图导出到桌面上，最后删除生成的 Actor 和 静态图 资源。 总结 &emsp;&emsp;这个方案有几个问题。&emsp;&emsp;一个是需要用到 Unreal 的资产，高版本的资产无法兼容老版本。&emsp;&emsp;第二个是，第一次拍屏的时候，shader可能需要进行编译，导致拍屏效果为空。&emsp;&emsp;最后就是延时 1 秒的方案，还是有些许不确定性，如果需要渲染一个复杂的模型可能 capture 时间不够。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python FBX SDK 切线处理]]></title>
    <url>%2Fposts%2Fef0f2205.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个需求是好久个月前就已经实现了的，这里补充一下文章，记录实现的过程。&emsp;&emsp;需求是这样的，描边需要用额外的法线信息进行处理，但是当前角色的法线已经有软硬的用途。&emsp;&emsp;因此需要将额外的圆滑过的法线信息写入到 切线 中，引擎的 shader 读取切线进行描边绘制。 &emsp;&emsp;最开始要做这个需求，我想到的是利用 OpenMaya 的 API 将法线写入到切线就完事了。&emsp;&emsp;然而我大意了，我发现 Maya 的 MFnMesh 只有获取切线信息的没有修改的功能 链接 &emsp;&emsp;在网上也搜了一遍，似乎也没有很好的解决方案。&emsp;&emsp;不过我的前导师有给我留了一手，虽然他的脚本是对接 Unity 的，但是思路是完全可以借鉴的。 &emsp;&emsp;他的实现方式是将 FBX 保存为 ASCII 模式，然后用正则表达式将模型的法线信息替换到切线信息上。&emsp;&emsp;这个方案用纯 Python 即可实现，方便高效。 &emsp;&emsp;只是我觉得用 FBX SDK 的话或许效率会更高，也能直接处理 Binary 的文件。 FBX SDK 使用 &emsp;&emsp;关于 FBX SDK 是什么，如何使用，我在之前写的文章有所介绍 链接&emsp;&emsp;FBX Python SDK 里面有支持 Py2.7 和 Py3.3 的 pyd 脚本，并且里面还有代码案例，可以参考学习。&emsp;&emsp;Py3.7 版本有需要可以在这篇文章末尾拿到 链接 12345678910111213141516171819import fbximport FbxCommondef clear_uv(output_file): """删除第一张 UV""" # NOTE 读取文件信息 manager, scene = FbxCommon.InitializeSdkObjects() result = FbxCommon.LoadScene(manager, scene, output_file) if not result: return # NOTE 获取节点信息 nodes = scene.GetRootNode() # NOTE 获取大纲中第一个模型 mesh = nodes.GetChild(0).GetMesh() uv = mesh.GetElementUV(0) # NOTE 删除第一个 UV 的信息 mesh.RemoveElementUV(uv) # NOTE 保存文件输出 FbxCommon.SaveScene(manager, scene, output_file) &emsp;&emsp;上面是我自己写的一个简单的示例代码，可以清理 FBX 里面的第一份 UV 信息。&emsp;&emsp;使用上和 C++ API保持一致，返回的数据结构可以查 C++ 文档 &emsp;&emsp;我自己写的或者收集的东西放到这个仓库下了 链接 FBX SDK 将模型法线写入到切线 &emsp;&emsp;思路: 输出两个 FBX 一个是正常输出，一个将模型的法线平滑再输出。&emsp;&emsp;输出完成之后将平滑法线的模型 写入到 切线 上。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import osimport tempfileimport pymel.core as pmimport pymel.core.nodetypes as ntfrom maya import melimport FbxCommonfrom fbx import FbxDocumentInfo,FbxNodeAttribute# NOTE 临时目录输出 FBX SOFT_FBX_PATH = os.path.join(tempfile.gettempdir(), "soft_normal.fbx")class TangentHandler(object): info = &#123;&#125; @classmethod def _export_soft_fbx(cls): """导出 平滑 法线的 FBX""" meshes = cls._soft_mesh() pm.select(meshes, r=True) mel.eval('FBXExport -f "%s" -s' % SOFT_FBX_PATH.replace("\\", "/")) pm.delete(meshes) @classmethod def _soft_mesh(cls): """平滑法线""" new_meshes = [] for mesh in pm.ls(sl=1, dag=1): if hasattr(mesh, "getShape") and isinstance(mesh.getShape(), nt.Mesh): # NOTE 如果 outline 模型用调整的法线 outline_mesh = mesh + "_outline" if not pm.objExists(outline_mesh): outline_mesh = pm.duplicate(mesh, n=outline_mesh)[0] pm.polyNormalPerVertex(outline_mesh, unFreezeNormal=True) # NOTE 硬化边 pm.polySoftEdge(outline_mesh, angle=0, constructionHistory=False) # NOTE 平均法线 pm.polyAverageNormal(outline_mesh) new_meshes.append(outline_mesh) return new_meshes @staticmethod def _read_fbx_attribute(path, attribute): """读取 FBX 属性""" manager, scene = FbxCommon.InitializeSdkObjects() result = FbxCommon.LoadScene(manager, scene, path) assert result, u"无法打开 FBX 文件 %s" % path data = &#123;&#125; for i in range(scene.GetNodeCount()): node = scene.GetNode(i) mesh = node.GetNodeAttribute() if not mesh or mesh.GetAttributeType() != FbxNodeAttribute.eMesh: continue # NOTE 根据属性名动态获取属性 attr = getattr(mesh, "GetElement%s" % attribute.capitalize())() if not attr: continue data[node.GetName()] = attr.GetDirectArray() return &#123;"manager": manager, "scene": scene, "data": data&#125; @classmethod def set_tangent(cls, fbx_path, meshes): # NOTE 选择模型 pm.select(meshes) cls._export_soft_fbx() origin_data = cls._read_fbx_attribute(fbx_path, "Tangent") target_data = cls._read_fbx_attribute(SOFT_FBX_PATH, "Normal") manager = origin_data["manager"] scene = origin_data["scene"] tangent_data = origin_data["data"] normal_data = target_data["data"] # NOTE 特殊切线导出 for name, array in tangent_data.items(): normals = normal_data[name + "_outline"] array.Clear() for normal in normals: array.Add(normal) FbxCommon.SaveScene(manager, scene, fbx_path, 0)# NOTE 输出的 FBX 路径fbx_path = r"E:\MayaTecent\MayaScript\FBXSDK\box.fbx"# NOTE 处理的模型export_meshes = [mesh for mesh in pm.ls(ni=1,assemblies=1) if isinstance(mesh.getShape(),nt.Mesh)]TangentHandler.set_tangent(fbx_path, export_meshes) 总结 &emsp;&emsp;默认不修改引擎的情况下，导入的切线无法通过重新导入来更新。&emsp;&emsp;并且切线信息的调用上，也会有些问题，unreal 会把切线当成正常的切线进行计算。]]></content>
      <categories>
        <category>CG</category>
        <category>pipeline</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyblish lite 前台批量输出]]></title>
    <url>%2Fposts%2F3abc2b42.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 提示(神秘号码 + 魔方) 128fc081afb2ac025729b324485bbfe261abae81db29cbe038e597d07315989b37ce7673fa665da3b7b37b2d744929eda397e2d51baa44510a49393da1951f9bf10b6225ffa67e08592a4383e94942e6931cb75256fe2b0189dcf3702d3a42fee387106b40ec04aef0fe2930790d2c140408a6ef088dda85a39607e2faf9a9c1b06c3ec98cc7f92ea27f3b726aa885430aa5d1b0ba767a67efc9f180bf8b92d450d81fedec811d2021515291c3fb42d0261ee53ec9b5d8d0806ec815eabdac4c2397b2b81967272df17fea8f731c62ac5be3fdd9d6ca8f76bfe6bb370b1d17f3549b7a332e36efd9066a0080604454d891f0669180091ebc57df5d5809344a25711c2d2d7992906cd0a10032f74ef2b6d3a74ea4060bc2065beef3bd67f7b79a231ca605d3f09539ac00dd984241759380851c8ecbe48ecea0351e7e2ccb09df20ccecdeb04fe3f6334b5a8a3b4e77de263feeda65d70e4cc6660b0d3457939326c0ace2f9f19cd40a289342ecf285ddb5af4b6cd37f32a63287d51b97a7e3a75e5be62983e6b0ba3e0654d52d26aa78f02089dafa3c0ec22d396339d7dda4ec0d973bb2cd5137690674d1347e2fd967298553998cf609fb530ccef17790cb424e27292ab81363d6c220345ef9bce6293f735420b4cc1c9b87ac69eb31aaeb98939131155ed6e1ea4fd04e38137dc738f9c30efa19efa158e15a2d14b729d8f890e8d4714b203ea915ed930f6baf579ffc240c24951e111e1e0d67c90edec58167adcd9be88bf5618c66f27f0b2a984d1099c31dc06441e63c13f485aa6f1555d111cf79958e082f75b3dd54bb87e2253d1a2f53201ac0c65dcfc6058bb67b0d541ed198e970c67fd839c5907ad55197ce93a76249ba47d27dad062b6e16f5ea058d0ba87e7ebd742d30a34f1328db1416d1f07d4a0841550a40fe23f7fc633f3e431e37ca7b62deb6a83de9519dd8b12b6b112211877d50db7743a40874b28ddc54fa2f5e3ad4d542c538b298e73d5a57920d8a69824f932bd74de70696854c466b18669cd9e2fe3543b653c65e3a5dde1cb2addb77ffb05bade84fb41ed425dd8e1faeec88438722e552f16a311b7b053f7cb87baa5e3e65cc0d61663af29ee8af1b453b33388062c5c5eef9766b58975dbdb0c9b6a767d4bf51cefd907a6a5626c70e8e3d12c1fe9e8f85f074110b412c08c40a3a3e3960a1152d4f3441922bc34a840ece0902cd45db5364e0ca7076ec804bc628f62c56266a547328640c07856b1b4e6cb640fda6fef4d0f4edc5239c074e6cef8372518e4dfdb2ab46d4b836284606c9ea1441230c0bf451f25cda06c93a39033c30b8fcd37dd328ee5262422a3d9402bd0aa5dfe93f0b1c75bb2dc469bd5f2b3b448868f1160b3eb689b5a6af57c52cc1465f77f6be5e9abbfef14b29e82047b25dea0784d346ca40c463c65ddd8981d74364b2363673b7cf1de8460ed7d6b1abf671f127b7ee0e538b8d036da25b1f9091d6cf23b5b0e970ca36ddaff364b82b2ba4928c67c75e4a9badee0af4b94e7f47769d1ca4b0f150790965fe1e654a674bfdff06d5602169732112378fbebb67cce06b1cc524132fe2a6f2a634962f94ab660b4f3d58799b65303b3943a07a43ee401ca90cb53888d6718b8f1d38494179ec2c8361688bbcdb2bb5b13ef957c707a5726f54f94646f00abde959b49969e78e80656f3ba9e0edf957ce83a1ab154a2eadec767dfbf057445903af6ff98e93e1109788920c179be377701e4e1dcdcf16ad67d0b842000e84f1f7c1efa49fa6caf7cd539c1fbbdc070223a662511c053998e49392cbd61a4113b0edc2bf91179f50abf31d0f771899cf70685bb8fa4709d72aa9be8c41b61268d0df47114f64e6bf9b803480e5d45bdb0c860b568979451ffcc6a0f00b6ab789c2813fae5105e2c70a9cc6bb44fa9b433165329cffce879eff90792a17cc55b0b3ed04969f9d83bfd049d187596ed89154a8bf2b3e766b1daba9844f91328720ebe6e208796703451245adacbcd7ab4d472b1141b363052dba95235811752b3946a33999a94e794934dd2fa57fb111b32d9d0699d6beeed670c292d29e888d7427f7330919b108cf489fe653315973c2e930d9b24ebaf66b55deeb68024f52064b3f1730eeb4ae94446d9477368bc87b27b5011403c9d1579532dbcae67d5277372986409d95a530101181cadb7010278c1f79477ef61c0416fd258791ce48c8adea273e9008f3318d117b5219b31153e0507c8518207a0b5af892d90c3d74009486c11a2ba6b3d5adf8f0847df18f71fe7e4be4868ca245b2df5a9a66233958cacbc735306dfa04dc5d04cbed8822d62eb1c66302dd8773d9495c1de2c0ee12f8745f4445e18147a1043dbaadfa0897db712e62b2717b7e52cd6d7e5df5bda14f0520f83f9c506fb4bb9effab89d89717137413eed11bd4a811a3ee91b1d3e60d8830493902a5a0fac207286b5279ef617adbf2da5f0137f6d42771fe216f4464fe7adcdaf31efda9a77bd8d07288510ec1866f9578144588f8139b92ac2a3ef7bdc98e72ebb4746837f08e8a3958bc1f71d2116b6da1cc2ee0f59c78b8fd0c8f3987a4039176ec5cf14b7c2cf846928d5787a78b94f37d9cd08c412d1e7f4ce6d644986820de20d2c0f431410d59b6618ae33454a9a32e0c64c019e692d1b85711b94e6ce9722178e56dc4843d54ed156e3886987d20cb428768062f54e20f6dfeadf02139aff691342c341fd318abde6816b519f422527c77a064170825eed967a2323ec32f443c96a269d7cbc209919d49cfc69ae5fdbad0cba122717cf558d6680972af7b9a295a2ae7527970e648081784725e9a92682256a8f4f1261fbed712e957fe676293f6f85a25376ef872deb1031b475e7565c9c1b22f89c675884c4467f252c31bda410fd05700570592e72449501d3575a4c55fccbfa0efef66b1437d97a84e92dc76e56d1fdf5aff84a490b095088ddd22e73b678a2110f63ec9ff95a6a522eb39d867a44b9deecb69be0d94d155b6db247eef9f70e7d1d3e60a86393b38428e66aaabd7f035127a9bb2797951a0290ee8490ac269eda0b1d9b2b0f9d8df33f70955f6e7454efaec9c4bff2dc2e4ee1b02d90e0f8aec5cf6af947236fc5183dc03aa6012fb32b9353ff5da0d4cc08b8be2a75036b1f385f7dd061649aabc6f74dc6adc2a67853e030dd3a901302de88f9a57a7c36698b54e37e0bc1cb889bfe215d9576ba9e903a6b5cbe7be2b9163a8dad4d8b70f2be56b7ac7e914f5d64915d679a3bf2a1147f8ac11b8b99f1bdfaf322ecf02b97e11054a3f7b053698dd340c8befc0d52767d83bb25af7faa75e4a35ec8cd206351c6e09767c1653543b1bea8f6572b1ea32482d19c4fa76f4d1a2938c962505b9779a738c72fc864a148f6657bc7b493131e3dfb9c0266e2a70b650e1d14c91d3b08be09f37b6eb4520d73dc44cbf330486239c09a4bb04005585cd30b4ca77a54deb9ab6305bd6c3b16113841165b091df62942b8620e899549ad14ffc85195da1bfae4abab283c4a1c021a7b16a0cb35d3b4507bca1257bfc9f56c3a694e0e868fa05be39872467d2cd55003f1a6cfae2dd391b65a62c09004b5cf0a717c75c639265feedbc19cb07ffe27a42d65a4e1d4f2d5e9849597fae69ffb690e507b5eb7f6613d9c7306c823df54d093a3d3a9dc3f27d8c1c1f3732f46c1ead76206c071038e487fd585bdc1e5ef6f25e84e2385fd51c5701e69f93f1d8b61787b0c55be41cd76035d9625e1ea19fd7b723ccd400f2749da7f65945e170c77f97863f056bb792ddd28a0f66cd1ad3683baa3c2f1243067a2a836f0342d937fb8a9dc2f3d1c69e477db5a118b2588199fe7af3cc78ba37cf9db40f7f603ed5701fc7a72dad03e511f6be5739056d1be4245311a21155d54c266e31430d93d6c5da3961146eba56d8124acc8b2541e5b29fd2546484f521d0a1402401f60b311cf068894c9acc5f40b2bd326c4e353239205ae9c96e25e7a315d58245f22f57f3be720c13db579721244b59f55dadf608b42358d0dfd391e2934f7cff76d47870ea21b10344bad420caadfa2e99051917a9bc4059e480ffa2e2f4a0ad6ee1383c3dc45e3d609171008fce2cb3d6137334f80794983e05baea2b2b15d8781c052664feff263eb43c3c57eea128bd450faebb7edf617a6f97d7e5a68dabf84fc6fa701ea99cdd49ea2ad4abb487eecb35fdda1286d56a968868c7965b335605d09812ba5a317ca8e2fabed96e8c6b4a882be71d25dbbed1df82a73c78545d9de835d7a3d3b5251c055c8acda3adc6f3efe7950faa4f2ea219020800a94d1ecdd586e2b682ba9e09825310861e3c06bf175254b19890d27c2555dd81d7fde822814e4790a3f5a722953780dcea3502c6eac06eaf5fb8addc0ad2a64eded61d4f2b05980aca69bc3f6bff5eacb905f901d176427684cd232baab70516b81ffdc6155663b4a9eb4c1f884f399f7dd922c1cce7ed1ba21ddfe7f1da7aceb355927119b6a9dc2d61c0d21b7a604f2174886c2b1c5cd61957973dac48ea2807aebb174b7d49b0b60fc7d746cd35017b15a6ae8aa10d3478cd70f773844a4981e31c1ea58e67c99e586e6c3be8b3607b6c45a01e1b1549800b540fba93dbaffacc1f39bca24f595485290d52a0bc43c9754d4a8aa63b4fd6080579a98ae88c28a4d944f232a09de99615c0490b4907819435201163677cf5a74d4b172763de13f1d0045c549fc61f64dfe4090dbcbcb31d21d0d066f5b9fcd384574a53d1a51cee8e2cd66577d1d5efa88e7069ecc326c85af4a947f6190244c98ef483372dc4cdc803ac0cb7c2ab23f090053f11a53f8b1b3fac30aeb8431c0a17a5c04e21d87c4418afeecd664c8d60ddd163e4208b3aeed95ec6023ece88ddf504c6212c3cfec150997391b4be9eb03542b5e686388b984718188d8e439187f9b9a38ad7ab114b5cff7b5c8ae0d07732b71c5fa594c24d7e08a2509633793a1955851c9a1397c180291820055333bd9646da54ce7bbbe48427437f2f8ce968f1a5406a57f5811af8e0413a1c518cef6ff0a1213ddc8acce44f75f122b36dbd5a678e6c9f8a0f1eb52d1666a09d9e3c1bff2de495d2a64a6e9d331e381ab24f31429222344ec81cb97ba768432e106eddd410ae6b0b9317b7188865e5808fb3cd969d401f3435630b425366de0f6a17f431515157b5c34ceccb5abcd8dd0746c27c4a5f12a85d26c8d1a8ed4b8fab7261d80deeaf15cfb097e60e9d5332bce1e222c4bb60f19c1a8ee9870dc1c9a843836d823b65df150d00499f4ee671dd467c8405e71ee061693540ff96f130835addc2256d751c9ffd8680e236fa71795e63bab24eed59c8ab313cdd844c6fef0624c549c453f646eff5ad3f9d5841b2055745a789e8214fac807ee07a032caf87ead0c5b356496f437d32f03058790e9e759cf570bd8e7fd84ba9442421911228c75de983b0b5d3229f6ee693d7a5b39a6d93d5b02dedd5a20d9f287fdb9103c9bc7727a322ee5b4ee07b85c08ea5bede07609766d636dfb64377dd6d61f3ca68923a2934236c758de8a32dcf7aa3a9db8a6b76b8f57a68368a64d97df28477bbdce831c15f6404d096a4dbf710ef8737b8741a5e7576973325a6b40e673cff2c352984223e4fbb5f630c4095a772a65538a031c618b4bab828d187ef8913ad7dad9d86aa1a7694445334d8d0e9695480bd880ac32596fcfa139d8e5b24c304f6e5c9a7963d7f72fb05d3caa13d71b4af13d0a6b54ca80bb106c146b0a4042537bd7e9d02a83a93bd85e66e0ec916e8563e7dcd65078248c871932900ed07ecfdebbb2faf7e9d2529e13d123c1f2ea781e328e96e05b416aebb80c0e9fd8fa160eaf41e118e047d015b24bd7a48698de2f2b2f1d6f08c3b34bed6ef2f728532489157121b534de90d72eacb2520f4cb6bf9827ff3f321cb358fbd9220893679e1b33871527f210909834e9faf5b7a2ad598dc49765a759d930307791be32182a1c09b905c49a3a9906cfbb55ac6d17af07b04ea32e557b613081e9d0a9750286c9ea2153c3f573ca7f90fcf3c2a3ca12899509cf4a9c8bd7f6d383184e4f18a90d98f359869e7fc206a6dcc01c47d5a76374e68afe0740b4a0fb23906dfbf4f2c68f40f813061ae6f80ea09b66b0abe2bf0002a7f895b1d43c77dbacf77922445e3677d200fe01f561b9a6d657ba0989d33348cabcf19bcacb8763d058bda5ad8bbe4570b78827780c830d8f9b254be602115009c372d8abe37531de0fe63e3e98a77834062166437d79279727678b0a06708715d24a15c60d7269b5e71aebe097d3bd373ab5f1bb0d3f5fca093ebcdb90ddbb3f4e51135afc124f6b157b10575fe7206e0b8d26448697ae1f63a13f060b0237924defc7000dbcd8ee05c994c53851f4acde024c46dfe713aa418e8ab8fb9dc09ea71f7fad8196d19e7e159d0c3a0014f6f19a9950baf3a45bec9c5eeeafbf35db11f82101da294f7d82a48c14834d77d2c9d9e32f67ffe8f290d48156d1d62daba90f6aa249908abfb1c251b73d060241d1dce8215ad2c0ff3394195ef741ce07653ff5815f66d204079b8bd8a4220d3fbe3fb600aeda973a0f27418102c3b980f5e05943624063b407d546cde3c09b171e9c88cb078ce6bdc6c769cfb2773c99d6a76fadd89e648cb1f316d99e3e5fe49a248eeaeef9eff86693bb0dfbde9f0e43ea576e6d49800213df8ae2b296520e280702efc0d96190a2b83971f3dd6615aaab20f7fdac75e934d9082720b9771c47266b3c7eec10c60c092ea0a9723a92eee7b6a9d5eac74560c8ae71115a6c0c2eede8a631419a75be1bc4dc1c30383234a51e5e9a8735c59ef10a21bb76d5f1189ec8aca3b883b85ab80aae6c52e0e059a540305c06b6bc7bd26cc03f831602ed8c93657e746854fd0fdcfccb66ff202dce88f8e8b3bad0014f9df464fa9a05dc34f58eb0f225463c3482864d4b9e3fa527d8815fb2c67f447e71f1015a14298ad13426527e1b8545a64a83d2a07c43f7ac919f2c3314a691160c2784a914a8c6f9376aa34c6ee37707b221982486711de0507a9e952f71c7b2eafdc9ef0efc2c44e2acbc82a09a7a41d7c9ddd70186bb901f34a4328d61e5f1eb680e9d643bf9ca9f0cb256a1e54501a9e35fabde50dcd32ebe6c0c1af0f000a320f470b1ea067deaa2ef5c7236de211f3d73a0b4cd1dd64cb38bdb1709fc947cd6f3b6665dd14a6e63c82e6371a1412c371bda58310b79528bb5040501d4af9a9c5fe738750aa76e3456ba77427ae453ca543e5b819caccec0d6a5cd8b74e34ff2474a5866af511feb1574cb87c83862691d1f5038df47ab07d35011654be33372f99fe5024da64e554c0c21a71236112b2d8cbefd2874644087468a1acde57d40886307a8bf516c9ce6b0a6db9898fcc97bfe89aac7b4b42504d7b4409d36a4499c68246dfe018a6ec9bcc73fcc33a1ffcdcc45338cf11b66bf9b186ec35f6ddc0440317ebdcd3bc6304a61fa522480fe54db451d3750267f226df4c8c0e8750446eea71fd5975d19df63ea03458bdd44dd6cdf7ab2ba03894a9f6aec60c237953dccc0278b495421b48ddf0283a53d5d4eb55e8730abfd03498404f1b54482f5fa92aeb0ab8804f460454c6a86e6527a8f31d0498f7819aa634934a7a511177cde916a0d274c0e1069ba20d983b6260350797492067717c670be1157bc7d14fe8ea22cacced948a05576e857b472ab6734403fefc4634aeb3a3d794e18f3ee7fe538bba3e366cfbcece11d18c2a24ab48b7b3533fef421a1e94738b3caae52b8f68663c194d66eefe9566a7959fef16f07c7083400c1b3c1757b8d59270d58c44c4654741bb338e35330d61650a61c3ad20ed55c4e6c12aba603756a15ea535f95abf0fa061aa26ba33725477671d2b18e484a9226ecaa4030dae58f1c870d169b117f5cab7d82a7603a59f2cf23f1a80115c611c3f6ab43b0a1abc5c12b90eccc7fd5b080216c91f6c0c2cd999ac230eab3b4e4a2d6e8c9fb99a61208ce9cec4d1e4cb53ec8568a43d629e63f46a5fd730b4c5e32aba379bc51264dafaa70e2a64642b5c984c2babb2dbc06c33ffe06d32f3b2d81e9b9bc18713956f88fe8c7d35245969fafe8b2f08c165a0509319c5e1457872c86ce3405dc3f42bcd1765a85fdf5271ba8aa5444a05fb47508e3358dfa490bc7cd2e74b39e2481ebe9a4201f094775a680cee7e9f4aef24c9e09857778502c95bea97e5d68604715e20d67fe02f4fac538b3bb71e9489fc1da2a11cb0bb118f24ea7fecb79a7fd747cb4ffec8f5f79b5c9af7391cbd90658ff4634ffc5b407e778093005905aa1acefd0026c0ce673e45f159fed5e3b9d966f6ba5b98cc40c3c9aab836bd5cc57a74b5326b923721a4ac51488712e245c116d2ed611988f95e8881fd4d955eb076b210b3d7c2089b1730cb99b717c80980a6be0ef5a11625a2954ed745c056069db18d708bb1c2ac41946619ba213a373b98200fe49bc2853c5ff8012151e858f0aa2fef76540fc359a951923a06bad54a4f2d2372983df84a438ed439c75672a67f06a969f2345567275f9e171c590ae1e6c1b17a8e39f697a5ea0e5772587a8a722b4c4866f696ce2d232c7348a8723c3fd89a0f783d1d0c712375c5851526811a2767d0306adc09ac9a6b88bbdfb1eeb2623f4c90422747099ab8a342dd6a9ca3e844ab7a0b880f17ed1938aeda983a5abab350e6aab518ef63a61b6817646e74ce29f81888b12878cc0a1445ea370942dedd09524275339408f6cec692ad25b4feb4b1bcb65f7755280025ee402d3c854e6d5d5de15a5624b7af278746db5297ac860e4a2a820f94cb17cee52cd88c4c141b7ddb3487e98250960a5df4e5ada9bcc84a91c0fe486466a9f7543b14f1441684ef57dad1a30ce1e092df0cca982122e185c72373e3b2035909b50c324c866cbe0c8549c7b7dfe7481521b4c520160c03e6608de14b0787627ebf8610433e21cb8eddc2f5069ec77b03d5745ad1e47445dc11f3ce7ada25c02f3e40f2a2dedda5db5c06eee69276f3234552b4b0b0de37d494923209637a558dabe2e9d2b372eaf15eba5814e234c2af6924c665c336408174ae29c6f2c5524b61380ebfcccdd2cbe73d1d53ee6b5957304a1ffe3258bf13eaffaa3b8c60d821a311fb9926471e8aa3b79d8adebf9d3d52af31a4c5a8225dd5058084649970a05d42527b6c539bae771cfbeab69a94907d050bdd0f626000906a64b29db24175052123b2607c8ae3fb211e1becd16ba47dba09566da80738ac787086e2b130b87aef77de3b66c5fce3350db5ed1da7f2a5b85994fd8114583c84bc03d71157ffabbb0eec4e29abbaa49950ca557d9da32660c1cee6d83dcf58a4ec539468b186ff5177d08c2fc2af59227d59d37a570cc4bbfc9e86206fcff8bed7371195ee13292d47be613f2262fd05cf6c22a8c2a7250000613bf96e392a4655c5ea8d39ea19ff90df9ca2b780142e22e4fca506e5ed8d59ec77ed4ffa01cedac226e0b9db9a06c9a50bd12b4aebca6550c57e8517f770b1459a22d312a56cc45ba70f676734a4aaa719db1284f7cb58f26370979ff6b7215c9415766509faf1021a78092adf1aa6a6518b4f443a62283602592d953520cb6c978e14f6d69be561e1ae9d0f854a53990005b8c251cb4050f76a1644b849d19d9daa1c859bcfa8bbbfb30aa7b9f5acb9ddc04ab2f747f097e8f27efed1d04a97554f2b0a0fb08a8328dfe0f718a346dd68d4684fcfd4689525a2144dc3455c74c8ec26f0f2a67c8ef478aecf1b0ffa1eef53ea91dc5dfefc96fa09f6aa1de985a24a292f80d1ed4b29eac3205bd468549a44a9304097a787b140c41a42c9cba8ef74304387c9dc863bc72774cf6355db1834ac2b7579cbcbe761cf0bc653b5bdc7a7d338e45a538d09f129688b7768b8a6ea1a69118a1e721f50a0fe0977e1ebb180a3f1f6495313ecf3506d9e7ce9b44c0e9856d661cb5182e2019a41194868f1d5bbef4dc1a2f30810dadabc92fa6afeb9b6daea4c40b0864e78e1857bb89cf034413c18d17ffddbd52ea84d8978c38ad36fd01edf27526151aba4cabb348ec45e23af58cb98c5fc6705cdd206c76d6d903594b01949bee68dccca18e4c620dbf2c13283e470de00876b68099c5ea092153b415d5dcdb7406484b0708f74c8fd140713c42997d0ac746d7ddc72c949c7e5fc1300617d244b6a241efe61d057070430896d9aa1b44083f7d1c501ac7ca2592a5b53219b9e215319431c4fc8a3d346a3f2ee99d31407a49f18080b59c4bd5ad9193204a58e8fca04e40e42f0389f52b973233571c52597237beac20b7a7136a13873e6778eccf2184d72eae7e8e3e2d8f7fe8801a9af41b45856a78b43a1f50d3f285c16a7b6fbfaf73b185b7099dca57a7813055856a523e578a74021e31446f96594be814abc03b1c23e79f14b9e9f5887c9d7be7bbe7f63d45ce144760de0b71cab4977c13f7d4cb346f7b6d229a0dc2e1e9e783818f81c4a2e8a0254deff7a1869739fd19074d2efe14f01d1b68d14b5e5bd6f99a55f0a3931ba46ca89ca4c78a6cb5745d8160f830ad8d5bc4630d8039d0897c0c0356cf1b92358ba9537ef6d8f77419774465e88ea679d363f8e2fcf0d931f7bbc82c3b3d6b390a807abc2d2666d06dd203b029ccdb5c63e55ed1a5136eb3ad590ec45ff5e6230285785e2aa6ee28f701279eebc2bb1292a364f581470de5e7fd4d82dbd0c1c33e0f31528b78c74165e6e7fba805029acbc97406f1f27853f63bea8cf6f4192bbb572cb966cd48272c4564f98e543aca6a846c4355202c72391b4f8ded506e267084aab3e851ecda9f475b1010538f95fcc7055dc5412a2daa4b13f128e60925ff36fbb297573f4ea8361f39930f9378f93e3881559b72efeb094d35481ab472c0b04db435e2c822b75e0251c48559dae5cb849a069d0e749553518f74664db9385abe18a78950ba2c2f2fea013017b6f4101f2ebf20d94573d1a811322e4addcc6923c519ba06cb39e92d1551a46b3460bc5e60bf833ca76718ce6e6ff563f3550f4d7455547e7ef4adf664b2a93b1aef37dd729359a66a1107ac3cdd19eca4049d3f95218407d3388f468836151c8740ac2d1a99640ecb638bf258d38b1f8cadc42da22088174ba59a753a49b204ddbb07a4372ca7dc80e4f1aa2995a5f7153d1ad2f4e5db6efcaa1de78714e54757744658725acf6afb930747c9152224129c37f84e6af81e1465bde73aea487882438ffb77308e260eafd868706c0c7f63544b413c0948c44869e1c67291199f55e3a4d10aee18d6d13dbc3ec25b729a706a7d8882c6b5f8bb6b1071f918521eed637490c7a48c4f114f184c4ce82890e2fcababf9af643d9074c5ac23ddda9eb119e0956d5035d1aed02fe0b1cf4a93113d5117585817d76bf980a53e3bf6dc9132defa968b48c59673afb9ef9705c6a44933b180f32c018457ffb3a4a4172416f17a4bbee053ed6e39716f46abcf6dc14d58d11e030aeef041b7cb83337396cb119a84c3ee084e56e5bccb138d96e8f6a6f28b9f25ce1eca0571ffbf35e50d6756275ffed8799059c4190f90a185c0430eeb54ea35909e28de9a324d1f01cc49156c5b00b600f6752cab3b137fd8c2cec30a61f009d3832f0392c62a52059eb1e3763f3a881a22cffba1af9652c29d1dd6f610b7b1a53f2eaa354777d9fd14cd225a3dceb8c8e28aaa0abcbcb36ad912ec9b215429cf9874c76e762920431a9e69bce3a74bd5a7cd0b8f95fa45321124ee5f576e1187443cc6b8028a51063f3916b8d6b7d8484cc6ca96b2033053eec64d325d3a076b570315b1f863c40464009d380d93f0618276898a222bf5de1692588d004a46dbff4f498a631fa9da0a004e99b89a79aa4c06a5ef7a537aad7458901adc7da914cf2889e22a16b0cca326aa659a7f1716ae6d2cdf2f39e3127c4c5cb8f27dd4978de39a8f7d623e00630ec8a82d5dc9dad46589765a142995e30fc0d8129b1e965684537915bfa622bc1ed9a7c668b7aa1d05f04fc98f998e7a1d3b39b41350374135cc0d32f50ae9c5d42f9e1549ee3d600847182f18f7243c1bbb7ff121d9df1f2c00ebcc22d97af518984eba3fe20069c3748823d04a9d6a1850615033057de3ad1335beb8f4f1bffb521d63e103f19229cb5c523cc28a79ff1bf16fe6db50d4707870184c015536e8dfd3b9864e83acabb552ef7f6214a2438bd8c9ff5b8527ac66a61a6a403e652f8b526c956a76997c7d8e3bb418d1fdd0b68fba618529fe6f07eb83e70464858c371e393270af0eeb0eb51efeb3460db43057f6e8d15a69a895e7d037f8ce8dcf07ef29b67f2740eeea80a28138310daa4cfc8d5ced918ea4c18b287587f32564af6eeb651d5e97a86e462a9a8bd32461cb5bda095aeae3559a471c3e035de15574cd1d969b577e7bc7fb1c43d9fac5a9c1696c3080b21b008d40866d96857f6742a358585eb87a5b1486d911f24a828c0c8078444dda7828feecdc1cbcae058419cfd8dd7405cdaf69b89b8b0b146818afb06eb60e999994959f39206473898a0d593d54b1158a73edcedeefd8a144b5eff4f41c85d8982427ff8371880b2a33e2b2d362c2d6d3b00431891c932405f6a65b48db9a862dc59fb13fe6ef78dbcf0043cc574a40a2a64e16c880ef4f5c024022041c47d5fed8e42c4fae89ceb8d4d618fe2d510f5ef123aad22af21bfcf301aeddccc6ccbea684e3407c190a1b5addca76c3d649ace88629ac7109e5c9dd2362f9b5caa6bb174d8a34dac75f53d478f69c702016f9984432cab722bcf71c0bcbdd8b807ff564c343f85723770b0a1333d0962854eee1e1d171713299297ed0d3c521c1f21afbf6e0a5087d3290027e7039dc44c52d33676eff21fab31e42841f703e8a00716efce8ab2a39cae16d16f11957ae9ac5aa9bcb34de10e64d61f9bb83e3120a4eadedf192ef7b353595593efb4ae2d1061ff37a722ccd9021a5a8bbe77b5902e214f0c52a369e93b0245f7cc9f31ffd402c5cd5a7a62a304087a1de257c932a551fc510f040c1fa2c6c919b241963b73f5e0a06fe41c4ad2ed73ac3121fdff244434f4171398a5e6131c507084f36830c664a246164a251ca668b7f52ac035545acef621d03501fd0e43ad3d84cd3814cdefb1c58064af89fd99e6e7990fdb550b844f2f97ce2b3860994b6b00d96c558fa12b8681083a3e4395cc625164394a8e0f552b58e280f33c9f977ec8023887ef365d7bdcb931df22a920e77c89abe2a5eede6ea95344120656edc31132d3f12518d7bac68f6bbcec76d05276b83a149b7bcdfebfbd688bbc49795d1adf8c7cf7f0c9e8360dd60a89f5b246f12ca7fb15f0f00b6130e44ca9ed31a1a35aa19b541e1f866727967425312a6142e3b214d9ed202222bd0b290aa9d096b5eece08e5abe5d84c27a2d9f0ec6b858f75f1cd0388515a89373bb0f2e5f93d127fffb940987976325b04f5ce2d21ff26e73be5aaf95a4ee5627c5ef58ae019bcc0a468507f8f1c643aad002bba739b185ca8410faeb7a74616de69a0232a91606a703cac5557f45f9b2c4720781937dbbf067782fc93adf69d7475379e8636c1a81084c115fe103b9b538c1bf4834bc974d65ceaacf60e1e46b855c59bc3d8c1ff4d063f6c35c41dc95a9b7acbd194565c55bff036a7c43c7777cfaf218ae0b501c7c12302ce667c63b0d64f55b4ef2a5d42b87d340dfd9780c748563c65bd0634eb9aa4cc95f5b24f9f09e963dd71592c887e91f05712ddd5472b2a199538dc3bad49aaf0e42d186038e5fd35c1aba2affd403b611428010f92fecc1c359e2af1fb9805f8613193df44703da3b8bb8af9c49cc8da2b39e99d1d865a616160bc8e3355b4aca148a5dfc3f51be81cc6e34acb192e10a0cc36e2b87eb79224595c446f107949775923ddf20a23f5ba4ace8d3d4642f167322a0b4aa27777616866e5a9cdb1590032eb53128bffce4745565008a9547a2d2d2ba69b4323d0511fd347e92fedd81ff5f9ab1ca883ef1b200a19bb644a326ae80f51f3d7ee1e13542ce3aa2f567c25ae9f2528f74fb0fae71f4d3d231aa8c7062d2261f25524f05823c04548953a361712fd4e309c50f253a1b4785b27823bfa7cbbe66d7028533584b41adaafcb5ad35868bdf4510439cf9875d30d1125108e5e7b74aa6b981e1bf9a4cc5bbc9ac0752f9071e7c95986ae8b35bd6dc56c817f5695effa98c00e8a2464696abd025268d777ddc09e09bc6d964c3dbc911dc17a348654a7996310e96742ddd36209387f1a69c370edf06fd2bcfc148bb14bb3fe016e471a99dc55f9b0f300d0025c6fca2c97542ecce159e0de23637780a05e1617efb2d482f3276ca5bc0cb8e1aa55da522c9f58b6dc782359c7a65e99df8522fd267d7b51061e823d9bc48d9543e8601ab2e99cc8dc6795ce4e5e7b0e349ed27055d12fa0931e6df2c99b728b78b2fb7f87d0fab43a5176dcbcba59cea0056bee5a80d726bde53fe6f1774d614a7729929124dbda34eaf32100cf54a40b62693cf059bee8a4e9c85a246aa8e4d41f5122dd6a7e65ba211decb7237cdfcacf26831087e5dd2f1f8ca291bed910c53155848f78047d90f3702ca3b1fbc7468d3d8b205627a6f827b050998a08e24e38bd7441c4bd2dd69a9b38fa71490a0c79e428ae1e455ef3b2b4aeef19bdc909e5623b038086ea43dffcb4fe10ec2b9525a1a72ae5ef9226de8bf9b2ba183c0cb350b5bdec5af1cd9e6eeb191fbfd791943ea33606631cb4e5a4b5f0524a630bd52acd32c65291b20649d77f3bbcc4c3c13404263f6f31b753aea0beec2b5efd51b4bde0ea5266f476473d870519347dc7902a9c06d03f3b47d1f0e2b8046b74affb83b6811f365eac1bf1f11df75f1c2264ec9d34bbd35c6cd395dc4e2e1d0d89bf76f6d8c51b908256cdb5ed13c8ec6ba6aecfe89866c5c56281b0a91f8d8c3de70e9bf3f65779ba757b0902a3fe84ee9f04ae54ec18056e5ca01219ac96c3185689fdd0f4d445d1b8db6d710a78510fefceaab689bde563d8163ef7cf00e3e0a91087338e3e828b07a99f6f5e26b0cb5dc31fab437120a270d372faed6f5ffe4a709c222716bf5a17a9c9f6270e8f53dab182df558d9b03ec763b66ca271ff21fe556b4091184eeaedd99f4507ab07ccce881ad74470fe4c08844800d9d971bb9b243258ab0b6d8e9064ca3717fe28c6ece05e8f608136688e5e6bf47574f1fc51a01e9729d014d6a406105fb2c5526ea82e7da8d1fcd416dc3730e9c6fdcf894fc50b3c004da491c288edc39eaf5ab4a1611a121f94e4712aefebfb7b60a789411014fb3b0e01eca02221c1e9de6d6adc4c43be5a4fb9d81953bd0e299187fa6270efb30bbce73cbd01c0f37327539e094753e2c17376b9739cbf54b801595458f7b3da42e1d4b485e0c075e83eec424b369735d5075ab9d515bb5a6450de88b3bd28a5e95c24910d65ee67c8222660b683a1966e9da2eb8b7a9d38f84182397f51f2f4cc589826ebdebb0d9775e521b185dcf5fdea1e5a979d7b10099cbcc7ec7a722daabe0a166d0f63ffb3fd1a7b61e34639d22159a81bb8428aeec6c7c89e19b067f36413f929a460994d67f0a84869f76b4a7456e1a56a9e62f4057c6681f59242f6418b61660a2a4eb1f89fed6a271d5129205bac3a84ba972e13d522b362662a800ef73bd949afb3d6cb7851d971cda94a1fd32bcf70115b3d19c8b9e330779d7176057d3676b1efd5b4def12dd40f821f382bbbae121bc0df2ff7ef67d4f4a26cf927d31f088c53ff50809561319e10db7f59b9001dc0ea71976e84176fcd4f0dd237ae3247eecd3f18bf4012703eb6f9ee1b37f880941f9d2670121a83208e18b212b2d8f8fdcda5d14f04b6af242f36b2ecd47ed51181bf99965ddfbb645eda0ebc6497dc7585a97e4c31010d24dd6a7943344cb69e329bcc31313d2d3de6532f9eccd4a2f37b902c25ea8b96635379794c3007fca758867bf99707d34701c4aa291dd8a2b10b72aca935a30fafee559dfb0d6555a0c5c89be01fd963bf4caa80f2513a8325498141f309952ba3baece58686b6aa183e299541d758574dbfc1a3b64d190be8581ea9e74126be166a5a83e4d723004a20c70e75b8ed922922a2db0f389bb933d38d36209933e7601a3db6ec68ebec8ccff5b349c0cc977ee624bb5a44a5071c33f4e393d6eedde8e09ce737d4db3a8301f271932d919680b4312b0b30ab6bb630eb0bdf42a9d5ecce7195322c9de120cf727ee6299d9ac722200bd3199edcb6916147e0ae3ec369fcffedd2e8c78271ffd1c793892c3abb4890fd04218be00a6dedeed24aab9ccbd5af11015b0cb37f0e312e82607d0df132d4ceaf4776925cc9ae1193dfb690b797730ce22f5f4897ba9af8eb79c1c5ad032fc3b6990d258c0af625aa421abc099e5c1600a8e7e518107c4af9dc6e38793e623a5d03f5d39ac504368ef6c97e0aa41e3f8db1bd9c04db677d54bc2b690f0376a11d626ffeeb4fbd79c3cbc32cc13ce7607b67a1f79b7a36f80bcf0e29826e2deb2246f876970302fc6e21d1c55ffc4b52dbb645ed5754f0d27f0b12fb40f321121bc8ac243f3e1b2e58e7219e35bc85e22e7cc711f8cc9d59ca4a37c13e1c2d65230a1c8c4eb87ce6cc8a414377605bee918f6032a58b0acb69e4a745ba54a12f469355d6b67d4503d0e1efd0ed7ee1be2fbcb6959dc3884530fff2b6fd487793a16c011bcafc68119da02b96707ed8dbf8b36d0ee53cc94f2e2345bca332d29c47bfa4fa6e1d3bf97ad5f38328d599bd37d7c0b79a2cac99f9b820ded88a5afc0cbd97c35667509a23cef3bc855438ace7dab580f5f3730c264b10cc9c4d89397f8a9e68534fd03152be3458beaab1779a8bd3e927c18cb0610d00032fd42a54e6bf242cd77df4de87b534cf13af0a534d40e13280ad672299ce7bc8514b9c4383de7185efe4d04b3489a709dc791a419f008a1ea63d4356a691882ad793543ecb276f9345ff71acb58d7fcbe46daf1434ee71aea347dd45487ef9763e90cd94ef21c980794350e7bdd5a5cfeccb871c032427d4bbabba22ddd344211c89d700691ee5b8e8393d07a1ce86764cb37a68b171ab8ed826e2c8583a6c1ffe03a42751c8f0040379e66e550a0ed585b078fd19ac9abe04c8455cfc2d691be4f7c194f1f5c45d877e2403c52dcae14fc9de20297566045e4ebf45ad472572242a9b684624bf21c950dd4545b08d2c55d87b1d7672fd52fdea56b64b3496c5ff67be801b9c7e57d1c9da41f5a26b5a3b89959e68c17dd6cb852bcd3617fb1b58be6ddcf958cff23a8badf928d90282664c2588e4b1d5bb748d413f4fbfd4da035695cd920e14ae3fd06bcc8b0e0bf77130f8ca678fa12ff1265704ce099747cd26bd9a36e5163d24a6f5cd53cc307d98b0ed53e2f3877434ac0756fa3873ba83a8de1c82bca5ff542bc9607dd8206daae4fea62335f33fbed7014a74a40de152e76066689cba58155a9b39967d62ad2edbfc7b90899d74a9341e108caea63fdef36227b3fb9ec4e03a10618dfad3bae9f270ff93b02fda66f2ac6aab7a550fb605bce2e62464032ed16b931ced701bf799a066b5831dfaa83274589621a351dfc389d9b1283eafcc6a784461cc889db3516b55d6fb31688f4b92b594c686666cd294527168b5b1a49265073ff980924185bc7261a8089a87203098d99349c7c2693d4d300af8eabde6c09028b9f43a3f09036acd0dbeace1afc6d370c225f2c2a5fd6ce848b78203e5623058e78ac54bfd3c4a83451152a3630c5663f5aa408aab935d700ab85ef7d81744fe103b16ceb598d37813473d02014fcf6b21cf97392fadb94fa07302322371c8eee32c883fbed0b29e86424d2050c3e417b0d5f0bd319faf48755ebd957d029b07118e41d6c5e5a925322ed48ea41f0baa0b663f3c7214906ae25f177c14fc7d72111682db8b1fa6918a11dc792d7e9fbc33febb76f7b40bce6204d6c83724bcff2053845d92fa2da1ffeabeebde2f90b944c3f158f9272a691c78a325063051ea913e0417a47646216f00bae022e05193f5466e0ab52fe9ade2a58970ce7629ebda16090fc0f60c4195c9ad3b281690a97537d3ccdaa8fe49732b5acc8bb86fd28ed9b908a6fa7d46f0ddc571305a337b4dbf2c47d1072fe5be7cf897c673209bec6eab2c184a5a1cdead3e5014afe68a0e527e776a40863dd8d2b42982d8144d071453873dfb385ffab2a8426c1c513d21f99e567a09664a4abf6a59a3f629d77efe3d11e09185768bb5bd10df8264d5fea8771055a5db41fe7136f7457ee69b0b6fbc590953fa29a8b4ce56c7a6f2178233cfe787b3e35f23441bfdfb9e9a8fdc92c9509d67428af799ba9f566f4636c16e8ba5e3381acdf4125f3e6e695a26f30b700af282a9aa7453dc7295208474af02d5daee7b6c1043a1c949b16d202695dff00595bcbb7b943c3763d363e2cbedc1c0edbe3a1819a279b85e8ea6026bfa1658a1bdf9f9b98c05fc5698ba4b220dc243888e754603053c2d5323a4ab371796277b240e78d843c12ea82c6fcb68ca6014344147a8f8cfd757729ca8fcc4333e3d6911d9e48a83506367eac901510fe00cb6cfe49e1b4eb2a936d902d9669743f8d7c252c48688689edae0d8077225b73eaa00f44fb45f7f2c93db286832fa1bc4857b04479f6956965338ccef917e31e075c32e50b4a431e40d8400c3ad529ec6046ca8fd0750db3f7a75ab8723391588e45989c6e7b37b29e68774f6563e110f85d814fb2e98c8a2df2183c65993fb5c02ff84326259ff393a628a15b77441bf783cb17e3e68222f3bbfc941dc33da94c56acb7c40dff0db11ccce4c91f6516e627c96e61952d82bb3320e15c4f3894ed233f425da76eff59479f8dcd4b1ea279644251979701ecbf9bc2b0e24a0da267c79f2fe0b2fe0aa97915c622e7cb956b3f371ab0739307dd2d8922c1133670b827af6ef18126e39cfbb162d155fa3453ba2f3e29081e158b734bc0146da27399aa1412e68cd8cc82c30677e7d40c6e4952e2f3993dd1cb1eef035d6314db147e3734d08c76f05f689d7eff273e087d3d725ea7c4201b9c6d28e0ee375de44813dce1f5669ec6a243c617210c30c9ec54c3e85f2c2c87caaf04541a68582947a8f271c838bafae1a4cb0564760c10463fb951f927b42bf92a4e8a286236ca5711f8ca64684d3a423aaf9e8914bc25eaff4753f681164bd139821b04d654870d0a29b9eaa5d43a0ccad9f11cf3626536b41fcb064a28dcfc542539e776dd1695bd2a612aea7d812c6d3927eea13935f509f88aa2c418cdd26ef4ce6dfd547cf35b77568dab72b814e73c6dfc6e6661c71e33a4f1a98fe8dc552794f5321a89d7b282d86956d42ecb30eef4aed288d3ea9b4a8f0c9afeb0bc749e959d83fb904e1c78ed41d36ecec021f66c64c83b82794c7afda8491714e29ba38bda36f1252ca153c9416d8d2778fa44466d6a17f36a8ecea3ca8541a9ed20d77ce5e5e7adef23fa3d3d8152cbbf5c249cf16ce1c2def52e09d1042de036c67a24eb10e07a1cc6878b3643657908c4bb6bba3bf978d315fe127c9d9ffc9a82a39fbb25892f3e96837390962afb8e43a14c80145cb0d9fa0c7d8b106a461a7b33caef531929e3ee1f43e719c7564d7006ade28310e51c43abb1b154d1862a7631b3ecb96283d447e96a90a4159886649ab0e7570166e67b59843064cbeb327a908088850f08af5469bef857cdccc8cd1befcc84064ab77527731852665265431a6a2aa3b1e4cf27f24253be599fab8a3ac15a36a49a1d50d56afc170de245c8231201b86af1a3df321f1f6ba76ac2bd7e610fba7bb4e32f16acadc9d34ac0ef481858d9dbb440be8dd16596bc0ccf7212891ecd4db3085189c74f3eaebbf3029d3513c25f6fc73a214289c93583ba1b7cc872b5babbcbbeb3088b4eec8038fd355f3dc68027c2992a14cd8473a243d0fb22727b344aac6d52bd2e830671e4b7e8655fa31277316e1b799df943209c847a57d4ec7da5393bd41b0d2957a250ddc43db306b3f0355cae2fc23e0c15b098d74ff797a195bc671a83267dd2d1de996a26c2256659b1f3acfe6152bba3179471036fcfe67783ac82c9e8e819a16392103b30070656b46901cb4b1881c885148aedd529c6455c51318e7d9ef745688fc16aab820c41923afbe8e6c082423a4f1c3345c65b8914bfaca991f05d3069fefb6d3bf4a2e35f282f7fa42f1594bac7d80d0c520a8b7636c5d0b0475be38bec56ce35fbe91abd638b2fcea1c0a724ea40afc5d4cb8ca83eec26eefc3c7ce183915a1b5d2fa062a0fe58319aa87b40817826232e03c520d5a32f398ecd0905025b4cab67d345036366be03aa3047ab4aba65fb3be552266060d15878f6f94952da2c859df333f4280358a054f922c4da4e3b16bf552708f9667c2146c20dc062794ce0890242c7e0fbe9f780b9646dd409b8c1a93b0176ebe6079a04393af924aeb5848ba24549ee4f7c3e8707750618b491a732f517df57047d14e8edd484064dd781b4e04f861ad224d482c3b7ec422d6e79015e0bd5ec106316764a9e00365b574e40f41fe7dfb4d2c1fc0273bcdd35a5ba87c8308012388f01241baa664b81d2f0139e638fce0bec52e1344859c67858311b7c150712edf9dcc687915136f855ed774461237ca78cae44ad05c919c2c55579e5ce8c1ea39e83df58fa503b4c9334791ce0d3ad2efdfba409132a03470494f4e9e8c87b9610ff790bccb3c39bc12ee518d4133821efc4fc4c15e2cd54d4ee9e9368be526ba845429483e08c84cfa93fc7dc2d24aaf3d105195148e0d8331cf7af8fad55e76e2a5fa6e1fc3fc0d125c04ab46bfd9ffe116e66f370e43dae90dbd8881e276f8b97c88e2cf0c341acd56680ba6a27e6063ebee8acf6ceeafb9b07e8923a48d535334edfc1e4c36ef7d305073af34f9ead4f7f2769a3a3ac5c75ad96ba0d74e425be024546e981d6c956247216bbb83286a8cc7ec2bd65e431983cf9c737b05a30c4eb28a3cd9c7d4b14ddb296262cc16d3970818999db34a0345d713fb8634e34d8a8cc5ed408757a875220059ccc7e5f88e5ac4119f3ca942291b1f3e324de29e74b893e9069f0f0e28e7f3e26c5dd19fd2dc8ed438bac1022b85d5dd55e50a921d4bbadedbe6581ac28e7899607f8de81b7941cb3abd616571099f29a2069a9ee6b74ee7ed6694a87859970c4e1150a61571c6355039bcab65ac086fd73881c05b2c12ca5b2f39d996526032e418772b081ee0d08d1e482e284dded1986f585b7e5d1138ac0db87b16c9e401e5f0ce7a26b314201a6be5cd592623ed82723a392abea2229635fd87cd1430fe94caf67b5d4a3da2f5c03bae1398133b38ab287e16067f430795e454eba58d79d3f68c85f2c36d39d25358ef0065c5642f1a4472ae97fcc1e8a507353d342532bb7e07bf10465d5afe62d5b074b27872fca89ef4b189da17091f80911f8b4fdff2bd8605515c282d53c23582c70b919cf47c464c857607fd1b7173c277af1af1439478624adf10fda910d43939a5a81c54c9861037e957d325d8c8534787f5c452416b2843521d95cbe71c230f16289174c432f661a6ef73e941011d17c9c7a51b71d27965e1459f05117e41f29069f33cae7ade56729a0d731fc95bc183a0e6e8890593e3732af61ff1682e445da5ceea69c3363f3e107d47a22d6c64f4b41a856f23aef4fb262e550683a2b3810468dca049072d9dc74818bbfcd27290e16318da207eb557badc874af221f8715878eb43f6a81a3167244654792419a227cc29727efc1d7229b0e42b1de40962ad263fc3061e000df673b4224563ea7e86f2e8494ba0086f0d31645deeaab9443d1d62813a5daac73fba864cbb0833b60e8f373a8fa7b8fe26c202168b1c91525cc03c71580bcec7f532760c3851bea7802f64fa7a150e3b6e8d3e2f909a05c289897acac925cd624974a149a0761094233223432df8c0402152d60425275b3eee45c6248c48cbf76f8c0f9aaa3ef84a9c9ecba6cc5613c699b1dcfa3649ee4ad3693bca7721cd80fd19a4b9526fe6a5747e584a6408cefa4e4693979ae87c5439f7b8960d839ee596fbd2949aeaa44824e77c085c98c0a8f5aca0563a561a34652d9024f2d48bcc155b82d714f6fa56ec98f051b8bf7079707b10e539ba4da43db40096aa435035e1596ea8f2ae1629613ff449d8a00cc682b48e28bec449914c6454a741924ed911c569bc9eee9b34ef751ecec1722d8178064a0073b464f55f31305f8ec0b8f4b1d26684df722384758e20a6d4a44e104dbb070d09e9d61b66a8c1d294a976498c41080aa32520c111f198d8e451b9047aa7121aaa9b71417aad672f8627ef724421448fc8dcf1f4975826f6f69b189f8a576a26592e29e26fa33f65f4b57c33648b21b4ca8eb80882aee376b75b62b80cb470bb513160f01537c3ef3ec27ee516b099b9bc588767d58e9c17eaa63ea04bd0b6b787bb9b40b932676d0e0e301a351350d26439667d8912c0c9a7d35a9722e1bb49ddf5bccc8d20561472cee569d116ca7e6f752e76e03f43f304b95113c4a9993d0719ccf126748da848439bc2ed4eaceb2e9adf69f4515b6bdf5f0181f7181207ec4d33170f0eda754f95d35aee1e8eb6111e9e37c743c53ccc8671fb47f4f1190f6b028ebba41794d82ee7837fcb235b5d94572bf3847b1dc37bbca716a55bc7af2c8b789b12a6066d2722c5acdd82f6749d4149113d7129061453f28a6ae6e539273cf62a9b0b97a38e1de198e15028156795a76a0647f9d31ddd5f9c6b2648e134ffe93eaad8375b622a3d91f8cdd80cb57a5326ae04030857ffdd4737b97d8875b63ab0b28c5497675fae6a9e26c0c9ec3a1a303968c261aeab4441f178aa5a301de158ce09484ede0917edc7f9a7bd0d72c674dd993dabeffdf1683b03af50a31288187b9ad5abf5306ad675178bd60564788d43ce11c3f5335f1f66b6529fdffab5bc99cf5bf3334b6bcc663a3f7eaf07ebde29d0be1b8aac794e2bedbe912789cb96b74fb7546e8d36cc341142b10d85e44f1a7b2e3653c9941aabb22efcd7d0f56aab7d1ca1278bbb6898cf597b033eb2932fe4b3ee338f26f797a6c028fbf5339bc906b1ef6298aaa205cf02a046e9def657c8caf93dfd3d7ebc1cfdfc60df9a201ab85f990931d01e5ac6fab5c79ef142c39260371e2dfc7f9a1a12b6cfb97fb7307bf728cb5ff8ffac295443478361eff918a8db34caffdae27fa14851fc77b80da942e46849d1b9dcd8cafeb3feb7b4bbd6e5ddbe881d0990c38d5f4bac405017ad91ee3133e320d436cb27589514af0cc71f6790a0188baca886cb3f00d1fb91613a3e82947e3bd5d5d05de2f450a6d42ad7dc7588ab34dc03fea17c84e5ad1788b5a80a0e5c2c8b5a95554c7862fc899a9732fac7a801b9bd7f146e3fe1dea6148ed95a136fe717c610b982a506b71dca43c0a3421319ede914e13edb483b53d08b151f368327a4240f3f4ee488a6b81595cf05574953430db447e25b7be30ffbb57eba85c447c81fa8e93d319c7599971d8eb531bf6102c91f6bc790e6fa6f26be6eb5ba320bb34081049737b91c3dd5d1e1fe1aad600ddb1bd9ee3e5b47efd2d9637ecbc4fef18ecbdba7ad8a616c0aaab5fa756425fe1e88c3a1702e1440b87f731df4cc87d4487fa53872078d21dd98a597a9dacf10572b74c2e7bd04505499561b914b13b05125d1983375c9e20cc53e53e0410dd1576f2d541e8e7459220875f229635f6bb2239cde0921ba982911f36c2f7050d6a99898b271248f48d4a9c68a097bc523a59b1e4c03d14bca79ccf845a3016a8100d52c587d6679b5abceeba64faa9b9a02f42378b758fd336327cae418b5cd4299dbb6b55a35821350a7e802b6bda60854563edaa3c18b4b5bc8acaacb589b31a04b15159ff935b07c37bc50a772c16a98aa5d31d6dce54caad5817ec9531380d9ee1dfa2ecaa1b4ef35f1ed021a9056a692ad5f13552201e8e89f00fa344a3bb8fac27e3be7ada566b307d5415a2b63a33145a19dcab7e553fc8023392b4b57b786439dea05b5f5268430c2a5429373f7be5411d4a7e02396d0575fbbf76f86b73342cf03ce2babcea71ad6bc72cf7b5c60f32cd875a7b992967dfa5abb5feb9e391252c88f3498651ae49a2caf62e85da840e5eefe7989c74d804f2dd67da5e60d302463e10ef8a2ed5f36e55dfd49fe9bb072250c75fd7ee1f67b2d614bedf6199ca7e9f6b01c05a36719ae55ab2eee44631a6988f94f815b752113d9b132e6fe772833008080226629ae1f110e1b7c3424de3471bbb6300861e4d3d9dea0497b3c694e237e6f13950f43e96914c2622c746104f94ef1a2126dc9555d88ed2499b2911150104433d509b7fe3fe94c5d580153d029872feebd572b4195e6cb3a5bb6a908583a5d6882ae96009162bfa560792c496c56527cff1c456f075643ba14de6b3b863bad8c6a1ccaf828a9a2526d4792969ba79c8aaad56934d5e879a272ddd96082f0a2196f039aba4f4c67933fbb397b317126132d5d3a85ec62c602f9a1861311ed054f4b4c16d8a5c1b19e9b5a2f526b38c1347b3c9759fc99e892e36f3a7d59aac543ff047e181fed8611f929bc591e79c263f3cdea939737a599a3fc72b07868767e5b1a2f22437596b598ca28b022d7ea69080c8e18ff559ccf3270fe4da0eeee4abcb3f06521671462efdc090b6b751061409b467a5c619b9b048ad00e25008de048c514461063e96a83e81d1d73fb01f7338c23384fcdbfd6f9ab47bf6e0e643f9abd06484ff39e7405521f7c8354ee31c0450a5d35284c3aa817290207c1c45c3f925aba99f40e93ca17f93d3b41441b9324a0fc82cb40944ed39cac6c704180fe4be2a8dbb06e707a73d0dd50f48a53272bdb1868b2b6695c9f36c99daeeef0e3f8d2e69b45fee40b33b2c7a6ca25304c4003e9d3c64b7731108a3867be9317dad3c531516fd9063c03f3ff99ed795b241d9b939a82289706de5bef0c897b4b0cf87760f82b628e5270bc3c1cf1122c364fee97b91ae01604ef5d10214f09ae962e52b7ccc348a69c57e8a3ed4a0dd18b3917d13b20715a6ce9736559b6dffe77fa9ce14bb648fb19576784fb6112f7569e2da1805400ce262fa6ebc7a6cacb805c5806821ba2f6712558016ae96224b3608d0e22bea344e4cccfc5e227a5eb5f9d93d29ebd66dcf176950ffbaf1686fc6245181060e82f30a13b1d6af54eab45cb94b4144eed319b12a6afa2f036fc66c2e641cd8997ae0b31173c0654929877563ca622acf5ccca2bd98d21690c79442873e98c4cec66adbd5ad290a5545625eaf4121b5c2de94487de8d4b66018b203cafc1d2976b73ced562d14b7922fb7a4ae56f11e56cbc764f1eb8bb7a16e750ef4362a52a3e07e65088f7c14d4f64f09fe915b2910bc5ec240aa608bc08f4026f0c8fbbcc92b306266e88abd54fc6c5e24dd2afd00f6766a0065f2dce9e40b87bf08103e4a4124fce895a0f2226376714e64d4d914220407baffef610d36644c16462be645b2158abe6186aedfb168528e22cabb05d7e13f35390975144be2f9effdee68bbca166879d59467774b2787ca0188ee8e99fd70817543667593d803507c39e49ab9da0c637c4206c7b3f00050cec783b264233526875ae2e99e46487c963c3b92758fdd0f56ebcb5a3e829ab8a272fe6c558cf063acaefddbe139cb00cb222d8fcb11ca12986e19ee7e0a6a2ec462ece6ff0bbc700ded549511922f6245c23aaa2581598cdb4c4e6b8e95cdaec0fda50a5ec00ed968757b80e5ff8a7c39b507633bfd01a547d7af478799e92fc854d408a80be635708fd3d39704c201b00876de250c64a3be74be55e5aa9b09b1647033395d4acfa8ff8ae89d2ccd77d749093a]]></content>
      <categories>
        <category>CG</category>
        <category>pipeline</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 贴图多重 resize 菜单选项]]></title>
    <url>%2Fposts%2F4d4b3024.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;之前写过一篇文章总结了 ToolMenuEntryScript 可以利用 is_visible 方法来控制 menu_entry 选项的显示 链接&emsp;&emsp;基于这个原理可以实现动态的右键的菜单选项。&emsp;&emsp;刚好遇到了个很适合使用这个方案的需求，给贴图加上多种不同 resize 的功能。 init_unreal json 解析菜单生成分析 &emsp;&emsp;之前我做了一个递归方案，只需要修改 json 配置就可以自动生成对应 unreal 菜单选项。 链接&emsp;&emsp;但是之前的方案并没有利用上 script_object 参数。&emsp;&emsp;于是我再 menu.json 的基础上加上一个 menu.py 脚本来存放自定义 ToolMenuEntryScript&emsp;&emsp;json 配置只要添加 类名 就会自动加载相应的 ToolMenuEntryScript 类&emsp;&emsp;通过这个方法就可以自定义可视化属性，来实现选项的动态可视化。 &emsp;&emsp;如上图所示的效果。&emsp;&emsp;之前没有在博客里面详细分析这个 json 是如何解析的，只是提供了 json 配置的文档链接&emsp;&emsp;下面来补充一下，json 配置遍历是如何通过递归的方式自动解析生成菜单的方式。 1234567891011121314PyToolkit│ PyToolkit.uplugin # 插件目录│ ...│└───Content │ └───Python │ │ init_unreal.py # 初始化脚本 │ │ ... │ └───_config │ menu.py # ToolMenuEntryScript 类配置 │ menu.json # 菜单配置 │ ... &emsp;&emsp;首先代码的目录结构如上图所示。&emsp;&emsp;init_unreal.py 只要在 PythonPath 路径下就会在启动引擎的时候自动加载 文档 &emsp;&emsp;相应的 PythonPath 路径有下面文档提到的路径。 &emsp;&emsp;在这些路径下添加 Python 包也就可以直接 unreal 里面 import 了&emsp;&emsp;因此我的 init_unreal.py 也是放在插件的 Content/Python 目录来加载。&emsp;&emsp;相应的 init_unreal.py 里面就可以读取 menu.json 的配置，实现引擎启动自动加载菜单。 &emsp;&emsp;首先要确保知道普通添加菜单的代码是怎么运作的，菜单有哪些选项可以配置的。 链接&emsp;&emsp;其实之前 PyToolkit 的文章也有比较早期的递归读取配置的代码，相对简单可以更好理解这次升级的地方 链接 &emsp;&emsp;完整版本的代码有点长，为了更好地讲清楚代码的运行过程，我将完整代码放到了 Github 仓库上 链接&emsp;&emsp;下面根据 json 配置逐个拆解代码的部分。 &emsp;&emsp;json 配置最上面定义了父类菜单的名称，这些名称可以通过我之前写的 list_menu 方法获取到，有些菜单需要右键生成了才能获取到 链接 1234567891011121314151617181920212223242526272829303132333435363738394041# NOTE 获取 init_unreal.py 脚本的路径DIR = os.path.dirname(__file__)CONTENT = os.path.dirname(DIR)CONFIG = os.path.join(CONTENT, "_config")def read_json(json_path): import codecs data = &#123;&#125; try: with codecs.open(json_path, "r", encoding="utf-8") as f: data = json.load(f, object_pairs_hook=OrderedDict) except: import traceback traceback.print_exc() return datadef read_config_json(config): return read_json(os.path.join(CONFIG, "%s.json" % config))def create_menu(): # NOTE 读取 menu.json 配置 menu_json = read_config_json("menu") fail_menus = &#123;&#125; for tool_menu, config in menu_json.items(): # NOTE 如果菜单不存在添加到失败列表里面 menu = menus.find_menu(tool_menu) if not menu: fail_menus.update(&#123;tool_menu: config&#125;) continue config.setdefault("menu", menu) handle_menu(config) menus.refresh_all_widgets() return fail_menusfail_menus = create_menu() &emsp;&emsp;handle_menu 分为 4 个部分，都是对 json 配置里面的相应选项进行配置，如过没有配置选项则利用 for 空循环来跳过。 123456789101112# NOTE 解析 section 配置for section, config in data.get("section", &#123;&#125;).items(): # NOTE 兼容简单的字符串命名的配置 config = config if isinstance(config, dict) else &#123;"label": str(config)&#125; config.setdefault("label", "untitle") # NOTE 如果存在 insert_type 需要将字符串转换大写 (这样 json 配置就不用区分大小写了) insert = INSERT_TYPE.get(config.get("insert_type", "").upper()) insert and config.update(&#123;"insert_type":insert&#125;) insert_name = config.get("insert_name") config["insert_name"] = insert_name if insert_name else "None" # NOTE 添加 section menu.add_section(section, **config) &emsp;&emsp;这里会判断 section 配置是否是配置或是纯粹的字符串。 12345678910"ContentBrowser.AddNewContextMenu": &#123; "section": &#123; "new_asset_section": &#123; "label": "PyToolkit 创建新资源菜单嵌入测试", "insert_name": "ContentBrowserNewAdvancedAsset", "insert_type": "AFTER" &#125;, "other_asset_section": "PyToolkit 其他的 section" &#125;&#125; &emsp;&emsp;上面的两种 section 配置都是可以的。&emsp;&emsp;只是没有配置 insert 选项的话，section 会添加到默认的位置，通常是菜单最下面。 1234567# NOTE 解析 property 配置for prop, value in data.get("property", &#123;&#125;).items(): if prop == "menu_owner" or value == "": continue elif prop == "menu_type": value = MENU_TYPE.get(value.upper()) menu.set_editor_property(prop, value) &emsp;&emsp;这里的 menu_type 可以定义菜单选项的类型，从而显示不同效果。 123456789101112131415161718&#123; "LevelEditor.LevelEditorToolBar": &#123; "property": &#123; "close_self_only": "", "menu_name": "", "menu_owner": "", "menu_parent": "", "menu_type": "", "prevent_customization": "", "searchable": "", "should_close_window_after_menu_selection": "", "style_name": "", "tool_bar_force_small_icons": "", "tool_bar_is_focusable": "", "tutorial_highlight_name": "" &#125; &#125;&#125; &emsp;&emsp;菜单的选项可以配置这些选项，大部分都是字符串选项所以，也不需要代码额外的处理 123456789101112131415161718192021222324252627282930313233343536373839404142# NOTE 字符串映射到 Unreal 对象COMMAND_TYPE = &#123; "COMMAND": unreal.ToolMenuStringCommandType.COMMAND, "PYTHON": unreal.ToolMenuStringCommandType.PYTHON, "CUSTOM": unreal.ToolMenuStringCommandType.CUSTOM,&#125;INSERT_TYPE = &#123; "AFTER": unreal.ToolMenuInsertType.AFTER, "BEFORE": unreal.ToolMenuInsertType.BEFORE, "DEFAULT": unreal.ToolMenuInsertType.DEFAULT, "FIRST": unreal.ToolMenuInsertType.FIRST,&#125;MENU_TYPE = &#123; "BUTTON_ROW": unreal.MultiBoxType.BUTTON_ROW, "MENU": unreal.MultiBoxType.MENU, "MENU_BAR": unreal.MultiBoxType.MENU_BAR, "TOOL_BAR": unreal.MultiBoxType.TOOL_BAR, "UNIFORM_TOOL_BAR": unreal.MultiBoxType.UNIFORM_TOOL_BAR, "VERTICAL_TOOL_BAR": unreal.MultiBoxType.VERTICAL_TOOL_BAR,&#125;ENTRY_TYPE = &#123; "BUTTON_ROW": unreal.MultiBlockType.BUTTON_ROW, "EDITABLE_TEXT": unreal.MultiBlockType.EDITABLE_TEXT, "HEADING": unreal.MultiBlockType.HEADING, "MENU_ENTRY": unreal.MultiBlockType.MENU_ENTRY, "NONE": unreal.MultiBlockType.NONE, "TOOL_BAR_BUTTON": unreal.MultiBlockType.TOOL_BAR_BUTTON, "TOOL_BAR_COMBO_BUTTON": unreal.MultiBlockType.TOOL_BAR_COMBO_BUTTON, "WIDGET": unreal.MultiBlockType.WIDGET,&#125;ACTION_TYPE = &#123; "BUTTON": unreal.UserInterfaceActionType.BUTTON, "CHECK": unreal.UserInterfaceActionType.CHECK, "COLLAPSED_BUTTON": unreal.UserInterfaceActionType.COLLAPSED_BUTTON, "NONE": unreal.UserInterfaceActionType.NONE, "RADIO_BUTTON": unreal.UserInterfaceActionType.RADIO_BUTTON, "TOGGLE_BUTTON": unreal.UserInterfaceActionType.TOGGLE_BUTTON,&#125; &emsp;&emsp;字符串映射到 Unreal 对象，利用 Python 的 upper 处理，可以让配置不用区分大小写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# NOTE 解析 entry 配置for entry_name, config in data.get("entry", &#123;&#125;).items(): label = config.get("label", "untitle") prop = config.get("property", &#123;&#125;) for k in prop.copy(): v = prop.pop(k) if v and k in ["name", "tutorial_highlight_name"]: prop[k] = v # NOTE 将字符串选项映射到 Unreal Python 的类型 if k == "insert_position": position = INSERT_TYPE.get(v.get("position", "").upper()) v["position"] = ( position if position else unreal.ToolMenuInsertType.FIRST ) v["name"] = v.get("name", "") prop[k] = unreal.ToolMenuInsert(**v) elif k == "type": typ = ENTRY_TYPE.get(str(v).upper()) prop[k] = typ if typ else unreal.MultiBlockType.MENU_ENTRY elif k == "user_interface_action_type": typ = ACTION_TYPE.get(str(v).upper()) typ and prop.update(&#123;k: typ&#125;) elif k == "script_object": # NOTE 获取 MENU_MODULE 有没有相关的类 script_class = getattr(MENU_MODULE, v, None) if script_class and issubclass( script_class, unreal.ToolMenuEntryScript ): script_object = script_class() context = unreal.ToolMenuContext() # NOTE 检查类是否配置 get_label 没有设置则采用 json 配置的名称 script_label = str(script_object.get_label(context)) if not script_label: # NOTE 生成一个动态类来设置名称 @unreal.uclass() class RuntimeScriptClass(script_class): label = unreal.uproperty(str) @unreal.ufunction(override=True) def get_label(self, context): return self.label script_object = RuntimeScriptClass() script_object.label = label prop[k] = script_object prop.setdefault("name", entry_name) prop.setdefault("type", unreal.MultiBlockType.MENU_ENTRY) entry = unreal.ToolMenuEntry(**prop) entry.set_label(label) typ = COMMAND_TYPE.get(config.get("type", "").upper(), 0) # NOTE 命令支持特殊字符替换 例如 &#123;Content&#125; command = config.get("command", "").format(**FORMAT_ARGS) entry.set_string_command(typ, "", string=command) menu.add_menu_entry(config.get("section", ""), entry) &emsp;&emsp;这个配置看似很复杂，其实大部分都是处理 字符串 到 Unreal 对象的映射而已，处理逻辑和上面的代码差不太多。&emsp;&emsp;其中重点是 script_object 的处理。 1234567# NOTE 获取 init_unreal.py 脚本的路径DIR = os.path.dirname(__file__)CONTENT = os.path.dirname(DIR)CONFIG = os.path.join(CONTENT, "_config")# NOTE 利用 imp 加载脚本 (等于与 import 指定路径的脚本)menu_py = os.path.join(CONFIG, "menu.py")MENU_MODULE = imp.load_source("__menu__", menu_py) if os.path.exists(menu_py) else None &emsp;&emsp;MENU_MODULE 通过 import 导入进来。&emsp;&emsp;可以直接从 menu.py 获取到对应的 ToolMenuEntryScript 类。&emsp;&emsp;有了这个类之后会获取一下 get_label 是否有配置菜单名称，如果没有就继承这个类将 json 配置的名称加上去。&emsp;&emsp;通过这个配置就完成了上面提到的动态显示配置的效果。 1234567891011# NOTE 递归解析 sub_menufor entry_name, config in data.get("sub_menu", &#123;&#125;).items(): init = config.get("init", &#123;&#125;) owner = menu.get_name() section_name = init.get("section", "") name = init.get("name", entry_name) label = init.get("label", "") tooltip = init.get("tooltip", "") sub_menu = menu.add_sub_menu(owner, section_name, name, label, tooltip) config.setdefault("menu", sub_menu) handle_menu(config) &emsp;&emsp;最后通过 sub_menu 递归解析数据，其中 sub_menu 会多出一个 init 选项&emsp;&emsp;可以配置新菜单的名称提示等等参数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; "ContentBrowser.AddNewContextMenu": &#123; "section": &#123; "new_asset_section": &#123; "label": "PyToolkit 创建新资源菜单嵌入测试", "insert_name": "ContentBrowserNewAdvancedAsset", "insert_type": "AFTER" &#125; &#125;, "sub_menu": &#123; "py_menu": &#123; "init": &#123; "label": "PyToolkit测试", "section": "new_asset_section", "tooltip": "PyToolkit 创建新资源菜单嵌入测试" &#125;, "section": &#123; "Test": "测试" &#125;, "entry": &#123; "Common": &#123; "section": "Test", "label": "演示:新资源菜单触发(打印到屏幕)", "type": "PYTHON", "command": "unreal.SystemLibrary.print_string(None,'新资源菜单触发',text_color=[255,255,255,255])" &#125; &#125;, "sub_menu":&#123; "test_menu":&#123; "init": &#123; "label": "PyToolkit 多重 sub_menu", "section": "new_asset_section", "tooltip": "PyToolkit 多重 sub_menu" &#125;, "section": &#123; "Test": "测试" &#125;, "entry": &#123; "Common": &#123; "section": "Test", "label": "演示:新资源菜单触发(打印到屏幕)", "type": "PYTHON", "command": "unreal.SystemLibrary.print_string(None,'新资源菜单触发',text_color=[255,255,255,255])" &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; &emsp;&emsp;可以看那到其他的解析通过递归调用 handle_menu 的方式从新配置，因此 sub_menu 可以无限套娃。 贴图 resize 选项配置 &emsp;&emsp;经过上面的说明，就可以用过 script_object 指定 menu.py 里面配置的类 1234567891011121314151617181920212223242526272829303132# NOTE menu.py 脚本import unrealutil_lib = unreal.EditorUtilityLibrary@unreal.uclass()class TextureReimport(unreal.ToolMenuEntryScript): @unreal.ufunction(override=True) def is_visible(self,context): # print(self.label) types = (unreal.Texture,) assets = [asset for asset in util_lib.get_selected_assets() if isinstance(asset,types)] return bool(assets) @unreal.ufunction(override=True) def get_tool_tip(self,context): return u'重导贴图并且按照规范压缩图片大小' @unreal.uclass()class UVCapture(unreal.ToolMenuEntryScript): @unreal.ufunction(override=True) def is_visible(self,context): print(self.label) types = (unreal.StaticMesh,unreal.SkeletalMesh) assets = [asset for asset in util_lib.get_selected_assets() if isinstance(asset,types)] return bool(assets) @unreal.ufunction(override=True) def get_tool_tip(self,context): return u'输出模型 UV 边界图' &emsp;&emsp;于是利用上面类的 is_visible 方法就可以控制菜单选项是否可见，目前的缺点是 子菜单 没法用这种方式隐藏，只能处理菜单项。&emsp;&emsp;所以我建议直接放到右键菜单上显示比较友好。 贴图大小自动 resize &emsp;&emsp;终于经过很长的铺垫之后，来到本篇文章的核心内容，怎么做到右键菜单直接调整 贴图的尺寸。&emsp;&emsp;其实背后用的是 imagemagick 命令行，当然也可以使用 PIL 或者 Qt 的图像处理，只是 imagemagick6 小巧功能强大，性能良好。&emsp;&emsp;不愧是命令行 PS Github&emsp;&emsp;只是最新的 imagemagick7 做了很大的改版，将工具拆分成了多个命令行工具，并且大小也膨胀了很多。&emsp;&emsp;所以还是 imagemagick6 的老版本比较香，功能也能够满足大部分的需求。 &emsp;&emsp;老版本可以在 Maya 或者 PS 里面拿到。 &emsp;&emsp;Maya 的版本老一点，但是大小更小。&emsp;&emsp;推荐还是用 PS 的版本，那是 6 代最新的版本了。 &emsp;&emsp;imagemagick 如何使用可以参考我之前写的一篇文章 链接 ，写得不太好有点东拼西凑请见谅。 &emsp;&emsp;思路就是获取 texture 导入的路径，然后将原图挪动到 临时目录下 。&emsp;&emsp;通过 imagemagick 处理图片大小输出到刚才的导入路径，再用导入路径重新导入，大小就已经改变了。&emsp;&emsp;接着将临时路径原图挪回到开始的地方即可。&emsp;&emsp;这样做的好处就是使用 Unreal 原生的 Reimport 可以用原图导入，使用我配置的选项导入就可以自动调整贴图的大小。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import osimport sysimport shutilimport tempfileimport subprocessimport contextlibimport unrealDIR = os.path.dirname(__file__)PLUGIN = "PyToolkit"plugins = unreal.Paths.project_plugins_dir()bin = os.path.join(plugins, PLUGIN, "bin")CONVERT = os.path.abspath(os.path.join(bin, "convert.exe"))util_lib = unreal.EditorUtilityLibraryasset_tool = unreal.AssetToolsHelpers.get_asset_tools()def texture_import_task(filename="", destination=""): task = unreal.AssetImportTask() task.set_editor_property("automated", True) task.set_editor_property("destination_path", destination) task.set_editor_property("filename", filename) task.set_editor_property("replace_existing", True) task.set_editor_property("save", True) return task def resize_texture(texture_path, size): assert size != 0, "贴图大小不能为0" # NOTE imagmagick 调整图片尺寸 commands = [ '"%s"' % CONVERT, '"%s"' % texture_path, "-channel RGBA", "-separate", # "-sharpen 0:0.55", "-resize %sx%s" % (size, size), "-combine", '"%s"' % texture_path, ] command = " ".join(commands) subprocess.call(command, shell=True)@contextlib.contextmanagerdef copy_texture(texture_path, size): texture_name = os.path.basename(texture_path) temp_path = os.path.join(tempfile.gettempdir(), texture_name) # NOTE 如果 size 为 0 则原图导入 if size: os.path.exists(temp_path) and os.remove(temp_path) shutil.copyfile(texture_path, temp_path) resize_texture(texture_path, size) yield if size: os.path.exists(texture_path) and os.remove(texture_path) shutil.copyfile(temp_path, texture_path) os.path.exists(temp_path) and os.remove(temp_path)def main(): # NOTE 获取贴图调整的大小 size = next(iter(sys.argv[1:]), 0) # NOTE 判断字符串是否是数字 size = abs(int(size)) if size.isdigit() else 0 for texture in util_lib.get_selected_assets(): if not isinstance(texture, unreal.Texture): continue data = texture.get_editor_property("asset_import_data") texture_path = data.get_first_filename() path = texture.get_outer().get_path_name() msg = "贴图文件不存在，请重新导入\n引擎路径: %s\n贴图路径: %s" % (path, texture_path) assert os.path.exists(texture_path), msg asset_folder, name = os.path.split(texture.get_outer().get_path_name()) texture_path = os.path.abspath(texture_path) with copy_texture(texture_path, size): task = texture_import_task(texture_path, asset_folder) name and task.set_editor_property("destination_name", name) asset_tool.import_asset_tasks([task])if __name__ == "__main__": main() &emsp;&emsp;处理结果就像开头看到的那样。 总结 &emsp;&emsp;使用 imagemaick 处理还是会有点问题，美术回反馈用这个工具缩图和 PS 的比例缩放调整不一样。&emsp;&emsp;但是我也不知道 PS 是用怎样的算法去缩尺寸的，所以还是有不能尽善尽美的地方(:з」∠) &emsp;&emsp;另外上面的工具有个问题，如果图片的原图已经不在了就无法执行了。&emsp;&emsp;其实也可以考虑将 Unreal 当前的图片当作原图导出去处理的，只是没必要就没做了。 2021-08-25 更新 &emsp;&emsp;其实引擎里面也有缩图的参数,可以实现类似 PS 的缩图效果。 &emsp;&emsp;后来经过评估,采用了引擎自带的缩图效果就可以解决问题，无需用 imagemagick 自动处理&emsp;&emsp;imagemagick 的好处是可以在图片做额外的效果,有需要的也可以接入进行图像处理。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 保存 导入 Hook 触发实现]]></title>
    <url>%2Fposts%2F90c2e3db.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间有遇到一个需求，需要在资源保存的时候做一些验证，检查资源是否正确。&emsp;&emsp;这就需要实现保存的时候触发一个 HOOK 执行相应的检验函数。 C++ 实现 &emsp;&emsp;面对这个问题，我简单查了一下 Python 相关的调用，似乎没有找到合适的调用函数，于是就去 C++ 里面加一个保存 HOOK 了&emsp;&emsp;其实当时是找到很是的函数了， 只是 Validator 误导了我，所以我就没有仔细去研究。 &emsp;&emsp;关于 C++ 的保存调用是相当的简单，在 UPackage 下有相关的 Event 链接 123456789101112131415161718192021222324void FPyToolkitModule::StartupModule()&#123; PluginName = "PyToolkit"; Content = FPaths::ProjectPluginsDir() / PluginName + TEXT("/Content"); // NOTE 读取 Content 目录下的 settings.json 配置文件 FString JsonSetting = Content + TEXT("/settings.json"); TSharedPtr&lt;FJsonObject&gt; JsonObject = FPyCommandList::ReadJson(JsonSetting); SettingObject = JsonObject-&gt;GetObjectField("script"); // 省略若干代码... UPackage::PreSavePackageEvent.AddRaw(this, &amp;FPyToolkitModule::OnPackageSaved);&#125;void FPyToolkitModule::OnPackageSaved(UPackage *Package)&#123; static FFormatNamedArguments Arguments; Arguments.Add(TEXT("Content"), FText::FromString(Content)); FString Path = Package-&gt;GetName(); // NOTE 读取 SettingObject 配置文件的 OnPackageSaved 属性调用相应的 py 脚本 FString ClosedScript = FText::Format(FTextFormat::FromString(SettingObject-&gt;GetStringField("OnPackageSaved")), Arguments).ToString() + FString(TEXT(" ")) + Path; GEngine-&gt;Exec(NULL, ClosedScript.GetCharArray().GetData());&#125; &emsp;&emsp;通过上面的代码可以非常简单实现保存的时候调用相关的 Python 脚本的效果。&emsp;&emsp;只是要确保 Content 目录下要有 settings.json 的配置文件，配置 OnPackageSaved 项来指定调用的脚本。&emsp;&emsp;否则启动的时候会因为找不到 json 文件直接 引擎崩溃 (还是做个检测处理比较妥当(:з」∠)) Python Hook 实现 &emsp;&emsp;后来非常偶然地加了一个网友，在交流的过程中，他教会了我使用 subsystem 的 Hook 实现导入的时候触发对应的 Python 函数进行处理。&emsp;&emsp;于是我在这个基础上我又仔细研究了 EditorValidatorSubsystem 也顺利利用纯 Python 来解决我最开始提到的保存触发函数的问题。 &emsp;&emsp;首先回到最开始的问题，保存的时候触发相应的函数。&emsp;&emsp;可以利用 EditorValidatorSubsystem 来实现 Python文档 &emsp;&emsp;这个类提供了 add_validator 方法，可以给 Asset 添加相应的 Validate 功能&emsp;&emsp;添加 validator 需要继承 EditorValidatorBase 这个类，然后重载相关的功能。 &emsp;&emsp;这种操作，具体可以参考我之前写的 Unreal Python ToolMenuEntryScript 使用研究 文章&emsp;&emsp;利用 Unreal Python 继承一个 C++ 类 12345678910111213141516171819202122import unreal# NOTE 生成一个 EditorValidatorBase 类@unreal.uclass()class OnAssetSaveValidator(unreal.EditorValidatorBase): # NOTE 保存资源的时候会调用这个函数 @unreal.ufunction(override=True) def can_validate_asset(self,asset): msg = 'Save Hook Trigger' unreal.SystemLibrary.print_string(None,msg,text_color=[255,255,255,255]) return super(OnAssetSaveValidator,self).can_validate_asset(asset)def main(): validator = OnAssetSaveValidator() validator.set_editor_property("is_enabled",True) validate_subsystem = unreal.get_editor_subsystem(unreal.EditorValidatorSubsystem) validate_subsystem.add_validator(validator)if __name__ == "__main__": main() &emsp;&emsp;在 unreal 里面执行上面的代码，保存的时候就会自动打印 Save Hook Trigger 的语句了。&emsp;&emsp;经过我的测试，我发现只有 can_validate_asset 可以正常触发，其他的函数尝试 override 了，但是保存的时候没有起作用。&emsp;&emsp;不过有 can_validate_asset 触发就足够了。&emsp;&emsp;我们可以检测传入的 asset 类型，然后调用相应的保存处理函数。&emsp;&emsp;这后面可以做的事情就很多了，资源的校验，配置选项的自动处理，自动生成配套资源 等等等。&emsp;&emsp;我之前就做了一个根据当前材质实例的勾选自动切换母材质的功能。 &emsp;&emsp;同样地，借助 subsystem 还可以实现 import 的 HOOK，&emsp;&emsp;具体用到了 ImportSubsystem&emsp;&emsp;其中提供了四种不同情况的调用，用得多的是 on_asset_post_import 导入之后对导入的资源进行后处理。 12345678910111213141516171819import unrealdef import_log(factory, created_object): msg = "Import Hook Trigger" unreal.SystemLibrary.print_string(None, msg, text_color=[255, 255, 255, 255]) print(factory, created_object)def main(): # import_subsystem.on_asset_post_import.add_callable(OnAssetImport.import_log) import_subsystem = unreal.get_editor_subsystem(unreal.ImportSubsystem) # NOTE 全局变量才不会被 GC 导致 hook 失效 global on_asset_post_import_delegate on_asset_post_import_delegate = unreal.OnAssetPostImport_Dyn() on_asset_post_import_delegate.add_callable(import_log) import_subsystem.set_editor_property("on_asset_post_import",on_asset_post_import_delegate)if __name__ == "__main__": main() &emsp;&emsp;需要注意的是 delegate 需要用全局变量指定，否则使用一段时间之后 hook 会因为 gc 问题失效。&emsp;&emsp;这个问题非常类似我当时做批量渲染工具时候遇到的问题 Unreal Python Sequencer 批量渲染总结 &emsp;&emsp;如果导入资源的命名有相应的规范，就可以自动把相关的属性勾选上，特别是 Texture 之类的处理会非常好用，美术也不会忘记勾选导致各种问题。 总结 &emsp;&emsp;纯 Python 的实现目前只能拘束在 Import 和 Save 两个应用场景。&emsp;&emsp;如果需要额外的应用场景比如说 打开资源的时候触发 等，就需要依靠 C++ 来实现了。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 实现 Function 调用]]></title>
    <url>%2Fposts%2F84f275f9.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近有个需求，需要在工具里面调用 EditorUtilityBlueprint 写好的功能。&emsp;&emsp;于是踩坑回顾一下。 call_method 调用内部函数 &emsp;&emsp;蓝图里面添加了连接好的函数 Function ，比如如下图所示 &emsp;&emsp;如何通过 Python 来调用这个自定义的函数呢？ 1234567# NOTE 选择蓝图bp, = unreal.EditorUtilityLibrary.get_selected_assets()bp_path = bp.get_path_name()gc = unreal.load_object(None, "%s_C" % bp_path)cdo = unreal.get_default_object(gc)cdo.call_method("TestCall",args=(unreal.World(),)) &emsp;&emsp;经过我的测试，可以利用 _ObjectBase 内置的 call_method 调用对象内置的方法&emsp;&emsp;但是这个方案有很多问题，上面只是一个简单的蓝图连接，就需要在 args 上加上莫名奇妙的 对象补充才能正常运行函数。 &emsp;&emsp;否则会提示缺少参数而无法执行。&emsp;&emsp;如果蓝图连接得非常复杂的化，会更加麻烦，需要填充非常多的参数才可以。&emsp;&emsp;于是出于好奇，我就去找了源码 &emsp;&emsp;从源码上可以看到是参数的识别出问题了。&emsp;&emsp;因此如果用纯 Python 调用，需要解决大量的参数调用，会非常地麻烦，唯一的好处是可以不用写 C++ UFunction 获取 &emsp;&emsp;既然这个方法不同，于是我想到了之前的思路，先找一下有没有 Function 相关的 UObject 操作链接&emsp;&emsp;通过这个方法可以获取， Unreal 里面完整的 UObject 列表 链接 12345678[ // 省略 ... "/Engine/Transient.REINST_NewEditorUtilityBlueprint_C_229:call", "/RedArtToolkit/Resources/UVCapture/NewFolder/NewEditorUtilityBlueprint.NewEditorUtilityBlueprint_C:TestCall", "/Engine/Transient.REINST_NewEditorUtilityBlueprint_C_229:TestCall", "/RedArtToolkit/Resources/UVCapture/NewFolder/NewEditorUtilityBlueprint.NewEditorUtilityBlueprint_C:call" // 省略 ...] &emsp;&emsp;从上面的路径的确可以获取到对应函数命名的 UObject&emsp;&emsp;用 Python 加载试试。 1234567import unrealobj = unreal.load_object(None,"/RedArtToolkit/Resources/UVCapture/NewFolder/NewEditorUtilityBlueprint.NewEditorUtilityBlueprint_C:TestCall")print(obj)# LogPython: &lt;Object '/RedArtToolkit/Resources/UVCapture/NewFolder/NewEditorUtilityBlueprint.NewEditorUtilityBlueprint_C:TestCall' (0x000001C7BE07E980) Class 'Function'&gt;print(dir(obj))['__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_post_init', '_wrapper_meta_data', 'call_method', 'cast', 'get_class', 'get_default_object', 'get_editor_property', 'get_fname', 'get_full_name', 'get_name', 'get_outer', 'get_outermost', 'get_path_name', 'get_typed_outer', 'get_world', 'modify', 'rename', 'set_editor_properties', 'set_editor_property', 'static_class'] &emsp;&emsp;可以看到获取到了一个 Function 对象，然而神奇的是 文档里面只有 FunctionDef 对象，并没有 unreal.Function 的说明&emsp;&emsp;尝试用 dir 打印 Function 对象提供的函数，然而也只能获取到 UObject 的白板方法。&emsp;&emsp;经过网上查阅，可以知道这个就是 C++ 的 UFunction 对象。 官方文档&emsp;&emsp;看来要实现 UFunction 的调用只能借助 C++ 了 UFunction 调用 &emsp;&emsp;如何才能解决 UFunction 的调用呢？&emsp;&emsp;我想到的还是去抄 Unreal 的源码，最容易想到就是 EditorUtilityObject&emsp;&emsp;官方的直播和文档里面都有提到，如果想要用蓝图扩展右键菜单，可以用 EditorUtilityBlueprint 继承相应的对象。 &emsp;&emsp;只要继承 AssetActionUtility 对象，就可以在右键菜单的 Scripted Action 里面调用蓝图相关的功能。 官方文档教程&emsp;&emsp;相必，可以查 C++ 源码知道里面的函数是怎么被调用的。 &emsp;&emsp;经过一番努力，我定位到代码出发的关键在 ProcessEvent 上。&emsp;&emsp;于是基于上面的代码，我可以封装一个蓝图库函数，来实现蓝图函数的调用。 1234567891011void UPyToolkitBPLibrary::RunFunction(UObject *CDO, UFunction *Function)&#123; // We dont run this on the CDO, as bad things could occur! UObject *TempObject = NewObject&lt;UObject&gt;(GetTransientPackage(), Cast&lt;UObject&gt;(CDO)-&gt;GetClass()); TempObject-&gt;AddToRoot(); // Some Blutility actions might run GC so the TempObject needs to be rooted to avoid getting destroyed FScopedTransaction Transaction(NSLOCTEXT("UnrealEd", "BlutilityAction", "Blutility Action")); FEditorScriptExecutionGuard ScriptGuard; TempObject-&gt;ProcessEvent(Function, nullptr); TempObject-&gt;RemoveFromRoot();&#125; &emsp;&emsp;类似于上面的蓝图库函数。&emsp;&emsp;Python 的这边就要获取 蓝图的 CDO 对象和 UFunction 对象，然后传入到 RunFunction 的 C++ 调用即可。 1234567891011import unrealpy_lib = unreal.PyToolkitBPLibraryfunc_name = "TestCall"# NOTE 选择蓝图bp, = unreal.EditorUtilityLibrary.get_selected_assets()gc_path = "%s_C" % bp.get_path_name()gc = unreal.load_object(None, gc_path)cdo = unreal.get_default_object(gc)func = unreal.load_object(None,"%s:%s" % (gc_path,func_name))py_lib.run_function(cdo,func) &emsp;&emsp;通过上面的方式就可以实现直接调用蓝图内部函数了。&emsp;&emsp;实测只有 EditorUtilityBlueprint 的对象可以起作用，如果是普通的蓝图还无法调用。 总结 &emsp;&emsp;我之前还花了不少时间，研究有没有可能通过 inspect 或者 异常处理 来实现纯 Python 的调用。&emsp;&emsp;然而经过我的测试 inspect 获取参数是不行的，毕竟不是 Python 的原生函数。&emsp;&emsp;利用异常可以解决部分问题，但是需要解析每个报错的信息，然后再将对应的参数提供到 args 里面&emsp;&emsp;如果是简单的蓝图连接还能应付，如果很复杂的话，需要异常出发很多次来处理出一个正确的参数序列，最后我还是放弃了。&emsp;&emsp;实践的部分代码在我的 CodeBase 里面 链接]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2021 我的效率软件汇总 (windows 篇)]]></title>
    <url>%2Fposts%2Fdeb8a681.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;好久没有更新博客了，最近两天,服务器还因为一些不清不楚的原因导致 Nginx 和 mysql 无法启动了。&emsp;&emsp;只能最近抽空备份数据然后把整个服务器的系统给重装了。 &emsp;&emsp;ε=(´ο｀*)))唉，这个月还不是很在状态，最近已经很久没有更新博客文章了。&emsp;&emsp;最近也没有折腾出值得分享的技术文章，只好分享一些非技术的水一水文章了。 &emsp;&emsp;其实去年我就有做过相关的效率软件汇总的文章。 Windows 效率提升指南Windows 效率提升指南 （二） &emsp;&emsp;如今回想起来其实还是那几个经典软件保留在我系统的后台中。 Windows 效率软件汇总 &emsp;&emsp;下面介绍的软件基本都在我上面的两篇效率指南里面有所提及。&emsp;&emsp;只是有一些不常用的软件被我干掉了，并且这期会将我这些软件常用或是黑科技的功能分享给大家。&emsp;&emsp;下列介绍的软件都是可以免费下载的软件，大部分是开源可信赖的。 listary &emsp;&emsp;如果我只能在别人的 windows 上装一个软件。&emsp;&emsp;那么我肯定会首选 listary&emsp;&emsp;listary 胜在它简单小巧，却十分简单好用。 &emsp;&emsp;listary 是一革命性的 windows 搜索工具，肩负软件启动器功能。 &emsp;&emsp;安装包不需要网上找，可以直接在软件管家里面安装启动。&emsp;&emsp;目前管家里面的安装包是 listary 5 的，日常使用没有什么太大的问题。&emsp;&emsp;不过我还是推荐 listary 6，只可惜 listary6 官方停更了。 listary 6 Beta 官方安装包 &emsp;&emsp;这个是官方最后的波纹了，幸好我还留了一个安装包，欢迎大家安装。目前官方已经没有最新版的下载地址了。 &emsp;&emsp;安装完成之后，双击 Ctrl 唤起全局搜索，搜索速度非常快。 &emsp;&emsp;可以用拼音简写定位软件。 &emsp;&emsp;可以通过简写跳转到对应网站的搜索。 &emsp;&emsp;这些搜索功能都是可以自定义配置的。 &emsp;&emsp;当然也可以自定义系统的命令，实现功能代码的调用。 &emsp;&emsp;对默认的快捷键感到不爽也可以进行自定义配置 &emsp;&emsp;在文件浏览器按鼠标中键可以打开菜单，通过这个菜单可以对相应目录进行收藏。 &emsp;&emsp;这样跳转路径的时候非常方便了。 &emsp;&emsp;以上的功能还只是皮毛，下面两个功能我觉得对日常的工作非常方便。 &emsp;&emsp;使用 windows 自带的文件浏览窗口可以，点击两个文件夹窗口，会自动进行跳转。&emsp;&emsp;按 Ctrl + G 也可以强制跳转到对应文件窗口上。 &emsp;&emsp;Ctrl + Shift + C 可以复制文件的路径&emsp;&emsp;如此就可以直接在文件窗口粘贴文件的路径进行打开操作了。 &emsp;&emsp;直接在文件窗口敲键盘即可出发搜索输入框。&emsp;&emsp;可以直接在文件夹内进行文件搜索和定位，在文件很多的情况下非常好用，比起系统自带的搜索快很多。 同类软件对比 &emsp;&emsp;和 listary 类似的软件还有 wox 和 utools&emsp;&emsp;wox 是 github 上开源的启动器，国内并不太流行，utools 用的人反而更多。&emsp;&emsp;utools 则是一款基于 electron 的启动器，优势在于支持多平台，但是安装包会比较大。 &emsp;&emsp;utools 我使用过，默认功能只能搜索系统快捷方式里面的软件。&emsp;&emsp;无法做到 listary 搜索全局文件，需要结合搜索神器 everything 来实现搜索。&emsp;&emsp;并且也无法实现文件夹内搜索定位文件，以及文件窗口自动跳转这些核心方便的功能。&emsp;&emsp;虽然 utools 集成了很多使用的工具包，但是这些功能其实都和 quicker 有所重叠。&emsp;&emsp;所以经过我的再三权衡，我还是把 utools 给卸载了。 quickerhttps://getquicker.net/ &emsp;&emsp;quicker 则是另一个牛逼的神器，而且随着它的发展状态，越来越有 all in one 的发展势头。&emsp;&emsp;quicker 相对 listary 要复杂一点，否则它就是我的第一推荐了，但是对于小白的简单使用也是非常简单的。&emsp;&emsp;并且 quicker 借助了社区的优势，通过 共享动作的方式 可以实现无数的可能。&emsp;&emsp;quicker 是付费软件，但是它的免费版就提供了多端同步的功能，不付钱就能满足绝大多数的使用场景。 &emsp;&emsp;quicker 的表面使用其实相对简单，按住鼠标中键可以打开一个盒子，盒子有相应的功能做触发。&emsp;&emsp;比如上面我就通过盒子里面的杀进程功能将 Maya 快速关闭。 &emsp;&emsp;你可以在盒子的格子上右键创建一些相应的操作。&emsp;&emsp;比如点击发送快捷键，发送固定的文本，启动相应的软件等等。&emsp;&emsp;这些只是最基础的用法。&emsp;&emsp;更牛逼的是，quicker 使用搭积木的方式让你实现编程。&emsp;&emsp;当我们在上面的选项中选择 新建组合 动作就可以弹出一个积木窗口。&emsp;&emsp;你可以通过自己的组合结合一些编程的知识，实现更多更复杂的操作。 &emsp;&emsp;如果你是小白，并不想自己造动作的话，也可以去quicker 的动作库，找广大网页分享的动作。 我的常用动作杀进程 &emsp;&emsp;我自己加了一些修改实现强制关闭。 剪贴板历史 &emsp;&emsp;这个动作帮我替代掉 Ditto 记录粘贴板历史 截图OCR &emsp;&emsp;用这个识别的文字非常准。 EVER截图 &emsp;&emsp;这个截完图之后可以钉住图片进行一些列操作。 文本/截图翻译 &emsp;&emsp;这个结合浏览器扩展可以 沙拉查词 可以非常方便查阅不同翻译的信息以及语音 &emsp;&emsp;上面这些动作还只是 quicker 的表层的社区共享功能。&emsp;&emsp;更多的功能可以去到 quicker 的动作库去查找 链接 WGesture &amp; Quickerhttps://www.yingdev.com/projects/wgestures &emsp;&emsp;WGesture 使用过鼠标手势滑动触发相应快捷键的功能。&emsp;&emsp;这些功能最新的 Quicker 都已经集成了，quicker 还可以实现多端同步，只是 quicker 需要付费才能解锁这个功能。&emsp;&emsp;如果不想付钱可以用 WGesture &emsp;&emsp;通过滑动鼠标可以实现各种快捷键触发。&emsp;&emsp;在浏览网页和文件的时候非常好用。 &emsp;&emsp;不小心划错了，可以多划几下，识别错误就不会触发任何指令。 snipastehttps://zh.snipaste.com/ &emsp;&emsp;我目前最常用的截图软件。&emsp;&emsp;可以实现图片钉在桌面上，也可以对图片进行二次的修改。 截图标注 &emsp;&emsp;钉住的图片 滚轮 可以调整大小，按住 ctrl 滚轮可以调整透明度。 取色 &emsp;&emsp;snipaste 可以在屏幕上直接取色，按 shift 可以切换不同表示的颜色值。 腾讯桌面管理https://guanjia.qq.com/product/zmzl/ &emsp;&emsp;就我个人来说，电脑的桌面通常很少会触碰。&emsp;&emsp;因为我的应用场景无论是工作敲代码还是日常刷视频，都被各种软件挡住桌面。&emsp;&emsp;如果要从桌面作为入口进行处理，会带来极大的不便。 &emsp;&emsp;所以我对桌面的要求见简洁清爽，将多余的快捷方式等东西可以用容器将他们全部整理起来。&emsp;&emsp;不至于让桌面非常凌乱，影响我心情。&emsp;&emsp;结合上面的 listary 搜索，我可以保留快捷方式到桌面方便我快速搜到。&emsp;&emsp;同时也不至于让我桌面满屏的快捷方式。 &emsp;&emsp;腾讯桌面管理可以很好地解决我的痛点。 Capslock+ 魔改Capslock+ 个人魔改 github 仓库 &emsp;&emsp;这个操作是当时看网上一篇关于 AHK 解决中文标点输入的文章学到的，于是我将它的功能融合到 魔改的 Capslock+ 工具里面了。&emsp;&emsp;简单的意思就是将 打字法 的中文标点输入取消，然后通过 AHK 实现 HotString ，两个英文标点自动替换为中文标点。&emsp;&emsp;我觉得这个操作用起来真的很舒服，敲代码的时候再也不会因为敲错中文标点报错了。 解析代码进行连发 &emsp;&emsp;解析代码进行连发。 &emsp;&emsp;标点符号自动替换&emsp;&emsp;自定义指令替换 QtTabbarhttp://qttabbar.wikidot.com/qttabbar1 &emsp;&emsp;一款比 clover 还要好用的文件多标签资源管理器。 http://qttabbar.wdfiles.com/local--files/documents/install.html &emsp;&emsp;根据这里的官方文档安装软件 &emsp;&emsp;完成之后可以在文件窗口的查看选项找到下拉菜单，使用 QTTabBar 就可以开启标签页。 &emsp;&emsp;可以对标签进行诸多的操作。 &emsp;&emsp;也可以直接将文件拖拽到另一个标签页下，默认是移动，按住 ctrl 键就会变成复制。 &emsp;&emsp;自带批量重命名工具，重名也能预览命名的效果，还支持正则表达式等复杂的命名匹配。&emsp;&emsp;虽然网上也有推荐更为复杂的重命名工具，我个人觉得这个工具已经够用了。 &emsp;&emsp;鼠标悬浮视频和图片还能有预览出现。 &emsp;&emsp;文件夹里面的文件也可以点击图标快速查看。 &emsp;&emsp;基本上日常使用知道上述的就够用了，不过这个工具还有扩展的 API 以及详细的文档。&emsp;&emsp;从中可以了解更多进阶的用法。 自定义配置http://qttabbar.wdfiles.com/local--files/documents/summary.html#section_what &emsp;&emsp;它的配置里面有很多功能都是可以自定义的，具体可以翻阅线上文档。 &emsp;&emsp;比如可以对标签页用各种组合的点击来触发不同的效果。&emsp;&emsp;其中用户命令可以实现绑定自定义的命令触发。 Scripting APIhttp://qttabbar.wikidot.com/scripting &emsp;&emsp;让我感到不可思议的灵活的是这个插件居然有自己的 API&emsp;&emsp;可以用 js 或者 vbs 来调用。&emsp;&emsp;只是需要注意这里支持的 js 是用 windows cscript 执行的&emsp;&emsp;cscript 不支持新版的 es6 标准，也不是 node.js 环境，所以写法会比较受限。 f.luxhttps://justgetflux.com/ &emsp;&emsp;屏幕颜色调节，护眼最爱。&emsp;&emsp;只是当我用惯了之后，很多人看我的屏幕都会很不习惯(:з」∠) TrayShttps://gitee.com/cgbsmy/TrayS &emsp;&emsp;当初找到这个主要是为了能够给我美化一下 windows 的任务栏&emsp;&emsp;当时也找到同类的产品 TaskbarX&emsp;&emsp;这个也不差，而且也是 Github 开源的，只是它的功能相对繁琐，我还是喜欢 TrayS 简约风。&emsp;&emsp;而且它也不支持 CPU 占用的显示。 &emsp;&emsp;任务栏图标居中显示，并且可以实时显示 CPU 和 内存占用&emsp;&emsp;特别是我装了联机编译，有时候 CPU 和 内存占用很高就可以很快看到是哪里被占用了。&emsp;&emsp;其实它还可以显示 CPU 温度之类的功能，只是我觉得用不上就没有开启。 7+ Taskbar tweakerhttps://rammichael.com/7-taskbar-tweaker &emsp;&emsp;这个工具可以和上面的 TrayS 相辅相成。&emsp;&emsp;这个软件可以对你的任务栏进一步进行定制化 &emsp;&emsp;安装完成之后的配置里面自定义任务栏图标的不同点击效果。 &emsp;&emsp;在任务栏空白区域双击可以让任务栏自动隐藏，我再双击又可以让任务栏锁定显示。&emsp;&emsp;有时候远程连接到别人的电脑，我侧边显示的任务栏会有所遮挡，这个时候快速隐藏就很方便。 &emsp;&emsp;空白区域按中键可以设置为任务栏监控插件，可以快速查看当前任务栏上打开的软件。 &emsp;&emsp;还有一些额外的小功能，比如任务栏滚动自动切换软件，只是这些功能我平时用得不多。 ImageGlasshttps://imageglass.org/https://github.com/d2phap/ImageGlass &emsp;&emsp;windows 自带的图片浏览器非常的一般，很多图片格式都不支持预览。&emsp;&emsp;而且启动速度也是慢地离谱。 &emsp;&emsp;后来我搜了比较好用的图片预览软件，市面上其实有很多。&emsp;&emsp;只是有不少有大有臃肿，集合了我很多不需要的功能，个人还是比较喜欢系统原生的简单界面。&emsp;&emsp;于是综合下来就是 imageglass 最符合我的需求，而且开源目前依然不断在更新维护。 &emsp;&emsp;界面相当简洁，还支持主题切换 https://imageglass.org/themes&emsp;&emsp;缺点是不支持跨平台。 keepasshttps://keepass.info/ &emsp;&emsp;keepass 是一款开源密码管理工具。 &emsp;&emsp;它可以自动帮你生成复杂的密码，极大降低盗号的风险。 &emsp;&emsp;我以前使用密码都是用固定的 3 - 4 个的密码组合。&emsp;&emsp;而且密码安全性相对简单，估计通用的密码本就有这类似的组合。&emsp;&emsp;如果黑客真想搞我，那可以尝试用通用的密码本暴力破解了其中一个密码。&emsp;&emsp;由于我各个账号的密码都相差不大，极其有可能会全部遭殃。 我被裸聊勒索后，看我如何揪出背后的团伙]可以看看这个大佬是怎么用技术和经验去人肉黑产信息的。 &emsp;&emsp;我自己目前还没有经历过被盗号的情况，不过也曾经被钓鱼网站欺骗过。&emsp;&emsp;还好发现及时，立刻更改了密码。 &emsp;&emsp;所以经过我的深思熟虑，我决定利用 keepass 这个免费软件来管理我的密码，毕竟数据抓在自己手里是最安全的。 &emsp;&emsp;keepass 的数据库可以通过坚果云的免费 webdav 进行同步。&emsp;&emsp;手机端可以使用 keepass2android 进行密码同步。 &emsp;&emsp;可能你会觉得密码数据库放到坚果云会不会不安全。&emsp;&emsp;keepass 数据库也是带安全验证，甚至可以用文件作为密码凭据，而这个凭据可以是任意文件，安全性极高。 bandziphttps://www.bandisoft.com/bandizip/ &emsp;&emsp;bandzip 国内开发的良心软件。&emsp;&emsp;免费版本不带广告，软件内可以直接预览图片，比起吃相难看的 winrar 要好太多了。 &emsp;&emsp;解压文件的右键菜单可以看到文件预览的信息。 carnachttp://code52.org/carnac/ &emsp;&emsp;屏幕实时显示按键操作，使用简单方便。&emsp;&emsp;方便用来做操作演示。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 编程基础汇总]]></title>
    <url>%2Fposts%2F3aad4b0a.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近被工作压垮，没有时间学习和研究新的东西，博客也停更了不少的时间(:з」∠)&emsp;&emsp;5月份只能更新一篇文章，还是因为各种催稿的压力，只好挤牙膏式地更新。&emsp;&emsp;ε=(´ο｀*)))，上个月的文章有说过要来讲解一下 pymel 的一些用法，对比 cmds 的好处和坏处。&emsp;&emsp;这次算是姗姗来迟地填坑吧 &emsp;&emsp;填坑之前决定先介绍一下 Maya 以及相关库的一些前世今生，想一下也够写上一篇文章了(:з」∠)&emsp;&emsp;关于 OpenMaya 以及 cmds mel pymel 这些内置 Python 库的关系，很久之前我也写过他们之间的关系 链接&emsp;&emsp;只是藏得比较深，所以这篇文章我重新梳理一下他们之间的关系。 Maya Mel &amp; Python &emsp;&emsp;Maya 安装之后又两种不同的编程语言 Mel &amp; Python | mel 百度百科&emsp;&emsp;为何 Maya 需要配置 Mel 和 Python 这些动态语言呢。&emsp;&emsp;主要是为了方便第三方扩展和辅助开发，动态语言开发工具快速便捷，方便调试，不容易导致软件崩溃。&emsp;&emsp;所以上古版本的 Maya 包括当时诸多类似的程序都有动态语言扩展的需求。 &emsp;&emsp;用 C++ 扩展软件的功能，成本和周期都显得过高，&emsp;&emsp;Maya 最古老的版本可以追溯到 1998 年甚至更早，那个时候 Python 还没有那么流行，所以那个年代不同 DCC 软件会选择各种不同的动态编程语言作为辅助开发。 出处 https://www.bilibili.com/video/BV1dJ411571P?p=3&amp;t=60 &emsp;&emsp;比如说 3dsMax 开发了 MaxScript ， Nuke 选择了 Tcl ，而 Maya 自个用 Mel 语言。&emsp;&emsp;后来 Python 作为 C++ 环境的胶水语言，其简单易用方便嵌入进行扩展调用，并且还有极其强大的生态，于是大量被各种软件库集成作为软件函数库的动态语言。 出处 https://www.bilibili.com/video/BV1Bt411f7hS?p=10&amp;t=100 &emsp;&emsp;如今才能看到 Python 几乎一统天下，大部分常用的 DCC 软件都支持它了。 出处 https://www.bilibili.com/video/BV1Kt411D7ca?p=1&amp;t=180 &emsp;&emsp;在目前的大环境下， Mel 语言因为其面向过程，功能单一 等多种缘由，已经越来越少被使用，如今的新插件亦或是 Autodesk 官方推出的新功能都已 Python 为主。 出处 https://www.bilibili.com/video/BV1dJ411571P?p=3&amp;165 &emsp;&emsp;Python 支持 subprocess socket 等功能，这些都是 Mel 所不具备的，如果没有 Python 就只能通过 C++ 来扩展，会非常麻烦。&emsp;&emsp;除了有过去的 Mel 代码需要维护之外，已经很少还有人编写 Mel 代码了，意外地想起 … 普天同庆 病毒是 Mel 代码编写的 (:з」∠) &emsp;&emsp;虽然说 Mel 已经很少人使用，但是了解 Mel 依然是学习 Maya 编程很重要的一部分，这也是为什么我上一篇要写 Pymel 来调用 Mel 的文章 链接&emsp;&emsp;升级 Python 之后 Maya 将 Mel 相关的调用以 Python 函数的形式封装到了 cmds 库&emsp;&emsp;这也是为什么 Mel 和 cmds 有大量的命令都是相通的，而绝大部分不相通的 Mel 命令，很大一部分都是 Mel Procedural 所以无法相通到 Python (当然解决方案就是利用 Pymel 的封装来 Pythonic 调用 Mel，参考上一篇文章) 出处 http://help.autodesk.com/cloudhelp/2018/ENU/Maya-Tech-Docs/Commands/index.html &emsp;&emsp;如果用 whatIs 命令查询到的 Mel 命令为 Command 那就是来自于 Maya C++ 底层，可以在 Mel 和 Python 之间互通(就只有 whatIs 这个奇葩不互通)&emsp;&emsp;那么 Maya 上层 和 底层是怎样的呢？ Maya 架构出处 https://www.bilibili.com/video/BV1dJ411571P?p=2&amp;t=170文档地址 https://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__files_API_Introduction_htm &emsp;&emsp;从上图可以看到，最上层的调用有 Mel Python 以及 C++&amp;C# 扩展&emsp;&emsp;中间层则有 Maya commands 和 Maya API&emsp;&emsp;最底层是 Maya 的 内核 出处 https://www.bilibili.com/video/BV19t411c7Vj?p=2&amp;t=1578 &emsp;&emsp;从上面的 Autodesk 官方教程可以看到 Maya Core 下面还对接 OS 层。&emsp;&emsp;从文档的描述可以确定 Maya Commands 就是 Mel 文档里面的每个指令，可以利用 C++ 对 command 进行扩展，如上图的 Custom Maya Command 出处 https://www.bilibili.com/video/BV1dJ411571P?p=2&amp;t=233 &emsp;&emsp;上面提及利用 command 可以用来编写 Maya 界面， command 是 Mel 的核心。 出处 https://www.bilibili.com/video/BV1dJ411571P?p=2&amp;t=240 &emsp;&emsp;Maya API 用来开发 Maya 的 C++ 插件,同时可以通过 Python API 1.0 和 2.0 (即 OpenMaya) 进行调用。 出处 https://www.bilibili.com/video/BV1Bt411f7hS?p=8&amp;t=200 &emsp;&emsp;另一个教程对 Mel 和 Python 以及 C++ 的各种优劣都有较为详细的介绍。&emsp;&emsp;其中 Mel 在 Python 面前毫无优势可言，而 C++ 则有效率高的优点，就是使用起来很繁琐。 出处 https://www.bilibili.com/video/BV164411f758?p=3&amp;t=300 &emsp;&emsp;上面是 C++ 和 Python 开发两者的比较。&emsp;&emsp;我个人的开发经验是先用 Python OpenMaya1.0 开发，如果实属高性能环境。&emsp;&emsp;就将 OpenMaya1.0 代码转换为 C++ 代码，由于两者调用很相近，转换过去相对简单。 出处 https://www.bilibili.com/video/BV1Bt411f7hS?p=8&amp;t=326 &emsp;&emsp;上图则比较了 Maya 内置的三个模块的 区别。&emsp;&emsp;pymel 是兼顾 cmds 和 OpenMaya 的模块，缺点就是效率有限制，我会在下一篇文章提供一些低效的解决方案。 &emsp;&emsp;Python 横跨 Mel 命令和 C++ 扩展的功能，而且动态使用无需编译，简直全能得离谱。 OpenMaya 介绍 &emsp;&emsp;OpenMaya下有两个不同的版本，分别为 OpenMaya 1.0 和 OpenMaya 2.0 附注:mottosso 大神在做 3.0 了 https://github.com/mottosso/cmdc官方不给力，只能靠社区才能把东西做好 &emsp;&emsp;OpenMaya 1.0 是通过 工具 将 C++ API 自动转换到 Python 下调用。 文档 https://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__files_GUID_EC669155_DD0C_4072_A0DC_D24C7FB2AB2D_htm &emsp;&emsp;因此 OpenMaya 库的文档是直接看 C++ 对应文档的 文档链接&emsp;&emsp;我使用过的命令里面 C++ 支持的 OpenMaya 都支持，文档里面提及有少量 C++ 命令不支持 Python 调用，但是实属极个别情况，目前我还没有遇到过。 OpenMaya 1.0 的问题出处 https://www.bilibili.com/video/BV19t411c7Vj?p=10&amp;t=637 &emsp;&emsp;上述截图只是 OpenMaya 1.0 部分问题，视频里面还有代码案例作为介绍,，非清晰看到问题所在。&emsp;&emsp;OpenMaya 1.0 调用非常繁琐，特别不符合 Python 开发者的使用习惯，某些函数需要让 Python 来传递指针。&emsp;&emsp;为此 Maya C++ 提供了 MScriptUtil ，虽然能够调用起来，但是使用体验会很差。&emsp;&emsp;并且 1.0 的自动转换没有性能优化，导致无谓的性能开销。 &emsp;&emsp;基于上述的问题， OpenMaya 2.0 诞生了。 2.0 文档 https://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__py_ref_classes_html 出处 https://www.bilibili.com/video/BV19t411c7Vj?p=10&amp;t=1963 &emsp;&emsp;API 2.0 打算纯手工重写 Python 的调用来提高性能，并且让调用更符合 Python 的习惯。&emsp;&emsp;然而这个 API 从 Maya 2012 引入，到 Maya 2019 都还没有完善好(:з」∠) 出处 https://www.bilibili.com/video/BV19t411c7Vj?p=10&amp;t=2443 &emsp;&emsp;然而 OpenMaya 2.0 不会做 面向对象 的绑定。&emsp;&emsp;用法依然和 1.0 大差不差的，只是传参各方面会好很多。 123456from maya import cmds# OpenMaya 1.0from maya import OpenMaya# OpenMaya 2.0from maya.api import OpenMaya as om# 官方推荐用 缩写 om 来区分 1.0 和 2.0 &emsp;&emsp;关于 OpenMaya 和 C++ 开发可以去下载 Maya 的 Maya devkit 网址 &emsp;&emsp;下载解压之后 devkitBase\devkit\plug-ins\scripted 路径有很多 基于 OpenMaya 1.0 和 2.0 的官方脚本。&emsp;&emsp;有时候看代码比看教程学得还快。&emsp;&emsp;如果是 C++ 的案例的话则看这个路径 devkitBase\devkit\plug-ins&emsp;&emsp;Maya 开发比较小众，但是官方提供的案例还是非常靠谱的。 pymel 永远滴神 &emsp;&emsp;在 2008 年， Maya 刚引入 Python 没多久之后。&emsp;&emsp;由于 cmds 和 OpenMaya 都没有提供 对象 属性 等的面向对象编程能力。&emsp;&emsp;于是 Luma Pictures 公司的开发团队开发了 pymel 来简化开发。 &emsp;&emsp;何为面向对象编程能力呢？ 具体可以学习 pymel 文档 Why Pymel &emsp;&emsp;长话对说就是， Maya Mel 命令下执行的指令，一切的物体对象都是以字符串走的。 123456789from maya import cmds# NOTE 获取第一个相机cam = cmds.ls(type='camera')[0]# Result: u'frontShape' # # NTOE 获取相机的 transform 节点transform = cmds.listRelatives(cam,p=1)[0]# Result: u'front' # tx = cmds.getAttr(transform + ".tx")# Result: 0.0 # &emsp;&emsp;如果使用 cmds 的方式，所有的调用都得拆开，因为和 Mel 语言一样 面向过程，需要不断调用相应的 函数 来触发功能。 12345import pymel.core as pmcam = cmds.ls(type='camera')[0]transform = cam.getParent()tx = transform.tx.get()# Result: 0.0 # &emsp;&emsp;面向对象开发，所有的函数调用都会后置，代码更加易读，理解更方便。 出处 https://help.autodesk.com/cloudhelp/2019/ENU/Maya-Tech-Docs/PyMel/design.html &emsp;&emsp;pymel 的开发哲学就是修复 cmds 的 BUG&emsp;&emsp;不会再数组返回时返回 None&emsp;&emsp;给 节点 和 属性 创建对应的面向对象类。&emsp;&emsp;这些新建的类可以接入 OpenMaya 的功能，让 pymel 的功能远超 cmds 12345import pymel.core as pmcam = pm.PyNode("persp")print(type(cam))# Result: &lt;class 'pymel.core.nodetypes.Transform'&gt; # print(dir(cam)) &emsp;&emsp;而这个 Transform 节点包含下列众多方法。 &emsp;&emsp;由于 Maya 所有的调用都是字符串， pymel 还包含了字符串的处理命令，还有诸如 longName objExists 等命令。&emsp;&emsp;调用起来更加清晰。 &emsp;&emsp;其次还有 __apimdagpath__ 等等的方法可以直接获取到节点对应 OpenMaya 1.0 的对象&emsp;&emsp;以此来调用 OpenMaya 进行更高效的处理。 12345678import pymel.core as pmfrom maya import OpenMayasphere, = pm.polyCube(ch=0)shape = sphere.getShape()mesh = shape.__apimfn__()# Result: &lt;maya.OpenMaya.MFnMesh; proxy of &lt;Swig Object of type 'MFnMesh *' at 0x0000020E80DC2480&gt; &gt; # dag = shape.__apimdagpath__()# Result: &lt;maya.OpenMaya.MDagPath; proxy of &lt;Swig Object of type 'MDagPath *' at 0x0000020E8131CF00&gt; &gt; # &emsp;&emsp;pymel 做好了 cmds 到 OpenMaya 之间的转换，这样可以很方便在两个 API 之间横跳。 12345678910111213141516171819202122232425262728293031323334353637import timefrom functools import wrapsimport pymel.core as pmfrom maya import OpenMayadef log_time(func): @wraps(func) def wrapper(*args,**kwargs): t0 = time.time() res = func(*args,**kwargs) print("[%s] elapsed time : %s" % (func.__name__,time.time() - t0)) return res return wrapper@log_timedef pymel_itr(): sphere, = pm.polySphere(ch=0) pos_list = [] for v in sphere.verts: pos_list.append(v.getPosition()) @log_timedef openmaya_itr(): sphere, = pm.polySphere(ch=0) shape = sphere.getShape() dag = shape.__apimdagpath__() itr = OpenMaya.MItMeshVertex(dag) pos_list = [] while not itr.isDone(): pos_list.append(list(itr.position())) itr.next()pymel_itr()openmaya_itr()# [pymel_itr] elapsed time : 0.132999897003# [openmaya_itr] elapsed time : 0.00699996948242 &emsp;&emsp;上述的例子可以很直观看到 pymel 在遍历数据的劣势。&emsp;&emsp;究其原因是 pymel 需要给每个顶点对象生成相应实例，如果直接 遍历 物体 所有的点，甚至会比 cmds 还要慢。 补充: pymel 获取顶点的时候，背后会拼装 mel 的字符串，顶点为例 pSphere1.vtx[315] ，在通过这个字符串调用 OpenMaya 的命令进行信息获取，所以在这个过程中会多次使用 OpenMaya 对多个顶点字符串进行解析查询，然而这个无谓的字符串解析查询其实很低效的。就好比查询数据库的时候一次拉取大量的数据下来，还是一条条数据逐个查询，显然如果拆得很碎的话，每个查询都要进行 http 请求，显然就会慢得不可思议，不过 mel 本质也是解析字符串，所以 mel 语言也是 &emsp;&emsp;但是如果获取 mfnmesh 的 OpenMaya 对象，再用相应的 MIt 命令遍历，那就快了很多。&emsp;&emsp;所以说 pymel 运用妥当，效率并不低，只要不去罗列大量的物体或者组件比如说顶点。 &emsp;&emsp;pymel 是在 08 09 年的时候开发的，那个时候还没有 Python API 2.0&emsp;&emsp;所以 pymel 底层都是用 Python API 1.0 实现的，也提供了很多方法直接调用底层的 API 比如 isReferenced 等方法。&emsp;&emsp;可以节省大量的代码。 界面开发 PySide Vs cmds &amp; mel &emsp;&emsp;我上一篇文章有提到 Maya 内置了一大堆 Mel 脚本 {Maya安装目录}/scripts&emsp;&emsp;这些 Mel 脚本其实有很大的部分是用来构建窗口的，很多老窗口比如 蒙皮设置窗口 等都是用 Mel 命令构建的。&emsp;&emsp;同样可以用 cmds 库，利用 Python 的方式来构建。&emsp;&emsp;甚至可以在这个基础上做面向对象的封装。&emsp;&emsp;界面开发应该用 PySide2 还是用 cmds 呢？ https://blog.l0v0.com/posts/2c06616b.html#MEL-amp-cmds-VS-PySide-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%BC%80%E5%8F%91 &emsp;&emsp;上面是我博客 Python结合Qt系列开发教程 的对比。&emsp;&emsp;PySide2 能做到的 cmds 也可以实现。 &emsp;&emsp;然而事实上如今用 cmds 开发界面的人也越来越少了。文档出处 https://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__files_GUID_D6567F97_012D_4F45_B252_C3112EBAE859_htm&emsp;&emsp;这主要是 Maya2011 之后接入了 Qt 图形框架。&emsp;&emsp;过去利用 Mel 或者 cmds 组装界面背后是调用了 各自 平台的图形框架。&emsp;&emsp;需要付出极大的人力物力去维护不同平台上的 BUG。&emsp;&emsp;Qt 框架支持跨平台统一，越来越多 DCC 软件都选择了 Qt 框架作为图形底层。&emsp;&emsp;并且 Python 生态有 PySide 和 PyQt 两个库，实现 Python 调用。&emsp;&emsp;只要学会 Qt 的 API ，就可以在各个不同软件上开发界面，一套技术解决不同软件的问题。 &emsp;&emsp;于是在开发上，直接使用 Python Qt 框架有两个无与伦比的好处。 可以跨软件兼容界面 可以利用 QtDesigner 快速开发 (当然 cmds 也有 loadUi 功能) &emsp;&emsp;重点还是在第一点上，开发一个界面就可以在不同软件上通用，这可是非常节省开发成本的。&emsp;&emsp;成熟的流程软件注入 shotgun 都是用这个套路。&emsp;&emsp;我在 Unreal 开发界面也直接用 Qt 界面省去我研究 Unreal 界面的开发成本，同时可以让不同软件的体验保持一致。 &emsp;&emsp;关于 Python Qt 框架在 Maya 的使用可以参阅 Maya 文档 链接&emsp;&emsp;上述文档有很详细的 对比，也列出了相应的代码案例来演示如何在 Maya 创建 Qt 的 UI 界面。 Maya 编程学习资源CGcircuit Maya Python APICGCircuit Introduction to the Maya APIAutodesk - Maya API Training WebcastsPython For Maya - Artist Friendly Programmingpython for maya with Justin Israel3DMotive - Introduction to Scripting in Maya Autodesk Learning ChannelIntroduction to MEL Scripting in MayaLTIntroduction to Python ScriptingCreating procedural terrainCreating a zombie simulation using MELLoading and executing a Python plug-in 官方Autodesk - Maya API Training WebcastsMaya 核心开发框架初探 - Denpendency Graph 介绍DevTV_Introduction_to_Maya_Dependency_Graph_Programming Chris Zurbrigg Maya 开发系列教程Beginning Python for MayaIntroduction to PySide for MayaChris Zurbrigg - Maya Python APIChris Zurbrigg - PySide2 for MayaChris Zurbrigg - Maya Python - Display Color OverrideChris Zurbrigg - Python in ProductionChris Zurbrigg - Maya Retiming Tool ProjectChris Zurbrigg - Qt Designer, PySide2 and MayaChris Zurbrigg - Maya Python - Tips and Tricks 中文教学maya API 白话教学视频（第一部 &amp; 第二部）CG-TA课堂 - Maya API &amp; PySide 开发 Digital Tutor 教程 (B站的链接大都挂了)Digital-Tutors Advanced PyQt for MayaDigital-Tutors Populating Complex Environments Using Python in MayaRender Scripting Using Python in Maya and PdplayerPluralsight - Python for Maya FundamentalsDigital Tutors - Enhancing Maya Toolsets with PythonDigital Tutors - Artist’s Guide to Python Scripting in MayaDigital-Tutors Getting Started with Python Scripting in MayaDigital-Tutors Procedural Rigging in Python with Custom Library in MayaDigital-Tutors Python Scripting in Maya Digital-Tutors Transferring Animation with MELDigital-Tutors Artist’s Guide to MEL in MayaDigital-Tutors Getting Started with MEL in MayaDigital Tutors Enhancing Your Maya Toolset with MEL &emsp;&emsp;这里列出的大部分教程都看过了，Chris Zurbrigg 系列后来才拿到的反而没怎么看，工作了就没有时间去看教程了o(╥﹏╥)o&emsp;&emsp;缅怀一下自己读大学，真就把教程当动漫看的时光。 扩展 Maya 第三方包 绑定 AdvanceSkeletonmGearngSkinTool 动画 MGtoolsanimBotspringMagicstudiolibrary 模型 instalLODQuadRemsher 日常 CosmossiShelf 编程 Charcoal EditorCoder2mpdb 代码扩展库https://github.com/mottosso/cmdxhttps://github.com/mottosso/cmdchttps://github.com/mottosso/qargparse.pyhttps://github.com/theodox/minqhttps://github.com/robertjoosten/maya-orm &emsp;&emsp;maya 一些底层库， mottosso 大佬独占鳌头。 总结 &emsp;&emsp;总算是经过千辛万苦，把文章更新完了。&emsp;&emsp;下期抽空剖析一下 Pymel 的底层原理。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Mel & Pymel 妙用总结]]></title>
    <url>%2Fposts%2F8c385876.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;去年的时候我有水过一篇文章 Maya 命令 自定义触发 &amp; Mel 源码获取&emsp;&emsp;看标题就知道介绍了 Maya 一些基础的命令调用方式，并且详细介绍了几个好用的 Mel 命令来辅助解析 Maya 回显的命令。&emsp;&emsp;利用 whatIs 和 runTimeCommand 可以非常方便查询到背后的命令。 &emsp;&emsp;但是使用 Mel 其实有更加 Python 的方法，那就是利用 pymel 来实现。 Pymel 调用 Mel123456import pymel.core as pmprint(pm.mel.whatIs('copyAttrValues'))# Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/others/copyAttrValues.melfrom maya import melprint(mel.eval('whatIs copyAttrValues'))# Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/others/copyAttrValues.mel &emsp;&emsp;直接 pymel.mel 就可以直接类似调用 Python 方法的方式调用 mel 函数。&emsp;&emsp;返回结果和 mel.eval 方法类似。 123import pymel.core as pmprint(pm.mel)# &lt;pymel.core.language.Mel object at 0x0000024FDFA296A0&gt; &emsp;&emsp;从上面可以看到 mel 是 pymel language.py 脚本中的 Mel 类实例。&emsp;&emsp;这个脚本当中还有 env 和 melGlobals 的实例&emsp;&emsp;env 的调用可以参考文档链接&emsp;&emsp;melGlobals 这个实例则可以获取到 mel 的全局变量。 123456import pymel.core as pmprint(pm.melGlobals['gMainWindow'])# MayaWindowfrom maya import melprint(mel.eval('$temp = $gMainWindow'))# MayaWindow &emsp;&emsp;利用上面的方法，可以完全用 Python 的调用方式来获取 Mel 才能调用的功能。 附注: Mel how to 文档有获取 Mel 所有全局变量的方法 链接 1234567891011string $allGlobals[] = `env`;$allGlobals = `sort $allGlobals`;print $allGlobals;// $AOVS// $AttrPaintInstOn// $AttrPaintPolyClr// $AttrPaintPolyShapes// $CAM_MENU_ADD// $CAM_MENU_CAMERA// $CAM_MENU_IGNORE// ... Pymel 运行 Mel 原理 &emsp;&emsp;Mel 类重载了 __getattr__ 方法。 12345678def __getattr__(self, command): if command.startswith('__') and command.endswith('__'): try: return self.__dict__[command] except KeyError: raise AttributeError, "object has no attribute '%s'" % command return MelCallable(head='', name=command) &emsp;&emsp;这个方法返回 MelCallable 实例。 123456789101112131415161718192021222324252627class MelCallable(object): """ Class for wrapping up callables created by Mel class' procedure calls. The class is designed to support chained, "namespace-protected" MEL procedure calls, like: Foo.bar.spam(). In this case, Foo, bar and spam would each be MelCallable objects. """ def __init__(self, head, name): if head: self.full_name = '%s.%s' % (head, name) else: self.full_name = name def __getattr__(self, command): if command.startswith('__') and command.endswith('__'): try: return self.__dict__[command] except KeyError: raise AttributeError, "object has no attribute '%s'" % command return MelCallable(head=self.full_name, name=command) def __call__(self, *args, **kwargs): cmd = pythonToMelCmd(self.full_name, *args, **kwargs) return Mel._eval(cmd, self.full_name) &emsp;&emsp;调用的时候会调用 pythonToMelCmd 方法，将函数名和参数转换为 mel 语句。 123import pymel.core as pmprint (pm.pythonToMelCmd('testCall',[1,2],["asd",1],True))# testCall(&#123;1,2&#125;,&#123;"asd","1"&#125;,true) &emsp;&emsp;最后调用 Mel 类的 _eval 的方法来执行 mel 语句。 &emsp;&emsp;从上面的代码可以看到 OpenMaya.MGlobal.executeCommand 利用 Maya C++ API 实现 mel 代码运行&emsp;&emsp;并通过上面的 返回值处理返回对应的数据。 附注: pm.mel 执行的返回都是字符串，并非是 PyNode 处理过的对象需要特别注意。 实用 Mel 命令汇总 &emsp;&emsp;经过上面的操作可以很方便调用 Mel 内置的函数。&emsp;&emsp;因此我们可以了解一下 Mel 内置了哪些便利的函数，可以更加方便地调用，而不需要从零开始写代码。 &emsp;&emsp;下面的代码可能默认没有加载到 Maya 里面，直接调用可能会有找不到函数的错误提示。&emsp;&emsp;这个时候可以利用 source 语句 source 脚本来解决问题 1234567pm.mel.isOnlyNurbsSelected()// Error: line 1: Cannot find procedure "isOnlyNurbsSelected". // # Error: MelUnknownProcedureError: file C:\Program Files\Autodesk\Maya2018\Python\lib\site-packages\pymel\core\language.py line 985: Error during execution of MEL script: line 1: Cannot find procedure "isOnlyNurbsSelected". # pm.mel.source('artisanValues')print (pm.mel.isOnlyNurbsSelected())0 &emsp;&emsp;如上所示通过 source 方法就可以加载到相关的 Mel 函数了 https://help.autodesk.com/cloudhelp/2018/ENU/Maya-Tech-Docs/Commands/index.html &emsp;&emsp;Mel 命令文档里面有不少函数是 M 后缀的，也就是 Mel 方法特有的，正常情况下无法通过 Python 调用。&emsp;&emsp;当然这些只是记录在文档里面的，还有一些藏在 {Maya安装目录}/scripts/others/*.mel 这个 scripts 路径下了。&emsp;&emsp;翻阅里面的 Mel 可以看到很多脚本都是 98 99 写的远古 Mel 代码。&emsp;&emsp;现在新工具新插件的代码都不用 Mel 而是 Python 了。 &emsp;&emsp;并且 Mel 有很多函数是复刻 Python 的，比如 startsWith strip dirname basename&emsp;&emsp;除此之外还有很多非常 native 的用法，调用官方的写法更加省心。 copyAttrValues &emsp;&emsp;copyAttrValues 全局函数选择两个物体，最后选择物体的通道选择上，会根据选择的通道同步属性值。&emsp;&emsp;用这个函数复制属性值非常便利，不需要再一个值一个值地进行传递。&emsp;&emsp;这个因为要选择对应的属性，更偏向于实际使用，而非代码 duplicateAttr &emsp;&emsp;duplicateAttr 和上面函数的用法类似，只是可以复制属性通道。 selectedChannelBoxAttributes12selectedChannelBoxAttributes;// Result: tx ty tz rx ry // &emsp;&emsp;selectedChannelBoxAttributes 获取当前通道盒选中的属性值 selectedChannelBoxPlugs12selectedChannelBoxPlugs;// Result: pSphere1.tx pSphere1.ty pSphere1.tz pSphere1.rx pSphere1.ry pSphere2.tx pSphere2.ty pSphere2.tz pSphere2.rx pSphere2.ry // &emsp;&emsp;selectedChannelBoxPlugs 获取当前通道盒选中的通道插槽 selectedChannelBoxObjects12selectedChannelBoxObjects;// Result: pSphere1 pSphere2 // &emsp;&emsp;selectedChannelBoxObjects 注意必须是选中通道才可以获取到物体 raiseChannelBox &amp; isChannelBoxRaised &emsp;&emsp;raiseChannelBox 将通道盒置顶&emsp;&emsp;isChannelBoxRaised 判断通道盒是否置顶 findRelatedDeformer12345678import pymel.core as pm# NOTE 创建球体pm.mel.CreatePolygonSphere()# NOTE 创建Blendshapepm.mel.CreateBlendShape()# NOTE 获取创建的变形器print (pm.mel.findRelatedDeformer(pm.selected()[0]))# [u'blendShape1', u'tweak1'] &emsp;&emsp;利用这个获取到 blendshape 等关联的变形器节点。&emsp;&emsp;蒙皮节点也属于变形器的一种，因此也可以获取。 findRelatedSkinCluster1234567import pymel.core as pmjnt = pm.joint()sphere, = pm.polySphere(ch=0)pm.select(jnt,sphere)pm.mel.SmoothBindSkin()print (pm.mel.findRelatedSkinCluster(sphere))# skinCluster1 &emsp;&emsp;与上面的方法类似，只是针对获取蒙皮节点。&emsp;&emsp;利用这个方法获取蒙皮节点非常省事 getFaces &amp; getEdges &amp; getUVs &amp; getVerts getFacesgetEdgesgetUVsgetVerts &emsp;&emsp;上面四个函数可以在不同的选择的 component 下切换。 attributeExists123456import pymel.core as pmsphere, = pm.polySphere(ch=0)print(pm.mel.attributeExists("tx",sphere))# 1print(pm.mel.attributeExists("ta",sphere))# 0 &emsp;&emsp;这个函数可以非常方便地判断属性是否存在。 rootOf &amp; longNameOf &amp; shortNameOf123456789import pymel.core as pmsphere, = pm.polySphere(ch=0)pm.mel.Group()print (pm.mel.rootOf(sphere))# |group1print (pm.mel.longNameOf(sphere))# |group1|pSphere1print (pm.mel.shortNameOf(sphere))# pSphere1 &emsp;&emsp;这些功能其实 pymel 都有所覆盖&emsp;&emsp;还有 isSameObject isParentOf 就不再赘述了。 getCurrentCamera &amp; getPanelCamera1234567891011121314import pymel.core as pmcamera = pm.mel.getCurrentCamera()panel = pm.mel.getCameraPanel(camera)print(panel)# modelPanel4# NOTE 传统方法active_mp = Nonefor mp in pm.getPanel(type="modelPanel"): if pm.modelEditor(mp, q=1, av=1): active_mp = mp breakprint(active_mp)# modelPanel4 &emsp;&emsp;利用 mel 封装的方法可以非常方便获取到当前聚焦的 ModelPanel&emsp;&emsp;缺点就是脚本编辑器下聚焦不在 modelPanel 用 mel 运行获取不到具体的 modelPanel 需要做成 工具架按钮触发才可以。 getCurrentOutlinerPanel123import pymel.core as pmprint(pm.mel.getCurrentOutlinerPanel())# outlinerPanel1 &emsp;&emsp;获取当前聚焦的 Outliner&emsp;&emsp;同样需要注意在 脚本编辑器下执行聚焦点不在 outliner 没有返回值 getSceneName123import pymel.core as pmprint(pm.mel.getSceneName())# untitled &emsp;&emsp;直接获取当前文件名(不带后缀)，可以和 pm.sceneName() 方法获取文件路径相辅相成。 getAssignedMaterials &amp; getConnectedShaders &amp; createAndAssignShader123456import pymel.core as pmsphere, = pm.polySphere(ch=0)pm.mel.source("cpvTexture")materials = pm.mel.getAssignedMaterials(sphere.getShape()))print(materials)# [u'lambert1'] &emsp;&emsp;getAssignedMaterials 可以直接通过 shape 节点获取到关联的材质。 12whatIs getAssignedMaterials;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/unsupported/cpvTexture.mel // &emsp;&emsp;需要注意这个函数在 unsupported 目录下，默认不加载，需要 source 文件，也不排除哪天就没了(:з」∠)&emsp;&emsp;所以我推荐另一个自带的方法 getConnectedShaders 12345678import pymel.core as pmsphere, = pm.polySphere(ch=0)sg_list = pm.mel.getConnectedShaders(sphere,0)print(sg_list)# [u'initialShadingGroup']for sg in sg_list: print (pm.PyNode(sg).listConnections(type="shadingDependNode"))# [nt.Lambert(u'lambert1')] &emsp;&emsp;getConnectedShaders 可以快速获取模型的 shadingEngine 节点，通过这个节点可以找到关联的材质。 shadingDependNode 是所有渲染节点的基类，囊括了所有的材质以及一些不搭噶的渲染节点。 123456789import pymel.core as pmsphere, = pm.polySphere(ch=0)faces = [sphere.f[i] for i in range(100)]pm.select(faces)# NOTE 创建并添加材质pm.mel.createAndAssignShader("blinn","")sg_list = pm.mel.getConnectedShaders(sphere,True)print(sg_list)# [u'initialShadingGroup', u' pSphere2.f[100:399]', u'blinn2SG', u' pSphere2.f[0:99]'] &emsp;&emsp;getConnectedShaders 第二个参数为 True 时可以获取到详细关联 shadingEngine 和 component 的数据。 gotoBindPose12import pymel.core as pmpm.mel.gotoBindPose() &emsp;&emsp;绑定下可以利用这个命令回到 bindpose 状态。 deleteIfNotReferenced12345678import pymel.core as pmsphere, = pm.polySphere(ch=0)print (pm.mel.deleteIfNotReferenced(sphere))# 1sphere, = pm.polySphere(ch=0)sphere.lock() # 注: 锁定节点无法删除 print (pm.mel.deleteIfNotReferenced(sphere))# 0 &emsp;&emsp;更加安全的删除命令，无法删除的物体返回 0 replaceNodehttps://ilmvfx.wordpress.com/2014/01/27/how-do-i-change-a-materials-type-from-lambert-to-blinn-for-example-using-mel-chs/参考上面的链接 Mel How-to 系列 &emsp;&emsp;这个命令就是实现材质替换的功能，不过理论上可以替换任何 Maya 节点。 1234import pymel.core as pmsphere,sphere_node = pm.polySphere(ch=1)cube,cube_node = pm.polyCube(ch=1)pm.mel.replaceNode(sphere_node,cube_node) &emsp;&emsp;上面执行生成了两个 方块， 因为利用 replaceNode 将 球体生成节点 替换为了 方块生成节点。 总结 &emsp;&emsp;以上就是关于 pymel 的用法探索，有机会还要加一篇文章分析 pymel 的实现原理，这个库简直是神器。&emsp;&emsp;虽然 pymel 存在一定的性能问题，但是它的背后其实都是调用 OpenMaya1.0 的API，如果在高性能情况下用 pymel 转换为 C++ 的方式调用，性能未必就差的，pymel 有内置的 api 转换方法，有机会也补充一下~]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 导出场景的 Actor 为 FBX]]></title>
    <url>%2Fposts%2Fa6d6fe7d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上周的时候，有网友问过我相关的导出场景模型的问题。&emsp;&emsp;当时他给我发了一篇微信公众号的文章 链接&emsp;&emsp;导出需要附带 矩阵信息 实在是太麻烦了，其实并不需要如此的复杂。&emsp;&emsp;碍于时间实在是太仓促，没有时间详细分析我这边具体的操作流程。&emsp;&emsp;遂抽空总结了一波，并且在总结的逛论坛的时候发现了更好导出的方案。 MergeStaticActor 方案 &emsp;&emsp;最开始分析这个问题，我首先想到的是对 Actor 右键能否直接导出模型。&emsp;&emsp;然而却没有发现相关的方案，于是只能采用对 StaticMesh 等静态资源导出模型的方案了。&emsp;&emsp;但是采用这个方案，通过遍历场景的模型可以找到关联的静态模型，导出却没有了 场景的 位置，只能按照上面链接的方式，将矩阵重新实现一遍吗？&emsp;&emsp;经过我对 Actor 右键的研究，我发现可以通过 Merge Actors 合并生成一个带世界坐标位置的新 StaticMesh ，通过这个 Mesh 导出 FBX 就是带世界坐标位置的模型了。 &emsp;&emsp;配置窗口勾选 Pivot Point at Zero 点击下方的 Merge Actors 会生成一个带世界坐标的 StaticMesh 静态模型资产。&emsp;&emsp;随后右键进行导出即可。 &emsp;&emsp;使用这个方案需要遍历场景中需要导出的资源，然后将临时的静态资源生成到临时的目录里，然后再逐个导出即可，最后再把临时目录删除干净。&emsp;&emsp;Python 都提供了相应的 API 可以批量处理执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253level_lib = unreal.EditorLevelLibraryasset_lib = unreal.EditorAssetLibraryselected_static_actors = [ a for a in level_lib.get_selected_level_actors() if isinstance(a, unreal.StaticMeshActor) ]options = unreal.EditorScriptingMergeStaticMeshActorsOptions()options.set_editor_property("destroy_source_actors", False)options.set_editor_property("spawn_merged_actor", False)setting = unreal.MeshMergingSettings()# NOTE 保留 Actor 的坐标setting.set_editor_property("pivot_point_at_zero", True)options.set_editor_property("mesh_merging_settings", setting)# NOTE 配置 FBX 导出选项fbx_exporter = unreal.StaticMeshExporterFBX()fbx_option = unreal.FbxExportOption()fbx_option.export_morph_targets = Falsefbx_option.export_preview_mesh = Falsefbx_option.level_of_detail = Falsefbx_option.collision = Falsefbx_option.export_local_time = Falsefbx_option.ascii = Falsefbx_option.vertex_color = True# NOTE 在工程里面创建一个临时导出路径temp_directory = "/Game/Temp_FBX_Export"# NOTE 设置 FBX 导出路径export_path = r"C:\FBX_EXPORT"for actor in selected_static_actors: actor_name = actor.get_name() asset_path = posixpath.join(temp_directory, actor_name) options.set_editor_property("base_package_name", asset_path) # NOTE 将选中的 Actor 合并为 StaticMesh 资源 level_lib.merge_static_mesh_actors([actor], options) fbx_path = os.path.join(export_path, "%s.fbx" % actor_name) mesh = unreal.load_asset(asset_path) task = unreal.AssetExportTask() task.set_editor_property("object", mesh) task.set_editor_property("filename", fbx_path) task.set_editor_property("exporter", fbx_exporter) task.set_editor_property("automated", True) task.set_editor_property("prompt", False) task.set_editor_property("options", fbx_option) unreal.Exporter.run_asset_export_task(task)# NOTE 删除临时目录asset_lib.delete_directory(temp_directory) &emsp;&emsp;上面的代码就可以实现选中场景的静态模型导出 FBX 的效果，每个 Actor 都是单独的 Mesh 进行命名导出。 导出贴图资源 &emsp;&emsp;可以看到上面的方案导出如果是没有带上贴图的，如果需要贴图，需要从 Unreal 的材质里面查找。&emsp;&emsp;这里我可以通过依赖关系的方式找到模型关联的材质。&emsp;&emsp;然后也通过依赖的方式将关联的贴图全部导出来。&emsp;&emsp;这样可以实现宁可误杀，绝不放过的将所有贴图导出。 1234567891011121314151617181920212223242526272829303132mesh_lib = unreal.EditorStaticMeshLibrarydef ls_dependencies(path): # NOTE 获取资产的依赖资产 data = asset_lib.find_asset_data(path) options = unreal.AssetRegistryDependencyOptions() dependencies = asset_registry.get_dependencies(data.package_name, options) return dependenciestotal = mesh_lib.get_number_materials(mesh)for i in range(total): material = mesh.get_material(i) textures = ls_dependencies(material.get_path_name()) for texture_path in textures: data = asset_lib.find_asset_data(texture_path) # NOTE 过滤非贴图资产 | 不用 `isinstance` 的方式可以不用加载资产 if not issubclass(getattr(unreal,str(data.asset_class)), unreal.Texture): continue texture_name = str(data.asset_name) tga_path = os.path.join(texture_folder, "%s.tga" % texture_name) tga_exporter = unreal.TextureExporterTGA() mesh = unreal.load_asset(asset_path) task = unreal.AssetExportTask() task.set_editor_property("object", data.get_asset()) task.set_editor_property("filename", tga_path) task.set_editor_property("exporter", tga_exporter) task.set_editor_property("automated", True) task.set_editor_property("prompt", False) task.set_editor_property("options", fbx_option) unreal.Exporter.run_asset_export_task(task) &emsp;&emsp;通过 ls_dependencies 的方式将静态资产关联的所有资产全部罗列出来。&emsp;&emsp;然后通过 AssetData 获取相关的数据。&emsp;&emsp;最后可以获取到关联在材质上的贴图导出。&emsp;&emsp;如果想要在 DCC 重建贴图需要将相关的 Diffuse Normal 贴图信息导出去，比如用 Json 进行存储，然后 DCC 端写一个读取配置工具。根据记录的贴图数据将关联的贴图贴到 DCC 材质的相关贴图通道上。 直接导出场景模型方案 &emsp;&emsp;上面的方案有个缺点，只能导出静态资产，如果是 SkeletalMesh 或者是 Foliage 相关的 Mesh 都无法导出。&emsp;&emsp;因为 EditorScriptingMergeStaticMeshActorsOptions 这个类只对 静态模型 起作用。&emsp;&emsp;然而 Unreal 的 Level 是可以直接导出场景所有的资产的。&emsp;&emsp;那么有没有解决问题的办法呢？&emsp;&emsp;非常凑巧，最近逛 Unreal 的论坛还真就找到了更加简单的方法。 https://forums.unrealengine.com/t/python-convert-actors-to-static-mesh/152073 1234567891011121314151617181920212223import unreallevel_lib = unreal.EditorLevelLibraryoutput_file = r'C:\FBX_EXPORT\ue4_output.fbx' selected_actors = level_lib.get_selected_level_actors()if len(selected_actors) == 0: print("No actor selected, nothing to export") quit() task = unreal.AssetExportTask()# NOTE 关键在于设置当前 world 为导出对象task.object = level_lib.get_editor_world()task.filename = output_file# NOTE 加上 selected 只导出选中的物体task.selected = Truetask.replace_identical = Falsetask.prompt = Falsetask.automated = Truetask.options = unreal.FbxExportOption()task.options.vertex_color = Falsetask.options.collision = Falsetask.options.level_of_detail = Falseunreal.Exporter.run_asset_export_task(task) &emsp;&emsp;使用这个方案可以导出 Foliage landscape 等特殊的 Actor &emsp;&emsp;只是使用这个方案查询材质需要在 关联的 component 下进行操作。 12345678for actor in unreal.EditorLevelLibrary.get_selected_level_actors(): comp = actor.root_component for comp in comp.get_children_components(True): # NOTE 查询继承于静态模型的 component if isinstance(comp,unreal.StaticMeshComponent): mesh = comp.static_mesh print(mesh) # NOTE 再通过 mesh 查找材质和贴图 &emsp;&emsp;通过上面的代码可以获取到关联继承的 StaticMeshComponent&emsp;&emsp;即便 InstancedFoliageActor 没有材质模型贴图的属性显示。 &emsp;&emsp;还是可以通过获取 actor 的 component 找到 FoliageInstancedStaticMeshComponent ，从而找到关联的 static_mesh 总结 &emsp;&emsp;至于在 DCC 里面重建贴图的方式没有细说。&emsp;&emsp;其实可以通过通配符匹配 _N _D 后缀的贴图，然后将这些通用的贴图在 DCC 里面自动连接上。&emsp;&emsp;主要通过 json 的配置描述每个 fbx 关联的贴图即可。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Qt.py loadUi 问题记录]]></title>
    <url>%2Fposts%2F50c81a5e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;2年前我还在华强的时候，就发掘了 Qt.py 内置了一个超棒的功能。&emsp;&emsp;可以动态加载 ui 文件生成界面，而不需要pyside-uic 进行代码组装。 &emsp;&emsp;但是不知道什么时候开始，我就发现在 Maya 使用 loadUi 的方案不灵了。&emsp;&emsp;偶尔会遇到 C++ 被删除的错误。&emsp;&emsp;后来鉴于稳定性考虑，我写了一个 compile 脚本来实现自动生成 ui python 文件。&emsp;&emsp;下面我就来总结一下一路走来的情况。 问题再现 &emsp;&emsp;去年的时候偶然发现 Maya 里面原来还有 mayaMixin 的库 链接&emsp;&emsp;可以继承一个类来实现 Maya 内置的 Qt 窗口，这样就不需要用以前那种将 Maya 窗口转为 Qt 再嵌入 UI 的奇怪方式了。 旧方案窗口生成 链接 &emsp;&emsp;如果没记错的话，自从用上了 mayaMixin 的方式生成的 ui 在特定的情况下就会导致调用错误 1234# Traceback (most recent call last):# File "G:\run_maya.py", line 85, in test_call# print(self.Test_LE.text())# RuntimeError: Internal C++ object (PySide2.QtWidgets.QLineEdit) already deleted. 12def test_call(self): print(self.Test_LE.text()) &emsp;&emsp;点击按钮只是触发 QLineEdit 的文本信息而已。&emsp;&emsp;这里只要是继承了 mayaMixin.MayaQWidgetBaseMixin 这个类&emsp;&emsp;然后使用 Qt.py 提供的 QtCompat.loadUi 方法显示窗口。&emsp;&emsp;就有可能出现这个问题。 &emsp;&emsp;但是这出错并不是无法读取 ui 文件生成界面，而是点击按钮去读取一些组件数据的时候。&emsp;&emsp;比如通过 button 读取 QLineEdit 的 text 的时候就会有上面的出错提示。&emsp;&emsp;但是这个在 __init__ 方法中调用相关的 组件 数据是没有问题。&emsp;&emsp;于是我通过 QTimer.singleShot 进行测试，发现只要延时执行 50 毫秒就会出现 C++ 被删除的问题。&emsp;&emsp;于是很自然想到这些生成的 ui 可能没有被类或者全局变量挂载，所以被垃圾回收了。 &emsp;&emsp;然而这个问题要如何解决呢？&emsp;&emsp;我最初推测是 Qt.py 的 load_ui 方法有问题。&emsp;&emsp;于是去研究了源码，源码就是 继承了 QUiLoader 这个类可以实现自定义的组件挂载功能 Qt文档链接&emsp;&emsp;于是我修改了 Qt.py 的源码，给每个生成的组件添加了 destroyed 打印的功能&emsp;&emsp;这样如果 QObject 被 垃圾回收 了 应该会输出删除的信息。&emsp;&emsp;然而奇葩就出现了，毕竟 UI 是能够显示出来的，说明它并没有删除，但是用 self 去调用相关的函数就会提示 C++ 删除了。&emsp;&emsp;这个问题让我百思不得其解，而且也只有 Maya 有这个问题，在 Unreal 的环境下并没有这个问题。 compile.py 自动生成 ui python 脚本 &emsp;&emsp;因为问题的症结不是很清楚，至少还有出脚本的方案可以走。&emsp;&emsp;于是我就走了一遍 PySide2-uic 编译的流程 操作链接&emsp;&emsp;果然这个方案是可以用，于是我就写了一个 python 脚本自动将脚本目录下所有的 ui 文件自动编译生成 python 文件。 脚本链接 &emsp;&emsp;当然脚本里面的 Qt.py 路径 和 Maya 路径都需要自行进行配置。&emsp;&emsp;最后经过对 Qt.py 源码的阅读，还发现它有命令行功能，可以将编译的 python 文件转成 Qt.py 下的规范。&emsp;&emsp;只是会额外生成 _backup 备份文件，属于 Qt.py 实验性的隐藏功能。 优势 提升启动效率 能提供代码提示缺点 需要手动触发一下编译才能更新 ui mayaMixin 最后的挣扎 &emsp;&emsp;后来我也查了 mayaMixin 的源码，查清楚到底是哪里的缺漏导致。&emsp;&emsp;于是发现官方的方案 和我以前自己想出来的第三种方案有很大的相似之处 链接&emsp;&emsp;也是将生成的窗口 parent 到 Maya 窗口的方案。&emsp;&emsp;但是当时我写文章的时候记得，parent 一定要在 __init__ 函数里面传入，只是调用 setParent 会引发 C++ 问题。&emsp;&emsp;于是我就转换思路，利用 QtWidgets.QApplication.activeWindow() 获取当前的窗口。&emsp;&emsp;然后传入到 __init__ ，虽然窗口会生成到左上角去了，不过的确解决了我的问题。 maya cmds.window 嵌入 &emsp;&emsp;后来我再整合了以前使用嵌入方案。 1234567891011121314151617181920212223242526272829303132333435class MayaShowMixin(object): @classmethod def maya_show(cls, win_name=""): from Qt.QtCompat import wrapInstance from maya import cmds, OpenMayaUI def maya_to_qt(name): # Maya -&gt; QWidget ptr = OpenMayaUI.MQtUtil.findControl(name) if ptr is None: ptr = OpenMayaUI.MQtUtil.findLayout(name) if ptr is None: ptr = OpenMayaUI.MQtUtil.findMenuItem(name) if ptr is not None: return wrapInstance(long(ptr), QtWidgets.QWidget) win_name = win_name if win_name else cls.__name__ # NOTE 如果变量存在 就检查窗口多开 if cmds.window(win_name, q=1, ex=1): cmds.deleteUI(win_name) instance = cls() window = cmds.window(win_name, title=instance.windowTitle()) cmds.showWindow(window) # NOTE 将Maya窗口转换成 Qt 组件 cls.__maya_window__ = maya_to_qt(window) layout = QtWidgets.QVBoxLayout() cls.__maya_window__.setLayout(layout) layout.setContentsMargins(0, 0, 0, 0) layout.addWidget(instance) cls.__maya_window__.setMaximumSize(instance.maximumSize()) cls.__maya_window__.setMinimumSize(instance.minimumSize()) return cls.__maya_window__ &emsp;&emsp;这样就可以实现 mayaMixin 类似的效果。&emsp;&emsp;需要注意这个方案，利用 maya_to_qt 转换的窗口需要有变量挂载。&emsp;&emsp;否则会招致上面的 C++ 删除的问题。&emsp;&emsp;这里我将它挂载到类里面。 &emsp;&emsp;这个方法利用 cmds 来构建窗口。&emsp;&emsp;好处是可以记录窗口打开的位置和大小。 总结 &emsp;&emsp;最后我还是采用了 compile.py 的方案，缺点就是没办法让 QtDesigner 在保存的时候给我自动编译。&emsp;&emsp;需要我手动触发一下，有需要的话也可以用 Qt 框架的 QFileSystemWatcher 来写个监听实现自动编译。 &emsp;&emsp;说到做到，就结合 QFileSystemWatcher 整出个自动监听 ui 变化的功能出来了 脚本链接 2021-4-28 dayu_widgets 的相关问题 &emsp;&emsp;今天发现 dayu_widgets 在 Maya2020 下生成 Python 代码运行会出错。 &emsp;&emsp;如上图所示在 Maya 2020 下运行出错，主要原因是 MPushButton(QWidget()) 传入 QWidget 类&emsp;&emsp;会导致触发 QPushButton.setText(QWidget()) 函数导致出错。&emsp;&emsp;但是如果使用 Qt.py 的 loadUi 方式就不会报错，也就是调用 QUiLoader 类可以兼容 Maya2020&emsp;&emsp;至于为何 Maya2020 为何如此特殊，主要原因是 Maya 2020 升级了 Qt 的版本，所以内核会有所不同。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 材质属性传递工具]]></title>
    <url>%2Fposts%2F34fd0fc0.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近遇到一个需求，需要做一个 Unreal 材质实例属性传递工具。&emsp;&emsp;Unreal 有内置批量属性编辑工具，但是似乎对无法实现材质实例属性的批量修改。 &emsp;&emsp;于是我利用 Python Qt 开发一个可以批量传递材质属性的工具。 &emsp;&emsp;上面的界面结合了之前研究的 Python Qt Overlay 堆叠组件 ，让界面维护更方便，UI 排列更紧凑。 基于材质编辑器实例的材质树获取 &emsp;&emsp;制作这个工具需要解决的问题是如何从材质里面知道材质的分组，分组从而构建出树形结构。 &emsp;&emsp;最初我是想通过材质编辑器上面的参数组来获取这个关系，为此还研究了很多 MaterialEditorInstance 相关的东西。&emsp;&emsp;但是这玩意就是个巨坑，研究到最后发现修改的是 UI 的数据，没法改到材质属性，还是得借助 MaterialEditingLibrary 库对材质修改属性才可行(:з」∠) &emsp;&emsp;基于上一篇文章研究 Unreal Python 利用 UtilityWidget 编写 UMG 工具界面 可以通过 C++ 罗列出所有的 UObject&emsp;&emsp;通过上面的黑科技结合以前 list_menu 的方法，我可以获取到所有的 MaterialEditorInstanceConstant 类型 1234567def list_material_editor(num=1000): return [ unreal.load_object( None, "/Engine/Transient.MaterialEditorInstanceConstant_%s" % i ) for i in range(num) ] &emsp;&emsp;然而这个获取到的并非是当前打开的编辑窗口。&emsp;&emsp;有可能是已经关闭的老窗口。&emsp;&emsp;因此需要用 C++ 获取当前正在编辑的资产，然后再获取 MaterialEditorInstanceConstant 里面所属的材质&emsp;&emsp;判断哪个是最新的材质面板 1234567891011121314151617181920212223242526UMaterialInstanceConstant *UPyToolkitBPLibrary::GetMaterialEditorSourceInstance(UMaterialEditorInstanceConstant *Editor)&#123; return Editor-&gt;SourceInstance;&#125;UObject *UPyToolkitBPLibrary::GetFocusedEditAsset()&#123; UAssetEditorSubsystem *sub = GEditor-&gt;GetEditorSubsystem&lt;UAssetEditorSubsystem&gt;(); UObject *FocusObject = nullptr; double maxLastActivationTime = 0.0; for (UObject *EditedAsset : sub-&gt;GetAllEditedAssets()) &#123; auto openedEditor = sub-&gt;FindEditorForAsset(EditedAsset, false); if (openedEditor &amp;&amp; openedEditor-&gt;GetLastActivationTime() &gt; maxLastActivationTime) &#123; maxLastActivationTime = openedEditor-&gt;GetLastActivationTime(); FocusObject = EditedAsset; &#125; &#125; return FocusObject;&#125; &emsp;&emsp;结合上面两个 C++ 就可以获取到当前正在编辑的 材质编辑器 1234567891011121314py_lib = unreal.PyToolkitBPLibrary()def list_material_editor(num=1000): material_editor = &#123;&#125; for i in range(num): editor = unreal.load_object(None,"/Engine/Transient.MaterialEditorInstanceConstant_%s" % i) if editor: material = py_lib.get_material_editor_source_instance(editor) if material: material_editor[material] = editor return material_editoredit_asset = py_lib.get_focused_edit_asset()material_editor = list_material_editor()editor = material_editor.get(edit_asset) &emsp;&emsp;通过 遍历 objects 的方式可以获取材质编辑器下的 DEditorParameterValue &emsp;&emsp;通过这个方法可以直接修改 MaterialEditor UI 下的选项。 123456789py_lib = unreal.PyToolkitBPLibrary()param = unreal.load_object(None,"/Engine/Transient.DEditorScalarParameterValue_0")print(py_lib.get_all_properties(param))# ["ParameterValue", "bOverride", "ParameterInfo"]info = param.get_editor_property("ParameterInfo")print(info.name)# Input Pattern Lightparam.set_editor_property("bOverride",True)param.set_editor_property("ParameterValue",0.5) &emsp;&emsp;可以用我以前写的 get_all_properties C++ 函数获取 UObject 内置的 property&emsp;&emsp;当然直接查 C++ 源码也可以查到 UProperty ，只有 EditAnywhere 的属性可以被 Python 修改。 &emsp;&emsp;然而这个只是 UI 层面的修改，并没有修改到 材质 内置的属性数据。&emsp;&emsp;当我关闭编辑器重新打开，数据又回滚到之前的状态了。&emsp;&emsp;所以折腾了一圈放弃了这个方案。 基于母材质数据的获取 &emsp;&emsp;上面的方案需要打开材质编辑器，而且也无法通过修改 UI 来改到材质实例的数据。&emsp;&emsp;于是我深挖了引擎的 C++ 的代码。(花了我很多时间(:з」∠))&emsp;&emsp;最后发现这个材质组是通过 母材质 的 MaterialExpression 来解析分组的。 &emsp;&emsp;有了这个之后，我也可以用类似的方法用 Python 调用实现材质属性树的构建。&emsp;&emsp;然而 Python 无法直接获取材质的 Expressions ， 需要使用 C++ 包装一个函数进行获取。 123456789TArray&lt;UMaterialExpression *&gt; UPyToolkitBPLibrary::GetMaterialExpressions(UMaterial *Material)&#123; return Material-&gt;Expressions;&#125;TArray&lt;UMaterialExpression *&gt; UPyToolkitBPLibrary::GetMaterialFunctionExpressions(UMaterialFunction *Function)&#123; return Function-&gt;FunctionExpressions;&#125; &emsp;&emsp;添加上面两个 C++ 函数进行 Python 调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import jsonfrom collections import defaultdictpy_lib = unreal.PyToolkitBPLibrarymat_lib = unreal.MaterialEditingLibrarydef cast(typ, obj): """ unreal cast 类型转换 """ try: return getattr(unreal, typ).cast(obj) except: return None def _get_material_paramters(expressions): """ inspire by https://github.com/20tab/UnrealEnginePython/issues/103 reference from MaterialFunctionInterface.h `GetParameterGroupName` """ paramters = defaultdict(set) for expresion in expressions: # NOTE 查找 material function 内部节点 func = cast("MaterialExpressionMaterialFunctionCall", expresion) if func: func = func.get_editor_property("material_function") expressions = py_lib.get_material_function_expressions(func) # NOTE 递归查找参数节点 params = _get_material_paramters(expressions) for group, param in params.items(): for p in param: paramters[str(group)].add(str(p)) continue # NOTE 查找转换参数节点 param = cast("MaterialExpressionParameter", expresion) if not param: param = cast("MaterialExpressionTextureSampleParameter", expresion) if not param: param = cast("MaterialExpressionFontSampleParameter", expresion) # NOTE 查找参数节点的 分组 和 参数命名 if param: group = param.get_editor_property("group") parameter_name = param.get_editor_property("parameter_name") paramters[str(group)].add(str(parameter_name)) return paramtersdef get_material_paramters(material): # NOTE 获取材质属性的命名 scalars = mat_lib.get_scalar_parameter_names(material) vectors = mat_lib.get_vector_parameter_names(material) switches = mat_lib.get_static_switch_parameter_names(material) textures = mat_lib.get_texture_parameter_names(material) # NOTE 获取材质的母材质 parent_material = material.get_base_material() # NOTE 获取 expression (包含所有材质节点) expressions = py_lib.get_material_expressions(parent_material) # NOTE 获取所有的参数节点按照 grp : [parameter_name] 排列 paramters = _get_material_paramters(expressions) collections = defaultdict(dict) # NOTE 对上面获取的数据重新排序 | 并获取对应的 value 值 for grp, params in sorted(paramters.items()): for p in sorted(params): value = None if p in textures: func = mat_lib.get_material_instance_texture_parameter_value value = func(material, p) value = value.get_path_name() elif p in switches: value = mat_lib.get_material_instance_static_switch_parameter_value( material, p ) elif p in vectors: func = mat_lib.get_material_instance_vector_parameter_value value = func(material, p) # NOTE 构建 RGBA 字符串 value = "|".join( [ "%s : %-10s" % (c.upper(), round(getattr(value, c), 2)) for c in "rgba" ] ) elif p in scalars: func = mat_lib.get_material_instance_scalar_parameter_value value = func(material, p) collections[grp][p] = value return collectionsmaterial = unreal.load_asset('/Game/ParagonShinbi/Characters/Heroes/Shinbi/Materials/M_Shinbi_Legs_Inst_2.M_Shinbi_Legs_Inst_2')params = get_material_paramters(material)print(json.dumps(params)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&#123; "None": &#123; "DisplaceValue": "R : 0.0 |G : 0.0 |B : 326.06 |A : 0.0 ", "SilkROUGHNESS": 4.0, "HitFlashBrightness": 0.20000000298023224, "Input Pattern Light": 1.0, "asdcasdfasdfasdf": 60.0, "Damage": 0.0, "Input Pattern Dark": 1.0, "IriExponent": 0.20000000298023224, "RGB": "/Game/ParagonShinbi/Characters/Heroes/Shinbi/Textures/T_Shinbi_Lower_RGB.T_Shinbi_Lower_RGB", "Fabric GrungeTint": "R : 0.73 |G : 0.73 |B : 0.73 |A : 1.0 ", "BrightnessAdjust": 1.25, "VertexDisplacePower": 1.5, "Fabric Trans": 1.0, "BaseColortint": "R : 0.99 |G : 1.0 |B : 1.1 |A : 1.0 ", "GoldScratchColor1": "R : 1.0 |G : 1.0 |B : 1.0 |A : 1.0 ", "IriMask": 0.029999999329447746, "goldMetGrimeColor": "R : 0.0 |G : 0.0 |B : 0.0 |A : 1.0 ", "Normal": "/Game/ParagonShinbi/Characters/Heroes/Shinbi/Textures/T_Shinbi_Lower_N.T_Shinbi_Lower_N", "Color1": "R : 0.1 |G : 0.1 |B : 0.1 |A : 0.0 ", "Color0": "R : 0.0 |G : 0.0 |B : 0.0 |A : 0.0 ", "MaskHardness": 2.0, "fgjgjghg": 4.03448486328125, "ScaleNormal": "R : 1.0 |G : 1.0 |B : 0.4 |A : 0.0 ", "RMax": 2.112884998321533, "Mask": "/Game/ParagonShinbi/Characters/Heroes/Shinbi/Textures/T_Shinbi_Lower_Mask.T_Shinbi_Lower_Mask", "RMin": 0.20569999516010284, "Alum Roughness": 0.46039101481437683, "GoldScratchColor": "R : 0.07 |G : 0.07 |B : 0.07 |A : 1.0 ", "Mask_1": "/Game/ParagonShinbi/Characters/Heroes/Shinbi/Textures/T_Shinbi_Lower_Mask_1.T_Shinbi_Lower_Mask_1", "NoiseTextureSize": "R : 100.0 |G : 100.0 |B : 100.0 |A : 0.0 ", "Fabric Scratch Tint": "R : 1.5 |G : 1.5 |B : 1.5 |A : 1.0 ", "Color": "/Game/ParagonShinbi/Characters/Heroes/Shinbi/Textures/T_Shinbi_Legs_Colour.T_Shinbi_Legs_Colour", "BaseColorDiv": "R : 0.27 |G : 0.37 |B : 0.56 |A : 1.0 ", "adsfsadf": 0.25, "ScalpColour": "R : 0.2 |G : 0.06 |B : 0.06 |A : 1.0 ", "asdfasdf": 0.30000001192092896, "ScratchRopughness": 0.8521010279655457, "BackMetalColorB": "R : 0.68 |G : 0.64 |B : 0.71 |A : 1.0 " &#125;, "Variant": &#123; "Base Silk Color": "R : 0.41 |G : 0.09 |B : 0.31 |A : 1.0 ", "Scatter Silk Color": "R : 0.22 |G : 0.11 |B : 0.22 |A : 1.0 ", "Base Fabric Color": "R : 1.0 |G : 1.0 |B : 1.0 |A : 1.0 ", "AlumMetColor": "R : 2.0 |G : 2.0 |B : 2.0 |A : 1.0 ", "BackMetalColorA": "R : 0.0 |G : 0.0 |B : 0.0 |A : 1.0 " &#125;, "FadeDeath": &#123; "FadeOut": 0.0, "FadeMask": "/Game/ParagonShinbi/Characters/Global/MaterialFunctions/Textures/T_AtmosphericCloudNoise03.T_AtmosphericCloudNoise03" &#125;&#125; &emsp;&emsp;构建了上面的数据就可以通过 QTreeView 将数据显示出来了。 dayu_widgets MTreeView 显示字典数据 &emsp;&emsp;我当时使用 dayu_widgets 的时候还没有 QTreeView 的使用案例。&emsp;&emsp;后来我联系作者给提供了一个。 &emsp;&emsp;dayu_widgets 对 MVC 做了不少简化，用法其实和我之前 批量改名工具 大差不差。&emsp;&emsp;只是数据多了 children 用来做 collapse 用法链接 &emsp;&emsp;用法上先定义 header_list 定义 view 的数据 123456789101112131415self.property_model = MTableModel()columns = &#123;u"property": "属性名", u"value": "数值"&#125;self.property_header_list = [ &#123; "label": label, "key": key, "bg_color": lambda x, y: y.get("bg_color", QtGui.QColor("transparent")), "checkable": i == 0, "searchable": True, "width": 300, "font": lambda x, y: &#123;"bold": True&#125;, &#125; for i, (key, label) in enumerate(columns.items())]self.property_model.set_header_list(self.property_header_list) &emsp;&emsp;后续添加数据 1234567891011121314151617181920if isinstance(asset, unreal.MaterialInterface): data = self.get_material_parameters(asset)data_list = [ &#123; "property": group, "value": "", "children": [ &#123; "bg_color": QtGui.QColor("transparent"), "property": prop, # NOTE 如果想要选项勾选上可以 用 `&#123;key&#125;_checked` 的属性配置勾选 # "property_checked": QtCore.Qt.Checked, "value": value, &#125; for prop, value in props.items() ], &#125; for group, props in data.items()]self.property_model.set_data_list(data_list) &emsp;&emsp;上面 header 定义的 key ， 会在 data_list 中作为显示。&emsp;&emsp;加入 children 数据作为 collapse 数据。&emsp;&emsp;另外直接设置数据的 bg_color 可以设置背景色。 &emsp;&emsp;我加了功能，当我选择右侧的资产列表时候，左侧的的 TreeView 会检测当前资产下的材质树勾选的选项是否可以传递。&emsp;&emsp;可以传递标注绿色，不可传递标注红色。 属性传递 &emsp;&emsp;大部分参数设置都可以借助 MaterialEditingLibrary 来完成&emsp;&emsp;唯独缺了 set_static_switch_parameter_names 的设置函数。 &emsp;&emsp;在日本的网站上可以找别人做的 C++ 函数 https://qiita.com/EGJ-Kaz_Okada/items/4fd6db895b398893cbbb&emsp;&emsp;直接抄就可以使用了。 1234567891011121314void UPyToolkitBPLibrary::SetMaterialInstanceStaticSwitchParameterValue(UMaterialInstance *Instance, FName ParameterName, bool Value)&#123; FStaticParameterSet StaticParameters = Instance-&gt;GetStaticParameters(); for (auto &amp;SwitchParameter : StaticParameters.StaticSwitchParameters) &#123; if (SwitchParameter.ParameterInfo.Name == ParameterName) &#123; SwitchParameter.Value = Value; break; ; &#125; &#125; Instance-&gt;UpdateStaticPermutation(StaticParameters);&#125; 注: 2021-5-22 更新 上面的方案如果参数没有 override 是不起作用的，新方案如下 1234567891011121314151617181920void URedArtToolkitBPLibrary::SetMaterialInstanceStaticSwitchParameterValue(UMaterialInstance *Instance, FName ParameterName, bool SwitchValue, bool bOverride)&#123; TArray&lt;FGuid&gt; Guids; TArray&lt;FMaterialParameterInfo&gt; OutParameterInfo; Instance-&gt;GetAllStaticSwitchParameterInfo(OutParameterInfo, Guids); FStaticParameterSet StaticParameters = Instance-&gt;GetStaticParameters(); for (int32 ParameterIdx = 0; ParameterIdx &lt; OutParameterInfo.Num(); ParameterIdx++) &#123; const FMaterialParameterInfo &amp;ParameterInfo = OutParameterInfo[ParameterIdx]; const FGuid ExpressionId = Guids[ParameterIdx]; if (ParameterInfo.Name == ParameterName) &#123; FStaticSwitchParameter *NewParameter = new (StaticParameters.StaticSwitchParameters) FStaticSwitchParameter(ParameterInfo, SwitchValue, bOverride, ExpressionId); break; &#125; &#125; Instance-&gt;UpdateStaticPermutation(StaticParameters);&#125; 123456789101112131415161718192021222324py_lib = unreal.PyToolkitBPLibrarymat_lib = unreal.MaterialEditingLibrarydef transfer_material_property(self,material, property_list): scalars = mat_lib.get_scalar_parameter_names(material) vectors = mat_lib.get_vector_parameter_names(material) switches = mat_lib.get_static_switch_parameter_names(material) textures = mat_lib.get_texture_parameter_names(material) for p in property_list: if p in textures: getter = mat_lib.get_material_instance_texture_parameter_value setter = mat_lib.set_material_instance_texture_parameter_value elif p in switches: getter = mat_lib.get_material_instance_static_switch_parameter_value setter = py_lib.set_material_instance_static_switch_parameter_value elif p in vectors: getter = mat_lib.get_material_instance_vector_parameter_value setter = mat_lib.set_material_instance_vector_parameter_value elif p in scalars: getter = mat_lib.get_material_instance_scalar_parameter_value setter = mat_lib.set_material_instance_scalar_parameter_value else: continue setter(material, p, getter(self.source, p)) &emsp;&emsp;通过上面的方式就可以将不同材质类型对应的数据进行传递了。 总结 &emsp;&emsp;以上就是材质属性传递功能的总结。&emsp;&emsp;开发的过程还是留下一些遗憾，比如目前还没在面板上制作直接调整属性数据的功能。&emsp;&emsp;要接入这个功能需要 MVC 的 delegate 来实现。&emsp;&emsp;dayu_widgets 在这方面还没有做支持，而且还得用 Qt 做一套色板，有点麻烦&emsp;&emsp;现实需求其实目前这个程度就已经够用了，要修改的话还是用 Unreal 原生编辑器进行修改。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 利用 UtilityWidget 编写 UMG 工具界面]]></title>
    <url>%2Fposts%2F2b15ceb.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;众所周知，目前的 Unreal Python 还无法编写界面。&emsp;&emsp;尽管 Python API 文档包含了诸多 UI 组件的调用说明。&emsp;&emsp;但是无法将窗口显示出来也是没有意义的。 &emsp;&emsp;经过我的研究，可以通过 Editor Utility Widget 来实现 Python 编写界面。&emsp;&emsp;真的是用 Python API 提供的组件来组装 UI ，甚至可以实现资源选择的功能。&emsp;&emsp;只可惜目前无法用纯 Python 实现 modal dialog 的功能，多少受到了一定的掣肘。 UObject 罗列 &emsp;&emsp;在 Python 环境下可以获取到 Unreal 继承于 UObject 的对象。&emsp;&emsp;之前我就是通过路径上的手脚可以罗列出当前注册的菜单名 链接: Unreal Python 进阶菜单扩展 &emsp;&emsp;后来我想到可以写个 C++ 函数将所有的 UObject 打印出来，这样似乎可以实现更多黑科技。 123456789TArray&lt;UObject *&gt; UPyToolkitBPLibrary::GetAllObjects()&#123; TArray&lt;UObject *&gt; Array; for (TObjectIterator&lt;UObject&gt; Itr; Itr; ++Itr) &#123; Array.Add(*Itr); &#125; return Array;&#125; &emsp;&emsp;通过这个调用可以用下属的代码将引擎内置的 uobject 输出来 1234567891011121314import jsonimport unrealpy_lib = unreal.PyToolkitBPLibrary()objects = py_lib.get_all_objects()res_list = []for obj in objects: try: res_list.append(obj.get_path_name()) except: print("error -&gt; %s" % obj)path = r"F:\UnrealScript\test\object_list.json"with open(path,'w') as f: json.dump(res_list,f,indent=4) &emsp;&emsp;输出的信息可以参考 我的仓库 链接&emsp;&emsp;利用这个方法我甚至可以获取到一些不在 Python API 的类型，不过通常这种情况也无法调用到 对象 内置的方法。 EditorUtilityWidget Python API 获取 &emsp;&emsp;通过上面的方法可以获取到 Editor Utility 的一些内置的对象。 1234567891011121314151617"/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:WidgetTree.CanvasPanel_0", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:EventGraph.K2Node_Event_2", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:EventGraph.K2Node_Event_1", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:EventGraph.K2Node_Event_0", "/Engine/Transient.NewEditorUtilityWidgetBlueprint_C_0:WidgetTree_0", "/Engine/Transient.NewEditorUtilityWidgetBlueprint_C_0", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint_C:WidgetTree", "/Engine/Transient.EdGraph_4", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:ExecuteUbergraph_NewEditorUtilityWidgetBlueprint", "/Engine/Transient.TRASHCLASS_NewEditorUtilityWidgetBlueprint_7", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint_C", "/Engine/Transient.WidgetGraphSchema_0", "/Game/sequence/NewEditorUtilityWidgetBlueprint.PackageMetaData", "/Game/sequence/NewEditorUtilityWidgetBlueprint.SKEL_NewEditorUtilityWidgetBlueprint_C", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:EventGraph", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:WidgetTree", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint", &emsp;&emsp;从上面可以获取到 EditorUtilityWidget:WidgetTree 12345tree = unreal.find_object(None,"/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:WidgetTree")print(tree)# LogPython: &lt;Object '/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint:WidgetTree' (0x000001CD4F78A520) Class 'WidgetTree'&gt;print(dir(tree))LogPython: ['__class__', '__delattr__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '_post_init', '_wrapper_meta_data', 'cast', 'get_class', 'get_default_object', 'get_editor_property', 'get_fname', 'get_full_name', 'get_name', 'get_outer', 'get_outermost', 'get_path_name', 'get_typed_outer', 'get_world', 'modify', 'rename', 'set_editor_properties', 'set_editor_property', 'static_class'] &emsp;&emsp;可以获取到 WidgetTree 对象，但是在 Python API 下查不到它。 &emsp;&emsp;下面开始一些骚操作了，从上面罗列的对象，可以看到有 _C 结尾的 EditorUtilityWidget 对象。&emsp;&emsp;根据我之前写的文章分析过 Unreal Python 修改蓝图组件属性 ， _C 结尾的对象是蓝图 compile 之后获取的 CDO&emsp;&emsp;Unreal 是调用 CDO 生成的对象实现蓝图的功能。 &emsp;&emsp;但是这里只有未生成 CDO CanvasPanel ， 于是我尝试打开 EditorUtilityWidget 点击 compile 再次获取 附注: 也可以直接获取 CanvasPanel ，然后调用 Python API 添加组件，只是在这里添加会导致蓝图 compile 出错。 12"/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint_C:WidgetTree.CanvasPanel_0", "/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint_C:WidgetTree", &emsp;&emsp;此时就可以获取到 _C 结尾的 CanvasPanel_0 123canvas = unreal.find_object(None,"/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint_C:WidgetTree.CanvasPanel_0")print(canvas)LogPython: &lt;Object '/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint_C:WidgetTree.CanvasPanel_0' (0x000001CD52D81F80) Class 'CanvasPanel'&gt; &emsp;&emsp;经过千辛万苦，终于可以获取到 CDO 生成的 CanvasPanel 容器。&emsp;&emsp;接下来就可以 Python API 添加组件了。 12345678910111213141516171819202122232425from __future__ import print_functionwidget_BP = unreal.load_asset('/Game/sequence/NewEditorUtilityWidgetBlueprint.NewEditorUtilityWidgetBlueprint')canvas = unreal.find_object(None,'%s_C:WidgetTree.CanvasPanel_0' % widget_BP.get_path_name())layout = unreal.VerticalBox()button = unreal.Button()# NOTE 添加按钮点击事件delegate = button.on_clickeddelegate.add_callable(lambda:print("button click"))block = unreal.TextBlock()block.set_text("click")button.add_child(block)layout.add_child(button)slot = canvas.add_child_to_canvas(layout)# NOTE 构筑 Vertical Layout 撑满效果slot.set_anchors(unreal.Anchors(maximum=[1,1]))slot.set_offsets(unreal.Margin())# NOTE 生成界面editor_sub = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)widget,id = editor_sub.spawn_and_register_tab_and_get_id(widget_BP) &emsp;&emsp;如上图所示，可以通过 Python 动态生成 UMG 按钮触发相应事件。 纯 Python 触发蓝图 compile | UMG 全自动生成 &emsp;&emsp;上述的方案多少需要一些人工的点击，比如 EditorUtilityWidget 的生成， compile 按钮点击。&emsp;&emsp;有没有可能在不使用 C++ 的前提下完成所有功能呢？ &emsp;&emsp;其实资源自动生成的问题还好， Python API 有相关的 Factory EditorUtilityWidgetBlueprintFactory&emsp;&emsp;问题是如何通过 Python 完成 蓝图 的 compile&emsp;&emsp;我之前研究过这个问题，找不到相关的 API 只好写了一个 C++ 蓝图函数来触发 compile 1234void UPyToolkitBPLibrary::CompileBlueprint(UBlueprint *InBlueprint)&#123; FKismetEditorUtilities::CompileBlueprint(InBlueprint);&#125; &emsp;&emsp;然而我还想再挣扎一下，于是我全局搜索了 FKismetEditorUtilities::CompileBlueprint&emsp;&emsp;希望有别的蓝图函数调用到它，没想到还真给我找到了一个地方 ~ &emsp;&emsp;通过 UBlueprint 的 rename 功能可以触发蓝图的强制 compile。&emsp;&emsp;如此就可以不自己写 C++ API 用纯 Python 的方式实现蓝图 compile 了。 &emsp;&emsp;关于 rename 的方式，我最初想到是使用 rename_asset 函数。&emsp;&emsp;后来我发现 UObject 也有 rename ，这样不需要保存 asset ，调用效率更高。 2022-5-15 补充 &emsp;&emsp;我发现 4.27 版本关于这个部分已经优化掉了，如果想要编译蓝图，还是用 C++ API 比较稳妥。&emsp;&emsp;另外 UE5 添加了 BlueprintEditorLibrary.compile_blueprint 链接 可以用 Python 调用。&emsp;&emsp;UE4.27 下如果想要纯 Python 实现估计是不行的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from __future__ import print_functionimport posixpathfrom functools import partialimport unrealasset_lib = unreal.EditorAssetLibraryasset_tool = unreal.AssetToolsHelpers.get_asset_tools()def create_asset(asset_path="", unique_name=True, asset_class=None, asset_factory=None): if unique_name: asset_path, _ = asset_tool.create_unique_asset_name(asset_path,'') if not asset_lib.does_asset_exist(asset_path=asset_path): path, name = posixpath.split(asset_path) return asset_tool.create_asset( asset_name=name, package_path=path, asset_class=asset_class, factory=asset_factory, ) return unreal.load_asset(asset_path)material = unreal.load_asset('/Game/test/CubeTest.CubeTest')directory = "/Game/test"name = "TestWidget3"path = posixpath.join(directory,name)factory = unreal.EditorUtilityWidgetBlueprintFactory()widget_BP = create_asset(path,True,unreal.EditorUtilityWidgetBlueprint,factory)# NOTE 改名强制 compilewidget_BP.rename("%s_" % name)canvas = unreal.find_object(None,'%s_C:WidgetTree.CanvasPanel_0' % widget_BP.get_path_name())layout = unreal.VerticalBox()button = unreal.Button()# NOTE 添加按钮点击事件delegate = button.on_clickeddelegate.add_callable(lambda:print("button click"))block = unreal.TextBlock()block.set_text("test")button.add_child(block)layout.add_child(button)slot = canvas.add_child_to_canvas(layout)# NOTE 构筑 Vertical Layout 撑满效果slot.set_anchors(unreal.Anchors(maximum=[1,1]))slot.set_offsets(unreal.Margin())# NOTE 生成界面editor_sub = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)widget,id = editor_sub.spawn_and_register_tab_and_get_id(widget_BP) &emsp;&emsp;上面的函数就可以做到从零开始生成一个界面。 关闭窗口 自动清理蓝图资产 &emsp;&emsp;利用 Python API 的 tick 函数，我可以实现更加便利的操作。&emsp;&emsp;比如说关闭窗口 自动清理蓝图资产。 12345678910111213141516171819202122232425262728293031323334global __dialog_dict____dialog_dict__ = &#123; id:&#123; "widget":widget, "widget_BP":widget_BP, &#125;&#125;editor_sub = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)def __slate_handler__(delta): global __dialog_dict__ remove_list = [] for _id,info in __dialog_dict__.items(): widget = info.get("widget") widget_BP = info.get("widget_BP") if not editor_sub.does_tab_exist(_id): remove_list.append(_id) continue # NOTE 自动清理本地资产 for _id in remove_list: info = __dialog_dict__[_id] widget_BP = info.get("widget_BP") # NOTE rename force compile widget_BP.rename("%s__delete__" % widget_BP.get_name()) QtCore.QTimer.singleShot(0,partial(asset_lib.delete_asset,widget_BP.get_path_name())) del __dialog_dict__[_id]tick_handle = unreal.register_slate_pre_tick_callback(__slate_handler__)unreal_app = QtWidgets.QApplication.instance()__QtAppQuit__ = partial(unreal.unregister_slate_pre_tick_callback,tick_handle)unreal_app.aboutToQuit.connect(__QtAppQuit__) 通过 UMG 获取 property 属性 &emsp;&emsp;于是我想到更加进阶的用法，那就是利用 EditorUtilityWidget 提供的 组件 用原生的方式获取虚幻的资产。&emsp;&emsp;EditorUtilityWidget 的设计界面提供了 SinglePropertyView 可以作为属性的选择。&emsp;&emsp;经过我的摸索，我可以用 Python 构建 UClass 来模拟一个 uproperty&emsp;&emsp;通过这个 uproperty 获取到选择的属性。 12345678910111213141516171819202122232425262728293031323334from __future__ import print_function# NOTE 蓝图构筑省略 ...canvas = unreal.find_object(None,'%s_C:WidgetTree.CanvasPanel_0' % widget_BP.get_path_name())layout = unreal.VerticalBox()property_view = unreal.SinglePropertyView()# NOTE 生成一个材质的 property 添加到 SinglePropertyView@unreal.uclass()class PropertyObject(unreal.Object): material = unreal.uproperty(unreal.MaterialInstanceConstant)obj = PropertyObject()property_view.set_object(obj)property_view.set_property_name("material")layout.add_child(property_view)button = unreal.Button()delegate = button.on_clickeddelegate.add_callable(lambda:print(obj.material))block = unreal.TextBlock()block.set_text("Get Material")button.add_child(block)layout.add_child(button)slot = canvas.add_child_to_canvas(layout)# NOTE 构筑 Vertical Layout 撑满效果slot.set_anchors(unreal.Anchors(maximum=[1,1]))slot.set_offsets(unreal.Margin())# NOTE 生成界面editor_sub = unreal.get_editor_subsystem(unreal.EditorUtilitySubsystem)widget,id = editor_sub.spawn_and_register_tab_and_get_id(widget_BP) &emsp;&emsp;如此生成的界面获取可以更加灵活。&emsp;&emsp;也可接入 detail view 直接让用户编辑特定对象的属性，只是属性太多配置不太灵活。 总结 &emsp;&emsp;利用这个黑科技，可以使用纯 Python 构筑 UMG 界面。 &emsp;&emsp;Qt 的痛点就是很难像原生 Unreal 的选择窗口一样快速罗列出所有可以选择的资源对象。&emsp;&emsp;利用 Python API 可以做，但是要获取缩略图转换到 Qt 下效率就很低，只能做到无缩略图的效果。&emsp;&emsp;目前虽然实现了 Python 构筑 UMG 但是无法使用 Modal Dialog 的阻塞方式配合 Qt 的 GUI 一起使用，还是差了临门一脚。&emsp;&emsp;这个问题只能 C++ 处理了。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 子进程快捷键监听]]></title>
    <url>%2Fposts%2F8ea189bd.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个常识其实早在去年就已经弄过了，然而当时的实现方案不好。&emsp;&emsp;虽然我合并到 PyToolkit 里面了，最后还是设置成了不开启状态。&emsp;&emsp;最近我研究出新方案，可以解决我之前提到的问题。 Python 键盘监听 &emsp;&emsp;以前我有做过一个基于 Python 的启动器，需要使用 C++ 在 Unreal 注册快捷键来启动。 链接&emsp;&emsp;这么做一方面是需要 C++ 进行编译，另一方面注册的快捷键并不是全局的，只能允许在注册的特定窗口触发 (可能是没有使用合适的 C++ API 导致的)&emsp;&emsp;然而既然 Unreal 支持 Python ，可以依赖 Python 生态完成键盘的监听。 &emsp;&emsp;最初我是使用了比较出名的 keyboard 库来实现键盘监听。 Github链接&emsp;&emsp;这个库是纯 Python 实现，而且可以跨平台使用，非常强大。&emsp;&emsp;使用上也很简单，可以查找官方提供的案例。 1234import keyboardkeyboard.add_hotkey('ctrl+shift+a', print, args=('triggered', 'hotkey'))# Block forever, like `while True`.keyboard.wait() &emsp;&emsp;上面的代码可以实现全局快捷键触发监听。&emsp;&emsp;那么似乎直接使用这个 库 到 Unreal Python 下使用即可。&emsp;&emsp;的确直接在 Unreal 下运行这个库可以用快捷键触发相关的 函数。&emsp;&emsp;然而，当我不关注 Unreal ，转而在别的窗口打字的时候，会变得非常的卡顿。&emsp;&emsp;以前不知道为什么，只想着在不关注窗口的时候将 hook 关掉的。 &emsp;&emsp;最近我才领悟到是什么原因导致的。 &emsp;&emsp;主要原因是勾选了这个选项，在 Unreal 切换到后台之后减少 CPU 的消耗。&emsp;&emsp;导致 Python 运行效率极大降低。&emsp;&emsp;我查了 keyboard 的源码，背后是通过多线程进行监听，需要持续运行的。&emsp;&emsp;然而这个由于 Python 的处理效率降低，导致键盘事件的 hook 一直处在等待处理的状态。&emsp;&emsp;以至于切换到代码编辑器写代码就会异常地卡顿。 &emsp;&emsp;我去年也深入剖析源码研究了这个问题，发现使用 keyboard 库可能不好进行修改。&emsp;&emsp;于是我改用另一个库 pynput 进行快捷键监听，并且对这个库的函数进行重载，通过 tick 间隔时间来判断是否在卡顿。&emsp;&emsp;如果卡顿就把 监听 给去掉。 pynput 监听魔改 &emsp;&emsp;pynput 是另一个比较知名的键盘监听库 Github链接&emsp;&emsp;这个库也有 GlobalHotKeys 的功能实现全局键盘监听。&emsp;&emsp;其实实现原理和 keyboard 大差不差。 &emsp;&emsp;经过我的研究，这些库别后都是多线程然后有个函数会进入到 while True 死循环进行持续监听。&emsp;&emsp;我需要在 Unreal 卡顿 的时候去掉监听，然后再 Unreal 不卡顿的时候重新启用监听。&emsp;&emsp;经过我对源码的研究我找到了 while True 循环的位置，并且进行一些魔改，可以减轻卡顿问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071def message_itr(self): global listener assert self._threadid is not None try: # Pump messages until WM_STOP while True: if delta_queue.empty(): continue elasped = delta_queue.get() # NOTE 如果虚幻阻塞 去掉 键盘监听 if elasped &gt; 0.1: listener and listener.stop() listener = None break # print('start capture key ...') msg = wintypes.MSG() lpmsg = byref(msg) # NOTE _PeekMessage 队列不阻塞 r = self._PeekMessage(lpmsg, None, 0, 0 , 0x0001) if r &lt;= 0: continue elif msg.message == self.WM_STOP: break else: yield msg finally: self._threadid = None self.thread = Nonedef get_hotkey(): json_path = posixpath.join(DIR, "hotkey.json") key_data = read_json(json_path) key_map = &#123;&#125; for k,v in key_data.items(): v = v if isinstance(v, dict) else &#123;"command":v,"type":"COMMAND"&#125; command = v.get("command") typ = v.get("type","").upper() func = HOTKEY_TYPE.get(typ) if not func: continue key_map[k] = func(command) return key_mapdef __key_listener__(delta_seconds): global listener,key_map,hotkey_enabled if not hotkey_enabled: return if delta_queue.empty(): delta_queue.put(delta_seconds) elif listener is None: # NOTE 重新构建 键盘 监听 listener = keyboard.GlobalHotKeys(key_map) elif listener not in listener_list: del listener_list[:] listener_list.append(listener) if not listener.is_alive(): listener.start() tick_handle = unreal.register_slate_pre_tick_callback(__key_listener__)unreal_app.aboutToQuit.connect(partial(unreal.unregister_slate_post_tick_callback, tick_handle))delta_queue = Queue(1)from pynput._util import win32win32.MessageLoop.__iter__ = message_itrkey_map = get_hotkey()listener = Nonelistener_list = [] &emsp;&emsp;在 Windows 下 win32.MessageLoop 是死循环的元凶。&emsp;&emsp;于是我魔改获取 tick 的变化时间，如果处于卡顿状态就打断 while 循环。&emsp;&emsp;这样可以使监听减速，随后在需要开启的状态重新启动新的进程。&emsp;&emsp;上面的方案只能减轻卡顿，不能从根本上解决这个问题，所以当时研究完了也没有写博客记录，不算是特别好的解决方案。 Python 子进程监听 &emsp;&emsp;直到最近，我发现是 CPU 问题导致卡顿之后，就自然而然地想到使用 Python 的子进程进行监听。&emsp;&emsp;子进程不受 Unreal 的 CPU 限制影响，就不会导致卡顿了。&emsp;&emsp;于是我又开始研究进程通信的实现，最后还真的给我捣鼓了一个比较可行的方案。 &emsp;&emsp;关于子进程，在 Python 下可以用过 subprocess.Popen 开启子进程，然后使用 PIPE 或 queue 实现进程通信。&emsp;&emsp;当然也可以使用 python 插件自带的 remote_execution 通过远程端口进行通信。&emsp;&emsp;理论上使用第一套方案效率更好，只是局限在单台电脑，使用远程端口的话甚至可以跨电脑调用。 &emsp;&emsp;那么如何实现不阻塞的进程通信呢？ 这里我直接参考了 Stack Overflow 的代码实现的功能 回答链接&emsp;&emsp;基于上面的回答我编写自己的监听脚本。&emsp;&emsp;首先是 init_unreal.py 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889FORMAT_ARGS = &#123;"Content": DIR&#125;# NOTE 初始化键盘事件hotkey_enabled = setting.get("hotkey")if hotkey_enabled: # NOTE 根据系统获取 Python exe 路径 os_config = &#123; "Windows": "Win64", "Linux": "Linux", "Darwin": "Mac", &#125; os_platform = os_config.get(platform.system()) if not os_platform: raise OSError("Unsupported platform '&#123;&#125;'".format(platform.system())) PYTHON = "Python" if six.PY2 else "Python3" ThirdParty = os.path.join(sys.executable, "..", "..", "ThirdParty") interpreter = os.path.join(ThirdParty, PYTHON, os_platform, "python.exe") interpreter = os.path.abspath(interpreter) exec_file = os.path.join(DIR, "_key_listener", "__main__.py") msg = "lost path \n%s\n%s" % (interpreter, exec_file) assert os.path.exists(interpreter) and os.path.exists(exec_file), msg # NOTE 开一个 Python 子进程进行键盘监听 # NOTE https://stackoverflow.com/a/4896288 ON_POSIX = "posix" in sys.builtin_module_names p = Popen( [interpreter, exec_file], shell=True, stdout=PIPE, bufsize=1, close_fds=ON_POSIX, ) # NOTE 关闭 Unreal 的时候同步关闭进程 unreal_app.aboutToQuit.connect(p.terminate) def enqueue_output(out, queue): for line in iter(out.readline, b""): queue.put(line) out.close() q = Queue() t = Thread(target=enqueue_output, args=(p.stdout, q)) t.daemon = True # thread dies with the program t.start() # NOTE 读取注册快捷键的配置 hotkey_path = posixpath.join(DIR, "hotkey.json") hotkey_config = read_json(hotkey_path) def __red_key_tick__(delta_seconds): try: line = q.get_nowait() except: return # NOTE https://stackoverflow.com/a/26970249 # NOTE 获取 windows 下当前关注窗口的名称 title = get_foreground_window_title() title = title if title else "" ue_active = "Unreal Editor" not in title if delta_seconds &gt; 0.1 or ue_active: return # NOTE python3 将获取的数据转换为 unicode line = str(line.strip(), "utf-8") config = hotkey_config.get(line) if not config: return callbacks = &#123; "COMMAND": lambda command: sys_lib.execute_console_command( None, command ), "PYTHON": lambda command: eval(command), &#125; typ = config.get("type", "").upper() callback = callbacks.get(typ) if not callback: return command = config.get("command", "").format(**FORMAT_ARGS) callback(command) tick_handle = unreal.register_slate_post_tick_callback(__red_key_tick__) __QtAppQuit__ = partial(unreal.unregister_slate_post_tick_callback, tick_handle) unreal_app.aboutToQuit.connect(__QtAppQuit__) &emsp;&emsp;监听用的脚本如下 123456789101112131415161718192021222324252627import osimport sysimport timeimport jsonimport keyboarddef main(): hotkey_path = os.path.join(Content, "hotkey.json") if not os.path.exists(hotkey_path): print("&#123;&#125; not exists".format(hotkey_path)) return with open(hotkey_path, "r", encoding="utf-8") as f: hotkey_config = json.load(f) # NOTE 注册的快捷键会打印快捷键信息 传输到主进程 for hotkey in hotkey_config: keyboard.add_hotkey(hotkey, print, args=(hotkey,)) while True: # NOTE 降低 CPU 占用 time.sleep(0.1) # NOTE 保持 stdout 刷新确保主进程可以持续获取数据 sys.stdout.flush()if __name__ == "__main__": main() &emsp;&emsp;使用 while True 循环持续监听，由于是另一个进程不受 Unreal 的 CPU 响应限制。&emsp;&emsp;加入 time.sleep 可以降低 Python 对 CPU 的占用。&emsp;&emsp;经过上面的配置，我只需要配置好 hotkey.json 文件，就可以调用类似之前做的菜单一样进行调用。 12345678910&#123; "ctrl+f":&#123; "type":"COMMAND", "command": "py \"&#123;Content&#125;/Msic/ue_launcher/launcher.py\"" &#125;, "ctrl+shift+c":&#123; "type":"COMMAND", "command": "py \"&#123;Content&#125;/_key_listener/copy_reference.py\"" &#125;&#125; &emsp;&emsp;比如我自定义添加 ctrl+shift+c 复制 Unreal 里面选中资源的路径。 总结 &emsp;&emsp;总算是把去年的文章给补上了。&emsp;&emsp;借助 Python 生态，这个方案甚至也可以作为 DCC 的功能扩展。&emsp;&emsp;趁着这个契机，我打算做一个 Unreal Launcher]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RenderDoc Python 开发 FBX 导出工具]]></title>
    <url>%2Fposts%2Fc12b915c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;本来要肝 Houdini 教程的，但是最近一直不在状态(:з」∠)&emsp;&emsp;然后工作上遇到这个需求，本来是打算从 RenderDoc 导出 csv 文件，然后读取 csv 文件在 Maya API 将相关信息写到模型里面。&emsp;&emsp;但是 RenderDoc 的 ID 序号和 Maya 的 FaceVertex 无法关联到一起。&emsp;&emsp;在 Maya 里面顺序被打乱了。 &emsp;&emsp;由于这个问题不急，所以也就搁置了，没有进行下一步的处理。&emsp;&emsp;直到最近在 KM 上找到了一篇 RenderDoc 插件开发的文章，瞬间觉得可以调用 RenderDoc API 来解决这个问题。&emsp;&emsp;于是才有了本篇文章的探索。 &emsp;&emsp;最后的实现效果已经开源在 Github 上 链接 RenderDoc 是啥 &emsp;&emsp;RenderDoc 是业内大名鼎鼎的 截帧软件， 用来分析游戏渲染数据的利器。不过我不是图形向 TA ， 使用上还是一知半解(:з」∠)。&emsp;&emsp;RenderDoc 是结余 Qt 框架开发，内置 Python API ，可以通过 Python 脚本实现插件开发。 Github链接官网链接文档链接 插件开发 &emsp;&emsp;RenderDoc 的文档里面有很详细关于插件开发的内容 链接 1234# windows%APPDATA%\qrenderdoc\extensions# linux~&#x2F;.local&#x2F;share&#x2F;qrenderdoc&#x2F;extensions &emsp;&emsp;在上面的路径下创建目录&emsp;&emsp;然后添加一个 __init__.py 和 extension.json 的文件 123456789&#123; "extension_api": 1, "name": "Extension name for users", "version": "1.0", "minimum_renderdoc": "1.2", "description": "A longer description of your extension.\n\nIt can contain multiple lines", "author": "Your name &lt;your@email.com&gt;", "url": "url/to/repository"&#125; extension_api 固定为 1 &emsp;&emsp;RenderDoc 会读取 extension.json 的信息显示在 Extension Mananger 的面板上。 &emsp;&emsp;启用插件之后就可以通过 API 扩展界面功能了 RenderDoc 调试 Python 代码 &emsp;&emsp;RenderDoc 有 Python Shell 面板&emsp;&emsp;这里编写代码有完整的 renderdoc 环境， 方便测试代码。&emsp;&emsp;毕竟上面的插件流程测试代码都需要 reload 一下，非常不方便 RenderDoc 使用 Qt 编写界面 &emsp;&emsp;虽然 RenderDoc 自带 PySide 模块&emsp;&emsp;但是 Qt 界面开发上并没有 Maya 那么灵活&emsp;&emsp;用 Maya 的传统思路构建 UI 会让 UI 一闪而过，即便使用 global 变量也不行。 123456from PySide2 import QtWidgetsdialog = QtWidgets.QDialog()dialog.show()# 下面注释的代码会导致 RenderDoc 卡死# dialog.exec_()# QtWidgets.QMessageBox.warning(None, "title", "msg") &emsp;&emsp;RenderDoc 的主线程不能被 PySide 创建的界面所阻塞，否则就会导致 RenderDoc 卡死。&emsp;&emsp;RenderDoc Python API 提供了 Mini-Qt Helper 12345678from PySide2 import QtWidgetsdialog = QtWidgets.QDialog()manager = pyrenderdoc.Extensions()mqt = manager.GetMiniQtHelper()mqt.ShowWidgetAsDialog(dialog)# 也可以通过下面的代码生成一个警告窗口# manager.MessageDialog("msg", "title") &emsp;&emsp;这里使用全局变量 pyrenderdoc 获取 Helper ，然后调用 Helper 显示 Dialog&emsp;&emsp;不过有个缺点这是个 阻塞 Dialog ， RenderDoc 的界面就无法响应了。 &emsp;&emsp;关于 RenderDoc 一些内置变量和库需要进行区分 renderdoc 是自身的 API 模块qrenderdoc 是Qt相关的 API 模块 &emsp;&emsp;pyrenderdoc 则是默认自带的全局变量，属于 CaptureContext 类型，可以在文档中查阅相关的信息。 文档链接 &emsp;&emsp;根据上面的文档上面， RenderDoc 推荐在 Python 环境下使用 pyrenderdoc.Replay().BlockInvoke(myCallback) 来进行处理操作。&emsp;&emsp;BlockInvoke 会调用非 UI 现成进行处理，避免 UI 无响应，并且只有激活的 controller 下才会触发。&emsp;&emsp;也就是没有截帧数据的情况下， BlockInvoke 的函数是不会被调用到的。&emsp;&emsp;但是这样会导致 BlockInvoke 的调用函数不在 Qt 线程里面，如果触发 Qt 相关的界面 API 依然不行。 1234manager = pyrenderdoc.Extensions()def myCallback(controller): manager.MessageDialog("FBX Ouput Sucessfully", "Congradualtion!~")pyrenderdoc.Replay().BlockInvoke(myCallback) &emsp;&emsp;比较神奇的情况就出现了，我也不太搞懂，理论上上面的代码无法执行的，但是在代码调试界面是可以执行的。&emsp;&emsp;但是如果在 插件环境 下执行这个代码就会卡死，使用需要慎重。 2021-4-10 更新 &emsp;&emsp;最近抽空来修复 renderdoc2fbx 工具的 一些 BUG ，想要用 Qt Designer 写个界面接入到 renderdoc 里面。&emsp;&emsp;我发现上面的测试还是差了一步，我只是生成界面，却没有生成按钮到界面里面。&emsp;&emsp;结果 renderdoc 的 API 需要用 GetMiniQtHelper 的 API 来创建组件。&emsp;&emsp;单纯使用 PySide2 库创建组件并不可行，因为 renderdoc 的 Python 和 PySide2 都是经过魔改的。 &emsp;&emsp;打开 renderdoc 的安装目录可以看到 PySide2 模块 以及 Python 都是缺失的。&emsp;&emsp;python.exe 都找不到，在renderdoc 下 import socket 库还会报错。 1234Traceback (most recent call last): File "script.py", line 1, in &lt;module&gt; File "socket.py", line 49, in &lt;module&gt;ModuleNotFoundError: No module named '_socket' &emsp;&emsp;因此在 renderdoc 创建界面只能使用 IMiniQtHelper 类里面提供的方法。 1234manager = pyrenderdoc.Extensions()mqt = manager.GetMiniQtHelper()print(dir(mqt))['AddGridWidget', 'AddWidget', 'ClearContainedWidgets', 'CloseCurrentDialog', 'CreateButton', 'CreateCheckbox', 'CreateComboBox', 'CreateGridContainer', 'CreateGroupBox', 'CreateHorizontalContainer', 'CreateLabel', 'CreateOutputRenderingWidget', 'CreateRadiobox', 'CreateSpinbox', 'CreateTextBox', 'CreateToplevelWidget', 'CreateVerticalContainer', 'FindChildByName', 'GetChild', 'GetNumChildren', 'GetParent', 'GetSpinboxValue', 'GetWidgetName', 'GetWidgetText', 'GetWidgetType', 'GetWidgetWindowingData', 'InsertWidget', 'IsWidgetChecked', 'IsWidgetEnabled', 'SetComboOptions', 'SetSpinboxBounds', 'SetSpinboxValue', 'SetWidgetBackgroundColor', 'SetWidgetChecked', 'SetWidgetEnabled', 'SetWidgetFont', 'SetWidgetName', 'SetWidgetReplayOutput', 'SetWidgetText', 'ShowWidgetAsDialog', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__int__', '__le__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'acquire', 'append', 'disown', 'next', 'own', 'this', 'thisown'] &emsp;&emsp;基于上面的 API 和文档，返回都是 QWidget 类型，简单的界面编写可以如下参考。 12345678910111213manager = pyrenderdoc.Extensions()mqt = manager.GetMiniQtHelper()container = mqt.CreateToplevelWidget("Test Widget")vertical = mqt.CreateVerticalContainer()edit = mqt.CreateTextBox(True,lambda *args:None)# NOTE 点击按钮关闭界面button = mqt.CreateButton(lambda *args:mqt.CloseCurrentDialog(True))mqt.SetWidgetText(button,"Button")mqt.AddWidget(vertical,edit)mqt.AddWidget(vertical,button)mqt.AddWidget(container,vertical)mqt.ShowWidgetAsDialog(container) &emsp;&emsp;因此在 renderdoc 用 Python 写界面会有诸多限制，我这里开发了一个属性输入窗口，倒是能够符合我的需求。 &emsp;&emsp;虽然有诸多限制，不过还有一些功能可以使用，比如 QSettings 2021-4-14 更新 &emsp;&emsp;获取的 QWidget 组件可以转换为 Qt 的对应组件然后用 PySide2 的 API 进行交互。&emsp;&emsp;比如说上面通过 mqt.CreateComboBox 生成下来选项， renderdoc 的 API 无法修改显示的 index&emsp;&emsp;可以将获取的 QWidget 传入到 QtWidgets.QComboBox ，通过 setCurrentText 进行修改。 1234567manager = pyrenderdoc.Extensions()mqt = manager.GetMiniQtHelper()combo = mqt.CreateComboBox(False, lambda:None)combo = QtWidgets.QComboBox(combo)combo.addItems(["unity", "unreal"])combo.setCurrentText("unreal") &emsp;&emsp;还是可以基于 Qt 的 API 进行修改，灵活性上并没有想象那么差。 2021-4-17附注: 这个用法只能在 插件环境下生效 ， RenderDoc 自带的 Python shell 不起作用。 FBX 导出插件编写 &emsp;&emsp;关于扩展的相关命令可以在 Extension Manager 相关的 API 文档里面找到 链接 注册 Mesh Viewer 菜单123pyrenderdoc.Extensions().RegisterPanelMenu( qrenderdoc.PanelMenu.MeshPreview, ["Export FBX Mesh"], callback) &emsp;&emsp;上面的代码可以在 Mesh Viewer 的插件按钮下扩展一个 menu item ，触发相应的函数功能。&emsp;&emsp;具体编写方式可以参照官方文档 链接 123def register(version: str, ctx: qrd.CaptureContext): # as above ... ctx.Extensions().RegisterWindowMenu(qrd.WindowMenu.Tools, ["My extension"], menu_callback) &emsp;&emsp;官方文档的案例是扩展到 Tools 菜单下 解析 模型 数据 &emsp;&emsp;官方提供了很详细的数据解析案例 链接&emsp;&emsp;官方使用 struct 库解析二进制数据，从中提取出我们需要的信息。 &emsp;&emsp;基于官方提供的数据就可以获取到 Vertex Normal UV Tangent VertexColor 的数据了。 &emsp;&emsp;接下来就是将这些数据更具 FBX ASCII 的形式组装到文本里面。&emsp;&emsp;具体操作我是从 Maya 导出一个简单的面片 ASCII FBX 去测试的。 &emsp;&emsp;其中比较坑的地方是， FBX 组装位置信息是有一个规则来区分三角面和四边面的。&emsp;&emsp;在网上查到了不错文章解决了我这个头疼的问题 https://www.codenong.com/cs105411312/ &emsp;&emsp;所以 PolygonVertexIndex 按照这个规范去构建数据就不会导致模型显示不出来。&emsp;&emsp;另外考虑到导出都是单个模型， 也不带材质，所以我导出的时候也将 FBX 无关的信息统统清理掉了。 总结 &emsp;&emsp;以上就是 RenderDoc 开发 FBX 导出工具的记录。 2021-4-17 性能优化 &emsp;&emsp;官方给出的 API 需要用 Python 进行 2进制解码获取模型数据。&emsp;&emsp;但是这个获取方案效率实在是太低了。&emsp;&emsp;经过我的摸索，可以通过 PySide2 模块获取 renderdoc UI 里面的数据。 链接&emsp;&emsp;直接获取出 QTableView 里面的信息，这样导出速度可以提升数十倍。&emsp;&emsp;另外使用插件的 Python 调用可以直接使用 PySide2 构建组件，但是在 Python Shell 下却不起作用。]]></content>
      <categories>
        <category>CG</category>
        <category>RenderDoc</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/RenderDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal 425 升级 Python3]]></title>
    <url>%2Fposts%2Fd048902d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;因为一些复杂的原因，打算对项目的 4.25 引擎升级 Python2 到 Python3。&emsp;&emsp;这个过程踩的坑做一些总结。 &emsp;&emsp;UE4.26 已经配置上 python 3.7.7&emsp;&emsp;所以升级 Python 并没有太大的困难，将相关的代码和文件复制过去再修改就差不多了。 Python3 配置 &emsp;&emsp;首先可以先安装 UE 4.26 Engine\Source\ThirdParty\Python3Engine\Binaries\ThirdParty\Python3 &emsp;&emsp;然后将上面两个目录拷贝到项目工程。&emsp;&emsp;然后再去修改 Source 里面的代码。&emsp;&emsp;然后需要修改 PythonScriptPlugin 下的 build.cs 依赖修改 “Python3”。 &emsp;&emsp;当然最好是将 UE4.26 的 PythonScriptPlugin 也搬过来。&emsp;&emsp;只是得去掉部分新模块依赖的代码，才行。 踩坑过程 &emsp;&emsp;第一次编译不知道需要搬运 Binaries ，于是就去 Python 官方下载 Python3.7 的版本。&emsp;&emsp;然后安装到 C 盘 Python37 目录。&emsp;&emsp;莫名其妙成功地通过了编译，后来我发现我编译的 Python sys.version 是 3.7.9 版本&emsp;&emsp;不是 UE4.26 官方的 3.7.7 才发现问题。 &emsp;&emsp;后来查了 Python3.build.cs 才发现问题。 &emsp;&emsp;它默认找不到 Binaries 是读取 C 盘的这个路径。&emsp;&emsp;所以我的把 Binaries 里的 Python 文件给补充上，否则推到项目都启动不了 Python &emsp;&emsp;后来在 git 上将 Binaries 推上去，本地编译也通过了。&emsp;&emsp;但是项目组那边编译还是出问题了，报错显示是 Python SDK not found&emsp;&emsp;一开始不知道是什么情况，毕竟我本地已经编译通过了。搜索报错，可以找到还是 Python3.build.cs 提示的错误。&emsp;&emsp;最后经过我修改 Python3.build.cs 打印为啥会触发这个问题，才发现是原来是一些 exe 之类的文件被 gitignore 给过滤掉了。&emsp;&emsp;我又得用命令行 git add --force . 强行将文件推上去。&emsp;&emsp;如此即可解决问题。 总结 &emsp;&emsp;因为有 UE4.26 的 Py3 可以抄。&emsp;&emsp;所以升级过程并没有那么困难。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Qt Overlay 堆叠组件]]></title>
    <url>%2Fposts%2F1ba28015.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;使用 QtDesigner 开发界面可以极大提高开发效率，我之前有些过关于 Qt Designer 使用攻略文章 链接&emsp;&emsp;然而使用传统的 Qt Layout 系统会有个小限制，无法让组件堆叠在一起。&emsp;&emsp;比如说我有个 QListWidget、QGroupBox 之类的内置组件，我想要在它的右上角加一个按钮。&emsp;&emsp;由于内置组件是自成一体的，如果使用 Qt 的 Layout 进行组件排列管理，就无法实现将组件叠在上层的效果。&emsp;&emsp;然而不适用 layout 的话，缩放窗口组件就无法动态调整大小了，这也是我不想要的。 &emsp;&emsp;为了解决这个问题，我开发了一个 OverLay 组件，只要定义方向就可以将组件叠在另一个组件上。&emsp;&emsp;通过 Qt Designer 的扩展自定义组件功能来配合使用，可以让 UI 开发更上一层楼。 解决的问题 &emsp;&emsp;上面的图就是传统 designer 开发由于无法堆叠，所以只能腾出侧边的组件空位放置按钮。 &emsp;&emsp;经过我开发的组件，就可以让侧边的按钮叠在 TableView 上。 &emsp;&emsp;Overlay 依然可以通过 QtDesigner 来进行组件的管理，比起 QTableView 扩展出按钮的方案更方便修改和维护。 &emsp;&emsp;上面的实战案例可能还感觉不出 Overlay 的好处，我可以再举一个 QGroupBox 按钮扩展的删除按钮。 &emsp;&emsp;通过 Designer 连接删除信号，然后点击删除就可以将整个 QGroupBox 删除。&emsp;&emsp;由于是 Overlay 状态，所以组件看起来是自成一体的，而且修改起来也很方便，要加多个按钮直接在 Designer 里面添加即可。 Overlay 的使用 &emsp;&emsp;直接 Designer 上扩展 QWidget 组件即可。&emsp;&emsp;提示组件的方法可以参考我之前写的文章 Qt Designer 使用全攻略 &emsp;&emsp;之后有两个属性 stretch 和 direction 需要配置。&emsp;&emsp;stretch 拉伸默认配置为 Auto ， direction 默认配置为 E。&emsp;&emsp;通常情况下 stretch 无需配置， direction 需要配置，否则无法找到依附的组件。 &emsp;&emsp;可以使用 Designer 的动态属性进行配置，添加字符串类型的属性即可。 1self.Overlay_Widget.set_stretch(self.Overlay_Widget.STRETCH.NoStretch) &emsp;&emsp;也可以使用代码的 set_stretch 和 set_direction 方法进行配置，代码只要不配置默认值就就会一定会覆盖 Designer 的配置。 &emsp;&emsp;direction 有 N S E W 四个字母属性，分别是英文东南西北的首字母，定义组件当前的位置。&emsp;&emsp;stretch 有 NoStretch Vertical Horizontal Center Auto 五个属性，分别代表需要动态拉伸的长宽位置。&emsp;&emsp;Overlay 类中有 STRETCH 和 DIRECTION 的常亮来配置属性。&emsp;&emsp;默认 Auto 可以根据组件的 direction 自动匹配 Vertical 还是 Horizontal。 &emsp;&emsp;如果使用 NoStretch 会如上图，不会动态更新组件的长宽。 Overlay 实现原理 &emsp;&emsp;首先要找出当前 Overlay 组件所在 layout 以及 layout 下的 index&emsp;&emsp;通过 layout takeAt 方法可以将 组件 从 layout 里面提取出来。&emsp;&emsp;这个时候 Overlay 组件已经悬浮在目标组件上了，只是调整大小无法响应了。&emsp;&emsp;因此要根据 Designer 配置的动态属性 direction 找到要依附的父组件，响应父组件的 resize 和 paint 事件进行相应的更新。 初始化注册12345678910from collections import namedtupleclass QOverlay(QtWidgets.QWidget): resized = QtCore.Signal(QtCore.QEvent) painted = QtCore.Signal(QtCore.QEvent) DIRECTION = namedtuple("Direction", "E S W N")(0, 1, 2, 3) STRETCH = namedtuple("Stretch", "NoStretch Vertical Horizontal Center Auto")( 0, 1, 2, 3, 4 ) &emsp;&emsp;定义类的 信号槽 和 属性常量。&emsp;&emsp;利用内置 namedtuple 可以更简洁生成相关的属性值 12345def __init__(self, parent=None): super(QOverlay, self).__init__(parent=parent) QtCore.QTimer.singleShot(0, self._initialize) self.stretch = self.STRETCH.Auto self.direction = self.DIRECTION.E &emsp;&emsp;通过 QTimer.singleShot 延迟到下一个 eventloop 触发。&emsp;&emsp;这样就不用纠结 stretch 和 direction 相关的属性是否已经设置了。 12345678910111213141516171819202122232425262728293031323334353637383940def _initialize(self): # NOTE 将组件放到最上面 https://stackoverflow.com/a/31197643 self.raise_() # NOTE 获取 stretch 动态属性 stretch = self.property("stretch") stretch = self.STRETCH._asdict().get(stretch) if not stretch is None and self.stretch == self.STRETCH.Auto: self.set_stretch(stretch) # NOTE 获取 direction 动态属性 根据方向获取依附组件 direction = self.property("direction") direction = direction.upper() if isinstance(direction, str) else "" direction = self.DIRECTION._asdict().get(direction) if not direction is None and self.direction == self.DIRECTION.E: self.set_direction(direction) # NOTE 递归查找 当前组件的 layout 和 index layout = self.parentWidget().layout() info = self._traverse_layout(layout) assert info, "%s cannot find layout" % (self) parent_layout, index = info # NOTE 获取依附的组件 value = 1 if self.direction &lt;= 1 else -1 item = parent_layout.itemAt(index - value) assert item, "%s wrong overlay direction" % (self) # NOTE 父组件添加事件拦截 parent_widget = parent_layout.parentWidget() parent_widget.installEventFilter(self) data = &#123; "index": index, "item": item, "layout": parent_layout, &#125; # NOTE 确保显示状态才去 生成 Overlay (否则 Tab 组件下看不见的 Tab 会出问题) self.painted.connect(partial(self._init_resize, data)) &emsp;&emsp;上面是初始化函数的过程，获取相关配置和属性。&emsp;&emsp;重点是 _traverse_layout 找出当前组件所在 layout 和 index 1234567891011121314def _traverse_layout(self, layout): # NOTE 递归查询 组件所在的 layout 和 index target = None for i in range(layout.count()): item = layout.itemAt(i) if isinstance(item, QtWidgets.QLayout): target = self._traverse_layout(item) if target: break elif isinstance(item, QtWidgets.QWidgetItem) and item.widget() is self: target = (layout, i) break return target &emsp;&emsp;通过上面的方法实现递归查找当前所处的 layout 和 index&emsp;&emsp;不能直接使用 parent 获取是因为组件有可能在 子layout 下，所以要获取 parent 的 layout 然后递归查找。&emsp;&emsp;从而根据方向找出 依附组件。 &emsp;&emsp;随后是 installEventFilter 拦截事件&emsp;&emsp;通过拦截的事件触发信号槽执行 _init_resize &emsp;&emsp;本来 installEventFilter 这一步应该弄一个 QObject 类生成拦截实例 会更加好理解。&emsp;&emsp;但是如果用 Overlay 组件自身的 eventFilter 会让代码都在一个类里面可以更加紧凑。 123456def eventFilter(self, obj, event): if event.type() == QtCore.QEvent.Resize: self.resized.emit(event) if event.type() == QtCore.QEvent.Paint: self.painted.emit(event) return super(QOverlay, self).eventFilter(obj, event) &emsp;&emsp;eventFilter 里面劫持相关的 Qt 事件通过 信号槽 来触发。&emsp;&emsp;这里劫持了 paint 事件，确保组件在可见范围下才生成 Overlay 效果，避免 TabWidget 看不见的状况下 size 对不上的问题。 resize 实现 &emsp;&emsp;上面确保在绘制的界面触发 _init_resize 函数。 12345678910111213141516171819def _init_resize(self, data, event): # NOTE 注销 init_resize self.painted.disconnect() layout = data.get("layout") index = data.get("index") item = data.get("item") # NOTE 从 layout 中取出 layout.takeAt(index) # NOTE 将当前的父组件大小进行记录 data["geometry"] = item.geometry() data["original_pos"] = self.pos() self.painted.connect(self._update_mask) self.resized.connect(partial(self._resize_overlay, data)) # NOTE 更新界面 QtCore.QTimer.singleShot(0, lambda: self._resize_overlay(data, None)) &emsp;&emsp;通过 layout.takeAt(index) 将 Overlay 组件取出来，如此就不受 layout 系统控制，成为一个悬浮组件。&emsp;&emsp;随后注册相关的信号槽更新 _update_mask _resize_overlay &emsp;&emsp;最后加上 QtCore.QTimer.singleShot 是强制更新当前组件的位置。&emsp;&emsp;要用 singleShot 到下一个 eventloop 进行更新是因为 layout.takeAt(index) 要等待它进入 eventloop 执行完成，更新 Overlay 组件的位置。&emsp;&emsp;更新了组件位置之后才可以用 _resize_overlay 方法来调整位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def _resize_overlay(self, data, event): item = data.get("item") geometry = data.get("geometry") layout = data.get("layout") original_pos = data.get("original_pos") width = self.geometry().width() height = self.geometry().height() spacing = layout.spacing() # NOTE 比较新的 geometry 大小和之前的差异 new_geometry = item.geometry() delta_x = new_geometry.x() - geometry.x() delta_y = new_geometry.y() - geometry.y() delta_width = new_geometry.width() - geometry.width() delta_height = new_geometry.height() - geometry.height() # NOTE 判断方向进行 x y 的位置调整 x = 0 y = 0 if self.direction == self.DIRECTION.W: x = delta_x + width + spacing y = delta_y elif self.direction == self.DIRECTION.E: x = delta_width + delta_x - width - spacing y = delta_y elif self.direction == self.DIRECTION.N: x = delta_x y = delta_y + height + spacing elif self.direction == self.DIRECTION.S: x = delta_x y = delta_height + delta_y - height - spacing self.move(original_pos + QtCore.QPoint(x, y)) # NOTE stretch 控制 Overlay 的缩放 if self.stretch == self.STRETCH.Auto: if self.direction in [1, 3]: self.setFixedWidth(new_geometry.width()) else: self.setFixedHeight(new_geometry.height()) elif self.stretch == self.STRETCH.Horizontal: self.setFixedWidth(new_geometry.width()) elif self.stretch == self.STRETCH.Vertical: self.setFixedHeight(new_geometry.height()) elif self.stretch == self.STRETCH.Center: self.move(original_pos) self.setFixedWidth(new_geometry.width()) self.setFixedHeight(new_geometry.height()) &emsp;&emsp;_init_resize 方法记录了依附组件当是时的 geometry 信息&emsp;&emsp;在 _resize_overlay 里面与之前的 geometry 数值做差就可以得到变化的偏移值。&emsp;&emsp;随后根据方向调整偏移值即可。 123456def _update_mask(self): # NOTE https://stackoverflow.com/q/27855137 reg = QtGui.QRegion(self.frameGeometry()) reg -= QtGui.QRegion(self.geometry()) reg += self.childrenRegion() self.setMask(reg) &emsp;&emsp;这个 mask 可以将 Overlay 组件自身挖空，保留子组件，避免导致下面的组件被遮挡。 &emsp;&emsp;左边是使用 mask 挖空的效果，右边是没有挖空的效果，没有挖空会遮挡住下面的功能。&emsp;&emsp;研究这个也让我解开了之前困扰我很久的问题， mpdb 开发时悬而未决的问题 链接&emsp;&emsp;当时也是想做一个 overlay 组件作为红色边框叠在 Maya 的窗口上，但是 overlay 组件会遮挡点击。&emsp;&emsp;现在就知道可以通过 setMask 来解决这个问题。 总结 &emsp;&emsp;以上就是 overlay 组件开发记录，源码可以去 Github 查阅 链接 &emsp;&emsp;内置了测试用的 ui 文件，使用上目前没有发现问题了。&emsp;&emsp;计划将这个组件功能添加到 dayu_widgets 里面，希望 pull request 可以通过。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# .Net WebService 拦截数据研究]]></title>
    <url>%2Fposts%2F9dbed701.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;没想到吧，四月份的首杀居然是搞这个，正好清明假期来总结一波。&emsp;&emsp;ε=(´ο｀*)))唉，研究这个那可是说来话长了，主要是想方设法帮我哥解决一下他们单位蛋疼的软件系统。 &emsp;&emsp;他们的软件系统用 .Net FrameWork 做的，需要在老旧的 XP 系统下运行(:з」∠)，使用上有很多 BUG&emsp;&emsp;软件承包商非常不给力，修了东墙又出西墙的问题，简直没完没了。&emsp;&emsp;这就导致很多需求特性都一直卡着无法落地，然后各种效率低下接踵而至。&emsp;&emsp;而且这承包商似乎和上层有道不清说不明的关系，还换不得，作为用户就只能干瞪眼。 &emsp;&emsp;我大致了解了情况，实在是看不下去了，作为日常工具人，这种小事写个 Python 脚本就能省下大量时间。&emsp;&emsp;于是我就开始尝试解决这个问题，然而我还是图样图森破了😔 AHK 自动复制方案 &emsp;&emsp;由于要支持 XP 系统，而且单位的系统实在是老旧的不行，和大学的讲课电脑有的一拼了。&emsp;&emsp;所以技术使用上有很多限制，很多新东西都无法使用了，比如 Python3 和 VScode&emsp;&emsp;于是我评估了一下支持老平台技术，恐怕就只有 AutoHotkey 是支持比较好的了。&emsp;&emsp;刚好那段时间才话时间研究了一下用 AutoHotkey 编写界面 AHK - 实现软件自动安装&emsp;&emsp;于是我当时想到的方案是通过 ahk 批量移动鼠标，然后找到对应的 GUI 窗口&emsp;&emsp;随后对窗口进行逐个复制，拿到的数据生成表格通过 AHK 显示出来。 &emsp;&emsp;于是为了实现这个效果，我客服了不少困难，在 Github 上开了仓库干这个事情 AHK_AutoValidate&emsp;&emsp;要让 ahk 的界面在 XP 系统下运行还需要用 32 位的编译器编译 exe&emsp;&emsp;开发过程可谓是异常艰难，好不容易才做了一个简单的 csv 表格界面。&emsp;&emsp;至于怎么定位 .Net 框架的 GUI 心里还是没有数。 &emsp;&emsp;后来我哥说那边的系统有很多硬件问题，回传的数据就已经不对了，别说自动获取了。&emsp;&emsp;让我不要再搞了，于是遂放弃了这个东西的开发。 &emsp;&emsp;后来我又认识了一个 AHK 录制神器，甚至集成了 GUI 图片识别 &amp; OCR 功能，自动化方面简直超神了 PuloversMacroCreator 官网&emsp;&emsp;这个如此强大的工具经过我测试可以在 XP 下运行~&emsp;&emsp;那么也可以利用这个录制出 AHK 脚本然后重复执行复制数据的操作。 &emsp;&emsp;然而我还是想得太简单了，软件界面里面的数据居然有些无法编辑无法复制。&emsp;&emsp;这一招也有不好使的地方 (:з」∠) ，遂没有进一步研究 Fiddler 请求拦截 &emsp;&emsp;如果要绕过 GUI ，那么就是要解决万变不离其宗的网络通信数据的拦截。&emsp;&emsp;过去我都是用浏览器自带的开发者模式来获取请求的信息。&emsp;&emsp;但是如果是本地的软件又要如何操作呢？&emsp;&emsp;以前大学搞 android 的时候有听说过一个叫 Fiddler 的软件，但是没有深入去研究。&emsp;&emsp;后来经过一番查找，发现还是这个神器做本地请求拦截是最合适的。 &emsp;&emsp;于是我在网上找了适合 XP 使用的老版本，然后用虚拟机安装了一个 XP 系统进行测试。&emsp;&emsp;测试的结果没有太大问题，于是我就去教我哥怎么使用这个拦截请求。&emsp;&emsp;本来还想着远程到电脑端进行处理的，但是单位电脑物理断网的，保证数据安全。&emsp;&emsp;内网通信也是只能通过指定电脑才能实现，猜测是做了 Mac 地址之类的识别吧。&emsp;&emsp;所以好不容易教会我哥使用这个拦截，拦截到的数据也是着实让我傻眼了。 &emsp;&emsp;这个请求是基于我先前重来没有了解过的一个 XML 规范做的。&emsp;&emsp;访问的是 asmx?WSDL 后缀的地址，并且请求和获取的数据都是 base64 加密过的。&emsp;&emsp;后来再一查才知道，原来这个是 WebService 的 SOAP 协议 SOAP 教程&emsp;&emsp;写文章之际又去网上搜了一下相关的介绍文章，感觉又有了全新的认识 知乎: 浅谈 RPC 和 REST: SOAP, gRPC, REST &emsp;&emsp;SOAP 和目前 Web 上使用主流的 Restful API 各有各的特点和应用场景。&emsp;&emsp;我这里的情况还算是比较合理的企业内通信应用方式。(我之前还以为是老掉牙的过时技术(:з」∠)) &emsp;&emsp;走 SOAP 协议的话，请求构建就非常单一，特别是我这里遇到的场景。&emsp;&emsp;通过 Fiddler 截获的大部分数据都时通过这个 WebService 路径进行访问的。&emsp;&emsp;接口很统一，都是 post 的请求。 &emsp;&emsp;然而最让我头疼的地方就是数据似乎被加密过。&emsp;&emsp;并不像 SOAP 教程中使用的明文数据。 &emsp;&emsp;于是我用 Python 对 base64 数据进行解码。 &emsp;&emsp;获取到的是比较蛋疼的二进制数据，这就让我毫无办法了，如果这个承包商还对数据做了加密处理，那我就原地去世了。 &emsp;&emsp;后来我担心是 Python 的 base64 解码有问题，用 C# 的功能也处理了一下，还是相同的问题。&emsp;&emsp;只是 C# 把二进制都打印出来了。 ILSpy 逆向 &emsp;&emsp;如果进过了加密，那就得知道加密算法才有办法解密出正确的数据。&emsp;&emsp;所以如果可以逆向 C# 的代码就可以解决这个问题。 &emsp;&emsp;不过我实际的研究就更加曲折了，在遇到 base64 问题之前，还卡在 AHK 的时候，我就有研究过逆向问题。&emsp;&emsp;由于我没有内网服务，所以我在本地的虚拟机测试是无法进入到软件的主界面的。&emsp;&emsp;我顺理成章地想到之前研究 IDA 对 dll 进行逆向破解的操作。 链接&emsp;&emsp;我想 C# 大概也能整一套这种骚操作，修改 二进制 文件从而实现绕过登录界面进入主界面。&emsp;&emsp;有了主界面我就可以用 AHK 识别相关 GUI 的位置了。 &emsp;&emsp;显然 IDA 不太适合处理这种复杂的多个 dll 的情况。&emsp;&emsp;于是我网上搜了一下 C# 的逆向，就找到了神器 ILSpy Github&emsp;&emsp;这个神器完全开源，可以通过 dll + pdb 文件逆向出项目源码，就问你离谱不离谱。 &emsp;&emsp;配合 Reflexil 二进制编辑插件就可以对项目的 dll 进行魔改了😎&emsp;&emsp;当时的确尝试修改了 dll 但是未能绕过登录界面反而是导致 C# 错误了&emsp;&emsp;于是就放弃了，毕竟这个问题并不重要。 &emsp;&emsp;再到如今遇到了 base64 加密问题，我再次想到使用 ILSpy 逆向破解源码，这就可以解决我头疼的加密问题了。&emsp;&emsp;于是我先从链接上的 RemoteMethodCallListener 下手。&emsp;&emsp;没想到这个还真是突破口，可以找到源码。 &emsp;&emsp;我居然在客户端上找到了服务端才应该有的代码，这有点不可思议😲&emsp;&emsp;通过上面的代码可以看到是调用 RemoteCallResult 对象的 ToBinary 方法 &emsp;&emsp;通过这里可以找到调用了 WrapHelper 方法 &emsp;&emsp;然后在这里的 FromBinary 方法就是解密方法。&emsp;&emsp;原来数据的头尾包了一个数字，来判断是压缩算法和加密算法，然后用 C# 的加密算法进行逆向解密。&emsp;&emsp;通过这个方法我应该可以自己写一个 C# 程序来破解数据。 dotnet SDK 开发破译程序 &emsp;&emsp;安装 dotnet 开发的 SDK 程序包。&emsp;&emsp;大多数情况都是 windows 自带的，毕竟是 微软 的亲儿子。&emsp;&emsp;安装成功的话可以在命令行输入 dotnet 来调用 sdk &emsp;&emsp;默认创建一个 命令行程序 可以使用 dotnet new Console&emsp;&emsp;然后在这个目录执行 dotnet run 就可以生成命令的 exe 并运行输出结果。 &emsp;&emsp;目录会生成 bin 和 obj 目录，可以无视，主要是 program.cs 和 csproj 文件。&emsp;&emsp;通过将 ILSpy 反编译的代码，可以套进去将 Fiddler 截获的二进制转换出来，结果和 ILSpy 破解的代码一样。&emsp;&emsp;这里并不是明文传输，而是直接传输了对象。&emsp;&emsp;用 Python 去理解的话，可以理解为 pickle 对象为二进制然后加密包装成 base64 发送。 &emsp;&emsp;但是获取的对象是他们 dll 里面生成的。&emsp;&emsp;如果直接在命令行打印解密的对象，会直接报错。 &emsp;&emsp;这就是提示缺少了相关的运行库，无法反序列化这个对象。 &emsp;&emsp;为了解决这个问题，我也摸索了很长一段时间，一开始是使用 System.Reflection.Assembly 的方法加载对应的 dll&emsp;&emsp;然后通过这个加载的 dll 实例获取相关的函数，使用 Invoke 方法进行调用。&emsp;&emsp;这个处理就异常的麻烦的，我就开始找有没有直接使用 using 关键字的方法，将整个依赖加入全局环境里面。&emsp;&emsp;但是实在搜不出有用的信息。 &emsp;&emsp;中途还看了一些 IronPython 的相关文章。 链接 12345678import clrclr.AddReference('CalcLib')#clr.AddReferenceToFile('CalcLib.dll')from CalcLib import Calcprint dir(Calc)calcObj = Calc()print "result of 3+4 is:", calcObj.Add(3,4)print "result of 10+2 is:", calcObj.Sub(10,2) &emsp;&emsp;看这篇文章的时候才发现， IronPython 居然可以通过 AddReference 加载 dll ，然后就可以直接导入了。&emsp;&emsp;通过这个引子，我顺藤摸瓜，找到了 Stack Overflow 的一篇回答 链接 &emsp;&emsp;这里面提到在 csproj 文件下可以直接添加 Reference ，然后指向对应位置的 dll 。&emsp;&emsp;这样全局的运行会将就有了相关 dll 的依赖。&emsp;&emsp;这样我写的 C# 程序可以直接调用他们程序提供的 dll 封装的方法，直接解析出对应的对象，将数据输出来。 &emsp;&emsp;终于经过了好多坑之后，我真的解决了这个数据加密问题，倍感欣慰。&emsp;&emsp;最难的骨头被我啃完了，我就不需要用低效的 AHK 方案来解决问题了。&emsp;&emsp;后续我还需要跟进一下的请求的构建，这样我就可以通过我写的命令行程序绕过软件承包商的 GUI 直接获取原始数据进行处理。 &emsp;&emsp;最后是要输出一个 32 位的程序在 XP 系统运行，需要加上一些配置 链接 总结 &emsp;&emsp;这次不务正业系列其实跨度很长，Anyway，总算是了却了一个心愿。]]></content>
      <categories>
        <category>CG</category>
        <category>C#</category>
        <category>.Net</category>
      </categories>
      <tags>
        <tag>࠴编程/CSharp</tag>
        <tag>࠴编程/dotNet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 断开 uasset 文件占用]]></title>
    <url>%2Fposts%2Fe314095b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Unreal 加载的资产会保持 打开状态，导致外部无法对资产编辑。&emsp;&emsp;这在更新资产的时候会比较难受，需要关闭引擎才能删除和更新。&emsp;&emsp;后来偶然看到项目组的程序用 C++ 写了一个断开 File Handle 的调用。&emsp;&emsp;于是我参考它的方案用 Python 写了一个，调用起来比 C++ 更方便且高效。 虚幻进行资产管理的好处 &emsp;&emsp;当 Unreal 读取了 uasset 文件资产之后，会通过文件句柄的方式锁定文件。&emsp;&emsp;避免外部对文件的修改。&emsp;&emsp;虚幻官方是推荐通过引擎的 Content Browser 对资产进行移动删除等的更新，这样做是有一些好处的，具体可以参考国外 reddit 的讨论 链接 官方文档参考Working with Assets 好处 移动资产可以自动更新关联资产的引用 删除资产可以替换资产的引用信息到新的资产上 拖拽直接生成资源 生成缩略图预览 &emsp;&emsp;因为虚幻的这种引用关系是嵌入在 uasset 里面的，所以如果要将资源迁移到别的项目，直接复制是会导致引用错乱的。&emsp;&emsp;解决方案是使用 Migrate 功能 官方文档参考 虚幻进行资产管理的痛点 &emsp;&emsp;虚幻引擎的这一套文件管理方式也会引入一些别的问题。 &emsp;&emsp;比如替换资产会引入莫名其妙的重定向器。&emsp;&emsp;重定向器的好处是保留旧资产的引用，这样不需要修改关联资产的路径，通过重定向器资产来链接到新资产。&emsp;&emsp;但是对新手来说不了解这个机制就非常的不友好，因为默认情况下重定向器是隐藏的！！&emsp;&emsp;如果命名为重定向器同名会提示命名冲突，但是隐藏的文件是看不到，就会让人很困惑。&emsp;&emsp;通常这种情况可以使用 Fix Up Redirectors in Folder 来删除隐藏的重定向器。 重定向器的问题 &emsp;&emsp;下面举出具体的例子来描述遇到的问题。 &emsp;&emsp;目前有文件有上述的资产，想要用 Cylinder_2 替换 Cylinder &emsp;&emsp;如果删除的时候没有引用关系的话，窗口会更加简洁，如上图所示。&emsp;&emsp;只是删除的时候还是需要虚幻找一遍文件的引用关系，导致删除大量无用资源的时候会比较慢。 &emsp;&emsp;由于 Cylinder 别隔壁的蓝图引用，直接删除 Cylinder 会弹出关联资源引用的窗口。 &emsp;&emsp;上面的资源替换弹窗选择 OK 之后，目录显示是很干净的。 &emsp;&emsp;但是当我们加一个新的资源，并且打算命名为之前的名字的时候，会发现该目录存在同名资源。 &emsp;&emsp;如果打开系统的文件浏览器就会发现的确有个同名小型的 uasset &emsp;&emsp;虚幻里面想要看到需要开启 Redirector 的过滤。 &emsp;&emsp;清理重定向器需要右键文件夹，选择 Fix Up Redirectors in Folder 来更新资源 &emsp;&emsp;清理之后就可以正常命名了。 &emsp;&emsp;虚幻这么设计也是有原因的，可以参考重定向器的文档 链接&emsp;&emsp;文档里面有所提及，更新资源的引用路径需要读取资源，如果有大量引用的话可能会花费很长的时间进行读取，协同开发也会受到影响。&emsp;&emsp;重定向器可以保留旧资源，引用到新资源上，而无需对关联资源做任何的修改。&emsp;&emsp;如果不清理重定向器会导致上面或者文档里面提到的不少问题，还是挺难顶的。 痛点 协同开发很容易因为路径更新造成冲突 (二进制无法解决冲突，可以接入版本控制来避免冲突) 某些情况资产更新需要重新导入才能完整更新，直接删除资产会修改到关联资产路径。 文件句柄占用导致需要关闭引擎才能更新 uasset 资产。(这个问题可以接入 UE4 的版本控制解决) &emsp;&emsp;另外还有一个痛点，就是当我文件做了我不想要的修改的时候，如何将 dirty 标记去掉，保留原来的资源。&emsp;&emsp;这个痛点我之前都是通过关闭引擎重新打开实现的。&emsp;&emsp;写文章的时候针对这个痛点我重新搜索了一阵。&emsp;&emsp;才知道 Unreal 原来早有设置好的解决方案。 官方问答链接 &emsp;&emsp;Unreal 的资源右键有 Asset Actions &gt; Reload 功能。&emsp;&emsp;reload 即可解决上面提到的问题。 handle 切断 uasset 占用 &emsp;&emsp;虽然强行切断 Unreal 的文件占用未必是件好事。&emsp;&emsp;但是实现一下这个功能，也并非什么难事。 &emsp;&emsp;主要是借助了 sysinternals 系列的 handle.exe 链接&emsp;&emsp;这个 handle.exe 可以监视系统内各种句柄的状态，也可以进行切断操作。 1234567891011121314151617181920handle /?Nthandle v4.1 - Handle viewerCopyright (C) 1997-2016 Mark RussinovichSysinternals - www.sysinternals.comusage: handle [[-a [-l]] [-u] | [-c &lt;handle&gt; [-y]] | [-s]] [-p &lt;process&gt;|&lt;pid&gt;] [name] [-nobanner] -a Dump all handle information. -l Just show pagefile-backed section handles. -c Closes the specified handle (interpreted as a hexadecimal number). You must specify the process by its PID. WARNING: Closing handles can cause application or system instability. -y Don't prompt for close handle confirmation. -s Print count of each type of handle open. -u Show the owning user name when searching for handles. -p Dump handles belonging to process (partial name accepted). name Search for handles to objects with &lt;name&gt; (fragment accepted). -nobanner Do not display the startup banner and copyright message.No arguments will dump all file references. &emsp;&emsp;首先可以通过 handle 的命令 查询当前进程下相关联的文件占用 1handle.exe -p PID PATH &emsp;&emsp;pid 是进程的 id ， PATH 是查询的路径。&emsp;&emsp;通过输入上述的命令可以在命令行下查询 Unreal 对相关文件的占用。 &emsp;&emsp;如上图所示，指定 pid 可以避免其他程序的干扰。&emsp;&emsp;但是 python 如何获取到 Unreal 的 pid 呢？&emsp;&emsp;这一步其实不需要第三方模块，用 Python 自带的功能就可以解决。 123456import osimport sysprint(sys.executable)# G:\RedAppEditor\Engine\Binaries\Win64\UE4Editor.exeprint(os.getpid())# 36688 &emsp;&emsp;可以看到 Python 自身 pid 就是 Unreal 的 pid 了。&emsp;&emsp;利用这个方法就可以完成占用的解除了。 &emsp;&emsp;最后就是接触占用的命令 1handle.exe -p 36688 -y -c 4358 &emsp;&emsp; -c 后面接 上面截图的获取路径前的 id&emsp;&emsp;通过上面的方式就可以解除占用了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import osimport reimport sysimport subprocessfrom multiprocessing.dummy import Poolimport unrealsys_lib = unreal.SystemLibrary()util_lib = unreal.EditorUtilityLibrary()red_lib = unreal.RedArtToolkitBPLibrary()paths = unreal.Paths()DIR = os.path.dirname(__file__)THREAD_COUNT = 8HANDLE = os.path.join(DIR, "handle.exe")PID = os.getpid()def convert_to_filename(path): content = sys_lib.get_project_content_directory() path = path.replace("/Game/", content) path = os.path.abspath(path).replace("\\", "/") if os.path.isdir(path): return path path = os.path.splitext(path)[0] return "%s.uasset" % pathdef unreal_progress(tasks, label=u"进度", total=None): total = total if total else len(tasks) with unreal.ScopedSlowTask(total, label) as task: task.make_dialog(True) for i, item in enumerate(tasks): if task.should_cancel(): break task.enter_progress_frame(1, "%s %s/%s" % (label, i, total)) yield i, itemdef get_release_pid(path): commands = [] path = convert_to_filename(path) path = paths.make_platform_filename(path) if not os.path.exists(path): return commands command = " ".join([HANDLE, "-p", str(PID), path]) # NOTE 获取文件占用信息 生成断开文件占用命令 output = str(subprocess.check_output(command, shell=True)) output = output.split("www.sysinternals.com")[-1] output = output.replace(r"\r", "") for line in output.split(r"\n")[:-1]: if not line: continue collections = re.split(r"[ ]+", line.strip()) if len(collections) &lt; 5: continue pid = collections[5] command = " ".join([HANDLE, "-c", str(pid), "-y", "-p", str(PID)]) commands.append(command) return commandsdef main(): # NOTE 接触当前目录下的资源 handle_path = red_lib.get_current_content_path() commands = get_release_pid(handle_path) # print("\n".join(commands)) pool = Pool(THREAD_COUNT) if commands: # NOTE 通过 Pool 简化多线程调用 批量解开占用 # NOTE 使用 imap_unordered 可以获取 遍历器 可以接入到 虚幻的进度条 itr = pool.imap_unordered( lambda command: subprocess.call(command, shell=True), commands ) for i,res in unreal_progress(itr, total=len(commands)): pass pool.close() pool.join() print(u"占用解除成功") else: print(u"无需解除占用") 总结 &emsp;&emsp;虽然实现了这种暴力解除文件占用的功能，但是其实并不是一个好的处理。&emsp;&emsp;本地文件断开占用挪动到别的地方，老位置的内存对象依然保留这的，所以也还是会让用户感到困惑。&emsp;&emsp;这个操作也不是虚幻官方所推荐的操作，不过了解了一下 handle.exe 的用法也甚好。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UE4.26 FBX Python Binding 编译]]></title>
    <url>%2Fposts%2F38fb96a1.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;关于 FBX SDK Python binding 在我最初的 Unreal Python 文章里面有所记录 链接&emsp;&emsp;当时是直接下载官方编译好的版本 &emsp;&emsp;但是官方只提供了 python2.7 和 python3.3 的版本&emsp;&emsp;过去 Unreal 4.26 以前 内置的 Python 是 2.7 还是可以兼容官方提供的 fbx 模块。&emsp;&emsp;但是到了 Unreal 4.26 官方总算是升级到了 3.7 ，以至于 Autodesk 官方提供的 fbx 模块无法使用了。&emsp;&emsp;那么如何才能让 Unreal 4.26 使用 fbx 模块呢？ &emsp;&emsp;官方提供了 源码 编译的相关文件，可以自己动手生成不同版本来兼容需求。 Python Binding 下载 &emsp;&emsp;下载安装 Binding ，安装了可以打开 readme 文档&emsp;&emsp;里面有很详细的操作说明。 What Is The Purpose Of Package? Binding 编译的目的The FBX Python Bindings allow developers to write the FBX Python SDK using their desired Python interpreter and Riverbank&apos;s Sip. Autodesk provides a pre-compiled version of the FBX Python SDK but only for a specific version of the Python interpreter (see the FBX Python SDK package) FBX Python 手动编译可以兼容不同的 Python 版本 Pre-Requisites 前置工作To be able to compile the sources in this package, you must also install the FBX SDK and you need to make sure that your system already has Sip (Linux system usually provide it by default). If your system does not provide Sip, you can download the Riverbanks Sip sources (https://www.riverbankcomputing.com/software/sip/download/) and build it as a pre-step of the PythonBinding.py script (see the HOW-TO section). A C++ compiler for your operating system will be required. For instance, on Microsoft Windows, the PythonBinding.py script will assume that you are working with Microsoft VisualStudio 2015. This can be changed by modifying the &quot;vcCompiler&quot; and &quot;vsCompiler&quot; variables defined in the script. Finally, the Python interpreter must be available on the build machine. 总结起来就是需要 FBX SDK C++ 源码，以及 C++ 编译器，默认脚本配置使用 VisualStudio 2015 的 C++ 编译器。 How-to 操作步骤3.1 Download the latest version of the FBX SDK and install it. &emsp;&emsp;下载并安装最新的 FBX SDK 3.2 Define the FBXSDK_ROOT environment variable to the location of the installed FBX SDK from step 3.1 (example: C:\Program Files\Autodesk\FBX\FBX SDK\2019.5) &emsp;&emsp;设置 FBXSDK_ROOT 的环境变量指向上面安装的路径 3.3 Run the PythonBinding.py script with the desired options (you can just call the script without arguments to see the available options). note: you may have to edit the script file to add your version of the python interpreter. By the default, the script defines the 32 and 64 bits ucs2 and ucs4 flavors of Python 2.x and 3.x (depending on the build machine). The PythonBinding.py script will try to locate the sipconfig.py file in the Python&apos;s sites using the getsitepackages() and getusersitepackages() returned paths. If found, it assumes that Sip has been installed on your machine and that it can be located using the system paths. If you want to use a specific RiverBanks&apos;s Sip sources version. You have to: a) download and extract the package sources. b) define SIP_ROOT environment variable to the location of the extracted Sip sources. c) call the PythonBinding.py with the buildsip option 3.4 The resulting files will be located in &quot;build/Distrib/site-packages/fbx&quot;. The fbx folder can then be, either moved inside Python&apos;s site-packages or, referenced using the PYTHONPATH environment variable (alternatively, by adding it into your python script using: sys.path.append()). Remarks: - If you generated the FBX Python SDK using a pre-installed Sip, you need to tell Python where it can find the libfbxsdk library. You achieve this by adding this library path to LD_LIBRARY_PATH environment variable. - Autodesk official build of the FBX Python SDK is using Sip sources version 4.19.3 because it is known that it correctly supports the &apos;--sip-module&apos; option and generates a private copy of sip named fbxsip. This fully qualified name does guarantee that there is not going to be conflicts with other sip modules in the system. Other versions of Sip sources, may fail to properly name the generated sip module. Therefore, if moving the content of &quot;build/Distrib/site-packages/fbx&quot;, be careful that you do not overwrite other sip module files already present in your system. &emsp;&emsp;运行 PythonBinding.py 会有相应的配置提示 &emsp;&emsp;使用之前可以先在 Python 下安装 sip ，这样就不需要源码编译 sip&emsp;&emsp;但是这里比较坑的点是 sip 最新版本不兼容， fbx sdk 里面的代码，运行会报错。&emsp;&emsp;建议使用安装使用老版本，我这里用的是比较久的 Anaconda ，默认是 python3.7 的，内置 sip 4.18.1 版本&emsp;&emsp;我顺带查了一下 sip 4.18.1 版本最高也只支持到 3.7&emsp;&emsp;riverbank 官网有 sip 源码可以下载 链接 &emsp;&emsp;但是使用新版本源码编译 sip 同样会出错，貌似是 fbx sdk 里面的 sip 文件有格式错误，估计是版本太新不兼容老的。&emsp;&emsp;于是我现在自己的 4.18.1 的版本运行编译,成功编译出了 fbx.pyd ，只是使用必须要加上 sip.pyd 才可以。 &emsp;&emsp;Remark 里面提到官方编译使用 4.19.3 ,然后利用 4.19.3 的特性可以 --sip-module 可以将 sip 转为 fbxsip 进行导入 避免 sip 模块的冲突&emsp;&emsp;于是我进一步研究了 buildsip 命令，从 sip 的源码开始把编译流程又走了一遍。 sip 模块编译 &emsp;&emsp;作为已经踩了一遍坑的前情提要， sip 的模块必须是 4.19.3 - 4.19.8 之间，因为最新的版本反而无法使用 fbxsip &emsp;&emsp;fbxsip 已经配置在 PythonBindings.py 里面，如果不用上述版本之间的 sip 则使用默认生成的 sip.pyd sip 4.19.8 下载和编译准备https://riverbankcomputing.com/software/sip/download sip 使用 Mercurial 版本管理工具进行仓库管理 &emsp;&emsp;点击上面的 repository 可以打开 sip 的仓库，后续的操作可以参考 github ，只是图形界面少了点。 &emsp;&emsp;选择 Tag 可以找到 4.19.8 的版本。 &emsp;&emsp;然后点击上面的三种不同的压缩包，都可以将当前版本下载下来。 &emsp;&emsp;下载下来之后，需要安装使用 bison 和 flex 来准备编译编译用的代码，具体可以查看 readme 说明，需要运行 build.py 来准备好编译文件。&emsp;&emsp;bison 和 flex 都是 Linux 下内置的 C 语言解析工具， windows 下需要特殊编译的版本，找到了个 github 仓库有编译好的版本 winflexbison&emsp;&emsp;将编译好的版本添加环境变量，运行 build.py prepare 进行编译准备。 &emsp;&emsp;后续的编译调用可以借助 PythonBindings.py 的 buildsip 命令。 PythonBindings 编译 &emsp;&emsp;需要配置 SIP_ROOT 的环境变量(路径为上面配置好的 sip 源码目录)，我这里为了省事，直接将路径写到了 py 脚本里面了。 1python PythonBindings.py Python3_x64 buildsip &emsp;&emsp;这个过程会自动进行 sip 的编译，生成 fbxsip.pyd&emsp;&emsp;脚本默认配置使用 VS2015 进行编译，需要配合 VS2015 的 SDK ，我本地都配置好了，编译很顺利，只是过程有些代码警告。 &emsp;&emsp;然后就可以得到我们需要的 pyd 文件了。&emsp;&emsp;最后生成的 pyd 完美在 Python3.7 下运行，兼容 UE4.26 引擎。 pyd下载 总结 &emsp;&emsp;找时间一定要研究下如何使用命令行调用 VS2015 的编译器进行编译的， VisualStudio 全部封装成按钮，反而让我很不爽，看不到背后的调用过程了。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Edge 浏览器迁移]]></title>
    <url>%2Fposts%2F7b971e06.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;以前写了一篇关于 Chrome 浏览器推荐的文章 链接&emsp;&emsp;那个时候我从 360浏览器 迁移到了 QQ浏览器。&emsp;&emsp;迁移最痛苦的是要重新习惯的收藏夹的分布，不过两个国产浏览器的体验其实大差不差。&emsp;&emsp;QQ浏览器如果登陆了还能同步安装了的 浏览器插件，这个比 360浏览器还要好点。&emsp;&emsp;当时我已经听说很多网站都推荐用 微软新推出的 Edge 浏览器。&emsp;&emsp;我以为就是默认的 win10 Edge 浏览器，最近尝试了才知道原来要另外下载安装包进行安装的。 &emsp;&emsp;最近在研究一些更好的笔记软件 比如 notion 、 wolai 等新式 all in one 软件。&emsp;&emsp;然后有被 QQ 浏览器古老的 Chromium 内核给气得火冒三丈，感觉 QQ浏览器自发布以来就没有更新过了(:з」∠)。&emsp;&emsp;网页的体验会有些许 BUG ，让我很难接受。 &emsp;&emsp;所以我也弃暗投明，转到 Edge 上了。&emsp;&emsp;但是转过来因为之前养成的很多习惯问题，来到 Edge 上发现都没法配置，让我难受了好一会😢&emsp;&emsp;经过一番摸索，装了好几个辅助的 Chrome 插件总算是还原了大体差不多的体验。 插件安装Super Drag for Google Chromehttps://chrome.google.com/webstore/detail/super-drag-for-google-chr/dlknjglebgomjjfaijjnebecgjbfjihk &emsp;&emsp;这个插件可以实现拖拽链接打开一个新的标签。&emsp;&emsp;而且还多了拖拽文字进行搜索功能 Open Tabs Next to Currenthttps://chrome.google.com/webstore/detail/open-tabs-next-to-current/gmpnnmonpnnmnhpdldahlekfofigiffh &emsp;&emsp;Edge 打开新的链接有时候不是在当前标签的右侧，这让我跳转标签变得很麻烦。&emsp;&emsp;当时在网上搜了一通都搜不到 Edge 改如何配置这个选项，有找到相关的问题，每个正经的回答。&emsp;&emsp;这个插件完美解决了我的烦恼。 Close All Tabshttps://chrome.google.com/webstore/detail/close-all-tabs/jcokdfogijmigonkhckmhldgofjmfdak &emsp;&emsp;QQ浏览器可以 Ctrl+Shift+W 关闭当前所有的标签。&emsp;&emsp;有时候标签多了可以用这个一键关闭，这个插件的快捷键是 alt+W 划词翻译https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91-%E7%AE%80%E5%8D%95%E5%A5%BD%E7%94%A8%E7%9A%84%E5%88%92%E8%AF%8D%E4%B8%8E%E6%88%AA%E5%9B%BE%E7%BF%BB%E8%AF%91%E6%89%A9%E5%B1%95/ikhdkkncnoglghljlkmcimlnlhkeamad &emsp;&emsp;以前在 QQ 浏览器直接双击就可以翻译单词，但是没法发声。&emsp;&emsp;这个插件比之前的还要好用，可以跨多个翻译平台，每个平台的语音都可以直接播放。 Separate WIndowhttps://chrome.google.com/webstore/detail/separate-window/cbgkkbaghihhnaeabfcmmglhnfkfnpon &emsp;&emsp;以前使用国产浏览器最棒的点就是可以将视频弹出到一个小窗口播放。&emsp;&emsp;虽然有个浏览器插件 Picture in Picture Mode 也可以实现类似的效果。&emsp;&emsp;这个功能我是用之前推荐过的 油猴脚本 来触发的。&emsp;&emsp;使用之后比起小窗口的好处是原网页依然可以进行滚动，看 Youtube 的时候就可以一边放视频，一边看底下的评论了。&emsp;&emsp;但是这个小窗口模式无法用油猴脚本来控制播放器。&emsp;&emsp;于是有些时候我还是希望能将特定的 DOM 元素提取出来放置到小窗口里面进行显示。&emsp;&emsp;这个插件就更加灵活，同时也能实现我想要的效果。&emsp;&emsp;国产浏览器里面只有视频弹出这个窗口，这个插件可以自定义任意元素的弹出，只是视频不会有按钮提示，需要手动点选配置弹出的元素。 浏览器功能扩展用好这些隐藏「小开关」，让 Chrome 浏览器更好用 &emsp;&emsp;Chromium 内核还有些隐藏的小功能，可以通过上面推荐的方式进行开启。 总结 &emsp;&emsp;通过以上插件的辅助，就可以还原大部分国产浏览器的功能。&emsp;&emsp;还有些就需要改变自己的使用习惯了，比如双击标签页关闭标签，这个在 Edge 里面使用鼠标中键进行关闭。&emsp;&emsp;点击浏览器的收藏标签需要用鼠标中键打开新的标签页，直接左键会覆盖掉当前页面。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python ToolMenuEntryScript 使用研究]]></title>
    <url>%2Fposts%2Ffe336621.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;去年有比较详细地研究如何通过 Python 生成 Unreal 的菜单 链接&emsp;&emsp;但是其实还有复杂的调用方法，可以实现更多的菜单项功能。&emsp;&emsp;这个就是本次探索的 ToolMenuEntryScript 对象了 用法 &emsp;&emsp;ToolMenuEntryScript 无法直接声明。&emsp;&emsp;需要用 Class 来继承它方能使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@unreal.uclass()class ScirptMenu(unreal.ToolMenuEntryScript): @unreal.ufunction(override=True) def execute(self,context): super(self.__class__,self).execute(context) print("context",context) @unreal.ufunction(override=True) def get_label(self,context): super(self.__class__,self).get_label(context) return u'测试 entry script' @unreal.ufunction(override=True) def get_tool_tip(self,context): super(self.__class__,self).get_label(context) return u'测试 entry script tooltip ' @unreal.ufunction(override=True) def is_visible(self,context): assets = unreal.EditorUtilityLibrary.get_selected_assets() return bool(assets) @unreal.ufunction(override=True) def can_execute(self,context): # NOTE 只有选择了场景的 ACtor 才可以调用 actors = unreal.EditorLevelLibrary.get_selected_level_actors() return bool(actors) @unreal.ufunction(override=True) def get_icon(self,context): # NOTE 只有选择了资源才会出现选项 icon = unreal.ScriptSlateIcon("EditorStyle","ContentBrowser.AssetActions.Delete") return icon menus = unreal.ToolMenus.get()menu_name = "ContentBrowser.AddNewContextMenu"menu = menus.find_menu(menu_name)# NOTE 如果已经注册则删除if menus.is_menu_registered(menu_name): menus.remove_menu(menu_name)menu = menus.register_menu(menu_name)# NOTE 注册 ToolMenuEntryentry = unreal.ToolMenuEntry(type=unreal.MultiBlockType.MENU_ENTRY)entry.set_label("测试 entry")entry.set_icon("EditorStyle","ContentBrowser.AssetActions.Edit")entry.set_string_command(unreal.ToolMenuStringCommandType.PYTHON,"",'import unreal;unreal.log("menu call")')menu.add_menu_entry('',entry)# NOTE 注册 ToolMenuEntryScriptscript = ScirptMenu()menu.add_menu_entry_object(script) &emsp;&emsp;开门见山，这是我自己研究出来可以使用的调用方法。&emsp;&emsp;Unreal Python 的函数重载需要用 Unreal 内置的装饰器进行包裹，可以参考 蓝图库封装 &emsp;&emsp;通过对 can_execute is_visible 的函数进行重载。&emsp;&emsp;我可以让菜单项根据选择的情况进行禁用和取消显示。&emsp;&emsp;比如我要做一个功能，只针对选择的 Texture2D 资源进行处理，那么我可以通过上面两个功能来禁用菜单选项。&emsp;&emsp;在用户交互方面更加友好。 &emsp;&emsp;根据上面的代码逻辑，没有选中资源不会出现选项。 &emsp;&emsp;选中资源没有选择场景的对象也无法执行。&emsp;&emsp;普通 entry 也可以接入 script_object 来扩展上述的功能。 &emsp;&emsp;icon 图标接入 python 下可以通过 set_icon 或者 get_icon 里面构建 ScriptSlateIcon 对象来实现配置。&emsp;&emsp;但是 Python 下无法注册自定义的图标，只能用引擎内置的图标。 &emsp;&emsp;引擎内置图标可以参考 SlateEditorStyle.cpp 脚本。&emsp;&emsp;里面有大量引擎的内置图标。 &emsp;&emsp;查看 C++ 的源码调用可以看到大部分调用都是诸如 FSlateIcon(FEditorStyle::GetStyleSetName(), &quot;Sequencer.CreateEventBinding&quot;) 的形式。&emsp;&emsp;后面的命名已经知道了，关键是 FEditorStyle::GetStyleSetName() 这个 set 的名称是啥。&emsp;&emsp;一开始我尝试在 Python 下不填写的，然而为空的话就什么图标都没有设置上。&emsp;&emsp;无奈只好做了一个 Unreal 蓝图节点打印一下这个字符串，返回的值是 EditorStyle&emsp;&emsp;所以官方的图标加上这个 Set 名称就可以用 Python 来调用了。 总结 &emsp;&emsp;以上就是 ToolMenuEntryScript 的研究&emsp;&emsp;ToolMenuEntry 对象也有 script_object 可以进行设置，因此可以设置起来很灵活。&emsp;&emsp;这些功能 ToolMenuEntryScript ToolMenuEntry 都是专门给 Python 扩展提供的类，因此和 C++ 的扩展方式是不太一样的。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal C++ 蓝图插件部署到任意项目]]></title>
    <url>%2Fposts%2F31ab7cbe.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;通过 开发 C++ Blueprint Library 可以扩展 Unreal Python 插件的功能。&emsp;&emsp;让 Unreal Python 的自动化更上一层楼，比纯 C++ 的调用要简单。&emsp;&emsp;然而 Unreal 的 C++ 插件有个很蛋疼的限制，不同电脑编译的 dll 都无法互相兼容。&emsp;&emsp;直接将插件相关的编译好的 dll 二进制文件扔到项目的 Plugins 目录，启动项目就会弹出需要重新编译的问题。 &emsp;&emsp;如果点击是尝试进行重新编译，基本上是不可能成功的。&emsp;&emsp;因为项目用的美术工程都是不提供源码的。 &emsp;&emsp;这导致 C++ Plugin 的部署非常受限，过去我开发的东西是和项目的程序工程绑定在一起的，这样部署就不会出问题。&emsp;&emsp;但是最近要支持多个项目，C++ Plugin 如果也能跨项目岂不美哉。 踩坑尝试 &emsp;&emsp;最初的方向还是在 Bing 上搜索 C++ plugin distribution 之类的关键字。&emsp;&emsp;也找到了一些论坛和回答上相关的问题，其中有些内容提到了官方的 Plugin说明 &emsp;&emsp;最开始我草草阅读 Plugin 说明，留意到里面有提到 发布插件相关的说明，需要用到 package 功能来发布到虚幻商城。 &emsp;&emsp;于是我也尝试走了一下打包流程，然并卵，打包只是将插件放到一个空的工程下，但是将工程里的 Plugin 搬到别的 项目中依然需要编译支持。 &emsp;&emsp;后来认真地把官方文档通读了一遍。&emsp;&emsp;发现里面分 Engine Plugin 和 Project Plugin 的。&emsp;&emsp;官方说明里提到 Engine Plugin 是不依赖项目的，于是我也尝试了一下将 自己的插件 放到 Engine 的 Plugin 目录下。 &emsp;&emsp;启动项目居然没有弹出编译提示，启动成功了。&emsp;&emsp;但是进入引擎之后去找插件，可以看到自己写的插件是没有加载的，勾选上之后重启引擎，然后编译的警告又又出现了。 &emsp;&emsp;到此我是真的卡主了，浪费了我好多时间。&emsp;&emsp;这个时候我只好进行进一步测试了，好歹我支持的项目是 程序 美术工程都在手的。&emsp;&emsp;我就不信将自己本机的程序工程拷到美术工程到不行。&emsp;&emsp;于是我也尝试了一下这个方案，结果还真的报警告了。 &emsp;&emsp;于是我又还原了美术工程的插件，然后只替换里面的 dll ，结果发现居然可以正常启动了。&emsp;&emsp;我仔细查了一下我插件下的文件，然后我就破案了。 &emsp;&emsp;关键是在 UE4Editor.modules 这个文件里面 &emsp;&emsp;这个文件里面存储了 BuildId ， 我发现 UnrealBuildTool 应该是识别这个 Id 是否一致来判断这个插件是否需要重新编译的。&emsp;&emsp;因此我没有替换这个文件就不会触发警告。&emsp;&emsp;顺着这个思路查了一下，可以在官方文档里面找到相关的内容 链接 &emsp;&emsp;这次是真的找到关键了，正如上面我所说的， Unreal 编译的时候会统一生成这个 BuildId 来确保 dll 是统一环境下生成的。&emsp;&emsp;避免 dll 的不统一导致引擎出现 Crash ，这种 Crash 就很难查，因此 Unreal 直接通过 BuildId 来规避问题。 &emsp;&emsp;沿着这个线索可以找到更多有用的信息 UE4多个分支版本兼容相同的工程dll&emsp;&emsp;上面的 CSDN文章 也是我所想要实现的效果，奈何之前不知道怎么搜索一直没找到这种关键的文章。&emsp;&emsp;文章还提到这个 id 是通过 引擎编译的时候生成的 uuid。&emsp;&emsp;检测提示则是在 LaunchEngineLoop.cpp 文件里面&emsp;&emsp;只有识别到跳过编译状态才会检测这个 buildId 是否一致。 &emsp;&emsp;如果在 EditorPerProjectUserSettings.ini 加入下面的选项 12[/Script/UnrealEd.LevelEditorViewportSettings]bForceCompilationAtStartup=True &emsp;&emsp;则会强制进行编译，就没有 buildId 检测了，但是强制编译也是不通过的结局。&emsp;&emsp;所以每次引擎更新的时候都要更新一下当前 C++ 模块的 buildId 才不会弹出提示窗口。 &emsp;&emsp;那么 BuildId 应该以哪个文件为准呢？&emsp;&emsp;骨骼找到一个 Unreal 插件的说明文档，还是挺有价值的 链接 &emsp;&emsp;以引擎内置的 UE4Editor.modules 的 BuildId 为准。&emsp;&emsp;经过我的测试，如果没有别的依赖的话，只要 BuildId 对应， dll 是可以跨项目使用的。 总结 &emsp;&emsp;以上就是这次踩坑的情况。&emsp;&emsp;如果不部署到项目的程序工程代码里面的话，就只能用一个工具检测 引擎内置的 UE4Editor.modules 有没有变化，变化了就更新 BuildId。&emsp;&emsp;这个处理也是挺麻烦的(:з」∠)，不过也不失为一个可行的方案。 &emsp;&emsp;当然也有一个更简单的方案，就是得和项目的程序进行商量。&emsp;&emsp;Engine\Build\Build.version 引擎里面有这个文件，具体的配置可以参考 C++ API &amp; 文档&emsp;&emsp;Build.version 的 json 文件里面配置 buildId 就可以了。&emsp;&emsp;但是以后所有的 BuildId 都用这里的配置的 ID。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python Placer 工具]]></title>
    <url>%2Fposts%2Ffc07371d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个东西本来是 Minigame 的时候用来方便搭建场景的工具，&emsp;&emsp;因为当时的情况，时间紧迫，所以最后没弄成，留下了些许遗憾。 &emsp;&emsp;后来也只是更新了个办成品到 PyToolkit 里面&emsp;&emsp;随后的开发就一直落下了。 &emsp;&emsp;最近刚好天时地利人和，就把这个遗憾给补上了。 获取 Unreal 资源缩略图 &emsp;&emsp;Placer 我想要实现将 Unreal 内置的资产缩略图整合到 Qt 的 ListWidget 里面。&emsp;&emsp;如此可以让 Qt 界面的功能性更强。 &emsp;&emsp;但是如何利用 C++ 获取到资源的缩略图呢？ &emsp;&emsp;经过网上搜查，我在 CSDN 找到一篇不错的文章 链接 &emsp;&emsp;Unreal 里面有 ThumbnailTools::RenderThumbnail 可以生成缩略图&emsp;&emsp;文章里面还用了 GetUncompressedImageData 可以获取到图片的源数据。 1234567TArray&lt;uint8&gt; UPyToolkitBPLibrary::GetThumbnail(UObject* MeshObject,int32 _imageRes)&#123; // NOTE https://blog.csdn.net/zhangxiaofan666/article/details/97643308 FObjectThumbnail _objectThumbnail; ThumbnailTools::RenderThumbnail(MeshObject, _imageRes, _imageRes, ThumbnailTools::EThumbnailTextureFlushMode::AlwaysFlush, NULL, &amp;_objectThumbnail); return _objectThumbnail.GetUncompressedImageData();&#125; &emsp;&emsp;通过上面的调用可以获取到一串数字的数组，这个整数的数组让我啪的一下就反应过来，和我以前研究的 Maya 视窗截取有相似之处。 链接 代码链接 12345678910# NOTE https://gist.github.com/hmasato/b72a95fbadf1c63b56ecpixel = image.pixels().__long__()ptr = ctypes.cast(pixel, ctypes.POINTER(ctypes.c_char))size = width * height * 4# NOTE ord将字符转换为 0 - 255 ASCII码区间if number: return [ord(char) for char in ctypes.string_at(ptr, size)]else: return ctypes.string_at(ptr, size) &emsp;&emsp;当时是从 Maya 的 API 中获取到了字符数据，然后通过 Python 将数据转换为 0-255 的数字&emsp;&emsp;这次反过来，我是获取到了一系列代表 0-255 的数字了。&emsp;&emsp;随后我研究了一下 QImage 的类，发现它其实可以直接处理 字符 数据，不需要像之前那样进行处理。 链接 &emsp;&emsp;之前为了将数据传到 Maya API 的 Image 才需要如此大费周折。&emsp;&emsp;因而这一次换一种思路管理获取的数据。 123data = "".join([chr(v) for v in py_lib.get_thumbnail(asset)])image = QtGui.QImage(data, size, size, QtGui.QImage.Format_RGB32)widget.setPixmap(QtGui.QPixmap.fromImage(image).scaled(size / 2, size / 2)) &emsp;&emsp;所以这里只要反其道而行之，将获取的数字数组转换为 字符串 即可。 2021-3-30 Python3 更新 &emsp;&emsp;升级 Py3 之后，使用上述的方法将 List 数据转成字符串传到 PySide2 之后会出错。&emsp;&emsp;首先的问题是 Python3 默认使用 unicode 编码，直接会导致 overflow 错误&emsp;&emsp;经过我的研究，需要将 unicode 转为 bytes 类型才不会出错，但是直接转 bytes 之后图片就对不上了。 &emsp;&emsp;后来实在没有办法了，请教了吴真大佬，最后得出是利用 struct 模块构建出合适类型的数据从而在长度上匹配，传入的数据才是正确的。 12345import structdata = py_lib.get_thumbnail(asset)data = struct.pack('='+'B'*len(data), *data)image = QtGui.QImage(data, size, size, QtGui.QImage.Format_RGB32)widget.setPixmap(QtGui.QPixmap.fromImage(image).scaled(size / 2, size / 2)) Unreal Python Undo 操作实现 &emsp;&emsp;之前做 Minigame 的时候，遇到了个棘手的问题，当时我通过 Python 的 set_actor_location_and_rotation 的方法来实现物体的吸附。 12345678# NOTE 获取用户的两个物体选择origin, target = self.get_selected_actors()location = origin.get_actor_location()rotation = origin.get_actor_rotation()target.set_actor_location_and_rotation( location, rotation, False, False)# NOTE 选择 actorslevel_lib.set_selected_level_actors([target]) &emsp;&emsp;当时上面的做法无法实现 Unreal 的撤销操作。&emsp;&emsp;如果用户不想要撤销我就彻底没辙。 &emsp;&emsp;我想起之前看 虚幻官方直播有提及 撤销需要接入 begin_transaction 和 end_transaction 才可以。 Youtube链接 Github链接 &emsp;&emsp;有些时候直接用 上面方法是好使的&emsp;&emsp;但是上面的移动物体的方法并不管用。&emsp;&emsp;后来还是在老牌的 UnrealEnginePython 的仓库里面找到了很有用的说明文档 Transactions_API.md &emsp;&emsp;非常凑巧，说明的例子也是移动物体。&emsp;&emsp;里面提到需要加上 modify 方法才可以正常调用。&emsp;&emsp;于是我查了一下官方 Python 文档也有这个方法，而且是配合 transaction 来使用的 链接 12345678910111213141516origin, targets = self.get_selected_actors()# NOTE 配置 undo# NOTE https://github.com/20tab/UnrealEnginePython/blob/master/docs/Transactions_API.mdsys_lib.begin_transaction("ALIGN", "align selected", None)for target in targets: location = origin.get_actor_location() rotation = origin.get_actor_rotation() # NOTE 设置 undo target.modify(True) target.set_actor_location_and_rotation(location, rotation, False, False) # NOTE 选择 actors level_lib.set_selected_level_actors([target]) target.modify(False)sys_lib.end_transaction() &emsp;&emsp;结合上面提到的就可以通过 modify 的设置来配置 Actor 的 Undo 了 C++ 直接调用右键菜单的功能 &emsp;&emsp;虚幻有些功能功能藏得很深，用起来也很不方便。 &emsp;&emsp;如上图所示吸附、选择等等功能，调用需要在大段的菜单里面找功能。&emsp;&emsp;我希望将这些功能整合到一个面板上，方便使用。&emsp;&emsp;当然这个调用靠 Python 做不到的，我希望通过简单的 C++ 就可以调用大量的这种内置的功能。 &emsp;&emsp;以前要解决这个问题，我通常多需要将引擎内部的源码拷贝到我的蓝图里面进行调用。&emsp;&emsp;如果说这个需要我这边做一些源码的修改还算合理。&emsp;&emsp;但是如果只是如上述所说的简单功能，那就很费劲了。&emsp;&emsp;那么有没有更加简单的方式来调用菜单里面注册好的功能呢？&emsp;&emsp;当然还是有的，答案也在 Unreal 的 C++ 源码里面。 &emsp;&emsp;之前我有研究过怎么用 C++ 添加菜单或者注册快捷键。&emsp;&emsp;需要用到 UI_COMMAND 来生成 FUICommandInfo &emsp;&emsp;然后通过 FUICommandList 的 MapAction 分配调用的方法。&emsp;&emsp;既然是用 FUICommandList 映射了 FUICommandInfo 执行的方法。&emsp;&emsp;那么能否只通过上述的两个类就能直接触发函数。&emsp;&emsp;这样我实现脸触发函数的参数都省了，更加简单。&emsp;&emsp;后来我翻阅 FUICommandList 的 API 文档发现他有 ExecuteAction 的方法。&emsp;&emsp;理论上应该可以直接触发注册的 FUICommandInfo 的。&emsp;&emsp;但是直接搜索 ExecuteAction 会找到很多无关的调用。&emsp;&emsp;后来我灵机一动，搜索 CanExecuteAction 这个方法应该可以极大缩小范围。 &emsp;&emsp;[^F]CanExecuteAction\(通过正则表达式过滤可以找到我想要的实现效果。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071bool UPyToolkitBPLibrary::ExecLevelEditorAction(FString Action)&#123; FLevelEditorModule &amp;LevelEditorModule = FModuleManager::GetModuleChecked&lt;FLevelEditorModule&gt;(TEXT("LevelEditor")); auto Actions = LevelEditorModule.GetGlobalLevelEditorActions(); auto Commands = LevelEditorModule.GetLevelEditorCommands(); TMap&lt;FString, TSharedPtr&lt;FUICommandInfo&gt;&gt; ActionMap; ActionMap.Add("SaveAs", Commands.SaveAs); // Ctrl + E ActionMap.Add("EditAsset", Commands.EditAsset); // Ctrl + shift + E ActionMap.Add("EditAssetNoConfirmMultiple", Commands.EditAssetNoConfirmMultiple); // Ctrl + End ActionMap.Add("SnapOriginToGrid", Commands.SnapOriginToGrid); ActionMap.Add("SnapOriginToGridPerActor", Commands.SnapOriginToGridPerActor); ActionMap.Add("AlignOriginToGrid", Commands.AlignOriginToGrid); // Ctrl + Space ActionMap.Add("SnapTo2DLayer", Commands.SnapTo2DLayer); // End ActionMap.Add("SnapToFloor", Commands.SnapToFloor); ActionMap.Add("AlignToFloor", Commands.AlignToFloor); // Alt + End ActionMap.Add("SnapPivotToFloor", Commands.SnapPivotToFloor); ActionMap.Add("AlignPivotToFloor", Commands.AlignPivotToFloor); // Shift + End ActionMap.Add("SnapBottomCenterBoundsToFloor", Commands.SnapBottomCenterBoundsToFloor); ActionMap.Add("AlignBottomCenterBoundsToFloor", Commands.AlignBottomCenterBoundsToFloor); ActionMap.Add("DeltaTransformToActors", Commands.DeltaTransformToActors); ActionMap.Add("MirrorActorX", Commands.MirrorActorX); ActionMap.Add("MirrorActorY", Commands.MirrorActorY); ActionMap.Add("MirrorActorZ", Commands.MirrorActorZ); ActionMap.Add("LockActorMovement", Commands.LockActorMovement); // alt + B ActionMap.Add("AttachSelectedActors", Commands.AttachSelectedActors); ActionMap.Add("SavePivotToPrePivot", Commands.SavePivotToPrePivot); ActionMap.Add("ResetPrePivot", Commands.ResetPrePivot); ActionMap.Add("ResetPivot", Commands.ResetPivot); ActionMap.Add("MovePivotHereSnapped", Commands.MovePivotHereSnapped); ActionMap.Add("MovePivotToCenter", Commands.MovePivotToCenter); ActionMap.Add("AlignToActor", Commands.AlignToActor); ActionMap.Add("AlignPivotToActor", Commands.AlignPivotToActor); ActionMap.Add("SelectAll", FGenericCommands::Get().SelectAll); // Escape ActionMap.Add("SelectNone", Commands.SelectNone); ActionMap.Add("InvertSelection", Commands.InvertSelection); // Ctrl + Alt + D ActionMap.Add("SelectImmediateChildren", Commands.SelectImmediateChildren); // Ctrl + Shift + D ActionMap.Add("SelectAllDescendants", Commands.SelectAllDescendants); ActionMap.Add("SelectRelevantLights", Commands.SelectRelevantLights); ActionMap.Add("SelectAllWithSameMaterial", Commands.SelectAllWithSameMaterial); // SLayersView.h bool Available = ActionMap.Contains(Action); if (Available) &#123; auto ActionPtr = ActionMap[Action].ToSharedRef(); Available = Actions-&gt;CanExecuteAction(ActionPtr); if (Available) Actions-&gt;ExecuteAction(ActionPtr); &#125; return Available;&#125; &emsp;&emsp;做了个字典用字符串映射内部的 FUICommandInfo&emsp;&emsp;这样 Python 传入相应的字符串就可以调用内部的方法了。 123import unrealpy_lib = unreal.PyToolkitBPLibrary()py_lib.exec_level_editor_action("SaveAs") 总结 &emsp;&emsp;以上就是 Unreal Python 的一些调用上的增强。&emsp;&emsp;其实最近还有一些别的 Unreal Python 探索。&emsp;&emsp;回头抽空在把 菜单 ToolMenuEntryScript 和 蓝图内添加 Component 给加上吧。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pyblish 框架原理探索]]></title>
    <url>%2Fposts%2F88ab5ea.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;没想到过年一拖更，便是长达一个月，如今已经开工第二周了(:з」∠)&emsp;&emsp;过年回家没有更新博客，倒是看了些许 Houdini 教程，记录在 HoudiniWiki 网站中了。&emsp;&emsp;然而最近一周迷上了煲剧 - 庆余年，快前年的剧了，热播的时候就有所耳闻，一直压着没看。&emsp;&emsp;最近回深圳上班之后，感觉不在状态，周末就想着看些爽剧休闲一下，结果打开了潘多拉的魔盒ε=(´ο｀*)))唉 &emsp;&emsp;恰逢最近工作需要搭建流程框架，试图将影视的部分 publish 流程，迁移到现有的游戏工作流中。&emsp;&emsp;这难免让我想起了以前老东家干的活，虽然那时候在实习，毕竟也是担任流程 TD 的岗位。&emsp;&emsp;当时做的很多东西未能落地，实属我入行的遗憾，未接触过成熟的流程框架落地的感觉。 &emsp;&emsp;总算在这边可以尝试开源的 Pyblish 框架将流程落地了。 &emsp;&emsp;Pyblish 框架是 mottosson 大佬(由于 Github 的图片是秃头的，我们都尊称为秃子)结合开源社区制作的一款通用流程框架。&emsp;&emsp;框架将前端后端分离，开源免费，适合大小 studio 结合不同平台来使用。 官网教学APIGithub生态 我个人收集的一些 studio 的案例 https://github.com/pyblish/pyblish-mindbenderhttps://github.com/BigRoy/pyblish-magentahttps://github.com/kredencstudio/pyblish-kredenchttps://github.com/bumpybox/pyblish-bumpybox Pyblish 作用 &emsp;&emsp;Pyblish 是 Python + Publish 的合成词，以为结合 Python 的发布流程。&emsp;&emsp;Pyblish 是前后端分离框架， pyblish-base 是底层内核的调度仓库。&emsp;&emsp;由于前后端分离，因此 Pyblish 前端有 pyblish-lite 和 pyblish-qml 两种不同的实现方式&emsp;&emsp;前端只是个界面，背后依靠的还是 pyblish-base 的调度，分为 collect 收集 validate 校验 extract 提取 integrate 整合 四个环节。&emsp;&emsp;这个四个环节官方去其英文首字母缩写为 CVEI 流程 &emsp;&emsp;这四个环节就是 pyblish 集众多流程软件的经验总结抽象出来的核心。&emsp;&emsp;四个环节的拆分可以让环节之间尽可能解耦，让框架更加灵活。 &emsp;&emsp;如果觉得我说的很抽象的话，可以看下面这个视频，这是秃子 Vimeo 账号下发布的 Pyblish 动画小短片。 &emsp;&emsp;这个是动画非常直观的表现了 Pyblish 框架的目的。&emsp;&emsp;作为一个质检流程，避免错误的文件发布到下游，提前发现问题，降低沟通成本。 &emsp;&emsp;结合 Github 的 Qml 前端操作的截图，想必会更加具象。 &emsp;&emsp;pyblish 会将分成 CVEI 四个环节分部进行。&emsp;&emsp;第一步是收集检查需要用到的信息，然后根据相关的信息生成对应 检查实例&emsp;&emsp;第二步是根据生成的 检查实例 分类进行响应不同的检查项检查&emsp;&emsp;第三步提取将文件导出关联的格式，比如 fbx abc 等等(影视流程要考虑更多，诸如 ass 高低模等等)&emsp;&emsp;第四步整合则是对接到相关到任务管理软件，更新任务相关的数据。 &emsp;&emsp;Pyblish 的核心是 Validate 质检过程，通过大量的检查项确保发布的文件基本符合规格。 &emsp;&emsp;了解 Pyblish 的基础要素强烈推荐过一遍官方的 Learn文档&emsp;&emsp;其中 Quick Start 章节有 Pyblish 的核心内容， Pyblish 概念 &amp; 使用Pyblish 基础运用 &emsp;&emsp;Pyblish 内部有两种不同的 Plugin ContextPlugin 和 InstancePlugin&emsp;&emsp;Collect 阶段使用 ContextPlugin 随后生成 InstancePlugin 来进行不同的调度。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import pyblishdisk = &#123;&#125;items = ["JOHN.person", "door.prop"]class CollectInstances(pyblish.api.ContextPlugin): order = pyblish.api.CollectorOrder # &lt;-- This is new def process(self, context): # for item in items: name, suffix = item.split(".") context.create_instance(name, family=suffix)class ValidateNamingConvention(pyblish.api.InstancePlugin): order = pyblish.api.ValidatorOrder def process(self, instance): name = instance.data["name"] assert name == name.title(), "Sorry, %s should have been %s" % ( name, name.title(), )class ExtractInstances(pyblish.api.InstancePlugin): order = pyblish.api.ExtractorOrder def process(self, instance): name = instance.data["name"] transient_path = "c:\temp\%s.mb" % name disk[name] = instance instance.data["transientDest"] = transient_path # NOTE maya 下 导出文件 from maya import cmds cmds.file(transient_path, exportSelected=True)class IntegrateInstances(pyblish.api.InstancePlugin): order = pyblish.api.IntegratorOrder def process(self, instance): transient_dest = instance.data["transientDest"] permanent_dest = "/instances/%s.mb" % instance server[permanent_dest] = disk[transient_dest] pyblish.api.register_plugin(CollectInstances)pyblish.api.register_plugin(ValidateNamingConvention)pyblish.api.register_plugin(ExtractInstances)pyblish.api.register_plugin(IntegrateInstances)pyblish.util.publish() &emsp;&emsp;上述代码基于官方教学整合而来。&emsp;&emsp;注册 Plugin 之后通过调用 publish 方法可以不通过 UI 执行注册的发布。 &emsp;&emsp;所有的 Plugin 固定调用 process 方法 &emsp;&emsp;ContextPlugin 固定传入 Context 类&emsp;&emsp;InstancePlugin 固定传入 Instance 类 &emsp;&emsp;Context 类可以通过 create_instance 方法创建实例，每个实例会根据 关联属性被相关的 InstancePlugin 调度。 链接 Pyblish 调度执行 &emsp;&emsp;我们会创建很多不同检查项，但是不同的实例走的检查不尽相同，Pyblish 提供了相应的标签属性来合理调度检查项。 Plugin API链接 123456789101112131415161718192021222324252627282930313233343536373839import pyblish.apiitems = ["john.person", "door.prop"]class CollectInstances(pyblish.api.ContextPlugin): order = 0 def process(self, context): for item in items: name, suffix = item.split(".") instance = context.create_instance(name) instance.data["families"] = [suffix]class PrintPersons(pyblish.api.InstancePlugin): order = 1 families = ["person"] def process(self, instance): print("Person is: %s" % instance)class PrintProps(pyblish.api.InstancePlugin): order = 1 families = ["prop"] def process(self, instance): print("The prop is: %s" % instance)pyblish.api.register_plugin(CollectInstances)pyblish.api.register_plugin(PrintPersons)pyblish.api.register_plugin(PrintProps)import pyblish.utilpyblish.util.publish()# The person is "john"# The prop is "door" &emsp;&emsp;上面通过配置 families 参数可以让 分别走不同的 InstancePlugin&emsp;&emsp;类似的还有 hosts 属性和 targets 属性 &emsp;&emsp;order 属性来管理当前检查的顺序，下面是官方支持的范围 1234-0.5 to 0.499.. &#x3D; Collection0.5 to 1.499.. &#x3D; Validation1.5 to 2.499.. &#x3D; Extraction2.5 to 3.499.. &#x3D; Integration &emsp;&emsp;action 属性可以给当前检查项添加右键菜单，触发额外的功能，比如获取错误的模型或者快速修复有问题的地方。 &emsp;&emsp;以上提到的就是 pyblish 的核心功能。&emsp;&emsp;另外还有一些让 Pyblish 更加灵活的功能，比如 event 事件系统 &emsp;&emsp;可以在不同的状态下触发不同的事件。&emsp;&emsp;也支持注册自定义事件，在检查项中触发 123456789101112131415161718import pyblish.utilimport pyblish.apiclass MyCollector(pyblish.api.ContextPlugin): order = pyblish.api.CollectorOrder def process(self, context): pyblish.api.emit("myEvent", data="myData")def on_my_event(data): print(data)pyblish.api.register_plugin(MyCollector)pyblish.api.register_callback("myEvent", on_my_event)pyblish.util.publish()# 打印 myData Pyblish-base 调度原理常用数据结构 &emsp;&emsp;上面是 Context &amp; Instance 类， process 传入的 context 和 instance 参数就是这两个类的相应实例 1234567class CollectInstances(pyblish.api.ContextPlugin): def process(self, context): passclass ValidateNamingConvention(pyblish.api.InstancePlugin): def process(self, instance): pass &emsp;&emsp;它们的基类 AbstractEntity 是个数组，所以可以进入 for 循环进行遍历。 publish &emsp;&emsp;入口函数是 publish ，从上面的截图可以看到后续核心调用是 _convenience_iter &emsp;&emsp;_convenience_iter 核心调度&emsp;&emsp;logic.Iterator 返回的 Context 参数 和 Instance 参数 logic.Iterator &emsp;&emsp;在 logic.Iterator 遍历器里面会先对 targets 属性进行过滤。&emsp;&emsp;然后遍历一遍传入的 plugins 类，通过 instances_by_plugin 的方法找出 plugin 和 context.create_instance 生成实例的关系。 &emsp;&emsp;这里直接对传入的 context 当成 instances 变量进行 for 循环。&emsp;&emsp;那为啥 context 是 instances 呢？&emsp;&emsp;这就承接上面数据结构所提到的， context 的基类是个数组，执行 context.create_instance 方法。 &emsp;&emsp;查看 create_instance 的调用可以看到如果传入 parent 就会将自身 append 到 parent 里面了。&emsp;&emsp;所以 context 直接 for 循环就是其关联的 instances。 &emsp;&emsp;最后会通过 plugin.match 以及 instance 传入的 family 和 families 过滤出对应调用的 plugin 。&emsp;&emsp;create_instance 的时候会将所有的后续参数 **kwargs update 到 data 中。&emsp;&emsp;过滤 family 会用到 data 中的数据，因此 family 的调用可以写到 create_instance 里面 123class ValidateMeshNonManifold(pyblish.api.Validator): def process(self,context): context.create_instance("instance",family="character",families=["actor"]) plugin.process &emsp;&emsp;通过上面的 logic.Iterator 可以返回 plugin 类和其关联的 instance 属性。&emsp;&emsp;后续会到 plugin.process 进行调用，注意这个 plugin 是小写是 模块 里面的函数调用。 &emsp;&emsp;process 为了兼容以前的 API 会分 __explicit_process 和 __implicit_process&emsp;&emsp;__explicit_process 会实例化传入的 plugin 类并且判断当前是 action 还是 plugin&emsp;&emsp;从中分配好 process 使用的参数。 总结 &emsp;&emsp;虽然上述的调用有点绕，不过基本就是这个原理完成了 publish 的实例调度过程。&emsp;&emsp;这么做可以根据当前文件里不同类型的数据拆分到不同 families 检查项下检查。&emsp;&emsp;实现更细致的检查控制和调度。 &emsp;&emsp;pyblish-base 是无 GUI 下检查调度的功能。&emsp;&emsp;pyblish-lite 带 GUI 检查的时候并不是直接用 pyblish-base 下的 publish 的。&emsp;&emsp;为了同步响应 GUI ， pyblish-lite 拆分了 publish 的过程，不过核心的调度还是用了 base 的 API。]]></content>
      <categories>
        <category>CG</category>
        <category>pipeline</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hugo 构建 HoudiniWiki 静态网站]]></title>
    <url>%2Fposts%2Fd8d5b740.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;元旦的时候回家看 Houdini 的教程。&emsp;&emsp;看的过程中萌生了一个想法，始终挥之不去。&emsp;&emsp;那就是能否做一个网站，将 Houdini 的知识点全部总结归纳起来。&emsp;&emsp;这样就可以将视频的知识和 Houdini 的节点连接起来。&emsp;&emsp;让 Houdini 复杂的知识脉络更加清晰。&emsp;&emsp;越是看教程，这个想法越是强烈，以至于教程都看不进去了(:з」∠)。 &emsp;&emsp;所以为了实现这个效果，就开始在网上查阅有没有好的文档制作工具。&emsp;&emsp;在使用 Maya 的 C++ 文档的时候，体验过每个函数都能够自动生成链接到案例的标签。&emsp;&emsp;找相关联的案例就非常方便。&emsp;&emsp;我也希望能够制作一个 HoudiniWiki 的网站实现类似的效果。 &emsp;&emsp;开始是在网上找相关的文档生成工具，我之前也有做过 基于 Docsify 前端技术来生成文档网站 链接&emsp;&emsp;但是 Docsify 无法做到将关联的信息自动生成出来，只能手动添加。 &emsp;&emsp;于是到头来我还是想到了 Hexo ，毕竟 Html 模板还是有很多操作可以坐上去的。&emsp;&emsp;但是 Hexo 相关的文档主题就很少，唯一找到一个比较完善的文档博客 链接&emsp;&emsp;但是要实现我上面说的效果还是差了点。 &emsp;&emsp;于是又去找，找着想起了当时 Hexo 太重想换 Hugo 的时候， Hugo 也有很多主题，说不定就有我想要的 文档 主题。&emsp;&emsp;于是我就去尝试 Hugo 的主题，才发现 Hugo 果真有我想要的东西 链接 &emsp;&emsp;我找到了几个不错的文档主题 docport Zdoc Learn&emsp;&emsp;我想让我的文档网站支持的侧边栏的收缩，当时使用 Docsify 的时候也为这个问题纠结了好长一段时间。&emsp;&emsp;最后也没有什么好的方案，所以这次选主题也重点参考了这点。 &emsp;&emsp;后来使用 ZDoc 文档的时候找到 Github 作者，发现他还做了一个 Zzo 的主题。&emsp;&emsp;这个主题可就厉害了，里面整合了很多前端技术，借助 Hugo 只需要用 markdown 的编写即可方便 &emsp;&emsp;为了将 Zzo 有的功能集成到 ZDoc 里面，我又花了很长的时间进行缝合，为此推荐 Youtube 上的一款教程 链接 &emsp;&emsp;另外推荐 Hugo 比较有用的网站 官方文档 Github 问题 论坛 Hugo 下载 &amp; 使用官方文档教程 &emsp;&emsp;上面是官方教程链接，操作过程首先要去下载 Hugo.exe 可执行文件。&emsp;&emsp;Github 的 Release 是一个不错的选择 链接&emsp;&emsp;windows 下推荐下载 extend 的版本，虽然大小会大很多，同时会囊括更多的功能。 &emsp;&emsp;下载之后给 Hugo.exe 配置环境变量就可以在任意路径访问它了~ &emsp;&emsp;Hugo 是个命令工具，简单的使用可以参照官方文档&emsp;&emsp;使用 Hugo new Site SiteName 创建一个 Hugo 生成目录&emsp;&emsp;然后在 themes 目录下 clone 一个 Hugo 主题的仓库&emsp;&emsp;修改 config.toml 的主题指向。&emsp;&emsp;在 content 目录下添加 md 文件。&emsp;&emsp;完成这些操作之后就可以直接在命令行输入 Hugo 命令生成网站了。&emsp;&emsp;当然也可以使用 Hugo server 部署一个本地服务器，在本地查看和更新网站。 &emsp;&emsp;下载的主题如果想要直接查看网站的显示效果，可以跳转到 exampleSite 目录，然后使用命令行 Hugo server --themesDir ../..&emsp;&emsp;可以直接预览主题内置的网站效果。 &emsp;&emsp;最后 Hugo 生成的时候可以使用 Hugo --minify 命令将网站全部压缩到最小状态&emsp;&emsp;Hugo 工具还有很多命令，其实日常根本不会用到，可以无需了解。 HoudiniWiki 文档构建 &emsp;&emsp;了解了 Wiki 之后我就可以根据上面找到的主题进行去构建属于我自己的 Wiki 网站了。&emsp;&emsp;但是只是到这个程度还不及我的预期，我想要的效果正如上面所说的，想要将 Zzo 和 ZDoc 两个主题结合到一起。 Hugo Templates &emsp;&emsp;之前有接触过 Hexo 的 ejs 和 pug&emsp;&emsp;Hugo 则是直接使用 html ，可以通过 大括号 标记嵌入 Go 语言的相关逻辑。&emsp;&emsp;Hugo 内置了相关的 变量 和 方法进行操作。 &emsp;&emsp;比如我魔改 HoudiniWiki 的时候，想要自定义 image 的渲染方式，让它自动识别 markdown 的 image 渲染并转为 video 标签。(只不过这个方案因为破坏了 Markdown 的语意，不便于文章迁移，所以作罢了) &emsp;&emsp;我可以在 layouts/_default/_markup/render-link.html 这个路径创建 html 文件，关于 Markdown Render Hooks 可以参考文档 链接 123456789101112131415161718192021&lt;!-- 将视频格式的后缀制作成 Go 数组 --&gt;&#123;&#123; $exts := slice "wmv" "asf" "asx" "mpg" "mpeg" "mpe" "rm" "rmvb" "mpg" "mpeg" "mpe" "3gp" "mov" "mp4" "m4v" "avi" "dat" "mkv" "flv" "vob"&#125;&#125;&lt;p class="md__image"&gt; &lt;!-- 参考 Markdown Render Hooks 的文档 .Destination 是 ![alt](url) 是 url 的部分 --&gt; &lt;!-- 判断当前链接是否是视频的后缀 --&gt; &#123;&#123;$destination := .Destination &#125;&#125; &#123;&#123;$isVideo := false &#125;&#125; &#123;&#123; range $exts&#125;&#125; &#123;&#123; if strings.HasSuffix $destination . &#125;&#125; &#123;&#123;$isVideo = true &#125;&#125; &#123;&#123; end &#125;&#125; &#123;&#123; end &#125;&#125; &#123;&#123;$url := .Destination | default "" &#125;&#125; &lt;!-- 如果是视频后缀用 video | 不是则 img --&gt; &#123;&#123;if $isVideo&#125;&#125; &lt;video src="&#123;&#123; $url &#125;&#125;" autoplay="autoplay" loop="loop" style="width: 100%; height:100%;"&gt;&lt;/video&gt; &#123;&#123; else &#125;&#125; &lt;img src="&#123;&#123; $url &#125;&#125;" alt="&#123;&#123; .Text &#125;&#125;" &#123;&#123; with .Title&#125;&#125; title="&#123;&#123; . &#125;&#125;" &#123;&#123; end &#125;&#125; /&gt; &#123;&#123; end &#125;&#125;&lt;/p&gt; &emsp;&emsp;以上就是 Hugo templates 的一个简单案例，采用 Go 和 html 混写生成的模式。&emsp;&emsp;让 HTML 带有了逻辑语句功能，目的和 ejs 或是 pug 是一致的，但是 Hugo 还能实现 Markdown 特定的 hook ，这个功能更为方便。 Hugo shortcodes &emsp;&emsp;shortcodes 是文章里面调用 Go 写好的模板，可以让 Markdown 的写作更为便利。&emsp;&emsp;hexo 也有 Tag Plugins 的玩意，实现效果是差不多的，不过我还从来没有研究过。 123456789101112131415&#123;&#123;&lt; columns &gt;&#125;&#125; &lt;!-- begin columns block --&gt;# Left ContentLorem markdownum insigne...&lt;---&gt; &lt;!-- magic separator, between columns --&gt;# Mid ContentLorem markdownum insigne...&lt;---&gt; &lt;!-- magic separator, between columns --&gt;# Right ContentLorem markdownum insigne...&#123;&#123;&lt; /columns &gt;&#125;&#125; &emsp;&emsp;比如上面的写法，通过 大括号 标记 markdown 的入口，然后将相关的 markdown 填入到分割符对应的位置。&emsp;&emsp;就可以根据提供的 shortcode 模板生成页面。 Hugo taxonomies &emsp;&emsp;Hugo 支持自定义分类。这个比 Hexo 要好， Hexo 要实现这个功能只能借助社区提供的插件。&emsp;&emsp;具体可以 Hugo 的文档 链接 1234[taxonomies] category = "categories" series = "series" tag = "tags" &emsp;&emsp;在配置文件里面配置这些分类标签之后，就可以在文章的 front-matter 里面添加相关的标记。 123456789101112categories:- Developmentproject_url: https://github.com/goHugoio/Hugoseries:- Go Web Devslug: Hugotags:- Development- Go- fast- Bloggingtitle: 'Hugo: A fast and flexible static site generator' &emsp;&emsp;Hugo 会根据这些标记生成汇总页面。 Hugo Related &emsp;&emsp;Hugo 有 Related 可以根据一定的权重比例生成关联文章的数组 文档&emsp;&emsp;Hexo 官方并没有提供这个功能，不过也可以通过 js 写一个，比如我现在这个主题就是自己写的，文章末尾会自动生成相关文章的推荐。 123456789101112[related] includeNewer = false threshold = 80 toLower = false [[related.indices]] name = "keywords" weight = 100 [[related.indices]] name = "date" weight = 10 &emsp;&emsp;相比较之下，Hugo 提供的功能更为方便且高效。 Hugo 于 Hexo 比较 &emsp;&emsp;Hugo 的主题比起 Hexo 数量和质量都差了很多。&emsp;&emsp;并且 Hugo 扩展插件很麻烦，最近的新版本开始支持 Go 语言写扩展了，但是还是需要有 Go 开发的背景。&emsp;&emsp;而 Node.js 很多前端都会使用，相较于 Go 的混写， Hexo 显然更受欢迎。&emsp;&emsp;不过 Hugo 最大的卖点生成高效也的确是当之无愧。 &emsp;&emsp;我思考在三，在文档生成领域里面的确 Hexo 这方面还是一片空白。&emsp;&emsp;相比较之下使用 Hugo 会更方便，博客方面的话就不打算迁移了，文章很多，迁移过去的代价有点大。&emsp;&emsp;现在用的主题经过我一点点的魔改，都不敢升级了(:з」∠) Github Actions CI 网站自动部署 &emsp;&emsp;很找就看到过有人用 Github 的 Actions 自动部署 Hexo 博客。&emsp;&emsp;而我目前走的方案还是沿用 hexo 官方提供的 deploy 部署，虽然效率比较低，但是好在管用。&emsp;&emsp;后来知道部署 QBinder 才开始稍微接触了一点 Github 的 CI 功能，的确是挺香的。&emsp;&emsp;于是这次 Hugo 的部署我就深入使用了 Github 的 Action CI。 &emsp;&emsp;经过了我多次 push 测试之后，这是目前我走 CI 流程的配置文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869name: github pages# 触发条件 | 每次 push 自动触发on: push: branches: - master jobs: deploy: runs-on: ubuntu-18.04 steps: # 拉取仓库到 服务器上 这个是 Github 自带默认配置的 - uses: actions/checkout@v2 with: # 下面是基于 Hugo 部署仓库推荐的操作流程 https://github.com/peaceiris/actions-hugo submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod # NOTE 跑 python 脚本生成 links.json 数据供 Hugo 调用 - name: collect links.json run: python $&#123;&#123; github.workspace &#125;&#125;/content/collect_link_data.py # 配置 服务器 Hugo 环境 | 直接调用别人做好的 actions - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true # 运行 Hugo 生成网站 - name: Build run: hugo --minify # 将网站部署到 Github Pages 上 | 直接调用别人做好的 actions - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./docs # 部署 ssh Key | Github 将隐私数据通过 secrets 插入 - name: Install SSH Key # You may pin to the exact commit or the version. # uses: shimataro/ssh-key-action@6f350ca8484d8d55c2e361e74d17e638dabe713a uses: shimataro/ssh-key-action@v2.1.0 with: # SSH private key key: $&#123;&#123; secrets.SERVER_SSH &#125;&#125; known_hosts: $&#123;&#123; secrets.SERVER_SSH_PUB &#125;&#125; name: blog config: | # will be appended! Host HoudiniWiki HostName $&#123;&#123; secrets.SERVER_IP &#125;&#125; User git IdentityFile ~/.ssh/blog # 部署 ssh Key 就可以让服务器直接连接到我私人服务器的 HoudiniWiki 仓库了 # 由于上面的 python 脚本生成了多余的数据，需要让仓库的修改全部放弃，然后将 仓库 gh-pages 分支同步到我服务器上的仓库上 # 最后我在自己的服务器仓库上配置 Git 钩子，接受 push 就 checkout 数据到静态页面挂载的目录，实现网站 push 自动更新 - name: push repo run: | git remote add server git@HoudiniWiki:/home/git/repos/HoudiniWiki.git git reset git checkout . git clean -fdx git checkout gh-pages git pull origin gh-pages git push server gh-pages &emsp;&emsp;其实 CI 配置就是指挥 Github 服务器的操作手册，上面的脚本可以让我 push 之后自动生成网站并且直接部署到我的个人服务器上。&emsp;&emsp;写法其实挺清晰的，而且编写界面还有别人写好的开源 CI ，可以直接套入使用。 &emsp;&emsp;不过刚开始总是出现各种配置错误，所以要 push 好几次才把流程跑通。 总结 &emsp;&emsp;目前 HoudiniWiki 已经部署了，大家有兴趣可以访问 hou.l0v0.com 访问。&emsp;&emsp;目前网站的骨架基本架设好了，后续我还要多去看 Houdini 的教程，将内容填充进去。&emsp;&emsp;我以前也将一些 Houdini 的教程整理写在博客里，就不删除了，到时候会将教程重新看一遍。&emsp;&emsp;然后将所有的知识点重新写文章总结一波。 &emsp;&emsp;近期会集中精力完善，所以博客大概会停更一段时间了~]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>ࡀHugo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python singledispatch 库原理探究]]></title>
    <url>%2Fposts%2F24d75f2f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最初认识这个库是因为 dayu_widgets 里面用到了这个进行函数的重载。&emsp;&emsp;对于它能实现的效果还是挺感兴趣的。 &emsp;&emsp;singledispatch 可以实现函数的泛型重载&emsp;&emsp;可以使用 pip install singledispatch 安装使用， github 地址&emsp;&emsp;下面是官方提供的案例整合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from singledispatch import singledispatchfrom decimal import Decimal@singledispatchdef fun(arg, verbose=False): if verbose: print("Let me just say,", end=" ") print(arg)@fun.register(int)def _(arg, verbose=False): if verbose: print("Strength in numbers, eh?", end=" ") print(arg)@fun.register(list)def _(arg, verbose=False): if verbose: print("Enumerate this:") for i, elem in enumerate(arg): print(i, elem)def nothing(arg, verbose=False): print("Nothing.")fun.register(type(None), nothing)@fun.register(float)@fun.register(Decimal)def fun_num(arg, verbose=False): if verbose: print("Half of your number:", end=" ") print(arg / 2) fun("Hello, world.")# Hello, world.fun("test.", verbose=True)# Let me just say, test.fun(42, verbose=True)# Strength in numbers, eh? 42fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)# Enumerate this:# 0 spam# 1 spam# 2 eggs# 3 spamfun(None)# Nothing.fun(1.23)# 0.615 &emsp;&emsp;可以看到 singledispatch 根据第一个参数的类型调用不同函数的功能。&emsp;&emsp;这个功能在 Python 3.4 之后引入到 functools 里面。 原理分析singledispatch 装饰器拆解 &emsp;&emsp;首先看装饰器 @singledispatch 的作用&emsp;&emsp;装饰器整体代码可以简化为如下所示 12345678910111213141516171819202122from functools import update_wrapperdef singledispatch(func): registry = &#123;&#125; def dispatch(cls): ... def register(cls, func=None): ... def wrapper(*args, **kw): return dispatch(args[0].__class__)(*args, **kw) registry[object] = func wrapper.register = register wrapper.dispatch = dispatch # update_wrapper 等价于 @wraps update_wrapper(wrapper, func) return wrapper &emsp;&emsp;@singledispatch 包装函数之后返回 wrapper 对象&emsp;&emsp;wrapper 同时添加 register &amp; dispatch 方法&emsp;&emsp;背后调用其实是将第一个参数的类型放到 dispatch 函数进行 调用分发。 &emsp;&emsp;因为 wrapper.register 有这个设置。&emsp;&emsp;如果我们把 装饰器 的语法糖拆除就很清楚到底发生了什么 123456789101112131415# @singledispatch# def fun(*args, **kwargs):# pass# 等价于下面的写法 ↓↓↓from singledispatch import singledispatchdef fun(*args, **kwargs): passfun = singledispatch(fun)# --------------------------------print(fun.register)# &lt;function singledispatch.&lt;locals&gt;.register at 0x0000027A6D0DE670&gt; &emsp;&emsp;经过 装饰器 封装之后 fun 就会有 wrapper.register 方法了。&emsp;&emsp;那只要 register 方法也是一个装饰器的写法，就可以继续沿用 @ 装饰器的写法。&emsp;&emsp;从这也可以理解为啥后续 register 的函数命名已经不重要了。 regsiter 函数分析12345678910111213141516171819202122232425262728from functools import update_wrapperdef get_cache_token(): return ABCMeta._abc_invalidation_counterdef singledispatch(func): registry = &#123;&#125; # dispatch_cache = WeakKeyDictionary() def ns(): pass ns.cache_token = None def dispatch(cls): ... def register(cls, func=None): if func is None: return lambda f: register(cls, f) registry[cls] = func if ns.cache_token is None and hasattr(cls, '__abstractmethods__'): ns.cache_token = get_cache_token() # dispatch_cache.clear() return func def wrapper(*args, **kw): ... # 省略 ... &emsp;&emsp;register 使用了非常取巧的方式构建带参数的装饰器。&emsp;&emsp;如果 func 没有传参就返回一个 lambda 来接收参数&emsp;&emsp;然后会将当前获取的类型存放到 registry 里面&emsp;&emsp;get_cache_token 是获取 ABCMeta._abc_invalidation_counter 的计数&emsp;&emsp;因为使用了 ABCMeta 元类会影响到 mro 判断，这里可以先抛开不提。 &emsp;&emsp;register 函数主要是给 registry 字典添加 类型 对应 func 的匹配关系 dispatch 函数分析1234567891011121314151617181920212223242526272829303132333435363738394041424344from functools import update_wrapperfrom weakref import WeakKeyDictionarydef singledispatch(func): registry = &#123;&#125; # NOTE 使用 WeakKeyDictionary dispatch_cache = WeakKeyDictionary() # def ns(): pass # ns.cache_token = None def dispatch(cls): NOTE ABCMeta 数量发生变化重置 缓存 if ns.cache_token is not None: current_token = get_cache_token() if ns.cache_token != current_token: dispatch_cache.clear() ns.cache_token = current_token try: # NOTE 从 cache 取值 impl = dispatch_cache[cls] except KeyError: try: # NOTE 从 registry 取值 impl = registry[cls] except KeyError: # NOTE 没有匹配的类型，可能是用户扩展的类型，查找 mro 找到最匹配的 方法。 impl = _find_impl(cls, registry) # NOTE 存放到缓存里面 dispatch_cache[cls] = impl return impl def register(cls, func=None): # 省略 ... # NOTE 重置缓存 dispatch_cache.clear() # 省略 ... def wrapper(*args, **kw): ... # 省略 ... &emsp;&emsp;WeakKeyDictionary 的用法可以参考这篇文章 链接&emsp;&emsp;大概就是如果 key 的对象已经不存在的话，那么 WeakKeyDictionary 会自动清理这个键值对 &emsp;&emsp;为什么这里需要用到 WeakKeyDictionary ，因为 dispatch 传递的 cls 可能是用户扩展的类型。&emsp;&emsp;用户也有可能处于某些原因直接删除了这个 cls 类型导致缓存出问题，所以用 WeakKeyDictionary 这种骚操作可以轻松解决问题。 &emsp;&emsp;应用场景如下 ↓↓↓ 123456789101112131415161718192021222324252627282930from singledispatch import singledispatchclass TestDict(dict): def __init__(self,data): super(TestDict, self).__init__(data) def some_method(self): print("some_method")@singledispatchdef fun(*args, **kwargs): print('original',args)@fun.register(dict)def _(data): for key, val in data.items(): print(key,val)a = &#123;'a':1&#125;fun(a)# a 1fun(TestDict(a))# a 1fun(['a'])# original (['a'],)fun(&#123;'as'&#125;)# original (&#123;'as'&#125;,) &emsp;&emsp;在这种自定义扩展的情况下，需要根据 TestDict 类型的 mro 匹配出最符合条件的 registry 类型，调用相关的方法。&emsp;&emsp;_find_impl 就是来干这个事情的。 _find_impl 剖析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758def _compose_mro(cls, types): """Calculates the method resolution order for a given class *cls*. Includes relevant abstract base classes (with their respective bases) from the *types* iterable. Uses a modified C3 linearization algorithm. """ bases = set(cls.__mro__) # Remove entries which are already present in the __mro__ or unrelated. def is_related(typ): return (typ not in bases and hasattr(typ, '__mro__') and issubclass(cls, typ)) types = [n for n in types if is_related(n)] # Remove entries which are strict bases of other entries (they will end up # in the MRO anyway. def is_strict_base(typ): for other in types: if typ != other and typ in other.__mro__: return True return False types = [n for n in types if not is_strict_base(n)] # Subclasses of the ABCs in *types* which are also implemented by # *cls* can be used to stabilize ABC ordering. type_set = set(types) mro = [] for typ in types: found = [] for sub in typ.__subclasses__(): if sub not in bases and issubclass(cls, sub): found.append([s for s in sub.__mro__ if s in type_set]) if not found: mro.append(typ) continue # Favor subclasses with the biggest number of useful bases found.sort(key=len, reverse=True) for sub in found: for subcls in sub: if subcls not in mro: mro.append(subcls) return _c3_mro(cls, abcs=mro) def _find_impl(cls, registry): mro = _compose_mro(cls, registry.keys()) match = None for t in mro: if match is not None: # If *match* is an implicit ABC but there is another unrelated, # equally matching implicit ABC, refuse the temptation to guess. if (t in registry and t not in cls.__mro__ and match not in cls.__mro__ and not issubclass(match, t)): raise RuntimeError("Ambiguous dispatch: &#123;0&#125; or &#123;1&#125;".format( match, t)) break if t in registry: match = t return registry.get(match) &emsp;&emsp;_c3_mro 会根据就是根据 _compose_mro 过滤的信息重新计算一遍 mro 顺序&emsp;&emsp;mro 计算采用了 c3 算法，具体的计算过程可以参考 链接 Python官网 123456789101112131415161718下面的伪代码比较好的阐明了 C3 算法的作用L[object] &#x3D; [object]L[D] &#x3D; [D, object]L[E] &#x3D; [E, object]L[F] &#x3D; [F, object]L[B] &#x3D; [B, D, E, object]L[C] &#x3D; [C, D, F, object]L[A] &#x3D; [A] + merge(L[B], L[C], [B], [C]) &#x3D; [A] + merge([B, D, E, object], [C, D, F, object], [B], [C]) &#x3D; [A, B] + merge([D, E, object], [C, D, F, object], [C]) &#x3D; [A, B, C] + merge([D, E, object], [D, F, object]) &#x3D; [A, B, C, D] + merge([E, object], [F, object]) &#x3D; [A, B, C, D, E] + merge([object], [F, object]) &#x3D; [A, B, C, D, E, F] + merge([object], [object]) &#x3D; [A, B, C, D, E, F, object]merge 会去取各个数组里面排第一位后面没有重复且排到第一位以外的对象 &emsp;&emsp;不过这里的 singledispatch mro 还考虑 ABCMeta 元类的影响。&emsp;&emsp;所以需要构建一个特殊的 c3 算法进行处理。&emsp;&emsp;也直接导致 singledispatch 复杂了很多。 &emsp;&emsp;因为大多数情况下，很少会用到 Python 的 ABCMeta 进行编程。&emsp;&emsp;所以 _compose_mro 大都是返回了 python __mro__ 的顺序&emsp;&emsp;然后再从 mro 继承顺序里找出最匹配 registry 存储对象的函数进行调用。 总结 &emsp;&emsp;singledispatch 用 Python 实现 c3 算法还挺有意思的，我这里就没有详细列出来了。&emsp;&emsp;建议去看源码学习。]]></content>
      <categories>
        <category>Python</category>
        <category>Python黑科技</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 黑科技 内存修改]]></title>
    <url>%2Fposts%2Fe2f82dfc.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近和吴真大大讨论了一下 QBinder 框架对于数据管理的问题。&emsp;&emsp;Python 语言本身会遇到一个比较麻烦的问题，那就是数据传递给 QBinder 框架之后，需要用 QBinder 构建的数据结构来更新数据。&emsp;&emsp;如此才能实现组件的更新。&emsp;&emsp;然而实际的应用场景下，编程的用户更加希望 QBinder 构建了绑定之后直接用原始的数据进行更新。&emsp;&emsp;所以为此需要 Python 能够实现类似 C++ 的指针的效果，直接处理原始数据。 &emsp;&emsp;基于这样的大前提下，我研究了一段时间，感受到了 Python 语言本身的瓶颈，很难解决(:з」∠)&emsp;&emsp;而且官方的也不推荐使用 Python 修改内存，因为 Python 有自己的 gc (垃圾回收机制) ，胡乱修改反而会出更多问题。&emsp;&emsp;虽然这个提议很有诱惑力，但是要实现反而会引发更多问题。&emsp;&emsp;参考 Vue 和 React 这些前端框架，也无法做到一套数据实现 框架之间 直接互通，都需要将数据转换到框架的数据结构之下。&emsp;&emsp;因此这个提议被放弃了，如果各路 仁人志士 有不错的提议 ，欢迎与我讨论交流 ~ &emsp;&emsp;所以这篇文章就是基于这个大前提的研究做的一些总结。&emsp;&emsp;从中有可以学到 Python 很多不为人所知的黑科技，胶水语言的名堂可不是白吹的。&emsp;&emsp;语言表层简单直白，底层也依然有内置 ctypes gc struct array 库来实现交互。&emsp;&emsp;当然还有黑科技 dis 和 ast 来处理 Python 汇编 和 抽象语法树。&emsp;&emsp;对比 node.js 大量的第三方库，我觉得 Python 内置库真的很完善。 利用 ctypes 强行内存修改 &emsp;&emsp;当时我在 Stack Overflow 查找相关的方法没有找到，想来 Python 应该是做不到的。&emsp;&emsp;没想到吴真大大做到了，我拿到了它的代码别提有多兴奋了。 12345678910import ctypesdef mutate(obj, new_obj): if sys.getsizeof(obj) != sys.getsizeof(new_obj): raise ValueError('objects must have same size') mem = (ctypes.c_byte * sys.getsizeof(obj)).from_address(id(obj)) new_mem = (ctypes.c_byte * sys.getsizeof(new_obj)).from_address(id(new_obj)) for i in range(len(mem)): mem[i] = new_mem[i] &emsp;&emsp;上面限制了数据长度必须相等，不会修改到 内存 的其他地方。&emsp;&emsp;不过我觉得不够灵活，于是改成来下面的样子。 123456789101112import ctypesdef mutate(obj, new_obj): mem = (ctypes.c_byte * sys.getsizeof(new_obj)).from_address(id(obj)) new_mem = (ctypes.c_byte * sys.getsizeof(new_obj)).from_address(id(new_obj)) for i in range(len(mem)): mem[i] = new_mem[i]# NOTE 用法演示a = "a"print(a) # 打印 amutate(a,"b")print(a) # 打印 b &emsp;&emsp;探讨这个函数的作用就得先理解清楚 Python 赋值的作用，还有为什么 Python 没有 i++ 这类的自增语句。&emsp;&emsp;这里特别感谢吴真大佬的讲解，我之前对这方面存在一些误区，现在更加清楚了~ &emsp;&emsp;首先需要知道 Python 存在 mutable 和 immutable 对象，可以参考 知乎链接 &emsp;&emsp;Python 赋值其实并不是全部都如 C++ 之类的语言会直接构建一个变量对象分配内存空间。&emsp;&emsp;Python 内部会有 Cache 缓存，将常用的 immutable 如 小整数 之类的数据预先分配好内存空间。 12345a = 1b = 1print(id(a))print(id(b))print(id(a) == id(b)) # 打印 True &emsp;&emsp;所以当变量同时赋值到 1 的时候，其实背后只是一个函数作用域的字典，将 &#39;a&#39; 键和 &#39;b&#39;键分别指向了 1 的内存地址。&emsp;&emsp;在这个过程并没有创建 1 而是将地址指向事先创建好的 1 上。 &emsp;&emsp;所以也就是这个区别，Python 没有自增操作符， Python += 的整数操作符其实也是重新将数据指向了新的数据而没有在原来的数据上进行自增。 &emsp;&emsp;所以用上面内存修改的方式修改了 缓存 的数据会出现非常非常神奇的情况。 1234567891011121314151617import ctypesdef mutate(obj, new_obj): mem = (ctypes.c_byte * sys.getsizeof(new_obj)).from_address(id(obj)) new_mem = (ctypes.c_byte * sys.getsizeof(new_obj)).from_address(id(new_obj)) for i in range(len(mem)): mem[i] = new_mem[i]a = 1print(a) # 打印 1mutate(1,2)print(a) # 打印 2b = 1print(id(1)) # 2841718882632print(id(2)) # 2841718882608print(id(1) == id(2)) # 打印 Falseprint(b) # 打印 2 &emsp;&emsp;因为上面的 mutate 将 1 的内存数据直接修改成了 2 的数据。&emsp;&emsp;所以 b = 1 结果变成神奇的 2。&emsp;&emsp;不过千万不要在项目上使用这种写法，保不准就让你程序崩溃了。&emsp;&emsp;所以 Python 内存修改是非常危险的，上面的方案演示了 修改 的 可能性。&emsp;&emsp;但是从 Python 的设计理念来看是完全不希望被这么骚操作的。 forbiddenfruit 研究 &emsp;&emsp;虽然上面的方案被否了，我还是有点不死心，毕竟 mutable 对象的内存修改总归是留有余地的吧。&emsp;&emsp;于是在这个方向搜索偶然找到了 forbiddenfruit 这个神奇的 Python 库。 链接 &emsp;&emsp;我是在上面的 Stack Overflow 的回答里发现这个库的。&emsp;&emsp;正如回答下的第一条评论所说，这个库做的黑科技可能导致内存出错，引发各种不稳定，项目上使用就得慎重了。&emsp;&emsp;forbiddenfruit Github链接 &emsp;&emsp;forbiddenfruit 实现对内置类型的函数扩展。&emsp;&emsp;可以实现 JavaScript 的 String.prototype 给内置字符串添加方法的效果。 123456import sysint.__dict__["hello"] = lambda self:sys.stdout.write("hello")# Traceback (most recent call last):# File "g:/repo/QBinder/research/forbiddenfruit/test_c.py", line 24, in &lt;module&gt;# int.__dict__["hello"] = lambda self:sys.stdout.write("hello")# TypeError: 'mappingproxy' object does not support item assignment &emsp;&emsp;默认情况下可以通过 __dict__ 查看默认类型的方法。&emsp;&emsp;但是无法如上面的代码所示进行方法的添加。 &emsp;&emsp;forbiddenfruit 的代码量也不多，也就 500 行左右。&emsp;&emsp;其中抽丝剥茧的核心部分如下 123456789101112131415161718from __future__ import print_functionimport gcimport ctypesdef patchable_builtin(klass): refs = gc.get_referents(klass.__dict__) assert len(refs) == 1 return refs[0]dikt = patchable_builtin(int)print(dikt)dikt["square"] = lambda self:print(self**2)a = 2a.square() # 打印 4# NOTE 这样会报错# 3.square() (3).square() # 打印 9 &emsp;&emsp;主要利用 gc.get_referents 重新获取到的字典对象就不会导致赋值出错了。 &emsp;&emsp;之所以还需要大量额外的代码，只要是因为需要考虑到修改诸如 __str__ 的内置方法时要确保其能够正常触发。&emsp;&emsp;所以需要调用 ctypes.pythonapi 来实现很多黑科技的操作。&emsp;&emsp;这个部分就需要更底层的 Cython 来驾驭了。&emsp;&emsp;Python ctypes 库提供了一定程度的 C 编程操作，因此 forbiddenfruit 不需要 Cython 编译，兼容性很强。 总结 &emsp;&emsp;后续的东西比较偏向底层，我就没有深入研究了。&emsp;&emsp;到头来 Python 内存修改虽然可以实现，但是却完全不是个好方案。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 Writing Clean Code | Chad Vernon]]></title>
    <url>%2Fposts%2F743b8e3e.html</url>
    <content type="text"><![CDATA[原文链接 Home Python Scripting for Maya Artists Writing Clean Code ← Coding Conventions Python in Maya → Writing clean, readable code is something we should all strive for. If you’rejust learning to program, you may not be paying attention to how clean yourcode is, but after a while when you start working with other people with ashared code base you may begin to recognize the importance of writing cleancode. Code is read a lot more than it is written and sloppy code justdepresses and frustrates people. Being sloppy up front when you are underpressure actually slows you down in the long term. You will end up creatingmore bugs which leads to more maintenance. In this section, I’ll give brief pointers on how to make your code cleaner andeasier to read. For more in-depth discussions on writing clean code, Irecommend the excellent book, Clean Code: A Handbook of Agile SoftwareCraftsmanship, by Robert C Martin, and the Pluralsight course,Clean Code: Writing Code forHumans by CoryHouse. The DRY PrincipleDRY stands for Don’t Repeat Yourself. You should state a piece of logic onceand only once. If you find yourself copying and pasting chunks of codemultiple times, that should be a signal that you are repeating yourself.Repeating code just leads to more code to maintain and debug. For example, thefollowing code has repeated code: sphere = create_poly_sphere(name=&apos;left_eye&apos;) assign_shader(sphere, &apos;blinn1&apos;) parent_constrain(head, sphere) sphere = create_poly_sphere(name=&apos;right_eye&apos;) assign_shader(sphere, &apos;blinn2&apos;) parent_constrain(head, sphere) This code should be written like the following: def create_eye(name, shader): sphere = create_poly_sphere(name=name) assign_shader(sphere, shader) parent_constrain(head, sphere) create_eye(&apos;left_eye&apos;, &apos;blinn1&apos;) create_eye(&apos;right_eye&apos;, &apos;blinn2&apos;) The second code example is easier to maintain. If an update needs to beimplemented, we only have to update code in one place rather than multipleplaces. Use Clean NamesThe names of your classes, variables, and functions contribute greatly to howreadable and clean your code is. Take this code snippet from an actual VFXstudio pipeline tool: curr= os.environ.get(&apos;CURRENT_CONTEXT&apos;) if curr: cl= curr.split(&apos;/&apos;) self.__curr= [None] * 6 self.setType( cl[0] ) self.setSeq( cl[1] ) if len( cl ) &gt; 3: self.setSubseq( cl[2] ) self.setShot( &apos;/&apos;.join( cl[2:] ) ) else: self.setShot( cl[-1] ) if wa: self.__wa= wa else: self.__wa= os.environ.get(&apos;CURRENT_WORKAREA&apos;) Can you tell what this code is doing? If you’re familiar with writing pipelineenvironment tools, you might recognize what it is trying to do. What isself.__curr? Why is it a list of 6 values? What do the elements of clrepreprent? Why does the length of cl being greater than 3 differentiate oneblock of the if statement from the other? A cleaner implementation would look something like this: context_type, sequence, subsequence, shot = self.get_current_context() self.set_type(context_type) self.set_sequence(sequence) if subsequence: self.set_subsequence(subsequence) if shot: self.set_shot(shot) self.__work_area = work_area if work_area else self.get_current_work_area() The above code cleans up all the list indices and string manipulations to makethe code easier to read and understand. The individual list elements have beenassigned meaningful names. Also the environment variable accesses have beenextracted away into new methods. This makes the code easier to maintain. Whathappens if we want to change the name of the environment variables or maybe wewant to read the values from a configuration file on disk? Extracting thosevalues to functions would let us update the code in one place rather thanmultiple direct accesses to the environment variable. Naming ClassesClass names should be a noun because they represent objects. The name shouldbe as specific as possible. If the name cannot be specific, it may be a signthat the class needs to be split into smaller classes. Classes should have asingle responsibility. Bad class names include: ShapeIE Utility Common MyFunctions DansUtils ShapeClass Good class names include: ShapeExporter RigPublisher Project User Naming MethodsMethod names should be verbs because they perform actions. There should be noneed to read the contents of a method if the name accurately describes whatthe method does. If the function is doing one thing (as it should) it shouldbe easy to name. If not, split the code into smaller functions. Sometimesexplaining the code out loud and help you name the function. If you say “And”,“If”, or “Or” it is a warning sign that the method is doing too much. Bad method names include: proc_new pending process1 process2 Good method names include: create_process is_pending send_notification import_mesh calculate_rivet_matrix Methods should only perform the actions described by the name. Any otheractions are called side effects and they can confuse people using your code.For example, a method called validate_form should not save the form. A methodcalled publish_model should not smooth the normals. A method calledprune_weights should not remove unused influences. Avoid AbbreviationsAbbreviated text may be easier to type, but code is read more than it iswritten. When people talk about code or read it silently, it is harder to saythe abbreviations. There are also no standards when referring toabbreviations. Bad names: sjData jid sjid nm sjState Good names: subjob_data job_id subjob_id name subjob_state Naming BooleansBoolean values should be able to fit in an actual sentence of saying somethingis True or False. Bad boolean names: open status login Good Boolean names: is_open logged_in is_valid enabled done Symmetrical NamesWhen names have a corresponding opposite, be consistent and always use thesame opposite. Bad naming on/disabled quick/slow lock/open low/max Good naming on/off fast/slow lock/unlock min/max Working with BooleansWhen comparing Booleans, compare them implicitly: # Don&apos;t do this if (is_valid == True): # do something # Instead do this if is_valid: # do something When assigning booleans, assign them implicitly: # Don&apos;t do this if len(items) == 0: remove_entry = True else: remove_entry = False # Instead do this remove_entry = len(items) == 0 Avoid using booleans that represent negative values. This leads to doublenegatives, which end up confusing people: # Don&apos;t do this if not not_valid: pass # Instead do this if valid: pass Use TernariesTernaries are ways of assigning a value to a variable depending on if somecondition is True or False. For example: # Don&apos;t do this if height &gt; height_threshold: category = &apos;giant&apos; else: category = &apos;hobbit&apos; # Instead do this category = &apos;giant&apos; if height &gt; height_threshold else &apos;hobbit&apos; Don’t Use String as TypesYou may have encountered code similar to the following: if component_type == &apos;arm&apos;: # do something elif component_type == &apos;leg&apos;: # do something else This is considered bad form for various reasons. If we end up wanting tochange the value of one of these types, we have to change it in all the placesthat it is used. It can also lead to typos and inconsistencies. A betterapproach would be: class ComponentType(object): arm = &apos;arm&apos; leg = &apos;leg&apos; if component_type == ComponentType.arm: # do something elif component_type == ComponentType.leg: # do something else The new code provides one place to change and update values (the DRYprinciple). It also provides auto-completion support and is more searchable ifyou are using an IDE like PyCharm or Eclipse. Don’t Use Magic NumbersMagic numbers are numeric values that seemed to have been pulled out ofnowhere. For example, the following code was pulled from an actual VFXpipeline tool: if run_mode &lt; 3: run_mode = 5 elif run_mode == 3: run_mode = 4 What do these numbers mean? You would need to search all over code that couldspan multiple files to figure out what these numbers represent. A betterapproach would be: class JobStatus(object): waiting = 1 starting = 2 running = 3 aborting = 4 done = 5 def __init__(self, value=JobStatus.waiting): self.status = value def not_yet_running(self): return self.status &lt; JobStatus.running def abort(self): if self.not_yet_running(): self.status = JobStatus.done elif self.status == JobStatus.running: self.status = JobStatus.aborting # job_status is the new run_mode job_status.abort() Encapsulate Complex ConditionalsSometimes you may have conditionals with many comparisons chained together. Atsome point, this is going to get hard to read. For example: # Instead of this if (obj.component.partial_path.startswith(&apos;model&apos;) and namespace == ‘GEOM’ and has_rigging_publish(obj.child) and edits_path): # Encapsulate the complex conditional in a function or variable def is_model_only_publish(obj): return (obj.component.partial_path.startswith(&apos;model&apos;) and namespace == &apos;GEOM&apos; and has_rigging_publish(obj.child) and edits_path) if is_model_only_publish(obj): Writing Clean FunctionsFunctions should be created in order to help convey intent. They should do onething and one thing only as this aids the reader, promotes reuse, easestesting, and avoids side effects. Strive for a function to only have 0-3parameters with a max of 7-9 parameters. Anything longer makes it harder forreaders to keep track of all the parameters while running through the code intheir head. Functions should be relatively short, maybe no more than 100 or solines. If a function is longer, it may be time to refactor (update) the codeinto smaller functions. Extracting a MethodIf you find your code 3 or 4 indentation levels deep, it may be time toextract some of that code into a separate function. For example: # Instead of this if something: if something_else: while some_condition: # do something complicated # Do this instead if something and something_else: do_complicated_things() def do_complicated_things(): while some_condition: # do something complicated Return EarlyPeople can usually only keep track of a handful of trains of thought at atime. Therefore, we should try to organize our code in as many discreteindependent chunks as possible. For example: # Instead of this def validate_mesh(mesh): result = False if has_uniform_scale(mesh): if has_soft_normal(mesh): if name_is_alphanumeric(mesh): result = name_is_unique(mesh) return result # Do this def validate_mesh(mesh): if not has_uniform_scale(mesh): return False if not has_normal(mesh): return False if not name_is_alphanumeric(mesh): return False return name_is_unique(mesh) This is not a strict rule. Like everything listed so far, use it when itenhances readability. Signs Your Function is Too LongFunctions should hardly ever be over 100 lines. Longer functions are harder totest, debug, and maintain since users need to keep track if updates at thestart of the function affect areas and the end of the function. Here are somesimple rules to determine if a function is too long: You separate sections of code in a function with whitespace and/or comments Scrolling is required to view all the code. The function is hard to name. There are conditionals several levels deep. There are more than 7 parameters or variables in scope at a time. Writing Clean ClassesClasses are like headings in a book, there should be multiple layers ofabstraction going from high level ideas to more detailed lower level ideas: Chapter Heading 1 Paragraph 1 Paragraph 2 Heading 2 Paragraph 1 Module Class 1 Method 1 Method 2 Class 2 Method 1 High CohesionCohesion is the fact of forming a united whole. When a class is said to havehigh cohesion, all of its functionality is closely related. We should striveto create classes with high cohesion. High cohesion not only enhancesreadability; it also increases the likelihood of reusing the class. Signs thata class does not have high cohesion are: The class has methods that don’t interact with the rest of the class. The class has fields only used by one method. The class changes often. For example: # Low cohesion class class Vehicle(object): def edit_options(): pass def update_pricing(): pass def schedule_maintenance(): pass def send_maintenance_reminder(): pass def select_financing(): pass def calculate_monthly_payment(): pass The Vehicle class contains many unrelated methods. This makes it harder to useand maintain because parts of unrelated code are intertwined together. Abetter approach would be to split this class up into smaller classes: # High cohesion classes class Vehicle(object): def __init__(self) def edit_options(): pass def update_pricing(): pass class VehicleMaintainer(object): def schedule_maintenance(): pass def send_maintenance_reminder(): pass class VehicleFinancer(object) def select_financing(): pass def calculate_monthly_payment(): pass Method ProximityCode should read top to bottom and related methods should be kept together: def add_take(): if not validate_take(): # First method referenced should be directly below raise ValueError(&apos;Take is not valid&apos;) save_take() # Second method referenced should be below first def validate_take(): return take.endswith(‘.mov’) def save_take(): # save in database Collapsed code should read like an outline. Strive for multiple layers ofabstraction: Class Method 1 Method 1a Method 1ai Method 1aii Method 1b Method 1c Method 2 Method 2a CommentsComments should only be used to explain ideas and assumptions not alreadyapparent by reading the code. Redundant CommentsThe comments in this code do not add anything the user could not have figuredout by reading the code. # Clear the node combo box then add items self.node_combobox.clear() if nodes: # Sort the nodes nodes.sort() # Check to see if there is a shape controller associated with the node self.find_shape_controllers(nodes) # Now add the list of nodes to the combo box self.node_combobox.addItems(nodes) # If a node is specified set the combo box if node: # Find the node&apos;s index index = self.node_combobox.findText( node, QtCore.Qt.MatchExactly | QtCore.Qt.MatchCaseSensitive) self.node_combobox.setCurrentIndex(index) Divider CommentsIf you see divider comments, it’s a sign you need to extract the code into itsown function: # Now create the new group object and insert it into the table # ---------------------------------------------------------------------------------- # Create the group object group = slidergroup.SliderGroup(name) self._slider_groups[name] = group # Tell the group what its start row is group.setRow(row) # Apply color if color: group.setColor(color) # Generate sliders from the attributes attached to the group # ---------------------------------------------------------------------------------- row_index = row + 1 sliders_to_add = [] for attr in attributes: if cmds.objExists(attr): slider = self.add_slider(attr, rowIndex, group) row_index += 1 Zombie CommentsZombie comments are large sections of commented out code. People often do thisbecause they think they might need the code in the future. This is unnecessarybecause version control systems like git, svn, and perforce perform this exactfunctionality. People looking at code with large commented out portions willbe confused. Why is the code commented out? Is it important? Clean Code ConclusionIn this section, I covered a quick overview on writing clean code. There aremany other great resources that go in a lot more detail of writing clean codeincluding explanations why it is considered clean code. As I mentioned at thestart of the section, for more in-depth discussions on writing clean code,refer to Clean Code: A Handbook of Agile SoftwareCraftsmanship, by Robert C Martin, and the Pluralsight course,Clean Code: Writing Code forHumans by CoryHouse.]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>✒博客/©转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Houdini 自定义菜单选项]]></title>
    <url>%2Fposts%2F6b1c0cfc.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;好久没有碰 Houdini 了，因为各种原因，原计划 2020 年 10 月份要学起来的 Houdini ，一直耽搁到最近才开始渐渐捡起来。&emsp;&emsp;虽然一直好想认认真真地把 Houdini 学透，但是却又无时无刻地意识到自己在逃避，硬骨头就是难啃(:з」∠)&emsp;&emsp;所以之前一直上传 Houdini 的教程来麻痹自己，然而 B 站已经停更了 2 个月了，堆积如山的教程让我无所适从。 &emsp;&emsp;Anyway，最近趁元旦回家，总算肝了一些 Houdini 的教程，然后又遇到我以前也遇到过却不知道怎么解决的问题。&emsp;&emsp;Houdini 默认打开文件保存文件的窗口用了 Houdini 特殊修改过的 File Dialog&emsp;&emsp;这样就无法嵌入 listary 插件，用起来让我倍感不爽。 listary使用总结&emsp;&emsp;几个月前遇到这个问题，我以为 Houdini 也可以像 Maya 一样切换为 OS native 的文件窗口，然而查了一通并不可以。&emsp;&emsp;于是最近又遇到了这个让我很是头疼的问题，以下是我解决它研究的一些方案 利用 PySide2 框架获取软件所有的组件进行魔改 &emsp;&emsp;那么还有一个方法就是遍历 Houdini 所有的组件，然后将 Menu 的 action 替换为系统内置的窗口。&emsp;&emsp;以前自己搞 mpdb 的时候在 Maya 里面使用过这个骚操作，利用 PySide2 可以获取 Maya 几乎绝大多数的组件。 打印 Maya 组件树的代码 链接这个脚本里面我以前写的 traverseChildren 方法可以通过递归打印出 Maya 的组件树，只是代码加了额外不必要的功能，而且当时写的代码比较稚嫩，规范也不太好(:з」∠) 12345678910111213141516171819from __future__ import print_functionfrom maya import OpenMayaUIfrom PySide2 import QtWidgetsfrom shiboken2 import wrapInstancedef print_widget_tree(parent,indent=4,prefix=""): print(prefix,parent,parent.objectName()) if not hasattr(parent,"children"): return prefix = " " * indent + prefix for child in parent.children(): print_widget_tree(child,indent=indent,prefix=prefix)window = OpenMayaUI.MQtUtil.mainWindow()window = wrapInstance(long(window), QtWidgets.QMainWindow)print_widget_tree(window) &emsp;&emsp;上面代码经过我精简过，在 Maya2017 下输出的结果如下 数据链接&emsp;&emsp;从打印出来信息可以看到， Maya 可以获取到几乎所有的组件信息，包括主窗口上面的菜单也是可以获取到的。&emsp;&emsp;所以我有理由相信，通过 Houdini 的 PySide2 可以同样的方法获取到顶部的菜单信息。 1234567891011121314151617from __future__ import print_functionimport houfrom hutil.Qt import QtWidgetsdef print_widget_tree(parent,indent=4,prefix=""): print(prefix,parent,parent.objectName()) if not hasattr(parent,"children"): return prefix = " " * indent + prefix for child in parent.children(): print_widget_tree(child,indent=indent,prefix=prefix)window = hou.qt.mainWindow()print_widget_tree(window) &emsp;&emsp;Houdini 获取主窗口的文档链接&emsp;&emsp;于是将上面的代码在 Houdini 下面执行，输出如下 1234567891011121314151617181920212223242526272829303132333435&lt;PySide2.QtWidgets.QWidget object at 0x000000007500E048&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E088&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E0C8&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E148&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E1C8&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E288&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E2C8&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E308&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E348&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E208&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E2C8&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E288&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E348&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E308&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E248&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E288&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E2C8&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E308&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E3C8&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E488&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E4C8&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E508&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E548&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E408&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E448&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E488&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E548&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E508&gt; &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E348&gt; &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E188&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E108&gt; RE_Window &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E188&gt; &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E148&gt; RE_GLDrawableWrapper &lt;PySide2.QtWidgets.QWidget object at 0x000000007500E248&gt; RE_GLDrawable &lt;PySide2.QtWidgets.QVBoxLayout object at 0x000000007500E1C8&gt; &emsp;&emsp;结果真的是啪啪打脸……&emsp;&emsp;看来 Houdini 做得没有 Maya 灵活，只能获取到这些的组件了，这样也比较安全。&emsp;&emsp;我猜测 Maya 之所以可以获取所有的组件很可能是因为所有的 UI 元素都是用 Mel 语言构建的。&emsp;&emsp;可以通过修改 Maya 启动的 Mel 脚本来直接修改 UI 。&emsp;&emsp;因此 Maya 大部分的 UI 都是动态生成的，也就导致几乎所有组件都可以被访问到。&emsp;&emsp;Houdini 底层的 UI 估计是 C++ 的 Widget 写的， 无法通过 Python Binding 获取。&emsp;&emsp;以上也只是我的个人推断，毕竟没有深入接触过 Qt C++ 的东西… 修改 Houdini 菜单 xml 配置 &emsp;&emsp;一计不成，再生一计。&emsp;&emsp;难道 Houdini 的菜单无法扩展吗，按照 DCC 软件的尿性，不至于这么不灵活。&emsp;&emsp;所以简单搜一下 houdini add custom menu 就可以找到解决方案 文档链接 &emsp;&emsp;通过上面的链接可以知道 Houdini 是通过 xml 来管理菜单的。&emsp;&emsp;在 Houdini 的安装目录可以找到 houdini/MainMenuCommon.xml 配置文件&emsp;&emsp;里面有关于菜单配置的所有信息。 &emsp;&emsp;根据上面文档链接最后的部分，可以通过添加 &lt;scriptcode&gt; 标记来执行 Python 代码。 &emsp;&emsp;这样就好办了，我可以通过 QFileDialog 调用本地的文件浏览器，然后再用代码来让 Houdini 打开文件。&emsp;&emsp;缺点就是这个 xml 配置需要重启 Houdini 才能生效，就无法动态修改菜单了。 &emsp;&emsp;使用 OS Native 的文件预览窗口可以用 Qt 内置的 QFileDialog 来调用。&emsp;&emsp;然后调用 hou.hipFile 的 API 来读取和保存 文件 文档链接 12345678910111213141516171819202122232425262728 &lt;scriptItem id="h.native_open"&gt; &lt;label&gt;Native Open...&lt;/label&gt; &lt;scriptCode&gt;&lt;![CDATA[import houfrom PySide2 import QtWidgetspath, _ = QtWidgets.QFileDialog.getOpenFileName( None, caption=u"读取 hip 文件", filter="*;;*.hip;;*.hip*;;*.hiplc;;*.hipnc",selectedFilter ="*.hip*")if path: hou.hipFile.load(path) ]]&gt;&lt;/scriptCode&gt; &lt;/scriptItem&gt; &lt;!-- ...省略... --&gt; &lt;scriptItem id="h.native_save"&gt; &lt;label&gt;Native Save As...&lt;/label&gt; &lt;scriptCode&gt;&lt;![CDATA[import houfrom PySide2 import QtWidgetspath, _ = QtWidgets.QFileDialog.getSaveFileName( None, caption=u"保存 hip 文件", filter="*;;*.hip;;*.hip*;;*.hiplc;;*.hipnc",selectedFilter ="*.hip*")if path: hou.hipFile.save(path) ]]&gt;&lt;/scriptCode&gt; &lt;/scriptItem&gt; &emsp;&emsp;为了代码运行不出错，需要确保代码前面没有缩进。&emsp;&emsp;如果想让 xml 看起来更整洁，可以用 exec 运行字符串的方式，字符串的多余缩进可以用 from textwrap import dedent 来解决 1234567891011121314&lt;scriptItem id="h.native_save"&gt; &lt;label&gt;Native Save As...&lt;/label&gt; &lt;scriptCode&gt;&lt;![CDATA[from textwrap import dedent;exec(dedent( ur""" import hou from PySide2 import QtWidgets path, _ = QtWidgets.QFileDialog.getSaveFileName( None, caption=u"保存 hip 文件", filter="*;;*.hip;;*.hip*;;*.hiplc;;*.hipnc",selectedFilter ="*.hip*" ) if path: hou.hipFile.save(path) """)) ]]&gt;&lt;/scriptCode&gt;&lt;/scriptItem&gt; &emsp;&emsp;通过 ; 也可以解决 Python 的换行，只是官方不推荐，因为代码挤在一起会破坏可读性，这里用了一个分号来换行 可以避免 xml 缩进被破坏。&emsp;&emsp;字符串前加了 ur ，其中 u 代表 unicode 字符串，确保中文显示不会变乱码， r 代表 raw ，确保不会对字符串进行转义，避免代码有 \ 之类的路径导致转义出错，这样直接贴代码也不用担心出问题。&emsp;&emsp;使用效果如下↓↓↓ &emsp;&emsp;通过这个方法也可以嵌入 Python 代码实现一些特殊效果，比如官方的菜单里面无法直接打开一个悬浮的渲染窗口，需要先打开一个渲染窗口再切换。&emsp;&emsp;可以加一个菜单项让这个动作一步到位。 文档链接&emsp;&emsp;渲染窗口的类型是 hou.paneTabType.IPRViewer 123456789&lt;scriptItem id="h.floatIPRViewer"&gt; &lt;label&gt;Open Render Panel&lt;/label&gt; &lt;scriptCode&gt;&lt;![CDATA[from textwrap import dedent;exec(dedent( ur""" import hou hou.ui.curDesktop().createFloatingPaneTab(hou.paneTabType.IPRViewer) """)) ]]&gt;&lt;/scriptCode&gt;&lt;/scriptItem&gt; 总结 &emsp;&emsp;以上就是 Houdini 自定义菜单修改。&emsp;&emsp;最近看 Houdini 教程萌生了一个想法，想要去做一个 HoudiniWiki 的网站将教程的思路和节点全部集中式管理成文档。&emsp;&emsp;看教程的时候就一直惦记着要做这个网站将知识归类，所以没法子，教程又给搁置了。 2021-2-6 更新 &emsp;&emsp;很久以前刚开始学习 Houdini 的时候有配置过一款插件，可以将 Vex 代码自动同步到 VScode 进行编写。 http://cgtoolbox.com/houdini-expression-editor/https://github.com/cgtoolbox/HoudiniExprEditor &emsp;&emsp;最近我重新配置了这个工具，发现菜单扩展可以通过我的文档 C:\Users\%USERNAME%\Documents\houdini##.#\ 里面进行添加。&emsp;&emsp;如此就不用改动官方默认的文件了。 &emsp;&emsp;这么写的话需要注意 parent 和 insertAfter 标签描述来定义添加的选项的位置。]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blender 工具开发]]></title>
    <url>%2Fposts%2Fe362cb4d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近刚好有用 Blender 开发工具，于是研究了一下如何使用 Blender Python 来实现简单的工具。 Blender 印象 &emsp;&emsp;虽然久仰 Blender 大名了，一直吐槽 Maya 的不思进取，将 Blender 奉为圭臬。但是其实我并没有使用过它。&emsp;&emsp;目前Blender 已经到 2.9 的版本，界面风格都好看了不少，整体透露着精致。&emsp;&emsp;以前老版本的界面和 Unity 的灰色界面一个调性，说实话我还是喜欢深色一点风格。&emsp;&emsp;而且 blender 整体的大小优化得很好，功能也很齐全，启动速度还快了很多。&emsp;&emsp;然而遗憾的是终究没有太多时间深入来学习它，毕竟对我目前而言，学习 Houdini 更为重要。 Blender 下载&amp;界面 &emsp;&emsp;Blender 下载可以去到 Blender 官网下载地址 &emsp;&emsp;点击大大的下载按钮下载安装即可。&emsp;&emsp;安装上其实无脑按确认和下一步即可。&emsp;&emsp;安装完成之后可以打开界面如下图所示。 &emsp;&emsp;默认会启动一个界面进行快速配置。 &emsp;&emsp;快捷键 shortcut 推荐使用 industry compatible&emsp;&emsp;毕竟我好歹也是 Maya 用户迁移过来的，Maya Houdini Unreal 主流的界面操作方式已经成为标准了。&emsp;&emsp;所以使用这个就不用去研究 Blender 自身的三维控制操作，让我舒服了很多。 &emsp;&emsp;在上面的界面点击确认会在 %appdata%\Roaming\Blener Foudnation\Blender\${version}\config 这个路径下创建 userpref.blend 的文件。&emsp;&emsp;如果配置错了，可以把这个文件删除，重启 Blender 可以重新配置。 Blender 编程界面准备 &emsp;&emsp;新版本的 Blender 已经将不同的功能界面整合到最上面了。&emsp;&emsp;编程方面可以直接选择最右边的 Scripting &emsp;&emsp;Blender 使用 Python3 ，可以在这个界面下新建一个文本编写代码。&emsp;&emsp;代码 print 的信息可以在 Windows &gt; Toggle System Console 打开查看信息。 链接&emsp;&emsp;如果没有双屏，可以使用 PowerToys 快速分屏将 Blender 的窗口和 Console 摆放好，方便查看输出。 &emsp;&emsp;另外如果可以打印到 Python Console 也挺好的，所以我找到这个链接通过重载 print 方法可以实现。 bpy 编程 &emsp;&emsp;blender 内置了 bpy 模块，从而可以通过 Python 代码来自动化 Blender 。&emsp;&emsp;学习编程还是离不开从文档开始 链接&emsp;&emsp;blender.stackexchange 是个非常好的提问网站，比起 Maya 的编程，这里有大量大佬提供了很多问题的解决方案。 &emsp;&emsp;关于 Blender 的 GUI 编程可以参考官方文档 Panel 相关的介绍 链接&emsp;&emsp;Blender 并不是用 Qt 框架写的，所以界面上稍微没有那么灵活，不过也可以通过 Python 安装 PyQt 或者 PySide2 相关的 GUI 库来编写界面。 GUI 界面123456789101112131415import bpyclass HelloWorldPanel(bpy.types.Panel): bl_idname = "OBJECT_PT_hello_world" bl_label = "Hello World" bl_space_type = 'PROPERTIES' bl_region_type = 'WINDOW' bl_context = "object" def draw(self, context): self.layout.label(text="Hello World")bpy.utils.register_class(HelloWorldPanel) &emsp;&emsp;官方案例运行起来如上图所示。&emsp;&emsp;注意: 官方要求 bl_idname 必须 CATEGORY_PT_name 一这样的形式命名，否则 Console 会弹出警告。 &emsp;&emsp;更多 Blender 插件是直接配置 Category 1234567891011121314import bpyclass HelloWorldPanel(bpy.types.Panel): bl_idname = "OBJECT_PT_hello_world2" bl_label = "Hello World" bl_space_type = 'VIEW_3D' bl_region_type = 'UI' bl_context = "objectmode" bl_category = "MyCategory" def draw(self, context): self.layout.label(text="Hello World")bpy.utils.register_class(HelloWorldPanel) &emsp;&emsp;blender 的 GUI 编程目前我接触得很不深，初步使用和 Mel GUI 编程很类似，通过 layout 布局进行配置 链接&emsp;&emsp;layout 通过 colum grid_flow 等不同的方法进行 GUI 排列。&emsp;&emsp;虽然没有 Qt 编程那么灵活，但是胜在简单明了。 &emsp;&emsp;另外 Blender 还支持通过 property 配置生成 GUI 的操作， 类似 Maya 的这个 qargparse 库 链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import osimport bpyfrom bpy.props import StringProperty, PointerPropertyfrom bpy.types import Panel, PropertyGroup class MyProperties(PropertyGroup): directory : StringProperty( name="", description="Path to Directory", default="", maxlen=1024, subtype='DIR_PATH')bpy.utils.register_class(MyProperties)class ButtonOperator(bpy.types.Operator): bl_idname = "mf_blender.select_path" bl_label = "Print Directory" def execute(self, context): scn = context.scene path = scn.my_tool.directory print(path) return &#123;'FINISHED'&#125; bpy.utils.register_class(ButtonOperator) class OBJECT_PT_DirectoryPanel(Panel): bl_idname = "OBJECT_PT_Directory" bl_label = "Directory Panel" bl_space_type = "VIEW_3D" bl_region_type = "UI" bl_category = "MyPanel" bl_context = "objectmode" def draw(self, context): layout = self.layout scn = context.scene col = layout.column(align=True) col.prop(scn.my_tool, "directory", text="directory") col.operator("mf_blender.select_path")bpy.utils.register_class(OBJECT_PT_DirectoryPanel)bpy.types.Scene.my_tool = PointerProperty(type=MyProperties) &emsp;&emsp;上面的脚本实现获取路径，点击按钮打印输出路径。&emsp;&emsp;Blender 会根据 StringProperty 的配置自动生成获取路径的 UI&emsp;&emsp;通过 Scene 绑定 property 来实现数据共享。 &emsp;&emsp;当然上面的操作获取路径比较繁琐，能否只通过一个按钮来获取路径并且打印呢？&emsp;&emsp;当然也是可以的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osimport bpyfrom bpy.props import StringProperty, PointerPropertyfrom bpy.types import Panel, PropertyGroup class ButtonOperator(bpy.types.Operator): bl_idname = "mf_blender.select_path" bl_label = "Import Directory" directory : StringProperty( name="", description="Path to Directory", default="", maxlen=1024, subtype='DIR_PATH') # NOTE invoke 是作为 GUI 调用执行的函数 def invoke(self, context, event): # NOTE 注意这个函数放到 execute 函数执行会导致 blender 崩溃 # NOTE 打开文件选择窗口 context.window_manager.fileselect_add(self) return &#123;'RUNNING_MODAL'&#125; # NOTE execute 默认调用执行的函数 def execute(self, context): print(self.directory) return &#123;'FINISHED'&#125; bpy.utils.register_class(ButtonOperator) class OBJECT_PT_DirectoryPanel(Panel): bl_idname = "OBJECT_PT_Directory" bl_label = "Directory Panel" bl_space_type = "VIEW_3D" bl_region_type = "UI" bl_category = "MyPanel" bl_context = "objectmode" def draw(self, context): layout = self.layout scn = context.scene col = layout.column(align=True) # col.prop(scn.my_tool, "directory", text="directory") col.operator("mf_blender.select_path")bpy.utils.register_class(OBJECT_PT_DirectoryPanel) 材质节点自动化123456789101112import bpy# NOTE 获取默认场景的 Cube objectobj = bpy.data.objects["Cube"]# 注: 获取当前选择的物体可以用 bpy.context.selected_objects# NOTE 获取默认的 Material 材质插槽slot = obj.material_slots["Material"]print(slot) # 打印 &lt;bpy_struct, MaterialSlot("Material") at 0x0000028D6166AB88&gt;mat_name = slot.nameprint(mat_name) # 打印 Materialmaterial = slot.materialprint(material) # 打印 &lt;bpy_struct, Material("Material") at 0x0000028D6347EEC8&gt; &emsp;&emsp;上面的方法可以获取到特定的材质&emsp;&emsp;objects material_slots 这些方法在 Blender 里面既可以用数组的序号获取也可以用字典的名称来获取。 12345678910# NOTE 进入材质节点matnodes = material.node_tree.nodes# NOTE 生成贴图节点texture=matnodes.new("ShaderNodeTexImage")# NOTE 加载一张贴图image_path = r"C:\Users\timmyliang\Pictures\Sketchpad.png"texture.image = bpy.data.images.load(image_path)# NOTE 连接两个节点的通道channel = matnodes['Principled BSDF'].inputs["Base Color"]material.node_tree.links.new(channel, texture.outputs["Color"]) &emsp;&emsp;上面执行可以实现贴图节点连接到材质的颜色通道上。 开启加载脚本 - 配置顶部菜单项https://blender.stackexchange.com/questions/2738 &emsp;&emsp;根据上面的回答，可以配置用户的 Scripts 目录路径，然后再路径下添加 startup 文件夹实现开启 Blender 自动执行。 https://devtalk.blender.org/t/blender-user-scripts-and-multiple-paths/10395 &emsp;&emsp;修改用户的 Blender 配置比较麻烦，可以用上面链接提到的环境变量来配置 Blender 的启动路径 $BLENDER_USER_CONFIG Directory for user configuration files. $BLENDER_USER_SCRIPTS Directory for user scripts. $BLENDER_SYSTEM_SCRIPTS Directory for system wide scripts. &emsp;&emsp;有了这些之后就可以实现类似 Maya userSetup.py 脚本的效果。 &emsp;&emsp;下面我们想要实现 Blender 添加顶部自定义菜单，点击菜单弹出提示弹窗。 1234567891011121314151617181920212223242526# NOTE https://www.youtube.com/watch?v=3C6wVPVrPtMimport bpyfrom bpy.utils import register_classclass WM_OT_myOp(bpy.types.Operator): bl_label = "Alert Dialog" bl_idname = "wm.myop" # https://blender.stackexchange.com/a/23976 bl_options = &#123;'REGISTER', 'UNDO'&#125; def execute(self,context): return &#123;'FINISHED'&#125; def draw(self,context): self.layout.label(text="Custom Dialog Message") def invoke(self,context,event): # NOTE https://blender.stackexchange.com/a/14319 return context.window_manager.invoke_props_dialog(self) # NOTE 使用 invoke_props_popup 可以让弹窗没有按钮 # return context.window_manager.invoke_props_popup(self,event)register_class(WM_OT_myOp)bpy.ops.wm.myop('INVOKE_DEFAULT') &emsp;&emsp;上面的脚本可以实现自定义弹窗。 &emsp;&emsp;更简单的弹窗配置方案 链接 12345import bpydef show_message(message="", title="Message Box", icon="INFO"): bpy.context.window_manager.popup_menu( lambda self, _: self.layout.label(text=message), title=title, icon=icon ) &emsp;&emsp;下面就是想办法配置顶部的菜单项然后触发上面的 Operator 弹窗 https://blender.stackexchange.com/questions/156652 &emsp;&emsp;根据上面的链接可以知道，自定义菜单栏添加可以使用 TOPBAR_MT_editor_menus.append 1234567891011121314151617181920212223242526272829303132import bpyfrom bpy.utils import register_classclass WM_OT_MessageDialog(bpy.types.Operator): bl_label = "Alert Dialog" bl_idname = "wm.message_dialog" def execute(self, context): return &#123;"FINISHED"&#125; def draw(self, context): self.layout.label(text="Custom Dialog Message") def invoke(self, context, event): return context.window_manager.invoke_props_dialog(self)class TOPBAR_MT_custom_menu(bpy.types.Menu): bl_label = "Custom Menu" # NOTE 没有设置 bl_idname 自动拿 class name 作为 id def draw(self, context): layout = self.layout layout.operator(WM_OT_MessageDialog.bl_idname, text="Open Message Dialog") @classmethod def menu_draw(cls, self, context): self.layout.menu(cls.__name__)register_class(WM_OT_MessageDialog)register_class(TOPBAR_MT_custom_menu)bpy.types.TOPBAR_MT_editor_menus.append(TOPBAR_MT_custom_menu.menu_draw) &emsp;&emsp;bl_idname 没有设置自动用 class 的名称作为 id 链接 总结 &emsp;&emsp;Blender 工具开发接触还比较浅，目前体验的感觉是灵活度欠缺了很多，用惯了 Qt 框架，面对新的框架编程充满了不习惯。&emsp;&emsp;可能还是因为没有找到好用的 ui 可视化界面工具吧，比较怀念 QtDesigner 的开发体验。 （接触尚浅，太菜了，有好的经验欢迎大家分享。）&emsp;&emsp;不过 Blender 虽然没那么灵活，也实实在在的简单高效~]]></content>
      <categories>
        <category>CG</category>
        <category>Blender</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠂBlender</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageMagick 生成渐变]]></title>
    <url>%2Fposts%2F44f69d3.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 提示(神秘号码 + 魔方) 0785f83707a61d55300b600102362e06da54e64d6fc86d963edb6c76c1d096305f36742346b1c3b7f68288e62d91f922cf39e2f8378b6387bb106db8e2c18d05cb41335525c36622ff9145e10d2589169165286fa31663900f9fabd3881e2553ae1468252e303b11b5b068af38e8870bc5327460a85cee6affd97b244e8a38a299d77a5150bd16d7d6aed8ececf77d1704422e5f8875461142a70ea8639fb9d934d78496162167636d47d68f34af77527c316e1593a4015abc6de9dd0f6f4a9b2785167ff59b3e8a35c21c99f280b326bec1f0e430d0691a0ad4b7903297c4d7104325cf9347033a4439996db71b3d4f53301a8e460f585c366526ac5dc752680f06bf51f478ee152865eda8f7725d4d4d4b4c76e5532dfc50379e0e0bdce95a23aea2b024701b04cccbe63db3d4bdd6583d8da6f665c28b3ed1eb0638efd01646859aa245a1a4bde4d12def94e4af11242e7accf3589b67594de8c3e92a2c654fb9194f3c05319434824c04c495fe584b07c9a03148051639aaaaf28428c16b18fc80b718f674228837300333bcf9962d0c8e26639aa08022d598bd5b18f18eb86f7934e8aeeaa9675c0c6304bfe6b307b1dcef47d4f65273aa7e3e19108dddf41199f5c749bf11b4c9a78d9b4f7592c7d14504dfef0c11eb6e5bfef2bcc8e6a412e09990126a73edc7d8202d8d72d3022c76e15d12f68c4818377bb3891138bd7b0c0b32c12a02edf379741feb214d07509271eb61163c7b69a876690ecb763a88a6de908dac76a6ddd4b26db3a96a68393123b0b3780798ee729bb354b2332c308e45770b398c33f7b12c788baf5a73e341dcf2c5dbd976eef30b45b1422c4355103f2e2aed50158548541fd5ac42a507cd62c14d6699283abcfce7c33c5dce6066adf1864e7d1fb43113ee5a50f99fb7a5fca80430bfbdd24af9d373cff3cfb427ab0c5777b79158116aeacd14a868cea72756f6d26d9a1489a752d532c02cdc2262621e489aa5ae45e09035ce3bfddfb0bfe94c75652cdb3be7c1751b4c9edd60f046060b8fda23d0f7441066ae8bbb1c686e7ad57e5268c2f67360fb0e6094fb338d18ab895e6c2cd1bafe97752423248ba8b2d7b1e601eb43a722632b69a96ac1edaac2a7f66811a5eb3a8f1f546238f3de9aa0d84ca4448884d8d35050191f173f0470ffd299c45b57261dec3ead718ddb0801ab0d78ce42838eb47c2dd449e96e6245089bf7868acd7040ab91e747afd6761902753e54b8e16657cba0aa545e1a96a94aae61a574f1aa35640cb3a6d757ad10098944fbeae6242d760eaf94f473c17de2529e86831a3f6751daedaca008a1a4b7fab9f74f0d86b66c775ad926355607c7c5a0b4868ef0f69b9c193b345a8d099a47fe2a2a62467db12b38d3cd63ba7c8e9682e7ae6bbb7deebcc8d67133e46f6f2f775696962bc696d36076fd6ad1b29eb78c6f5c87d836c2c163fd4189c4b8a9d2dba46ea8a715000e0ffdebf19d738bcb39d89d14d5850ee8ed84e93c1c2e2d53dcbeb016c7c20dda360f14a7d637f77775974424e381fa077d11fe9aeefaf1460b528ec32a960c8485e69857a47b38229b8101b73befdc999c63cf5ea52bf69bc1aeaad7270555b7e61ac56005417e14c1ef74192bf7dd8751deb0f10995de4a31bd1dd76715466d060b9119e7cde6cec7774e13c196fc580f9361fb870b48a6de454cc2e336edccdc265672166f93cd5f4cc24d58b83b8607ed045388143df81d3951af42035329c568c70d30bad67f9b2d38565e1a5ba35de899be8d138fcdc030b7a60d9a083e70988f2939f6e0e4663000ad7d0ec36769f4f75cd65e262def77d03e8d4152a29fcb2be8d6fe954775ecc88ee8d2b63286620b9d842fd7ad837b3698d2fbcedba7f23106a1cc795329c02db03ce569df06853acc1b6dfa1683fac4ab24d8040c2b2ed96e060e3d2c04ee360d3fe73526b45bc287fd98fa062d61c6323a189c42c23756f3de3099b7651bc2f5ce6f3219243404925d5ce9e92365965c07cf6a5941fc7659a865ac162c0187a7e33dc10e180397aa7748b65fbba891739175a71f7ea1dcc9189a86776aa8aee14a8dcd0fd1063b732dfc58d869e9c89cf9187958ec683c456803891702094c396d732b159c8ff4bf02369120b336a3a1630354dce464588ae30dc968c7f27d183986cee28c7483c1a99edf4fb9b69994cffb2820435e4b10b34ea518c50d35ec2b1034b36b09a264cb5f123c9014b637bdb5f17244f2c5e490bb40726a1c04b3a3405c8c2b4a3fb0e2b48fd8cc9ebe0578de3c687d71a461127862f4626afe647977cdfc4ac352b1a3a0f9764ab521b475aa4e61814902580e97c1c320e4af124ac499a205723e427d59dfd068b14c94ba7daf5782c857fec57aba9fc62cf13753e7ac1ec052ea6993a59b6d8c52d899d46babcc1df3399cf1db36ed443426ecd56ac6061e66e4ede68082b7702d9daefc3598a08a84794d025389bfc16559008f56fde3c2cdc20ebdfda4110e159d62c66456c0f6a0d9f0b75d43648567162063534cadea3854b103cf26ba920260b60cbd75939d6869633d26c9aa60858ca077e9f2edb1670ff2496d0900f60315594abd5e3c930abe4ba2fe9d9b3a0b98ce6bff8b98f2f07f7b204cc1033330aa32b075dad15d0b2b02204b86e0f359b671c9d59f4bb16fe2cb9da7d9321feeadbab274ec22472502b8a357d98d45a9fb5426a0437df00d833a17dbb6337aaefb7bc88aad4e276c29ab46d29a0d60b4d48c672e45305cd9f26dd9bbaefb86b69b8279695818c22299aebdc0fcbb4d3b77204ef1d10dc4ded58cb7afd4e305eed0a77dfdd316502f19d0cce98ca95e8e8893c2583fab07848ce0a1d25bde12a70eb43611c946f4d3398ef25fb176b9b9e2481a32a9b6a3fbb1208bedf12f30d4d50e616902d415c28ebd5f01e078958b42adf93ad3511f3ef4f610e9181b22d2afb9352d92c4545f2a02e4cd052e12746aa219541d7f3d6243127ca97c4c3b57ca87e4e9d9a127938cd8f5f2714feb9c80e3844eb28d464899ec75ec37cbb90df43d0570ed0d2be497e730a40b8c583a22e6b6a05b273aac61c81dbf54b491e7c873e6f68903dbbc10782d0c45d3c11f06332653d88ff3fee2aeeeab9df8ce4a4ed69dc0d420570f013caf56098459bf711daa47ba8aa6e6e501c69af7eda8244977f966f9d6217d82bd806a8d76126ca209472fdff4e3bb36e025d1ffc7c01a7139da556d5ce03082e9d22f627b8dfc3324a39539f4dd1d31c0fd4bbbb91db22a684d21b36b68506e74b484647c9e5f6c2aad7e830f8c88a07a16be8048056fd9b66e8fb428f2af899bcd4d341e8a1a98d8fb5254a7f507c25ba52d221ab5054ac47a394f265d9d4c7c7ffef686fd96147863d888d8e6aa1df17144cbbb9b397da19c09d7b7b2245840933df84c519268b9be03116febec700bae70dba90ffdb756a889f0822d0124fe8da835196a4c2de07e9be5432d4f6a24e6b0242998edcc060018787905cd1a96cfffe4f38e22d875dcb57820af81d8d3c126324476a93800cc39ba36350518c544c66bf6e3e19cb67cc272a82b0b4996b1e69ab267ca7dbd92f45a03292916bbaf291ec1a40298554c2fde133721539cd025a4b1f7fab8473ded9fecc1ce7a68afa51d0ccd14f46379851ae62137e21c21396069ccbdb496d30731b3db043a88f801aaf59ab0c71f42aa60b93c5c03f1da0f6071e292f2d1896097410fee21a052474a6a11cb118e9f0fa5bfb8ba0f470da25ac7e215b696e0567f8daed78373a4fbbd8a95f11136814678ff20854137f966b4867f67e5de8c31d6ced35d04b688c233590bca8e6272fdecdaaa4105f5a424697b14efc7d2817df1449af5294c2517050a3305bf577c26405d62bde0eeb8cb1e36c32d1155e37c0df63a69cc0d5cb1d4d6635f5976a7513d1ab51e2a3ce649d6c35649ed1937ddd9161132790c2682c7fc8cff649a1fb9bd38ea9b00301028894d8cd83c960d3a094161de3cde7832f1ba5c3bbb75b7c3681622e74f40df35086dc67efd44fa3df4a23ea768fc03801eee9649021c185c7d142b1b1951ed86a8bd4eef42651708c8f7f1b587c177f52c9bca21a31474de8c1cbacb7a6a1a26a142770c4df0420e897bfee3c07a12f367e7d7f3888cee1d8dd21daefd7f2c2aa8fd85ca57aac66f8e6f83caaa461d3a6f92db47ea54d45d687547c39fd71fb55769186af5f95ddff2aa0ccb0827cd6dca3d21cd3feb84088af18c28d9e704c3d6b628e76bafc2e5b0fef5cfb493a4ca270f9522dda6ca31254fdc5e74a67000fec988f6b0f1ee15258f4279537fe303c45533a2059f2bd914039408bb3a0bcd6af9bc094e737d6a92ba70355cb07ca0e56fe8f51c5b54c099ea0d9a7691e5d4942e1f15dc8f561372563b023a10218874f53f24cc33e57bb3455e73706d0384173974a8ca0a33cad2d51e88318cc9c718b8cbab4ebde1096ebfe91c292002aed35a861dfa95219edc90988fb61d3d885fb29afebd0f0eff3bd887e4d2154069edd342a3af5d4a86119cebeaa21a99df19a9d739047658dc8cbb752b1b542bc35a8a1618cca4ac7f62d1a31a156a4db68bc8574cc2eaa2410cc0c6c2430f0ebbdf28e1fc3b9621c50d35a9cd064864a709316b1261be83baae0d7a977c3cafddb8ac2741abb641b5d975c1a86abca721f1fc98b4d96f05c4006046251c06da62e4883737fe2adaa52dcb70787ead362c9e183f61beff63a0acd1a543fd6a815509c22f21008d4736f735f0aecab6d6b8d3288934db16c4fec38f7d77ae94f813a656b3d5618ec58a4270facdf169d8b84e6da3e2fd702470d02701d3b627d4edad98f95e03f365d1431b144beb210ca44ec0073b35e7fffc78598e22e0a8a75dfd6f5be8311863ace92168a841c90d894b7bd4994865e1d4a260f768ece32764023756a1a65fc0795253355c848819f9dfbce53533e53baa0ea4dc4f5d6a3b93edd3ccc64074e52ac14351a8cf443140b604618fbd27ae4ecb14adb7745e9f2fff524df8f8b48f2a49a93713fb623732172a5ff8309b5567078f6d00d35a1fbd6ddc2b43deee0db0547aebb2f429e7106393e00579d015f1799cc91b91bfc0aa1928e1913a1ea43a613aecfd7b0475c4960e42d14c21fd3e0b8321841b613b55e8203d370bb95ab63f8445d83948a7a0ad20f728e5688415a8d422cc16e78e31f2da64111edf73e0d602e556cc39279137b3f9cb6afde642c10b8465e2e6028de043660f3d5e97ff7ae11a4c2db566719d62f8ea08953ded6287354c8811346e5798977bf424d0d6c39ee3d13bd988ff436294ab45cd5351c2da58514443dd722e3880cf80a1be004e2ab5e3c27733d0097bdb9c5f4a74fb377e149a9d3fefe7f0c8da7dd39f27983b36fe25e3cadab9360d042a762b87245d337a3dede32b946c29a38261aeb4a0f0e18899f0b5aa747400a3bcc77ce3e1371a2127d97094e19bd6ee9cbabd498ced0902382e1a4b01e9c86ae9d001afb2a70444e4e74801e676c91f764e4664f86b0368d539544811e22d2efaba7d9e8d6b74c51c9aeeb0c4b78a39e1650b3375d411e43de1d23e9c9a011363195781d85184ebb6bb0f11c70f1848a4adc9eec707f23ebde96ea565d086522aa6720ee11ae02cb452e16a8548136f632c06213d3a1242477f2be37992f7d76deddbfeae64de0622af54a9182bbefc669d240256cc7839595c47b10df27560d5a4e50288c8c24e548ea0769de1e6af3c7c8ee654c06abb0e1226e4adf43cf3f1f68ed03cd9bca678c1c78bf8b547faf406fbd3b57c08e594857d2924d5704ff716c2bac7081d12165798dd09ad3884e650fd3a2104fb98f33871c0f485c1396c6dde6cce36ccd54225a0716050b81858f9c4c52e0776776c4869cca69cd2a7730de46e4699f48298b7e120885f71c630095ffe18cb1451785cc9e249348ba9c437e77474ab55756ae817c1965304e9d7d0fa20ae8cb8893309492958e6b0aa7d056e9be51cfd7a9dac66495c0f2dd8da7794c02a87c5eb8466709ef5a2193e2b4b3ce884c3f0f32d192aede6c0043d39b31df880309cf0cc270fa4c0f54be1c59d460fa338e7602bb6895a56ac8a3f5bfce874a731175600db91b635d47f822933888a3b3da5e8bfb878e3498d2b61de5cdb743e20f1c5974427c352fb78799cff346c8076a90ba18228bf3afd5051d727e14f610c731a22855cf8571d7f28ed7d658e772e5752395a0391201872aff3a1e55ba6ce3ac3b953afdbf9dce417501007fbf183ea7a1898bd9ebad96ac1a257197143b054b966c18443405bebe81411d1a86206441f57af946659ecbbbf2e41d12d9da061e846da864a94a1b37f0101dac233a4e2d049b2ca85eedebea23a4487b1f29c907b98363b00961f956e3dbb6357037b51e0d053dd51729e58c93d74fc3af5e5ee4a42ea1942d1277b19b5aa72dfff2491b8d9359af0f1d39e35c62112d44f8a552147a601d726200f0e9fddee3498b7c9c348408a0b7ecda5c80080e654a207d315968cbcf97115a9f388f69ec51d4877698c7c6f5a864c948c60fcd0ec2780b464f21d2f27a533e125f8cb5ed653e692d00dc9846e287ef6b6883b48c28d842997ddbb9f8b8cec9848061e7ceb118f40d63039cf7e77dca513c404efe8ec1020e080415cb67c33d73a9c3898c0999b948fef7a59f9825456c7c1f2f650d075411c1908af258fe75936cf9d2e6b499e4cf6ddc6a6e4157a49bb100c20c5233bccec5dd6df40b3d12252f2e284a2c8292c48b7dcbf899249a641e518ffee475ab721db91dd40c8d2e16dff467593d09ca25529c31492fa81140a3de49367b3714f4808042bc059e870867b3cd000592b2cf4362c187114a58d72075a1f21a5ce4cc43cec513075212d077ea7550c9471f0900522a949b72e5bad91a56607b8d8af7ebe9f417fad92bf961d571707a9c5318c6998f2e81a9401a4c784dab64a0b1a210ac922e63f9359e603be17e2488444038516e01aa53659b0f90e4149038c012a0dbfb2d630b0e4009a253328e829710e7408b0bbf052d530d702bbef02990d3203793501de0af41c96e8a4c4389561c057e534643038a911985a72162af3573a3cb82336b6f747043d1c28581ae4ca6159ecd0f355cbe001654e8ce60260d9c9cc0a29797f53b60d358244a99e6a8f3ca8e16731b6f6e8a4bf758e00df4f33033e38abeac4007e29f5827754d46ecaeb13447efc6e536e791dd768d4f06d351d8cfbbec9cfbe0a6077de6426b336249b687516dba8a5564e8f04fdfac645c96448c4854cdddf72600819a535a1d13184e15a93e14e0ac10487c444ca24f315b9de5e3edf7c7c99a61f99028cc9d9371ebc1e26cd6175acea067438abd4a6ea831d1dd067e136b42b24d3d1b354c66747ce77921b067220c1c6db59d798e353f4a394bc68895811715df28f2496945663f72f64e3f804edcd5b2d3841dd3c8388397ed9849bdb930b921babcc44063ef0b3dafacf555bbd5fca6ec7bf8b1bd0c7d1c07db2d00b6ad7517ad60f7fcf3588d82f97b4ebaeffb065f260ebe55e75138faaaf34be287865e3fa98c88f36d7e9aaf3c5053de1d7e46d86957fa84c5ec86dbcb14a210b8e36aa9a477ad1155f6e2f6e419168a8c9e951ffa24a3971cacf54c36dbf8e5e574bb8901d2ee4e7e678dd2ffc15a9b66100ee3703b7059463fa1d28a5b8ab9cda9e060bc906210bfdc4659641b2dc3a8eb220debb0c6a2ea6a6a027232fa0957424287c3b4a74967241d3800a503ac1ce9d17d8efa2cffe3bfab3ef08c69b8ccd48683f83b9578e2adde71144b10089d6b6665957fb121ce7feb623d6de0193d0806424ae3882885111d5e5b055a6a2c9f105e726ef22d81172dc51226cb3b1b50394f10a97096cd0f9893ca082fd78e8f9c38b1179d85df6c3791b7355233705f336946e6902f3b5a9665affe897a05a74451b64b0d936253462be827435ba770a282efb53bccfc1a8db1c2e4b8f71dfd8adb81076b9cc092e0b0acab0308fea5fa944be0ebc104808b8e1ac111ca724884ea78b71ce38a3a738867dae7610bc593914c96c093e79c1f3d24a1aaad798ecb032d40e5758c4151df08e367c69ec83fbf367a251c0a626b735932be972fd32489a4372e6bbb698cec19862014638cf229c3577eed4a6ac526ba591f202a8f8d53e2a5fe2f5381b6a6f90d4ec710d580be001bd50955030efb621fdd4c022eaa13296dc5739e920b32681ebf53b71e95bd3a1a20877a3550a0daf8029f6597fd2d5a646a8c4f28092a09ebbc70b1e5022725efd321dc2eaa51045bb09c9d36a80e6d224f03e7a38aeb9b404f7334eac81284e3c89f9aecb38532fd4f850c55b274098ee365a63bacbabf1b0d1cc4c1b566d95ab5478e52881855d4aa0a02190ac8f6ebc78c1075848e5d825e0675c2ad9ae9ba92d167784037e469fe767c7d4ea11b310036fcba8e1442eb69c7e82b099a27a274a0da48b4d89811f7dabeed1e890fb77bbc3200be38a19704cf90d8d27c5003e1169da8c8ed3a16889dda5715f9582111151ff28d1e0631066ef350082a16a52982ac943a996388c7ce2c5cd0c4dc43c1e1335baf38d8992481362b725c3d988e55dae924827ee16243156b124aba09b7b7f1a928cff5b053b0b8e0d16cfa9bdebc925752b76e3bca5f74867d6fda02bfcbf9a5407ea8cced980c17e9849f61116f4294e8a2ab66fd655d929d3f23501d6fb411152c098dd07b601bd7d67cf9e15d9af2e3698270b62df779e9de9eeb2ee59cfeb8600f2c8cdbf8279a5a89c80e5181ec0c1207e78cd3eae8290e1bbba02414c4a17b8f8b8e9e70241d89be8f682fe2a9e51f6ddfe05af3fabc87ed525d108bd4a076772cec3c760c70023107369462b0dc0c1c4f465a6da50da15f621726851fa5c3603ffe6411d871df04de4215fc550a3ff8f51b1f2d222cd77be6cb86f1171d4d51239af371992a0655ca48dff95642b9da08d0c5f606c92a4d526eba22e2dd28a1e94712406093462eec183ae1c10ec139565107f0d3087dc6d40ce10a743c27d93a3c0d37444b5ac0eec2514a73b3adb807899bbfff6e0d050e8aff58bfb7218051613e7d5d668edf7d32d660a4b2d30cf44efbc875651a03dd929dbfc7aabcbc16da2f7ea351adbbb8142169cc43170257a373b9f310fd70cbc167c7c1107ddd7d829fdaec137660db743a678bef21274c67f8485b210cedafaf36b8de3b5569926dbd726f05ee4b6882a4feb035b6d1b955b6ab4b5a302e3021f9552a6acf2aa52c47a6be5effa60afd256dbadfa2cd8e41e24d5b3d44196a812b73972de6bd798b77a483a2f8684307ec7c7337a4aafb0827b53f0ce14ab1d6e8c409c79a818f5fe52c06088ab9471b64db0258823c33e475a4cea36a8461d6887ec934a156e9d3995b3ce3e4bf7f473b16e2989a1a12d89558f055e700ea2066c3acbfe0c791652a25d1cd3b7bf6ffdd8f738450b44d83e546f1fd5b09a8a760c235a72afc1b176a8b8ea08ca44bdb2ae638213bc03197a43669a4247aefb63ebaafcad35ae348a7c93d908ec3ec361a9a639859e4ff4daf84aff8da398784494fdac5a7ef07bf48e6527e66a69e236525c9d908336d876315a4b3504fd043ad543dd3d541c9c38a46f658016d0ffd94bc69b937fdd9ae35ba907a806a734affac12e9c269ea104e669321569477d81a23ca701afdf0573a1416994e82daf27b5beaa4c4926a43fb8b6477cceab91e6c83a5babd410f555adf1ee39727f7a9eb1b531e5fae35a325b9d030970dbc2b6034b5f1256291373f054c26660a6a64ad3955db67491843c83d793b01ada003429ad4489c95fde4ca0c86181abaefb6f345bec1d988151b7091a1c649d508489786add16b1a74ba3400cd7a3b4a9ee625efc2402f3c0e2352a54d5f2923fb089371eb41cbe4acc4203900eca8db8b0d8227762119aaa564b571c78838c750b5c0a7bdf13740f42bb8d73b75b12c17e025afcee9fbe3f43b54a666c24d8a662b2c2f5ecc361c317a1ec3eae94dc3860c238cc2eccba9cbf73b69aa5e4035f22b90f880c2f8e7ce65c8483a3c64b9a922e7b08f4e019015fbd75456d7393d2ea0deb1af3e879d1ecacd98dc916215b4c908e940ebffe12443b537c9dab7be7d47b4dbbc0af7de0c2fe7da1a347c4b9f24a3b1967f86ae935fe547af7102c2f84ea66289b8a9c5b4e874a9be54e1308a1c4013159f67b797df8f18f06b90d5c90cbeb5707a436fd0e54d0389bd98a8ae76be22ae82248eed053a2c3d610a7d8c96aef67d48a4a78fafa9ff2b00ae4be4026b82ccc7009bdbdc071d8b4a3d0b59b9f90cd960591c32fbd07495345910326f24175db96843eae79cb4b7c59351e579d3b3f21b6bb06334df3b56b8af3e0fb006be4edc73088bffa5f2902ace8a6c3f28744f77ae9edfe971e0ae7faaac54c559bfa5672de299fd61751670e75f3421cc3f17ee659693f0f32192b582e9f50c5c5f46dcb010d889425a7c04475c6b735bca49247565bdada4549e87f09eb28d36a672b1df3f22d44eabe9fe38bf2bb04428d9b062a6a93045a909573e2e445b268648f2a840a543e3db0f2e1bde39d6893270c2f39ad272b26e542d8d5284c4683a8534c5b5e7c2e27ad37f09535f99975bb39e8d3d06f69445a2eedc42f5f3cca7cc933ea3b38bca2b45e2aec2c000fe1d1fbb7add13bbafb886ab133cca5ecbcbface492a053460dc1cf449cd8b4540971731990aae4213c719d61fb02dafa565e3018394c8afd8187d353776bcb50d62fd5fd5ff0dc6e22d5d27c1da3846ef6c91fb4192ab68e545bfb0a6a54f5c88d726eb9d34e83314966713b6c4e3014879bce176573d6bddb421cd9e9c76094c4150a08725b38dbb6941b54eec32e3145207f7fa6e8f5eadba6bba0e3f995b436b6a3085a88ed621abf23ae5e3f0ccd349bc2368213fef3ad8573816b6e5815f885c831ca7964faebec1b4770fce4341f2cc59feca8c083e87cd004040c8fd9f89761e85ef0f2e0707db9402a69039a4b54583d37cef6164e1613732c3c827d30b24fc23629ee0bc3b9ad18309fc43fdc5b8f0107bceb6b67fcb2dcb8e52edc71c3ee541742890417bd80a92619aa94e272031b10e4afc2e703ba299424ffdf9b67a7e2044911a50eabff4be09164aaeabcd26b7a68aadaef9823d476763cd094d68e958e639f5f653f1ece37508d31d833206a9106c1e2ad3c3a719ed8cf128721233e7425f645129951aaa59a418efb33b1153c6d0cf8e486fc2a4bb78738262940fb50b8e9da632c4706776b172e6c448e080c5786740af83bca3466a2f0d66eec3ccff07fec28b8de939e5d42e736cfb7ac79cd1f3454d2f90d0ce050ba631a18ebc078ea81d75298478ff51ea3a16d0a08e45a6053b991df13171332eaed4158a202e72772139eb612aaad1fa72f77edcc04cc724c37da63bc65ca07fa4523fad377e46f3a1d1cbfe9979235c0bf00698e4df578d36538950d21a4805ab88fb81a0b2441a5dc8a0367dd5bfdf6c2317cb907b668c065e9fa9f58967532c03ddbba607d3c8bb26f5d853b95936af3247d14ee4003c5fc884fee32c2dcb1f6e0eef48ca29a35f182786da950b158500b8bf97f9879839259b52f4e0ef2686bef9ee09e7f25abe485cee31aa2a906942a78c2cf605b97e92e06313cdebf27cf3ab79d4760d0e522a5ee9c2a10ddeacb9c2ff8db8c7640ac555085c29c7ff9e52ded396ce33d23b0f261da26c67c9587748de9d2fb30214631961ea56834da7f85cc879140c4953e44a3f1dfd4ee914a6210437a62ace254f09baf74f2e74f277a01b6159d32bc9dfb28cd79718279e7d1afc2f8516ac4567186f71927fce21551f951c28828a7147d27470a4e90716789b5e6e8458218f634c656ddada0b68d61ffc34e876a6121620dd033897f39f892fbd3a9d3e57358be5c89849ebb124a724543dc4b0ce7d27dbf320686dbbc3388b07ab2fa927e3cf5fcb7ba4fc93bc4c22010e7857b02588f929ddffd1684b812c5ffd9184cc1dce4709134fc3753c44e4f3b333ca0174798daf4523718e5b7210ec9eb829ca88d3a077abbefee4e28830f678244e76e2f002ee5d904e693a5a884f2620a45a13b89958e7d401a5570cfc33798632298e64692eeb05b94890ecbd506713562f465ef54090a210b80f424a6be24d106114b11f095cffe3811bf48e599bfabed8df709302d07ac43c1684dffef6efe6ae4fa8fa97cae236f2697fe308ce35e5600c7b1426a19cdad7416535d700c70ba440d83ff43151891717d2b137983312ac6e8e3b9d11371c42e316beee173d3c712c98ae1841cba52d35d98ae7f6712576c4af86b0e797a1b9b14d7e414b63039942fd850408095fac1d9189f0c910cdf3cff4510a223cab4ef6708adb85beedf555178c5c09f5da5a2d8e0e5a7b95462cf8392c2d44c5f34ac3382e35036574bdd4523fa35401b64022d9bd1b909a43d0fd3f4579b084537a2e242f4e368fbc6923395c27a03f755c01f36bf6b15e55dcac7070c3ef679746a58108113b39cea02f88f1c8486e48fa85806a2b1ef64fb7682540af377684d10fe113b43fb73e9e9b8f4b10261af5de4c28646b10189464315ce7a3ec7fe15db838bfbd8cf24aa96ea02494ee66547082d340661a02dcdf9085a2c141e75c2ff4ad2b276835ed318ea06b140771cee384897ece89da6315a83dad5446356270e72ffc497dadd035123f9508a594f2c090f279597cb36fe5ae30fe61ecff3856da7229bff2e46218f2b331f84aeb115b11b6dd47812d6e13d2ccc10175b1ebc14e30941d19507924f38d1490d8b3d681a0bb100b7b1171b73cb9991829bde8c7442448921ef5a8a9790ddd40dcde770a08e89cb4a6ab075b6e0bf66fd878e84a7da5af367d5a1f08f5859d5ededa6b866a2965e109e64bc0dcb6f49b3267f00085dbcdfc34a10b495b2edcca8d453a37d3b64f07a8b4d5c7d07862ce8d690f3671e23d75f4d8d43635d10c74f6086bb0885de963d1d83e2f2dfb3bd69eb58eb2e0a6cae78f51df198dd2fcfb858668cc6118e548400589da739b5045c90075cd947ea65f73d8cd0d2c9210695180e31508d6ac1303fa1b3a4676a27dc376410e2a42d148759eda74b8bdae37633ac4d862151f1b92e52ed8ed8ed0da1e43541302e308b9921e5b24f1efce82dbaf34879e3e8c2060aa2e8c6d3b02fd8849f3f9e2f0eb4eebacd29c6a6f575161df491775a8214c95e90b54e5424c1e99a87efaff89409d0f43376def0e9460bc21ee6041a]]></content>
      <categories>
        <category>魔方</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>🇨🇬CG/ImageMagick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImageMagick 图像处理介绍]]></title>
    <url>%2Fposts%2F852e1bef.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间一直在搞图形处理的研究，以前以为 Qt 框架的图像处理很强大，可以解决很多 Maya 处理图像的问题。&emsp;&emsp;但是自从认识了 ImageMagick 这款命令行处理工具之后，我才知道什么是小巫见大巫。 &emsp;&emsp;ImageMagick 是个纯命令行开源图形处理工具，有服务器 PS 的美誉，用 C &amp; C++ 语言编写，有多核性能的优化，扩展性非常强。&emsp;&emsp;最让我赞叹的是 ImageMagick 支持 PSD 等多种不同图片的格式，图片处理的功能内置形态学 API ，甚至可以自定义处理核函数，处理功能远在 Qt 框架之上。&emsp;&emsp;另外 Maya &amp; PS 都内置了 imconvert.exe &amp; convert.exe 可以直接调用。&emsp;&emsp;最新版本的 ImageMagick 甚至集成了 ffmpeg 视频处理功能，只可惜太大了，失去了老版本的精致小巧。&emsp;&emsp;Maya 的 imconvert 版本比较老，但是胜在大小不到 10 M 非常小巧，依然能够满足大多数的应用场景。 文档使用https://legacy.imagemagick.org/Usage/ PS &amp; Maya 处理 &emsp;&emsp;PS 自带 convert.exe&emsp;&emsp;Maya 自带 imconvert.exe&emsp;&emsp;都在启动软件的目录里面可以找到，然而 Maya 的版本虽然比 PS 的老，但是处理渐变的效果比 PS 的要好很多。 参数详解+dither 参数https://legacy.imagemagick.org/Usage/quantize/#intro 1convert colorwheel.png -colors 32 color_quantize.gif 1convert colorwheel.png +dither -colors 32 color_quantize.gif 使用案例剖析官方提供两个大佬 的 案例&amp;脚本 http://www.fmwconcepts.com/imagemagick/https://im.snibgo.com/ 缩略图处理https://www.jianshu.com/p/9c7d53055adf 图片大小获取123convert input.png ^ -flatten ^ -format "%wx%h" info: 这个支持绝大多数的图片格式(包括 psd 格式)，比起 Qt 的 QImage 还好-flatter 可以将 psd 图层压缩到一层，否则会获取每个图层的大小信息 链接 Python 通过 subprocess.check_output 方法可以直接获取命令行的输出。 抗锯齿 半透明边缘 剔除https://legacy.imagemagick.org/Usage/formats/#boolean_trans 123convert input.png ^ -channel A -threshold 1% +channel -alpha extract -negate ^ output.png 使用 -channel A -threshold 1% 可以将大于 50% 半透的 转为 完全透明可以剔除 anti-alias 引入的半透边缘 主颜色提取https://legacy.imagemagick.org/discourse-server/viewtopic.php?t=28963 12345convert input.png ^ +dither -alpha off ^ -colors 16 -define histogram:unique-colors=true ^ -format "%c" histogram:info: ^ output.png +dither 去除杂色-alpha off 关闭透明通道-colors 16 提取主要的 16 种颜色 输出会以命令行的方式输出 渐变生成https://im.snibgo.com/islands.htm#grad]]></content>
      <categories>
        <category>CG</category>
        <category>Image</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/ImageMagick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhotoShop 工具开发流程]]></title>
    <url>%2Fposts%2F2c964fd8.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近因为各种原因严重拖更，不过还折腾了很多东西，主要是上一周遇到了让我吐血的需求。&emsp;&emsp;肝了一个多星期才算是勉勉强强解决了，实在是太难顶了，所以就一直拖更了。&emsp;&emsp;PS 的工具流程也是那个需求的一部分， &emsp;&emsp;最近接到一个需求，需要开发 PS 的工具来协助模型的贴图处理流程。&emsp;&emsp;尽管 Python 也有一些控制 PS 相关的库，但是考虑到 美术人员的使用环境问题。&emsp;&emsp;还是用原生的 PS JavaScript 进行开发较为稳妥。 开发文档文档链接 &emsp;&emsp;关于 Photoshop 开发相关的 JavaScript 使用，首先需要去查 Adobe 官方提供的文档以及编程规范。&emsp;&emsp;上面链接可以拿到各个不同版本的 脚本规范 PDF ，其实不同版本的 PDF 都是大同小异，重点需要关注两本。 Photoshop Scripting GuidePhotoshop JavaScript Reference &emsp;&emsp;只有 JavaScript 支持跨平台，因此其他两种语言的 PDF 可以忽略掉&emsp;&emsp;但是只靠上面两个文档还是不够的，因为文档里面并没有包含 GUI 编程相关的内容。&emsp;&emsp;GUI 相关的内容在 ExtendScript Toolkit 下面。 ExtendScript Toolkit javascript_tools_guide &emsp;&emsp;最初不知道有这个文档，还查了很长一段时间。&emsp;&emsp;从 ExtendScript Toolkit 的版本到了 CS5 就没有更新，可以看到用这个语言编写工具流程已经很久没有更新过了。 &emsp;&emsp;ExtendScript 是经过 Adobe 扩展过的 JavaScript 支持 Adobe 全家桶开发。&emsp;&emsp;使用 ExtendScript 的好处是能够一直兼容支持到 Adobe CS2 系列的产品。&emsp;&emsp;可以通过上面的 ExtendScript Toolkit 来调试代码。 &emsp;&emsp;缺点就是 ExtendScript 是基于 ES3 的规范，所以很多 JavaScript 的新特性都将不支持。 stackoverflow 链接&emsp;&emsp;当然也正如 Stack Overflow 的链接提到的可以使用 polyfill 来实现前端的向前兼容。&emsp;&emsp;所以 Adobe 官方也推出了相关的 extendscriptr npm 模块，可以使用 node.js 来构建出兼容 ES3 的 js 代码 Github 链接 &emsp;&emsp;另外 VScode 也有 ExtendScript 的扩展，功能完善，完全不需要安装老旧的 ExtendScript Toolkit CS5 来调试代码了。&emsp;&emsp;另外 VScode 的扩展也同样支持 将 jsx 编译成 jsxbin 格式来保护源代码。 ExtendScript 编程 &emsp;&emsp;如何使用 ExtendScript 来制作 PS 工具，可以先看看 Youtube 的一个老外的入门教程，浅显易懂。 Youtube 链接&emsp;&emsp;yotube 上还有很多相关的 Extendscript 教程，都是可以参考学习的。 GUI 编写 &emsp;&emsp;关于 ExtendScript 语言特性自带的部分重点看 javascript_tools_guide 这个文档。&emsp;&emsp;可以跳过 第二个章节的 Toolkit 说明。&emsp;&emsp;其中 第四章 就是关于使用 ExtendScript 编写 GUI 的。 1234// Create an empty dialog window near the upper left of the screen var dlg = new Window("dialog", "Alert Box Builder");dlg.frameLocation = [100, 100];dlg.show() &emsp;&emsp;上面代码可保存为 jsx 然后拖入到 PS 的灰色界面上，即可打开一个小窗口 &emsp;&emsp;由于没有关闭窗口，所以关闭需要通过 Esc 键来实现。&emsp;&emsp;基于上面的逻辑，可以编写出更为复杂一点的代码 123456789var docRef = app.activeDocument;var dlg = new Window('dialog', 'My first script!',[100,100,480,250],&#123;closeButton:true&#125;);dlg.btnPnl = dlg.add('panel', [25,15,365,125], 'Hello world!');dlg.btnPnl.testBtn = dlg.btnPnl.add('button', [15,30,305,50], 'Finished', &#123;name:'ok'&#125;);dlg.btnPnl.testBtn.onClick = function () &#123; alert("Congratulations - it all worked!"); dlg.close();&#125;;dlg.show(); &emsp;&emsp;具体的对象参数可以参考文档，参数说明都有标注。 &emsp;&emsp;除了使用 js 构建窗口，还支持 Resource specifications 来构建窗口 12345678910111213141516171819202122232425262728293031323334var windowResource = "dialog &#123; \ orientation: 'column', \ alignChildren: ['fill', 'top'], \ preferredSize:[300, 130], \ text: 'ScriptUI Window - dialog', \ margins:15, \ \ sliderPanel: Panel &#123; \ orientation: 'row', \ alignChildren: 'right', \ margins:15, \ text: ' PANEL ', \ st: StaticText &#123; text: 'Value:' &#125;, \ sl: Slider &#123; minvalue: 1, maxvalue: 100, value: 30, size:[220,20] &#125;, \ te: EditText &#123; text: '30', characters: 5, justify: 'left'&#125; \ &#125;, \ \ bottomGroup: Group&#123; \ cd: Checkbox &#123; text:'Checkbox value', value: true &#125;, \ cancelButton: Button &#123; text: 'Cancel', properties:&#123;name:'cancel'&#125;, size: [120,24], alignment:['right', 'center'] &#125;, \ applyButton: Button &#123; text: 'Apply', properties:&#123;name:'ok'&#125;, size: [120,24], alignment:['right', 'center'] &#125;, \ &#125;\ &#125;"var win = new Window(windowResource);win.bottomGroup.cancelButton.onClick = function () &#123; return win.close();&#125;;win.bottomGroup.applyButton.onClick = function () &#123; return win.close();&#125;;win.show(); &emsp;&emsp;具体的定义也可以通过 文档查询 到。 &emsp;&emsp;PS 的脚本执行除了拖入的方式之外，也可以使用 文件 -&gt; 脚本 -&gt; 浏览 选择一个 js 脚本来执行。 PS API 调用12345678910111213141516171819// JavaScript Documentif (app.documents.length == 0) &#123; alert("You must have an open document to run this script.");&#125; else &#123; var docRef = app.activeDocument // 设置 TGA 保存的设置 var saveOptions = new TargaSaveOptions(); saveOptions.alphaChannels = true; saveOptions.resplution = TargaBitsPerPixels.TWENTYFOUR; // 设置 TGA 保存的路径 var saveName = docRef.fullName.toString(); saveName = saveName.replace('.psd', '.tga') docRef.saveAs(new File(saveName), saveOptions, true, Extension.LOWERCASE) alert("保存成功")&#125; &emsp;&emsp;上面的脚本就是基于 Ps 的 API 实现将当前 psd 文件存储为 tga 格式的脚本。&emsp;&emsp;具体的操作方式都可以通过文档查询到。 &emsp;&emsp;结合上面的 GUI 界面就可以构建出 按钮触发保存 TGA 图片的效果。 PS Script listener 插件 &emsp;&emsp;虽然 PS 的很多操作都可以看 API 来实现，但是手动去查 API 还是非常麻烦。&emsp;&emsp;可不可以像 Maya 一样自动回显命令，这样直接抄代码就可以了。&emsp;&emsp;这个官方也出了一个 C++ 插件来实现相应的功能 插件列表&emsp;&emsp;上面的链接里面有很多 插件 ，找到 ScriptingListener 插件，按照说明安装到对应的目录即可。 &emsp;&emsp;安装完成重开 PS 之后，在 PS 进行任意的操作会在桌面上生成 ScirptingListenerJS.log 的文件&emsp;&emsp;里面会将 PS 的操作转换为 js 代码。&emsp;&emsp;不过代码大概是从 C++ 的命令里面转换过来的，所以自动生成的代码比较不简洁。 &emsp;&emsp;自动生成的代码里面包含很多特殊设置，文档也没有说明，因此通过自动生成的代码可以实现更多操作。 ExtendScript 配合 动作 自动化调用流程 &emsp;&emsp;虽然 ExtendScirpt 可以直接拖入来执行。&emsp;&emsp;但是操作起来还是非常不方便，我测试脚本的时候通常会制作执行脚本的动作。&emsp;&emsp;然后通过这个动作来快速调用脚本。&emsp;&emsp;于是我想到通过这个方法自动化部署美术人员的工具。 &emsp;&emsp;经过网上的一番操作 xtools 老牌 jsx 工具集里面有将 PS 的 atn 动作文件和 xml 互转的工具。 &emsp;&emsp;我可以预先设置好一个 atn 转换成 xml 的 xml 模板，然后留下 jsx 脚本路径的特殊标记。&emsp;&emsp;然后通过 install.jsx 来读取 xml 替换标记的路径为当前路径，然后通过 xml 生成 atn 文件使用 PS 读取 atn 动作。&emsp;&emsp;这样做好的工作，无论放置到哪里都可以正确安装调用到相关的 jsx 脚本。 &emsp;&emsp;具体的调用代码可以参考这里 链接 保持 ExtendScript 窗口响应 &emsp;&emsp;使用 ExtendScript 写界面有个非常麻烦的问题。&emsp;&emsp;界面一启动就会将 PS 完全占用，无法像 Maya 一样界面和操作互不干扰。&emsp;&emsp;这个问题其实 PS 自带的操作都是如此。 &emsp;&emsp;最初我想可能是 dialog 类型导致的。&emsp;&emsp;于是尝试在 PS 里面使用 palette 类型的窗口，&emsp;&emsp;没想到执行起来的就是一闪而过，窗口立刻就被关闭了。 &emsp;&emsp;后来经过大量查询，在网上找到了解决方案 链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263var isDone, s2t, waitForRedraw, win, windowResource;// Shortcut functions2t = function (stringID) &#123; return app.stringIDToTypeID(stringID);&#125;;waitForRedraw = function () &#123; var d; d = new ActionDescriptor(); d.putEnumerated(s2t('state'), s2t('state'), s2t('redrawComplete')); return executeAction(s2t('wbait'), d, DialogModes.NO);&#125;;//sentinel variableisDone = false;// palette same as beforewindowResource = "palette &#123; \ orientation: 'column', \ alignChildren: ['fill', 'top'], \ preferredSize:[300, 130], \ text: 'ScriptUI Window - palette', \ margins:15, \ \ sliderPanel: Panel &#123; \ orientation: 'row', \ alignChildren: 'right', \ margins:15, \ text: ' PANEL ', \ st: StaticText &#123; text: 'Value:' &#125;, \ sl: Slider &#123; minvalue: 1, maxvalue: 100, value: 30, size:[220,20] &#125;, \ te: EditText &#123; text: '30', characters: 5, justify: 'left'&#125; \ &#125;, \ \ bottomGroup: Group&#123; \ cd: Checkbox &#123; text:'Checkbox value', value: true &#125;, \ cancelButton: Button &#123; text: 'Cancel', properties:&#123;name:'cancel'&#125;, size: [120,24], alignment:['right', 'center'] &#125;, \ applyButton: Button &#123; text: 'Apply', properties:&#123;name:'ok'&#125;, size: [120,24], alignment:['right', 'center'] &#125;, \ &#125;\&#125;";win = new Window(windowResource);// Button listenerswin.bottomGroup.cancelButton.onClick = function () &#123; return isDone = true;&#125;;win.bottomGroup.applyButton.onClick = function () &#123; return isDone = true;&#125;;// don't forget this one!win.onClose = function () &#123; return isDone = true;&#125;;win.show();while (isDone === false) &#123; app.refresh(); // or, alternatively, waitForRedraw();&#125; &emsp;&emsp;通过上面的文章可以知道 palette 一闪而过是因为窗口的生命周期依赖于脚本。&emsp;&emsp;脚本执行完毕之后窗口就会被清理掉。&emsp;&emsp;所以需要不断执行 app.refresh() 来保持相应，其实这个做法和我开发 mpdb 的时候用 Qt 的 QApplication.processEvents() 有异曲同工的地方。 &emsp;&emsp;尽管如此，这个方案也还是有些许瑕疵，比如使用选区工具就会因为不断刷新看不到蚂蚁线了。 Adobe CEP 流程 &emsp;&emsp;经过上面的 ExtendScript 的一系列折腾之后。&emsp;&emsp;项目组的另一个 TA 有提到 PS 开发支持 HTML 的了。&emsp;&emsp;我发现我这个流程完全没有用上 HTML 呀~&emsp;&emsp;于是又查了一圈发现了新大陆。 &emsp;&emsp;自从 Adobe CC 系列推出之后，Adobe 推出了全新的扩展开发流程&emsp;&emsp;CEP (Common Extensibility Platform) 流程，具体文档可以查看 Cookbook CEP 结构 &emsp;&emsp;关于如何使用上，Adobe 的团队有一个专门的仓库有很详细的描述 CEP Getting Start &emsp;&emsp;CEP 开发其实非常像小程序，需要根据特定的目录结构和配置文件来定义扩展的信息。 &emsp;&emsp;通过上面的目录结构来配置插件可以实现如上面动图一样启动插件扩展。 Bootstrap 快速开发 &emsp;&emsp;通过上面的目录层级结构就可以实现界面上调用 Html 来开发界面了。&emsp;&emsp;背后的原理大概是通过 node.js 开端口让 PS 进行界面渲染。 &emsp;&emsp;没有仔细测试，不过浏览器的大部分功能都是支持的。&emsp;&emsp;理论上可以使用前端主流的 Vue 或者 React 框架开发出一个静态网站，作为页面进行挂载。&emsp;&emsp;就日常开发的简单工具而言，上面两个框架无疑让复杂度上去了，毕竟写个界面又不是做商城。&emsp;&emsp;所以我更加推荐使用 ES5 时代的 JQuery + Bootstrap 流程。&emsp;&emsp;使用 Bootstrap 可以减少 css 代码的编写，提高开发的效率。 &emsp;&emsp;最重要的是 Bootstrap 有类似 QtDesigner 的工具，开发效率直线上升。 layoutit链接 &emsp;&emsp;通过 bootstrap 简单开发的效果如下 安装 &amp; 签名 &emsp;&emsp;cookbook 里面有提到关于 extension 安装目录，只要按照上面的 CEP 结构，将文件夹放置到上图的特定目录上。&emsp;&emsp;PS 启动的时候会自动加载。 &emsp;&emsp;但是默认按照流程走的 extension 扩展启动时候遇到扩展未签名的问题。&emsp;&emsp;官方提供了 debug 模式来忽略未签名问题， windows 上只需要在注册表加一个键值即可。 操作链接 &emsp;&emsp;但是没有签名无法使用还是让人非常蛋疼，毕竟不是所有的环境都支持注册表的修改。 &emsp;&emsp;签名文件需要下载 ZXPSignCmd 命令行工具来进行签名操作。 发布文档 &emsp;&emsp;使用 ZXPSignCmd 生成一个证书，类似于发布 Android 打包时候定义的证书一样。 12# 生成 p12 验证文件ZXPSignCmd.exe -selfSignedCert zh guangdong tencent timmyliang 123456 test.p12 &emsp;&emsp;然后再使用 -sign 命令将扩展插件打包成 zxp 文件。 12# 生成 zxp 打包文件ZXPSignCmd.exe -sign C:\Users\timmyliang\AppData\Roaming\Adobe\CEP\extensions\Flickr test.zxp test.p12 123456 &emsp;&emsp;安装上发布文档提供了三种不同的方式。&emsp;&emsp;不过 zxp 文件本质上是个压缩文件，其实也可以用 7z 解压文件，然后将解压目录移动到 extension 的固定目录下。&emsp;&emsp;这样的插件扩展就是已经完成了签名的。 CSTK 工具补充https://github.com/Trevor-/CSTK &emsp;&emsp;Github 上有人开发了支持 Adobe 都款软件的 JSX 运行工具，调试代码会方便简单了很多，十分推荐使用。&emsp;&emsp;关于 PS 开发的一些个人总结可以参考我的 Github 仓库记录 链接 CEP 案例补充 &emsp;&emsp;https://github.com/Adobe-CEP/Samples 这里面有很多参考案例&emsp;&emsp;其中 CEP HTML Test Extension 非常有用，包含各种 API 的调用 总结 &emsp;&emsp;上述就是 PS 工具流程开发最近的一些发现。&emsp;&emsp;但是 PS 毕竟不是命令行工具，而且很多算法封装实现，在程序批处理调用上非常不灵活。&emsp;&emsp;我最近还花了大量的时间研究 终极命令行图形处理工具 imagemagick&emsp;&emsp;不愧是服务器领域的 PS ， C &amp; C++ 语言编写，兼顾极致的效率，同时又能实现 PS 的各种功能。&emsp;&emsp;无论是 绘图 还是 图像处理，亦或是更甚的 核函数自定义 脚本编写 都可以灵活实现。&emsp;&emsp;如此强大的工具，没想到 Maya 的 bin 目录下就有了，后续一定要好好总结一下 imagemagick&emsp;&emsp;虽然没有图形界面，但是比 PS 要强大得多~]]></content>
      <categories>
        <category>CG</category>
        <category>Image</category>
      </categories>
      <tags>
        <tag>࠵Photoshop</tag>
        <tag>࠷JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 Python 编码风格参考 | Huoty's Blog]]></title>
    <url>%2Fposts%2Fc5bdc0e0.html</url>
    <content type="text"><![CDATA[原文链接 代码除了用来运行外，更多的是用来读。为了是代码的可读性更强，很多编程语言都有自己的编码规范。规范的制定是为了保持代码的一致性，以使代码更美观和易读。代码应该怎么样排版和编写并不是绝对的，所以一些地方会有争议。有时风格指南并不适用，最重要的知道何时不一致。当你无法判断该怎么做时，应该所参考下其他的例子。 本文仅是一个 Python 编码风格的参考，并不是一个规定，规定必须要这么去做。本文的目的应该是起一个指导作用，指导开发者去写更易读的代码。 一、代码编排主要是缩进与空行的排版： 1、使用 4 个空格进行缩进（编辑器都可以完成此功能），不推荐使用制表符，更不能混合使用制表符和空格。 2、每行不超过 80 个字符，换行可以使用反斜杠，最好使用括号（Python 会将圆括号, 中括号和花括号中的行隐式的连接起来）。 3、类和顶层函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。 二、文档编排主要是整个源码文件的布局： 1、模块内容的顺序：模块说明，模块文档字符串，导入语句，全局变量或者常量，其他定义。 2、模块导入部分顺序：标准库，第三方模块，自定义模块；各部分之间空一行。 3、不要在一个 import 语句中一次导入多个模块，比如 import os, sys 不推荐。 4、导入模块时应该使用合适的方式来避免命名冲突，例如在适当的时候才使用 from xx import xx，尽量避免使用 from xx imoprt *。 5、在自已编写的模块中，如果需要使用 from xx import * 时，应该在导入语句后或者模块尾使用 __all__ 机制来限制导入规则。 三、语句编排 1、通常每个语句应该独占一行。 2、不要在行尾加分号, 也不要用分号将多条语句放在同一行。 3、if/for/while 语句中，即使执行语句只有一句，也应尽量另起一行。 4、不要在返回语句（return）或条件语句（if/for/while）中使用括号，除非是用于实现行连接。 5、对于 if 语句, 在没有 else 且语句比较短时，可以在一行完成（但不推荐），比如：if foo: bar(foo). 6、对于简单的类定义，也可以在一行完成（但不推荐），比如定义一个异常：class UnfoundError(Exception): pass. 7、函数和方法的括号中使用垂直隐式缩进或使用悬挂缩进。 # 一行写不下时，有括号来连接多行，后续行应该使用悬挂缩进 if (this_is_one_thing and that_is_another_thing): do_something() # 函数调用参数较多时，对准左括号 f = foo(a, b, c, d) # 不对准左括号，但加多一层缩进，以和后面内容区别 def long_function_name( a, b, c, d, e): print(a, b, c, d, e) # 列表、元组、字典以及函数调用时可以让右括号回退，这样更加美观 l = [ 1, 2, 3, 4, 5, 6, ] result = some_function( &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, ) 四、空格使用总体原则，避免不必要的空格。 1、各种右括号前不要加空格。 2、逗号、冒号、分号前不要加空格，但应该在它们后面加(除了在行尾)。 3、函数的左括号前不要加空格。如 Func(1)。 4、序列的左括号前不要加空格。如 list[2]。 5、操作符左右各加一个空格，不要为了对齐增加空格。 6、函数默认参数使用的赋值符左右省略空格。 良好的风格： spam(ham[1], {eggs: 2}) if x == 4: print x, y; x, y = y, x f = foo(1, 2, 3) ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] ham[lower:upper], ham[lower:upper:], ham[lower::step] ham[lower+offset : upper+offset] ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)] ham[lower + offset : upper + offset] x = 1 y = 2 long_variable = 3 def foo(a, b, c=0): return moo(m=a, n=b, o=c) 不好的风格： spam( ham[ 1 ], { eggs: 2 } ) if x == 4 : print x , y ; x , y = y , x f = foo (1, 2, 3) ham[lower + offset:upper + offset] ham[1: 9], ham[1 :9], ham[1:9 :3] ham[lower : : upper] ham[ : upper] x = 1 y = 2 long_variable = 3 def foo(a, b, c = 0): return moo(m = a, n = b, o = c) 五、注释总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释。注释尽量使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。注释应该在# 后加一个空格才开始写注释内容。 1、块注释，在一段代码前增加的注释。段落之间用只有 ‘#’ 的行间隔。比如： # Description : Module config. # # Input : None # # Output : None 2、行注释，在一句代码后加注释。应该尽量在语句后空两格后再开始注释。当有连续的行注释时，为了美观可以让 ‘#’ 对齐。 在语句比较长时，应该尽量少使用行注释。比如： person = { &quot;name&quot;: &quot;huoty&quot;, # 姓名 &quot;age&quot;: 26, # 年龄 &quot;stature&quot;: 169, # 身高 &quot;weight&quot;: 60, # 体重 } print person # 输出信息 3、对类或者函数的说明，尽量不要在其定义的前一行或者后一行用块注释的形式来说明，而应该使用文档字符串（docstring） 4、使用 TODO 注释来标记待完成的工作，团队协作中，必要的时候应该写上你的名字或者联系方式，比如： # TODO(sudohuoty@gmail.com): Use a &quot;*&quot; here for string repetition. # TODO(Huoty) Change this to use relations. 5、避免无谓的注释。你见过哪些奇趣的代码注释？ # 你可能会认为你读得懂以下的代码。但是你不会懂的，相信我吧。 # 要是你尝试玩弄这段代码的话，你将会在无尽的通宵中不断地咒骂自己为什么会认为自己聪明到可以优化这段代码。 # so，现在请关闭这个文件去玩点别的吧。 # 程序员1（于2010年6月7日）：在这个坑临时加入一些调料 # 程序员2（于2011年5月22日）：临你个屁啊 # 程序员3（于2012年7月23日）：楼上都是狗屎，鉴定完毕 # 程序员4（于2013年8月2日）：fuck 楼上，三年了，这坑还在！！！ # 程序员5（于2014年8月21日）：哈哈哈，这坑居然坑了这么多人，幸好我也不用填了，系统终止运行了，you&apos;re died 六、文档描述 1、尽量为所有的共有模块、函数、类、方法写 docstring。 2、前三引号后不应该换行，应该紧接着在后面概括性的说明模块、函数、类、方法的作用，然后再空一行进行详细的说明。后三引号应该单独占一行。比如： &quot;&quot;&quot;Convert an API path to a filesystem path If given, root will be prepended to the path. root must be a filesystem path already. &quot;&quot;&quot; 2、函数和方法的 docstring 层次顺序大致为概述、详细描述、参数、返回值、异常，一般不要求描述实现细节，除非其中涉及非常复杂的算法。大致的层次结构如下所示： &quot;&quot;&quot;函数或方法的概述 详细的描述信息…… 详细的描述信息…… 参数说明 -------- 参数1：... 参数2：... 返回值： ... 异常： 异常1：... 异常2：... &quot;&quot;&quot; 一个参考示例： &quot;&quot;&quot;Start a kernel for a session and return its kernel_id. Parameters ---------- kernel_id : uuid The uuid to associate the new kernel with. If this is not None, this kernel will be persistent whenever it is requested. path : API path The API path (unicode, &apos;/&apos; delimited) for the cwd. Will be transformed to an OS path relative to root_dir. kernel_name : str The name identifying which kernel spec to launch. This is ignored if an existing kernel is returned, but it may be checked in the future. Return a kernel id &quot;&quot;&quot; 3、类的 docstring 的层次顺序大致为概述、详细描述、属性说明。如果类有公开属性值时，应该尽量在 docstring 中进行说明。如下所示： &quot;&quot;&quot;这里是类的概述。 详细的描述信息…… 详细的描述信息…… 属性(Attributes): ----------------- 属性1: ... 属性2: ... &quot;&quot;&quot; 七、命名规范 1、模块命名尽量短小，使用全部小写的方式，可以使用下划线。 2、包命名尽量短小，使用全部小写的方式，不可以使用下划线。 3、类的命名使用驼峰命令的方式，即单词首字符大写，类名应该全部使用名词。 4、异常命令应该使用加 Error 后缀的方式，比如：HTTPError。 5、全局变量尽量只在模块内有效，并且应该尽量避免使用全局变量。 6、函数命名使用全部小写的方式，使用下划线分割单词，并采用动宾结构。 7、常量命名使用全部大写的方式，使用下划线分割单词。 8、类的属性（方法和变量）命名使用全部小写的方式，使用下划线分割单词。 9、变量、类属性等命令尽量不要使用缩写形式，除了计数器和迭代器，尽量不要使用单字符名称。 10、类的方法第一个参数必须是 self，而静态方法第一个参数必须是 cls。 11、在模块中要表示私有变量或者函数时，可以在变量或者函数前加一个下划线 _foo, _show_msg 来进行访问控制。 12、在 Python 中没有诸如 public、private、protected 等修饰符，而在类的定义中往往会有类似这样的需求，那么可以在属性或者方法前加一个下划线表示 protected，加两个下划线来表示 private。加两个下划线的变量或者方法没法直接访问。比如：类 Foo 中声明 __a, 则不能用 Foo.__a 的方式访问，但可以用 Foo._Foo__a 的方式访问。` 13、命名 Boolean 变量时，表示是不是时加 is 前缀，表示有没有时加 has 前缀，表示能不能时加 can 前缀 八、程序入口Python 属于脚本语言，代码的运行是通过解释器对代码文件进行逐行解释执行来完成的。它不像其他编程语言那样有统一的入口程序，比如 Java 有 Main方法，C/C++ 有 main 方法。Python的代码文件除了可以被直接执行外，还可以作为模块被其他文件导入。所有的顶级代码在模块导入时都会被执行，当希望模块被导入时，应该避免主程序被执行。这样就需要把主程序放到if __name__ == &#39;__main__&#39; 代码块中，比如： def main(): ... if __name__ == &apos;__main__&apos;: main() 一个包除了能够被导入外，也可以通过 python -m package 的方式被直接执行，前提是包中需要有__main__.py，这个文件可以说是包的程序入口，包中有了这个文件就可以用 Python 的 -m 参数来直接运行。 九、编码建议 1、尽可能使用 ‘is’ 和 ‘is not’ 取代 ‘==’，比如 if x is not None 要优于 if x != None，另外用 if x 效率更高。 Note: 等于比较运算符（==） 会调用左操作数的 __eq__ 函数，这个函数可以被其任意定义，而 is 操作只是做 id比较，并不会被自定义。同时也可以发现 is 函数是要快于等于运算符的，因为不用查找和运行函数。 2、用 “is not” 代替 “not … is”，前者的可读性更好。 3、使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自 Exception。 4、异常中尽量不要使用裸露的 except，except 后应该跟具体的 exceptions。 5、使用 startswith() 和 endswith() 代替切片进行序列前缀或后缀的检查。 6、使用 isinstance() 比较对象的类型，而不是 type()，比如： # Yes: if isinstance(obj, int) # No: if type(obj) is type(1) 7、判断序列是否为空时，不用使用 len() 函数，序列为空时其 bool 值为 False，比如： # Yes: if not seq if seq # No: if len(seq) if not len(seq) 8、字符串后面不要有大量拖尾空格。 9、使用 join 合并的字符串，字符串方法 join 可以合并 list、tuple、iterator 中的元素，效率比连接符 + 高。 10、使用 while 1 比 while True 更快。 11、使用 ** 比 pow 快 10 倍以上。 12、使用迭代器和生成器代替列表等数据结构效率更高，使用列表（字典）解析式和生成器表达式比用循环效率更高。 13、避免在循环中用 + 或 += 来连续拼接字符串。因为字符串是不变型，这会毫无必要地建立很多临时对象，从而成为二次方级别的运算量而不是线性运算时间。 14、[]、{} 和 () 中的换行符会被忽略，因此如果代码里有多行的列表、列表推导、生成器表达式、字典这一类的，可以省略不太好看的续行符 \。推荐使用 () 来完成续行，而不是直接使用续行符。 15、多去了解标准库，标准库中用很多好用的功能，能够更优雅的解决问题，如 pkgutil.get_data()、operator.methodcaller() 等等。 参考资料 https://www.python.org/dev/peps/pep-0008/ http://www.elias.cn/Python/PythonStyleGuide https://my.oschina.net/u/1433482/blog/464444 http://nanshu.wang/post/2015-07-04/ https://zhuanlan.zhihu.com/p/25696847 https://zhuanlan.zhihu.com/p/25715093]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>✒博客/©转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 PYCON中国(2018)大会笔记 | Huoty's Blog]]></title>
    <url>%2Fposts%2Fe8c230c0.html</url>
    <content type="text"><![CDATA[原文链接 今年去参加了下国内的 PyCon 大会，想着这类活动还是应该多支持下。此次大会的分享者们分享了 Python 的语言特性、Python创新应用（人工智能，大数据，区块链专场）、Python 工程化应用（架构，Web后端，运维专场）以及一些从业经验。其中还有 CPython 的核心开发者Ezio Melotti 介绍了 CPython 幕后的开发过程，并分享了如何为 CPython贡献代码。以下为我在与会过程中做的笔记，内容有些散乱，所涉及的内容也没有详细描述，仅作记录用。 Python 语言特性三元运算符在 Python 2.5 之前，没有三元运算符，但可以用 and or 表达式代替： a = cond and foo or bar 以上语句利用逻辑运算符的短路特性来模仿三元运算符。但这个表达式有一个缺陷，只有 foo 为真时才能达到想要的效果，否则 a 将永远等于 bar。Python2.5 之后，使用写在一行的 if else 语句实现三元运算符的功能： a = foo if cond else bar 字符串格式化Python 最初使用类 C 风格的字符串格式化方式，即使用 % 操作符来支持字符串格式化。之后又加入了 Template 来支持字符串格式化，见PEP 292，示例： &gt;&gt;&gt; from string import Template &gt;&gt;&gt; tpl = Template(&apos;$who likes $what&apos;) &gt;&gt;&gt; tpl.substitute(who=&apos;I&apos;, what=&apos;WangQing&apos;) &apos;I likes WangQing&apos; &gt;&gt;&gt; tpl.substitute(who=&apos;I&apos;) Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/usr/local/lib/python3.6/string.py&quot;, line 126, in substitute return self.pattern.sub(convert, self.template) File &quot;/usr/local/lib/python3.6/string.py&quot;, line 119, in convert return str(mapping[named]) KeyError: &apos;what&apos; &gt;&gt;&gt; tpl.safe_substitute(who=&apos;I&apos;) &apos;I likes $what&apos; 再之后，字符串对象有了 format 方法实现更高级的字符串格式化，见 PEP3101，示例： &gt;&gt;&gt; &quot;{0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) &apos;hello world&apos; &gt;&gt;&gt; &quot;{} {}&quot;.format(&quot;hello&quot;, &quot;world&quot;) &apos;hello world&apos; &gt;&gt;&gt; &quot;{1} {0} {1}&quot;.format(&quot;hello&quot;, &quot;world&quot;) &apos;world hello world&apos; Python 3.6 开始对 format 字符串格式化方式进行了增强，即 f-strings。其支持自动从当前名字空间中查找值，且支持函数调用。见 PEP 498 – Literal StringInterpolation。示例： &gt;&gt;&gt; name = &quot;Huoty&quot; &gt;&gt;&gt; f&apos;My name is {name}&apos; &apos;My name is Huoty&apos; &gt;&gt;&gt; width = 10 &gt;&gt;&gt; precision = 4 &gt;&gt;&gt; import decimal &gt;&gt;&gt; value = decimal.Decimal(&quot;12.34567&quot;) &gt;&gt;&gt; f&quot;result: {value:{width}.{precision}}&quot; # nested fields &apos;result: 12.35&apos; &gt;&gt;&gt; import datetime &gt;&gt;&gt; now = datetime.datetime.now() &gt;&gt;&gt; f&apos;{now} was on a {now:%A}&apos; &apos;2018-01-18 11:21:58.444054 was on a Thursday&apos; &gt;&gt;&gt; def foo(): ... return 18 ... &gt;&gt;&gt; f&apos;result={foo()}&apos; &apos;result=18&apos; 语言高级特性增强可读性的特性代码通常都会被反复阅读（Readability counts），所以在编写代码时应考虑其可读性、可维护性、可持续性。 “工程师要有文化，Write Beautiful Code.” 以下列举了 Python 一些能增强代码可读性的特性，这些特性应该多用： 装饰器 生成器 上下文管理器、 关键字参数 f-string、 协程支持（yield） 函数式编程（map、reduce、filter） … 提高语言能力的特性 inspect metaclass 描述符 getattribution import hook … 这些特性非常强大，但其会使得代码难以理解，降低了可读性，所以不建议在业务代码中使用，而应该在更为底层的代码中使用。 使用新特性 能增强可读性的特性就大胆去用 Know why, know how – Read PEP 架构设计什么是架构？架构包括：1、动的部分；2、不动的部分。 Python 的骨架：Everything is adict（赋值只是在 dict 中增加 k-v 对） 架构设计的三个关键点：抽象、分层、接口，下层是上层的服务提供者。 架构调整要慎之又慎，选型时要在 保守 和 激进 之间进行权衡，最主要的一点是要保证 易维护性 。 时下关键词： Cloud SaaS Docker / Kubernetes Microservice FaaS / Serverless 进程调试与监控对进程的调试和监控主要为了解决如下问题： 为什么我的 Python 进程运行结果不符合预期？ 为什么我的 Python 进程卡住了？ 为什么我的 Python 进程消耗这么多的内存？ 为什么我的 Python 进程占用这么多的 CPU？ 基本调试方法 print &amp; log pdb，breakpoint(new in python3.7) sys.excepthook and more … gc tracemalloc (new in python3.4) 优点：解释器器⾃自带，完善的⽂文档和社区⽀支持，功能更更强⼤大。缺点：需要添加、删除、重启。 # sys sys.excepthook sys.getallocatedblocks sys.setprofile sys.settrace sys.set_asyncgen_hooks sys.set_coroutine_wrapper sys._current_frames sys._getframe more ... import sys, traceback for frames in sys._current_frames().values(): traceback.print_stack(frames) def print_stack() traceback.print_stack(sys._getframe(1)) # gc gc.get_objects gc.get_referrers gc.get_referents import gc, greenlet, traceback for obj in gc.get_objects(): if instance(obj, greenlet.greenlet): traceback.print_stack(obj.gr_frame) # tracemalloc import tracemalloc tracemalloc.start() # ... run your application ... snapshot = tracemalloc.take_snapshot() top_stats = snapshot.statistics(&apos;lineno&apos;) print(&quot;[ Top 10 ]&quot;) for stat in top_stats[:10]: print(stat) import tracemalloc tracemalloc.start() # ... start your application ... snapshot1 = tracemalloc.take_snapshot() # ... call the function leaking memory ... snapshot2 = tracemalloc.take_snapshot() top_stats = snapshot2.compare_to(snapshot1, &apos;lineno&apos;) print(&quot;[ Top 10 differences ]&quot;) for stat in top_stats[:10]: print(stat) 高级调试工具 heapy objgraph pyflame py-spy pyrasite pyderd pyrings pytools dtrace、systermtap strace （Linux 命令工具） 元编程什么是元编程? 【维基百科】Metaprogramming is aprogramming technique in which computer programs have the ability to treatprograms as their data 即对程序有更高的控制权，可改变代码现有的行为。 元编程在 Python中，简单的理解就是关于创建操作源代码(比如修改、生成或包装原来的代码)的函数和类。主要技术是使用装饰器、类装饰器和元类。另外还有一些其他技术，如签名对象、使用exec() 执行代码以及对内部函数和类的反射技术等。 为什么需要元编程? 有人认为“元编程花哨，破坏抽象封装，降低可维护性和可读性”。 在 Python 中存在一些没有元编程就难以解决的问题: 1. 代码热更新 2. 对未知的数据结构做特定优化(regex, json load/dump) 3. 各种高级的抽象方式(generic, trait) 4. 更为全面的静态检查支持 为什么需要安全高效的元编程？ 元编程本身并不和“邪恶”挂钩。合理的使用它，能够极大地提高代码的可读性、可靠性、可维护性、执行效率，并增强抽象封装，还能提高开发者的编写效率： 1、支持静态检查。用代码生成扩展 python type hinting，获得强力补全和编译期错误检查，实现面向合同编程 2、支持声明式编程。开发者之处必要信息，用 DSL 对此信息进行分析，生成可读并安全可靠的静态优化程序 3、为运行时增加程序监控器，收集信息，对部分程序进行多种优化。将运行时拆分为过个时期，应用优化技术 其他GILGIL(Global Interpreter Lock)，即全局解释器锁。其是进程内的全局锁，用于保护共享变量。常见的 IO 会释放 GIL。 Python 在调用其他语言时会释放 GIL，如 ctypes 调用动态库时会释放 GIL MROMRO(Method Resolution Order)，即方法解析顺序。旧式的 MRO 已经很好解决的继承的二义性问题： &gt;&gt;&gt; class A: pass &gt;&gt;&gt; class B(A): pass &gt;&gt;&gt; class C(A): pass &gt;&gt;&gt; class D(B, C): pass &gt;&gt;&gt; import inspect &gt;&gt;&gt; inspect.getmro(D) # 输出结果经过人工美化 (D, B, A, C) 解决完了二义性问题，那么还有什么问题? 本地优先级:根据声明顺序查找类，比如 D(B, C)，那么要先找 B 然后找 C 单调性:如果类 C 的解释顺序在 A 之后，那么在所有子类中也要保证这个顺序 新式的 MRO 采用 C3 线性算法实现 。基于 C3 线性化算法的 MRO 要解决的就是本地优先级和单调性的问题。C3线性算法的其他应用：singledispatch。 总结与建议： 从 Python 2.3 以后已经完美的解决了二义性、本地优先级、单调性 你需要理解 MRO ，但是不要刻意为了炫技去使用它，除非你在写一个框架 无论在任何时候不要使用多继承，C++ 已经用历史证明，这并不好用 不浪费多继承功能，应该多使用 Mixin 去替代多继承，比如 Django 编程原则 好代码应有的特点：可读性高，逻辑清晰，高内聚，低耦合，易测试 尽量使用组合而不是继承 （如在类中直接使用其他类的实例，尽量使用 Mixin） 使用 abc 模块 每一个代码块、函数、类、模块都只做单一的事情 先把业务模块划分清楚，而不是一上来就考虑技术细节（使用什么设计模式、存储等等） Huoty 2018.10.14]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>✒博客/©转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QBinder 数据绑定框架]]></title>
    <url>%2Fposts%2F301b3c35.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这篇文章就是好好分享一下开发 QBinder Github地址 框架一路过来的心路历程，以及框架里的实现机制。&emsp;&emsp;如果要更直接了解框架的使用方法，推荐前往框架的 wiki 文档进行了解。 链接 &emsp;&emsp;我以前做过一些 Vue 和 React 的前端开发，前端领域的数据绑定框架目前是如日中天，谁用谁知道，好用得很。&emsp;&emsp;本来今年的毕设想要做一个 CG资产管理库 的。&emsp;&emsp;打算要做一个数据绑定的框架，实现类似前端开发的体验，否则界面复杂之后，组件的通信会变得很难受。&emsp;&emsp;虽然 Qt 也内置了比较古老的 MVC 框架，还是能够用一下的，但是使用场景比较限制。&emsp;&emsp;只支持几个 View 以及衍生出来的组件，对于日常的 LineEdit CheckBox 的数据绑定均是没有支持。&emsp;&emsp;我当时打算先把这个数据绑定框架做出来，再去做 CG 资产管理库。&emsp;&emsp;当时师弟他们还做一个类似库去打比赛，我也从中帮了一些忙。&emsp;&emsp;花了不少时间研究如何将 WebGL 嵌入到 Python Qt 框架里面 链接&emsp;&emsp;于是就把数据绑定框架给搁置了(加上因为自己懒(:з」∠))&emsp;&emsp;再就是自己也没有想好到底怎样的数据绑定才是好用的，还是在网上找了很多 相关的案例，以及 Python 能够实现的黑科技进行研究.&emsp;&emsp;也就是那个时候研究了 future-fstring 库的实现原理 链接&emsp;&emsp;其实还研究很了解了很多别的东西，比如 ast 、 dis 等等 Python 内置的包，它们的作用以及能够实现的黑科技。&emsp;&emsp;并且也找了很多 github 上的 PyQt 相关的数据绑定框架来参考学习。 &emsp;&emsp;当时很多研究并没有记录下来，而是仅仅存放在了我自己的框架的 research 文件夹 链接 &emsp;&emsp;我记得还考虑在 Qt Designer 里面加入自定义 property 来配置数据绑定，导致引申出了个 unicode_literal 的问题 链接&emsp;&emsp;后来有放弃了上面的方案，使用装饰器加 字典 配置的方式 具体可以参考我仓库的 QMVVM 分支，后面再详细说一下 链接 &emsp;&emsp;当时的确是实现了比较粗糙的数据绑定，但是使用上不太理想。&emsp;&emsp;而且终究折腾太久，时间不够了(:з」∠)&emsp;&emsp;差不多 5 月份了，毕设还卡在前期的框架搭建中，而且当时已经复工了(没有请假回学校)&emsp;&emsp;所以后来临时改了毕设的方案，将资产管理库改为全栈开发，顺便学一下时下很热的 Go 语言，跳过数据绑定框架的开发。&emsp;&emsp;还好我的指导老师很随意，从来没有打听过我的毕设进度，我偷梁换柱也完全没有关系，在我匆匆赶工之下，做了一个月把毕设给赶出来了 链接&emsp;&emsp;所以毕设的水平也就那样，内容量其实很单薄，还好大学的老师都不懂，随意吹嘘一下就给忽悠过去了。&emsp;&emsp;毕设论文也是按照写博客的方式写的，一点问题也没有(/ω＼) &emsp;&emsp;后来毕设过去了之后，这个数据绑定框架的制作也就搁置了，真就一鼓作气，再而衰，三而竭吧。&emsp;&emsp;其实自己也是一直记着的，但是当时工作的原因，要开始搞 Unreal 的 Python 流程，于是乎就这了。&emsp;&emsp;一直到 10 月份之后，我总算脱离了项目组，可以做一些更加框架性的东西了。&emsp;&emsp;并且和 Unreal 相关的需求也少了，每当做 Maya Qt 的界面就一直惦记着想要把这个框架重新撸起来。&emsp;&emsp;然而 10 月份的时候是计划开始开撸 Houdini 教程的，还花了很多时间整理了相关的教程。&emsp;&emsp;最后的导火索是 10 月底，我忍不住还是给 焕焕 演示了以前做的不成熟的数据绑定框架案例。&emsp;&emsp;虽然他表示了肯定，然而也没有掀起什么波澜~&emsp;&emsp;我回去反思了一下，还是觉得目前的阶段的框架太拉胯了，没法很好进行推广。&emsp;&emsp;于是我一意孤行地搁置了 Houdini 学习计划，将大部分的空余时间都投入到这个框架的重构上。&emsp;&emsp;最近还把 仓库的名字改为更贴切一点名字， 叫做 QBinder 。&emsp;&emsp;目前重构了一个月，感觉进入了可以发布推广的阶段了，毕竟闭门造车并不好，这段时间一直觉得很多东西不完善，所以一直没有和别人交流分享。&emsp;&emsp;稍微完善了点，所以写下文章记录一下。 Python Qt 相似框架的研究 &emsp;&emsp;我其实不太喜欢造轮子的，拿别人做好的轮子，再花点研究一下底层的原理就可以了。&emsp;&emsp;所以既然要做框架也不可能上来就是莽，看看别人都是怎么做的。&emsp;&emsp;然而 github 上能找到的资料并不多，只找到两个比较相近的 MFieldMixin pyqtconfig &emsp;&emsp;另外也需要感受一下前端框架的数据同步的感觉。这里拿 Vue 的官方文档进行演示 链接 ↓↓↓ dayu_widgets - MFieldMixin &emsp;&emsp;dayu_widgets 强烈推荐，我的 PyToolkit 的 qt 界面就是基于这个组件库做的。&emsp;&emsp;在它的案例里面可以找到一些使用 MFieldMixin 进行数据绑定的例子。&emsp;&emsp;比如 field_mixin_example.py &emsp;&emsp;可以看到上面输入的时候下面的邮箱也可以进行数据同步。&emsp;&emsp;不过有个小 BUG ， 输入的指针位置会因为数据更新被挪到了最后，我做框架的时候也遇到了这个问题。&emsp;&emsp;实现上很 pythonic ，但是用起来比起前端框架就繁琐很多。 dayu_widgets 需要预先在组件层提供好 qt 的 property 属性注册用到的数据名称和初始值使用 MFieldMixin 混合之后需要用 bind 方法来绑组件和 property 属性最后还要通过调用函数来修改数据 &emsp;&emsp;毕竟 Python Qt 里面少了 前端的 html 模板作为界面描述，所以数据绑定的时候就需要用户提供更多信息，来满足绑定。&emsp;&emsp;我认为这是很难平衡的痛点。 pyqtconfig &emsp;&emsp;发现 pyqtconfig 这个框架也是很偶然&emsp;&emsp;某天在国外某个大佬教学网站里面找到了他的 github，然后随手搜了一下大佬的仓库找到的。链接 &emsp;&emsp;这个框架比起 MFiledMixin 要更加完善，还实现了 QSettings json xml 不同的格式来存储。&emsp;&emsp;调用上比起你 MFiledMixin 更加简洁一点。&emsp;&emsp;因为不需要提供 信号槽， 代码上通过字典的方式将 Qt 自带组件的信号槽实现了自动绑定。&emsp;&emsp;不过编写上基本还是和 MFiledMixin 一样的。 QMVVM 数据绑定 &emsp;&emsp;结合上面两个框架，我想要数据绑定框架的使用更加简单,使用的代价降到最小。&emsp;&emsp;参考 Vue 框架的做法，会通过字典将所有相关的配置作为参数传入框架内。&emsp;&emsp;然后框架解析 dom 生成出 virtualdom 将配置关系和 templete 里面添加的属性进行匹配绑定。&emsp;&emsp;通过我也没搞清楚的 diff 算法，算出更新的 dom 对象实现高效更新。&emsp;&emsp;当然这种写法都是单独引入 vue 作为 js 脚本的用法。&emsp;&emsp;如果使用 vue 脚手架结合 node.js 就可以直接解析 vue 文件代码，让 MVVM 框架更加紧凑。 &emsp;&emsp;然而目前 Python Qt 的代码环境下，缺失了 Html 层来描述组件状态，所以绑定就很难做得精简。&emsp;&emsp;Qt 之下其实可以使用 qml 作为代替，但是传统代码无法兼容，迁移也不方便。&emsp;&emsp;我其实还想到 ui 文件，毕竟是个 xml ，可以用 python 来解析当 view 来用，实现 view model。&emsp;&emsp;但是在 UI 文件上修改还是很蛋疼，而且 ui 可以转代码，但是代码没有转 ui 的工具，还不如上面两个框架通过代码解决好。&emsp;&emsp;所以我最后的想法回归到如何精简代码绑定数据的过程。 &emsp;&emsp;参考了 Vue 的写法之后，我想通过 装饰器加上配置信息来进行绑定。 1234567891011121314151617181920212223242526272829303132333435363738import QMVVMfrom Qt import QtGui,QtCore,QtWidgetsclass WidgetTest(QtWidgets.QWidget): @QMVVM.store(&#123; "state": &#123; "message": "", # 初始化数据 &#125;, "methods": &#123; "label.setText":&#123; # 绑定 setter "args":["message"], # action 传递的参数 "action": lambda a: "message is %s" % a, # action 作为响应传递的数据 &#125;, "edit.setText":"message", # 直接绑定 等价 下面的扩充写法 ↓↓↓ # "edit.setText":&#123; # "args":["message"], # "action" : lambda a: a , # &#125;, &#125;, &#125;) def __init__(self): super(WidgetTest, self).__init__() self.initialize() def initialize(self): layout = QtWidgets.QVBoxLayout() self.setLayout(layout) self.edit = QtWidgets.QLineEdit() self.label = QtWidgets.QLabel() layout.addWidget(self.edit) layout.addWidget(self.label) if __name__ == "__main__": app = QtWidgets.QApplication([]) widget = WidgetTest() widget.show() app.exec_() state 里面初始化响应的绑定变量。methods 定义绑定的方法以及响应的参数和数据 &emsp;&emsp;python 有很灵活的反射系统，可以通过字符串结合 getattr 可以获取到相应的属性。&emsp;&emsp;但是为了更加灵活，更好区分地获取不同的变量数据，就需要加入更多标识符来区分。 123456789101112131415161718192021@QMVVM.store(&#123; "state":&#123; "count":0, "count2":6, &#125;, "methods":&#123; "label.setText":"count", "@label2.setText":&#123; "args":["$count","count"], "action":lambda a,b: "&lt;center&gt;%s %s&lt;/center&gt;"%(a,b), &#125;, "@label4.setText":&#123; "args":["$count","count2"], "action":"$calculate", &#125;, "@label5.setText":&#123; "args":["count2"], "action":lambda a :str(a), &#125;, &#125;,&#125;) 后来引入 @ 前缀来获取本地变量的 widgetmethods 的参数上用 $ 符号只带本地的变量以及类方法。 &emsp;&emsp;结果可以看到上面的配置越来越复杂，而且配置文件必须和代码对应，否则就会报错。&emsp;&emsp;报错还无法判断到底是哪一行配置出错了，为此我还专门定义了一个 SchemaError 的类来进行这种配置错误的处理。&emsp;&emsp;实现了一定程度的错误定位功能，总体而言用起来可能比之前两个框架还要繁琐。&emsp;&emsp;而且方法绑定无法做到 js 一般直接上匿名函数，所以还要用字符串来指向类方法。&emsp;&emsp;比较复杂的配置还需要通过正则来匹配配置的字符串数据，我写起来也很难受。&emsp;&emsp;虽然绑定关系可能因为全部放到一起会更加清晰，但是规则复杂，配置起来也不友好。 123456789101112131415161718192021222324252627@QBinding.store(&#123; "state": &#123; "selected": "", "option_A": "A", "option_B": "B", "option_C": "C", &#125;, "computed":&#123; "item_list": [ "$&#123;selected&#125;", "$&#123;option_A&#125;", "$&#123;option_B&#125;", "$&#123;option_C&#125;" ], "*item_model": [ ["$&#123;option_A&#125;","$&#123;option_B&#125;"], "$&#123;option_B&#125;", "$&#123;option_C&#125;", ["12"], ["asd","1234"] ], &#125;, "signals":&#123; "line.textChanged":"option_B", # "combo.currentTextChanged":"selected", &#125;&#125;) 最后为了兼容 Qt 内置的 model 还做了更进一步的规则扩展coumpted 参数可以通过 $符号获取上面定义 state 构建新的数据* 前缀生成 modelsingals 进行数据更新的绑定绑定 &emsp;&emsp;做好了 model 这个 demo 之后，开发进度就停滞了。&emsp;&emsp;当时我觉得这个配置过于复杂了，研究 future-fstrings 之后一直想通过里面的黑科技实现代码转换。&emsp;&emsp;利用 python coding 的机制将 python 源码当做一个 html 进行绑定数据的提取，自动修改源码实现自动绑定。&emsp;&emsp;不过这个想法太复杂了，一点也不好实现。 &emsp;&emsp;后来有和 dayu_widgets 的作者 鬼猫猫 聊过一下数据绑定相关的话题。&emsp;&emsp;她想要实现绑定之后还能保留代码的提示功能，确保代码文件的 pylint 不会报错。&emsp;&emsp;我觉得这个要求很合理，但是不好去实现。&emsp;&emsp;不过至少她给我指了个方向，无论用上多少黑科技，至少得兼容 pylint 才是好的写法。&emsp;&emsp;为了实现这个有点奢侈的想法，我又研究了一段时间。 &emsp;&emsp;当时我的配置需要加上 methods 来配置 setter 数据响应的行为。&emsp;&emsp;后来我想到其实可以直接将我的 lambda 方法加到 setter 上。 1self.label.setText(lambda:"CheckedNames: %s" % self.state.checkedNames) &emsp;&emsp;这样绑定 method 更加直观，我只要通过装饰器扩展一下 setText 方法让它接受 lambda 参数即可。&emsp;&emsp;加入 lambda 之后由于数据不是立刻算好传递的，所以每次 lambda 触发的时候都会用 self.state.checkedNames 最新的数值组合成字符串。&emsp;&emsp;也达到了我想要的数据更新的效果。&emsp;&emsp;这个想法对我后来重写出 QBinder 有很大启发~ QBinder &emsp;&emsp;时隔 5 个月之后，我决定重写之前 QMVVM 框架。&emsp;&emsp;而且框架命名也名不副实， 因为我根本就没有 Vue 这种的 ViewModel 对象。&emsp;&emsp;回想起之前定下的大方向目标，要 pylint 支持不会报错，并且最好还能自动提示出绑定的变量。&emsp;&emsp;那我这套字符串配置是不可能实现的了。 &emsp;&emsp;既然要重构，就要玩大的，这次我将之前的装饰器加配置的方案彻底给改了。&emsp;&emsp;后来我觉得在 Qt 的 setter 上通过装饰器支持 lambda 绑定参数还挺好的写法，虽然看着很 evil&emsp;&emsp;但是耐不住用起来很方便。 &emsp;&emsp;后来因为一些契机研究了 pymel 初始化过程 链接 ，在这里我发现 python 的 __clousure__ 黑科技。&emsp;&emsp;于是我觉得 lambda 的玩法还能进一步扩展，实现更好的支持， QBinder 特性 使用简单，修改代价小 自动记录数据 进行持久化存储 lambda 特性简化绑定 数据绑定可以实现动态 stylesheet QEventHook qapp 全局事件钩子 数据绑定案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from QBinder import Binderfrom Qt import QtWidgetsfrom Qt import QtCorefrom Qt import QtGuiclass WidgetTest(QtWidgets.QWidget): # NOTE 注册 绑定变量 binding state = Binder() state.text = "empty" state.num = 1 state.val = 2.0 def __init__(self): super(WidgetTest, self).__init__() layout = QtWidgets.QVBoxLayout() self.setLayout(layout) self.edit = QtWidgets.QLineEdit() self.label = QtWidgets.QLabel() self.button = QtWidgets.QPushButton("change Text") layout.addWidget(self.edit) layout.addWidget(self.label) layout.addWidget(self.button) self.button.clicked.connect(self.change_text) # NOTE 数据绑定 self.edit.setText(lambda: self.state.text) self.label.setText(lambda: "message is %s" % self.state.text) self.spin = QtWidgets.QSpinBox(self) self.label = QtWidgets.QLabel() layout.addWidget(self.spin) layout.addWidget(self.label) # NOTE 数据绑定 self.spin.setValue(lambda: self.state.num) self.label.setText(lambda: "num is %s" % self.state.num) self.spin = QtWidgets.QDoubleSpinBox(self) self.label = QtWidgets.QLabel() layout.addWidget(self.spin) layout.addWidget(self.label) # NOTE 数据绑定 self.spin.setValue(lambda: self.state.val) self.label.setText(lambda: "val is %s" % self.state.val) def change_text(self): self.state.text = "asd"if __name__ == "__main__": app = QtWidgets.QApplication([]) widget = WidgetTest() widget.show() app.exec_() &emsp;&emsp;QBinder 实现了 Python 最小改动来实现数据绑定的效果。&emsp;&emsp;仅仅使用非常 tricky 的方式让 组件的 setter 可以支持 lambda 函数&emsp;&emsp;lambda 函数注入 Binder 注册的变量，就可以实现的数据绑定。&emsp;&emsp;当 binder 的变量改变的时候会自动触发 setter 进行更新~ 结合 QEventHook 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from QBinder import Binder,QEventHookfrom QBinder.handler import Setfrom Qt import QtWidgetsfrom Qt import QtCorefrom Qt import QtGuievent_hook = QEventHook()class WidgetTest(QtWidgets.QWidget): state = Binder() state.text = "aasdsd" state.num = 1 state.val = 2.0 state.color = "black" state.spin_color = "black" def __init__(self): super(WidgetTest, self).__init__() self.initialize() def initialize(self): layout = QtWidgets.QVBoxLayout() self.setLayout(layout) self.edit = QtWidgets.QLineEdit() self.label = QtWidgets.QLabel() self.button = QtWidgets.QPushButton("change Text") layout.addWidget(self.edit) layout.addWidget(self.label) layout.addWidget(self.button) self.button.clicked.connect(lambda:self.state.text &gt;&gt; Set("asd")) self.edit.setText(lambda: self.state.text) self.label.setText(lambda: "message is %s" % self.state.text) event_hook.add_hook(self.edit,QtCore.QEvent.FocusIn,lambda:self.state.color &gt;&gt; Set("red")) event_hook.add_hook(self.edit,QtCore.QEvent.FocusOut,lambda:self.state.color &gt;&gt; Set("black")) self.label.setStyleSheet(lambda:"color:%s" % self.state.color) self.spin = QtWidgets.QSpinBox(self) self.label = QtWidgets.QLabel() layout.addWidget(self.spin) layout.addWidget(self.label) self.spin.setValue(lambda: self.state.num) self.label.setText(lambda: "num is %s" % self.state.num) self.spin &gt;&gt; event_hook("HoverEnter",lambda:self.state.spin_color &gt;&gt; Set("pink")) self.spin &gt;&gt; event_hook("HoverLeave",lambda:self.state.spin_color &gt;&gt; Set("blue")) self.label.setStyleSheet(lambda:"color:%s" % self.state.spin_color) self.spin = QtWidgets.QDoubleSpinBox(self) self.label = QtWidgets.QLabel() layout.addWidget(self.spin) layout.addWidget(self.label) self.spin.setValue(lambda: self.state.val) self.label.setText(lambda: "val is %s" % self.state.val) &emsp;&emsp;上面的案例结合 handler 和 QEventHook 可以实现更加灵活方便的组件写法。&emsp;&emsp;handler 的使用场景是通过 &gt;&gt; 运算符重载对 binding 进行操作。&emsp;&emsp;上面使用 Set 方法类就是用来解决 lambda 无法赋值的兼容方案。&emsp;&emsp;简单的数据操作就不需要声明冗余的函数 &emsp;&emsp;QEventHook 会劫持 Qt 全局的事件响应，这样不需要继承组件来实现。&emsp;&emsp;可以通过我的 劫持 钩子来直接扩展组件的行为响应。&emsp;&emsp;QEventHook 使用单例模式，无论在哪里实例化都只获取同一个实例。(避免多重劫持导致性能下降) &emsp;&emsp;QEventHook 支持两种写法 add_hook 或者 &gt;&gt; 运算符 。&emsp;&emsp;&gt;&gt; 运算符重载的写法更加简洁，只是如果前面的组件有重载 __rshift__ 运算符会导致出错。&emsp;&emsp;事件绑定上支持 QEvent 和 字符串 两种写法。 复杂使用场景 &emsp;&emsp;后面我模仿 Vue 做的 todo 案例写了一个 QBinder 实现的版本。 &emsp;&emsp;除了部分样式效果没有同步， Todo 相关的所有功能已经全部用 QBinder 绑定实现了~&emsp;&emsp;另外之前 QMVVM 架构留下的一些历史功能还是支持的。&emsp;&emsp;比如直接绑定一个 Model 变量，实现多个 View 同步数据。 QBinder 实现原理 &emsp;&emsp;上面看到的效果是第一个成熟版本实现的绑定效果。&emsp;&emsp;中间的实现并不是一帆风顺的，磕磕绊绊地走过来，也踩了不少的坑。 自动绑定 &emsp;&emsp;最初的想法我是参考了 pyqtconfig 的实现方式。&emsp;&emsp;通过字典来描述 Qt 组件的行为，然后解析字典来实现绑定。 12345678910111213141516171819202122232425262728293031import QtHOOKS = &#123;&#125;HOOKS.update(&#123; "QtWidgets.QWidget": &#123; "setStyleSheet": &#123; "type": str, &#125;, "setVisible": &#123; "type": bool, &#125;, &#125;, "QtWidgets.QLabel": &#123; "setText": &#123;"type": str, "getter": "text"&#125;, &#125;, "QtWidgets.QCheckBox": &#123; "setChecked": &#123; "type": bool, "getter": "isChecked", "updater": "stateChanged", &#125;, "setText": &#123;"type": str, "getter": "text"&#125;, &#125;,&#125;)def hook_initialize(hooks): for widget, setters in hooks.items(): lib, widget = widget.split(".") widget = getattr(getattr(Qt, lib), widget) for setter, options in setters.items(): wrapper = binding_handler(getattr(widget, setter), options) setattr(widget, setter, wrapper)hook_initialize(HOOKS) &emsp;&emsp;大致的操作如上面所示&emsp;&emsp;默认只需要添加上 setter 即可绑定，倘若要双向数据绑定的话则需要添加上 updater&emsp;&emsp;但是这样需要手动配置 Qt 所有的方法，感觉不太现实。&emsp;&emsp;后来研究了一下 Qt 内置的机制，发现 Qt 有 meta 反射机制用来给 C++ 获取自身属性的。 链接&emsp;&emsp;虽然日常 Python 就带有反射特性，平时根本用不上，&emsp;&emsp;但是通过 Qt 的 meta 特性可以判断函数是否为 signal 对象，这给我双向绑定提供了自动化操作的可能。&emsp;&emsp;并且如果要兼容 Qt 的老版本，通过 meta 特性获取的函数比起手动配置考虑兼容要更好。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from collections import defaultdict# NOTE https://stackoverflow.com/a/8702435nestdict = lambda: defaultdict(nestdict)HOOKS = nestdict()_HOOKS_REL = nestdict()qt_dict = &#123;"QtWidgets.%s" % n: m for n, m in inspect.getmembers(QtWidgets)&#125;qt_dict.update(&#123;"QtCore.%s" % n: m for n, m in inspect.getmembers(QtCore)&#125;)qt_dict.update(&#123;"QtGui.%s" % n: m for n, m in inspect.getmembers(QtGui)&#125;)def byte2str(text): # NOTE compat python 2 and 3 return str(text, encoding="utf-8") if sys.hexversion &gt;= 0x3000000 else str(text)def get_method_name(method): # NOTE compat Qt 4 and 5 version = QtCore.qVersion() name = "" count = False if version.startswith("5"): name = method.name() count = method.parameterCount() elif version.startswith("4"): name = method.signature() name = name.split("(")[0] count = method.parameterNames() return byte2str(name), countfor name, member in qt_dict.items(): if not hasattr(member, "staticMetaObject"): continue meta_obj = getattr(member, "staticMetaObject") # NOTE 目前最新版本使用了 json 配置进行 hook for i in range(meta_obj.methodCount()): method = meta_obj.method(i) method_name, count = get_method_name(method) if count and method.methodType() != QtCore.QMetaMethod.Signal: if hasattr(member, method_name): HOOKS[name][method_name] = &#123;&#125; _HOOKS_REL[name][method_name.lower()] = method_name for i in range(meta_obj.propertyCount()): property = meta_obj.property(i) if not property.hasNotifySignal(): continue property_name = property.name() method_name = _HOOKS_REL[name].get("set%s" % property_name.lower()) data = HOOKS[name].get(method_name) if isinstance(data, dict): updater, _ = get_method_name(property.notifySignal()) if updater: data.update(&#123;"updater": updater, "property": property_name&#125;) &emsp;&emsp;上面的代码可以获取到对应的 updater 和 property ，结构可以参考这个 链接&emsp;&emsp;python3 之后 inspect 可以获取到函数的 signature 参数，但是要兼容 python2 的话只能使用这个。 &emsp;&emsp;写文章的时候，我测试了代码，感觉到不对劲。&emsp;&emsp;Qt 的 Meta 机制并没有记录所有的函数，只是记录特别少的部分，所以无法 hook 到所有的方法上。&emsp;&emsp;我当时测试了 QLineEdit 的 setSelection 函数，就是没有 hook 到的。&emsp;&emsp;所以只能修改方案。 &emsp;&emsp;然而 Qt 不能无脑 hook 所有的函数，因为 Qt 有些函数是 static 类型的。&emsp;&emsp;我 hook 了之后，测试一下案例就会出现 QApplication.postEvent 的错误。&emsp;&emsp;而这个错误是因为静态方法变成了 unbouded method 导致的。 &emsp;&emsp;于是为了解决这个问题走了很大的弯路。&emsp;&emsp;首先我拿 QApplication 的 setStyleSheet 和 postEvent 进行方法类型对比。&emsp;&emsp;发现在不同的环境下的获取的类型不一样 setStyleSheet PySide &lt;type &apos;method_descriptor&apos;&gt; PyQt4 &lt;type &apos;builtin_function_or_method&apos;&gt; PySide2 &lt;class &apos;method_descriptor&apos;&gt; PyQt5 &lt;class &apos;builtin_function_or_method&apos;&gt; postEvent PySide &lt;type &apos;builtin_function_or_method&apos;&gt; PyQt4 &lt;type &apos;builtin_function_or_method&apos;&gt; PySide2 &lt;class &apos;builtin_function_or_method&apos;&gt; PyQt5 &lt;class &apos;builtin_function_or_method&apos;&gt; &emsp;&emsp;所以在 PySide 下可以利用这个类型的不同过滤出可以 hook 的函数。&emsp;&emsp;但是在 PyQt 下的环境不可以区隔，如果用常规的装饰器写法会出错。&emsp;&emsp;最难受的是 hook 的时候不会出错，出错在后面执行方法的时候，所以无法用异常处理来调整 hook 的过程。&emsp;&emsp;我考虑到是 unbounded method 的问题其实可以让装饰器的 wrapper 函数提升为 类方法 去解决。&emsp;&emsp;然后就用了很特殊的方法来写装饰器。 1234567891011class deco(object): def __init__(self,func): self.func = func def wrapper(self,*args,**kwargs): return self.func(*args,**kwargs)def func(): passfunc = deco(func).wrapper &emsp;&emsp;好好的装饰器被我魔改成类方法，就可以解决 unbondedmethod 的问题。&emsp;&emsp;因为类已经实例化了， wrapper 返回的不是 unboundedmethod&emsp;&emsp;这可以解决 postEvent 的问题。&emsp;&emsp;但是在一些普通的 Qt 组件方法 比如 addWidget setLayout 就会出错&emsp;&emsp;因为传入 func 变成 Qt 没有实例化的方法了。&emsp;&emsp;所以这些方法需要用过去的装饰器来包裹才可以。 &emsp;&emsp;于是折腾了好久又回到 static 函数区分的问题上。&emsp;&emsp;最后来回折腾，决定还是使用白名单过滤来解决问题，直接简单。&emsp;&emsp;反正我在 PySide 环境下已经获取出可以 hook 的名单，借助 Qt.py 的兼容，就可以直接过滤出 PyQt 的白名单。&emsp;&emsp;然后读取 json 名单进行过滤即可。 &emsp;&emsp;所以绕了一圈其实和最初的做法差不多，只是借助 Meta 机制自动绑定了 Signal 实现双向数据绑定。 Binder 数据绑定容器 &emsp;&emsp;过去 QMVVM 框架下，容器被我固定命名为了 self.state 获取。&emsp;&emsp;一方面 pylint 找不到 self.state 的定义，另外 self.state 变量如果已经有别的用途，会造成冲突。&emsp;&emsp;所以这次重构的容器 Binder 作为一个可以任意命名的实例化对象。 12345678910111213141516# NOTE 需要 QApplication 启动的环境下运行from __future__ import print_functionfrom QBinder import Binderstate = Binder()state.num = 1print(type(state.num))# &lt;type 'int'&gt;print(type(state["num"]))# &lt;class 'QBinder.binding.Binding'&gt;# NOTE 注册事件state["num"].connect(lambda:print('num change'))state.num = 2# num change &emsp;&emsp;Binder 重载 __setattr__ 这样给类对象添加 member 的时候可以自动将 member 转换为 binding 对象。&emsp;&emsp;确保外部的写法保持简洁。 &emsp;&emsp;利用 binding 对象的 __get__ 方法确保每次从 binder 获取的值都是值的本身，而不是 binding 对象。&emsp;&emsp;但是一些特殊的情况，比如 binding 注册自定义更新事件的方法还是需要获取 binding 对象来执行。&emsp;&emsp;于是我重载了 __getitem__ 和 __setitem__ 来用字典取值的方式获取变量的 binding 对象。 12345from QBinder import Binderstate = Binder()dispatcher = state('dispatcher')dumper = state('dumper') &emsp;&emsp;为了避免 Binder 绑定 binding 对象的时候和自身命名的方法产生冲突&emsp;&emsp;Binder 类重载 __call__ 方法，然后通过 命令 模式。&emsp;&emsp;将对应方法 通过 BinderDispatcher 类进行分发调用。 &emsp;&emsp;输入对应字符串会调用 BinderDispatcher 对象下的方法&emsp;&emsp;输入 ‘dispatcher’ 是返回自己，获取到 BinderDispatcher 对象。&emsp;&emsp;输入 ‘dumper’ 则是获取 BinderDumper 类来进行特殊存储标记。&emsp;&emsp;具体的调用规则可以参考文档，如果输入非法调用名称会直接报错。&emsp;&emsp;往后也可以考虑可以扩展用户自定义的方法~ Binding 绑定对象 &amp; lambda 绑定 &emsp;&emsp;最初我先想法是通过 lambda 函数的 __closure__ 获取闭包的数据。&emsp;&emsp;然而这个方法只能获取到传递到 lambda 的变量字符串。&emsp;&emsp;也无法判断这些变量是否对应到实现定义的 binder 里面。&emsp;&emsp;并不是那么好从这个方向获取 lambda 里面绑定的变量。 &emsp;&emsp;后来我测试 Python 类的 __get__ 变量描述符可以在 lambda 里面触发。&emsp;&emsp;那么当 __get__ 触发的时候我可以将触发的 binding 存储到一个数组里面。 &emsp;&emsp;我用 contextmanager 通过 with 语句来简化代码 &emsp;&emsp;触发 lambda 的时候包裹一下 with 追踪一下 binding 变量就可以知道 binding 和 setter 关联的数组。&emsp;&emsp;借助这个方法就可以给 binding 绑定 setter 函数&emsp;&emsp;binding 则模仿 Qt 信号槽接口写了个很简易的函数注册执行功能 &emsp;&emsp;connect 注册 setter 更新函数。&emsp;&emsp;emit 则遍历执行所有的 更新函数。&emsp;&emsp;当 binding 的数值发生修改的时候会触发 BinderBase 的 __setattr__ 方法&emsp;&emsp;__setattr__ 再触发 binding 的 set 方法来 emit 实现数据同步更新。 &emsp;&emsp;Binding 对象本身是继承 QStandardItem 的，重载了部分相关方法，用来兼容 Qt 的 MVC 框架。&emsp;&emsp;Binding 在设置对象的时候会根据对象类型自动重载相关的运算符。 &emsp;&emsp;Binding 因为继承 QStandardItem 并不是继承 QObject 的。&emsp;&emsp;因此无法使用 Qt 自带的 signal ， 我这里用 Python 的方式简单实现了 signal 的 API。&emsp;&emsp;不过并没有考虑到多线程交互的情况，可能还是有必要改为 signal 来触发函数比较好。 FnBinding 函数绑定1234567891011121314151617181920212223242526272829from QBinder import Binderstate = Binder()state.callback = FnBinding()@state.callbackdef _(): print('call')state.callback()# callstate.cls_method = FnBinding()class Test(object): @state.cls_method def callback(self): print('class callback',self)instance = Test()# NOTE 因为绑定的是 类方法 需要注入 instance state.cls_method(instance)# ('class callback', &lt;__main__.Test object at 0x00000259E1E93FD0&gt;)# NOTE 如此注入 instance 方便 signal 链接state.cls_method[instance]# NOTE 最初的函数绑定方法 | 不需要拆开成两行 但是 pylint 无法识别定义@state('fn_bind')def test(): pass &emsp;&emsp;FnBinding 可以绑定组件的方法，方便其他组件进行调用。&emsp;&emsp;目前类方法绑定的方式还是有点不友好，需要将实例传进函数里面，有待优化。 &emsp;&emsp;另外之前的绑定方式是使用 dispatcher 驱动的 fn_bind 函数。&emsp;&emsp;后来还是因为确保能够代码更加优雅，还是不推荐使用了。 &emsp;&emsp;函数绑定的实现原理比较取巧。&emsp;&emsp;配合 __call__ 方法实现装饰器调用和函数触发调用。&emsp;&emsp;之前还写过一个 FnHook 的版本 和 FnBinding 类是分开的，后来觉得其实是可以合并到一起的。&emsp;&emsp;只是会把 FnBinding 给写得稍微复杂了点。 &emsp;&emsp;为了向前支持 fn_bind 的写法，所以 __init__ 保留了绑定的判断&emsp;&emsp;如果不是老方案进行函数绑定。&emsp;&emsp;那么装饰器触发的 __call__ 会进入 self.binded 的判断里面进行函数绑定。&emsp;&emsp;最后会将当前的类信息和方法名 存储到字典里面。&emsp;&emsp;后面会在 binder 对象里面找有没有添加到 binder 的类实例，实现实例的自动注入。&emsp;&emsp;但是如果 binder 存在多个实例，那么默认只会拿第一个找到的实例，不是很好的方案，有待改进。 &emsp;&emsp;connect_binder 函数会在 state.callback = FnBinding() 赋值语句中通过 __setattr__ 触发。&emsp;&emsp;将后面绑定函数需要的信息补充完整。 &emsp;&emsp;__getitem__ 的操作方便注入 instance 给 signal 进行连接。 QEventHook 全局事件钩子 &emsp;&emsp;这个实现活用了 Qt 的 eventFilter 机制 链接 &emsp;&emsp;给 QApplicaiton 的 instance 执行 installEventFilter 就可以 hook 到当前应用下所有的 Qt 事件。&emsp;&emsp;这个就非常灵活， DCC 端也是完全支持的。&emsp;&emsp;根据这个方法就可以捕获到特定组件的特定事件。&emsp;&emsp;后来开发这个框架的过程中，突发奇想，如果我可以提供这些 event 事件接口的话。&emsp;&emsp;我就不需要写一个新类去重载 虚函数事件了。(虚函数事件指的是 mousePressEvent 等的函数)&emsp;&emsp;有时候就是想要在默认的组件上扩展一些小功能。&emsp;&emsp;那么全局事件过滤来实现就会方便很多。 &emsp;&emsp;QEventHook 的用法已经在上面领略过了。 &emsp;&emsp;代码上使用 单例模式， 类在任何地方实例化都不会重复 添加事件过滤&emsp;&emsp;重载了 类 的运算符，使得扩展组件的写法更加好看。&emsp;&emsp;不过如果组件也重载了相关的运算符会出错的，所以这里保留了 函数 添加方案。&emsp;&emsp;事件定义支持 QEvent 对象以及 字符串。 数据自动存储加载1234567state = Binder()dumper = state('dumper')with state('dumper'): state.num = 1 state.text = "text" &emsp;&emsp;上面有演示过 state 通过命令调用 dispatcher 的方法&emsp;&emsp;state(‘dumper’) 会直接返回 dumper 对象。&emsp;&emsp;默认配置下 dumper 会在事件循环里面自动对双向绑cc定的 binding 进行读取和输出。&emsp;&emsp;如果要对特殊的 binding 属性进行绑定，可以用 给 dumper 对象使用 with 语句。&emsp;&emsp;with 语句下添加的 binding 会自动记录进行存储。 &emsp;&emsp;实现原理其实类似于 lambda 绑定一样。&emsp;&emsp;会在 binder __setattr__ 下查是否开启 trace ，开启就会将相关的 命名 存储到数组里面。&emsp;&emsp;再通过 __exit__ 将数组的数据提取存放到 dumper 的名单里面进行 dump &emsp;&emsp;自动存储是通过 lambda 绑定实现的。&emsp;&emsp;如果 lambda 绑定发现数据属于双向绑定状态会自动加入定时器触发 自动 读取和存储 功能&emsp;&emsp;通过 QTimer.singleShot 确保在下一个 eventloop 里面实现存储数据的添加。 &emsp;&emsp;自动存储会将文件存储到 临时目录，通过 md5 以 json 的格式进行存储。&emsp;&emsp;其实用数据库比如 Python 自带的 sqlite 也是完全可以的，后期有时间可以把这些功能都补充一下。 &emsp;&emsp;上面的自动存储 md5 对应的唯一计算方案也是我想了好久用比较取巧的方式实现的。&emsp;&emsp;首先 Binder 实例化的时候会自动将实例存储到 BinderCollector 里面。&emsp;&emsp;而这个添加的过程是和 Qt eventloop 关联起来的。&emsp;&emsp;每次 eventloop 执行的时候就会将 Binder 添加到 BinderCollector 对应的字典里面，字典的值用 uuid 实现，确保不会碰撞。&emsp;&emsp;那么每次 eventloop 跑完之后的数组序号对应的 Binder 都是可以匹配上的。&emsp;&emsp;这样可以确保在 DCC 软件里面每次启动界面 Binder 实例都是对应同样的序号。 &emsp;&emsp;最后为了区分脚本， json 文件的名称是 脚本路径+序号 再用 md5 算出来的。&emsp;&emsp;这样我在 DCC 环境下多开个工具的时候读取的数据还是固定路径的数据。 handler 扩展操作 &emsp;&emsp;handler 函数是用来简化 binding 数据操作的类。&emsp;&emsp;通过重写 __rrshift__ 函数重载了 &gt;&gt; 运算符。&emsp;&emsp;实现上其实也没有什么特殊的，运算符重载的好处就是可以兼容 lambda 里面对 binding 赋值。&emsp;&emsp;目前有考虑将 handler 做成可扩展的 API ，方便对 binding 做更复杂的操作。 &emsp;&emsp;另外 handler 是如何获取到 binding 对象的，毕竟直接 state.属性 借助 __get__ 方法获取的是实实在在的值。&emsp;&emsp;但是 handler 却可以通过这个获取到 binding 对象。&emsp;&emsp;其实还是利用 binding 的 __get__ 方法将自身存放到数组里面。 &emsp;&emsp;handler 就可以通过 类的 _inst_ 属性来获取获取到数组。&emsp;&emsp;之所以用数组而不是直接存储 self ，是应为直接获取 self 还是出发了 __get__ 导致获取的不是 binding 对象。&emsp;&emsp;用数组包裹一层才是获取到 binding 的对象。 &emsp;&emsp;handler 里面就是 binding = Binding._inst_.pop() 这样就可以为所欲为地对 binding 对象进行操作了。 总结 &emsp;&emsp;我过去重来没有做过这么复杂的框架，也就年初的时候搞了两个 Maya 工具 mpdb CommandLauncher&emsp;&emsp;要做比较庞大的框架，感觉自己的经验很有限。&emsp;&emsp;以前看过网上一些 Design Pattern 设计模式的教程，都是一通讲解猛如虎，实践才知不清楚。&emsp;&emsp;毕竟是闭门造车，只能自己摸着石头过河了。&emsp;&emsp;所以这个框架用到的设计模式我自己也说不清楚，就是怎么方便调用怎么来的。 &emsp;&emsp;这篇文章也断断续续写了 1 个多星期，因为写的时候发现 框架出现了一些问题。&emsp;&emsp;于是又去把框架优化好再继续写。 &emsp;&emsp;这个框架的目标打算是兼容 python2&amp;3 同时兼容 PySide 和 PyQt 多个版本。&emsp;&emsp;希望能借助 github 的生态让更多人参与到这个框架的开发。&emsp;&emsp;也希望这个数据绑定框架能够方便到我们这些工具人，提高界面开发的效率~ &emsp;&emsp;这个只是个人填坑的记录，写得太冗长了，而且还把以前的历史版本都翻出来鞭尸了。&emsp;&emsp;后续还要做个更精简的 wiki 文档~ ▄︻┻┳═一]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python 模型拍屏合并工具]]></title>
    <url>%2Fposts%2Fc45d9aff.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 提示(神秘号码 + 魔方) d00fd6d6dee698a4715b1ccb6da41d9e8b8c9c07bfd09d3c2e48659545ed20a69e016c70b6c9c34aafea832511838e61a9a8d22012bf691c508f8ba3df73b2bcdf1916c12891a415e3cac0182856a89760466c95294d1a7c9d4b7b8f8bb875e0b1836df1f3234983e88f1eef1c1dd49d3cd2766055aacd4dceb8f8ce2de80a9d5ef9a7ab90306aeafb05edafadf7f4fc52cd47135424e274a3d443979669540f759803fccbb094367644c5597212b47d51cefd677f9d427a44089b0877ad53d71c6920a4557e6280da5b5f016829af506b2520227576d2f344be94370f9a381c5ba2e2a16a4ddf06e47ef6353631407080e2289b34e776e80767cf8d5978473394d4452803fa9f2837b9e238101e355292e9cdfe80b54a7aa5a45a2ee510530f0f62b9e3d1637605e6672c8e1284e344cb9dfc802d220aba70024e296abeb2d84c9033b26a46191120e3f4c6bc2a1ca32781fb445975436b77cbcc34c48ea8fe90d35dc5be2a92653a5789eae68534aee237687c0abd160dbd3005e71f90b1bfaefa0314032dbf244e19838707a8bc1735e534eeec58a22612c30ed9c604d05cfe6659bedcecbf91d68fb6ae820073caae29101818467d709d70016f7045fad3159fcb674d332e904a6904f3038bdad3780ee1f5b916b6dd98b9f9d1cc5e9439a4e5d92ad200dc84b4cc00c56bb64f117de7bf3796eac43c2ca020ccdb3aaa3b413b7d70a0a1793d762157e5d3792f8804013f79874de41ea8bc289fa3020e9af4a57a3680ef7ce9904df7f6a1303d49398620492e2b440cd645f9f4d85794e7114d00da7c3a9c4187c3265fe71b4c8ad65cbe0a803c662fd7c7438f805831e8c57773b3b2399461c13344cb9be492bfd16028922320fbe43d815bc78313c6e8e63b5c9043638390b5fe659a0aca31f192aadcd9a11d9fe0e88c75383c3bca749161f97c7727c7ad796e2333743fb8335e001761f2279a41e2cdfd62a74b2cbe689b8d5a1c4f82e8753def5acd7a33baf7dbaaff2d26772716f8aaeaa30400bbf4610bbc17cf31bbc59b05436b66c2363ee9b014e7cf67379e575a011343705c1b16dbe0194fda88fc8d1306b1451705cd60781e22ec4f4099eb5681698e2ce08308ad76e88ec0ef63b795f5859c597af73c16a0a93845e76acf6aa5f99efb10ca395e29cae4c642a5068a9b802dd5ae26c2979e2df4edb43260b52716fe1603d639fa340f8ac51c5426ac55e2ec4030a6e0d4ad8cc68ee963a95f005210e026bbebd60edda6227d625d30c97f14fb8c2a9aff07e39730990d9d11b3f01c9bb40809342c6a6d0f46edc35e9feafcfc1705aff852784f34a5f883c3c204356a578017af8843a99b3d0093ad3de43f96712440c7df7c518c0f69faebbe158f40d486c001837941724e7021e86fedb8b3f3377cdeb30c886c6e590b55a18edf5b7be3e5c24f97686e18cb96ce7de819125b3f54f07f9ce5602f16380086afcc2835a0bc68b88f846f1fe5b4d15f6fe11dd614c4ceae43a63ab2b3628ec7d30f6c70960860ce6b989f65d2021409a92804ce2fdb4a6b29a50d78bcdb6b4a9a4ab214addf172f1ae94a0d2b211720dd18d1b9ffac86a1e28de58002043bf3313dc44afa40303737be1e98967ab2f08b276a55bbd8208f2d7c8ff72fe73ec45b4b6613cdaac9cdb1d6fe6f88920d1ca8c104968901d6d46926b91034c63b00fc8e085b3082d05ee803c786812851e188d4e1a2f47f91e80d44bac6091659a8e7d8080e322188a33c9882295b2af8d42124d2fc4cedb2c10b41b3013cb9e6e3828fdc560fc7cda69834c27edc3ee0428db25a397fe0c38b65724f6eb1b87c1d6bae087fc7944b5e16898f0755355704b9747961b219ec104dc36cfdb6a7de1e0759c1ead6a66aeca52482510716b9f1837e898c7cb8d5867bce19c1761139701c1aaeb8d7611d1b6b3ea3d875bccffa4144fcac752ee58b84bde552f987e1a89512cc9af5fe2f4419ed29b2fc1abca668a730f2f4f8c8106a0dca875ac752a90f7829e41001c7f68c83d1cc128580aafa0450debbdb023ee51048361da38e6a399bbfb3ce40746aeda199ea75051dd4d66bdabd365274d226ed403533384d6ba6667892cf6ee8fe830745d6e4603b6041f81fcdcd88ec46c4b58c3b8842cda83f2da23862106dbdc180890815279f6fc95e62147ae4ca47ee25d44d4586dddd9f94acef79b15f8c525f298137d7536c21d070902bdcb9a7b9be6ff86f20d15751b26e91d18f3dafba6908cdd1b1ac7200f6253e05b979c6274b89a4be97f98174e4d3e9601f1ad71204ab9da735dbf1a9818e5cbc0ed13a23097b9c4c78ba619085a65870340940958b2050b5bab59337e2eb4bcaf6052e1af95faad8c19b82b46cd6e76b7d7c3efc347a8e505345bc7fc0fefb7587a3d94a87709d587eab27df577bd0d10ca51d227afffc06311e6db5cf465474ddaeccc6aadbda2384d7debe3fd7f7ce85bae13a2c96279d977565364d8a3c7399622997e79759b69bcf5d14b80d47a0347d1c7a2125b905d032ab0ed6c01177940b063f6047950d5fb70e36d07e4c9afb48c9c9173dcd4146adf44fece544c611ce4dba610431e4fab7dec510a20795973913370967560d346c444351e81b2d0f9506e7e90ea17b83665dfb31673e23eff4d529c79e4295e68001bb90cdce29c23d3ea00d97ea11c0bdd917afb51a628db775ede9fa75bc2f5ea11513301c6b7d6695d6b357d82fb6b8e63a84ce53179a3a55f3c9635c1b8823e37b29623a444c77ecfaf494991b5a5636c8089e8a96a4a28fc4065713f4f3e798f05171b7d12c453745010cdaa63772b5d50567973ca4f0d3be6fd4ef3787224565ab6f522b9122864fa1325f84ef393361d2b9c41bce563704ea865acb1ec1809f3cf1f032659fde3fede710a279dacd31de84105998fd49a18429ad200791156b1b80ad7c5975608c67064848e6d1508160ff87071bb94903ae99f87ec0c4cec740f20e59243eca6b50a6c04c7d4bb9698444f5f4445e5c3d98c11e59a6dd25d000bb4eca23099dbd5242b46914707f696408f938c8983fedb5446e93c8f17e5861ef52a826793ae2f4fac6eae4fbd341ead2b6b5ef4f1f332b43864b1e8de0ddb240d0bb4576c1c440d527b96e13196dff702a26757ffaa56ad4b767f7d20d52b31b30ac089138f10f62de23f6303c5e77d006e0b9a1db2149b5c2a103e487a98b2d75e298203d9d85fd8d5f9209c2ca6dd505378f80293dd7bfe9c021b174ddb95927e10237dbd2f69b30ec81cc121f0d3a6facbedbd8d0caf5f12f0b3fcc01badd953490b901a3f3c5397c58b4ecb7a93f4afcb88f952fcd885c11e431e0e31315ce7d0e43bf5666291b9dd63617c464720dd0e916b312dfd891a63dff50e823076e2e6048b30389b05df7bbda17d3c913e68e73c50bf542428ecf98423243d1c2ffe5438621c7919db6724e9db70def8ff6d3afb9367c054db4ef143982e2bcd85efc48cc0d2acba737c26e996112e2c86988c3cd2098faf72623af0680478569dc3c99537ca13ca9912f4c6068a3945b098a340590b4e07ffdde51409fb3e47b98d8269dc6e10a92cc3da9904d2d0b8fcf8b26c7e2ddbe48f64b1061e591ea55acaecbf14e1abd154d687f684bfda7114450f697db3bb1e1c0ed781258e601411717816793f3fa23bae7072a97faf7b563d7ea4edb678a6823677f38b84c135d0227f651b7b5bc6e2043b4ae596e60fe641f2048e87e24e8ac0109cc90bed57cbd00b37ff75eaa654ac6fa94744edc08e74f2ccbb65c451065233e91011cc91959dc1f59e99adee0a7d0326530f83970ad358d70a36a5cb999677655e846df85a8c6236a6024039106e271e137cbc62fba0ff6bfca09fa97aa3a7df055039e9a78f3d355c466124a2d9a1264cf3bcb963b63175138b5a352d5144a0f57ce5e10a7685327e2c3aa12b58f2ae664cb6f5737a4d6f5a617caabc50cacf46c0cec3000b29e7c47b1eb0a9c5c6ba058ace51919e35d17bfc5409928d54ee9e53ea2659c3dde6d64f05773f8b70eec2af85ecf0760b42cf7c1b1466f3b81b521e9cc017b481df97d4cff9d38701c244f68d96c3b2178a45bc0564324cb1f100e757f55dbf7039952c29074be35c97a8f5ba00543ef2c626a9e5be6837eeb6ee6930bb5dfb1b05d5600921264f5407b65dc1c97feb0834f74ad0a51a0a10fa30c74ab17b8aff26a2e2ffa77974fc4fac1035d7a8c3e81941fa3a6bda19877714e48b0513a7f781135fc54d8d79ca92f679f66b309e0e2b0b9293537f86e66e83ca4be3d6a61ad5cb7b36baa94b10bc0f0d257cfb828dee5f3e5289535341ca74c107d3b6baeb13fe06486d5428149ffd079983862b0279da49188fd69bb12d4f0bc8106d9123e361ff4f83ed484e2abcb23e13a1f444b48b4fdb41f1a6e2459d9321cb4ba94def22c5b1d8496aba408e87c98c7d39d035dba01e8b65ed6f7e3f8fe32962163a133e1b560fcaf9c2b484215f1c5221c39f284a7a4f9ed02dd13a1fa1be1d6b170b5f99b343a14259dff1195b3e5583ba51fc63244312f542ed92d32d115a4d26a8038bcb90911512e5545252172d1eedf39aa2fd711d394dc405b5201365616f7a8433d25c3e656ca434efbd5edbd0a2d4e70c549dc289168cc33221a8546c85f64fa4e03505ff394befead0548ca868b978d8fa33f678d72de902424e1536d0ef837e85303201d49d13eba60caaa5e910e601213620fa0a8227e50ddeed3e7dea8894b3133e195de6d13ce4fcdeab408c1f3783daa7eb39d6136c81fd9cae427a1a167eb465f67e11a7559cb012a6476ad7206d00a52570b242deea40b7328223b2d8e646f5a02745d2dcccece06cb68d6463bd6911f4285081ea84efb05ab26dd4de2affe25e97abbcd1333f08d3337b8d7d89d4cb543ec93afdca8d7fa6cb4fa47481bd41cc01910ee4b2eeb15aa2cd5bd9c3409356d5869ea43bb4371a7b29349adf13477ca59f1368e6f3152a714859b5aea1e2b3d91782864bd244e1ed50617dd17ad101e29ef65ef816994e584dc2b760dc5b8d6d43b329ff28509130e75612deab0ff7c76ad779a8134b0c12dd720a121c6d33baae4a65c3aab55cc9395f0d901694a71170e110d416360c1c620fbf9e0912706e7e48123bf08efd088a5230595306f042501a99c18c62b5323f96b4664a565d788c00b93c2fcb65d222cb6664f55be26773837aa9cf2c6d190aadf36279313664996d330305bb2884df3159934bb3274b9a6c938e8d21217e2e881d6b50ec7688488f6c1277542b6d907f2e97ed38c0527da9aeae1073e0fa2638e65caf42fd1a931999fda2586234b1b866de638e7734d427ef6362d68681013b47791fb97e74ab76914880f502590741238953d9f627036908a7bf6319c7d1918018bd4e930b1747b56450b65d8b5080632f9d5dd64e82ffd36a81b9c79a6897c7179a0c999803ad7aecedb57df2e937fd95541f666852864ca4c8df21bb107b1cb6380ed79f93c83561106a61bb066ec918a34574a436ea94d591339f263858955dae0acac21ad1c49b97c1c9b6f33d500da89f6e178dd3918187fecf05c0e0fd13c991bafd779c96096057e5ed5db8f31121cffa6fd5a3ad46e47ed44fee0726a4504f73f65019e1696b741fd72042cb30e7ec62aac1e0266dc4bf2d32bc9b8bfa0b9b68c191e2001be1f7b818cbf465d8822044fe82ac0d5776a46b9f880c806055069b785af30f0c86c21428cdbcf262f98d06c7553159881a8a1995868981ff3564d7256faf1fabceab71f57594fc614cd1f1e7a767ed452368fae0ed3b15ca3c6febc40638583d039c02ec5ed64803a0dca0bc0a3b8f8def92b84d5e2ca20f093d6f63a38cc4c2078bbbab6cc6ef1accdaa760cfe8e2fad02551d6db76a4a7455e30df5d6468da29d4d4a5e1f9aaaa29839e45104b252ea18986e470481e40a1ff5ade96a5522caf4f198ffe5baf74199c54b895785e45f09add9b38d1da20f6102b3014f6a88f3bb71ca58c5664e1dd712a9f32201641ba8aea9534893d5a5565d895de8f79c8845431620a3d9db9cd7ba643730811788698ba5110fd0271f1d038e26c7f15c5493b33ecda2d59d6c4c71228bbf6336adc422e3ab5a63c1fed7743c88082c45afdc5a78b0d0cbe2a971d525c158bf851ce66effcb4b1fff1bba401766865589babcb9fc8c466c8d2c34f6bf8b49040f9a78c60295325ea2b5f070116892a582a48fb3b45703011961d7cf2a390444a59282a3b4f511c51e6421aa35a1656e734bca3eaefa5012df647d0c32d29d690c46ca4e1a61721e145bb28e03a5a5410e60833c246ce0fe40ade718d6ab1acf6412aa61b303857e9d3b506fc1ca196394039e3af19628fb1217be245a74eb1d4b8ca2a1878c301a82146276cf59ef5c2bd4c454888681da995c7bd6a4788dcb60ab26bca0e735d1631519c20a798b7291bb8453c8b810759ab16beb0a8d4f43a1565c6fc957bbbd6fe38d7d64e3bd71f3ecf5b76b766a8477b8bd922e085513f57dc3b70ff95cbd514b0d468f77d00a527a4c493ae373b95f3416f26e77da29718e8ceace9661e4bf3c52417e3dd25779d966183445d18a244cebe34a000994430fd8be3276911a40597f7a0851e651990e74055a0dedf0b59084495bea34b6e6c1708677a916537974b47c34fed4163fbd66477e8658ff5a39440ea82aa7a5a1a341972577cae535d2bbd0aa999efd22916270fc40ef4da6a70958e57fde9bbfea6433d51474de8072e13c9ef58a27f843e3cafb63cbe9991c7c8996842fcfdd11673b5f3542e4e66622933b6238a6448bdf1022105f742ee0208e683890a6085b18ce837536f94691abfdda97cc194e18e13e3b3f58d7cbc554abadaf698984991f2fa605e07b6c34d541f4186a60320572b6999fba42d9d4822f8f79b3c0a94653c34ca1e414e5e667a8c10209e7490d38dc9b02c8aa72c9769961c69fd705db50949b421cd911665e277c6a5f7b3c751a104117005abe1120519fb14d3573a6127d157ab215f7d225db6f51fcc9e21c93362a2553adcad337857c0e3e36ef88c8742949b411765a1ad4f6247a741ae89812360d0b88d9c86268e9354ded3206856978861317970defd305230de0dac6952fb5fa35cd4a8a1bf109fa8e9584e79e772edbe4811a8a0484ad5fb51bf0b48c5252675f531fed7e45fcaeb3ea86c566d3b1162e8260ae71f5bb296ce0ca8a26d834c95a64615f341b06d3e2010fb9646c5bc835ff414ce3006d3dae000826370a35de11b3a6cbfcf7e0cde22266c2561c29b015503b42daac78ec1241e4d9120335bf82ea4378897844eca2435e32c242f03980a22b29e38c6dd854b2137a5c6de77a1bdb8d3f3743d2e5eaffb1d58e30479aba743d82d9f1159772691edd07cb0b1968bda625630a6ea1fd86e5555c98cd6c11fca25677bdc515cdc085a97e2ef9ac5ff868d546507688c8bf3b160592450fd8f0ee14f22d7e93c616007cb923594bdc1946e8747d9fb3636e20b4745119299983a3e8aeec26b911a6e62b69d45ea5449135962f3304d8bdc1536ee3e04fdf0b706ad25dfde66cfef791282e45e1168808e7a35ec37860bd71cbfd29b30b10240c0ff4a31fc16c13664cff5060052b33f40281301a823dd628c827869cb0802ea1b2bc02764321a9849154308e5da31ad019ec2d88a8759aca5a93dca8968b2fe90e0e14058fb62d80e43bb51436e87cf575dd22247e9f996d135716252ce3ff9ee09b2711fad0ac34264cb46efcb90cd8998f3a23f7b12c9e49bb8b62110d24eaaa618c1161a0962bd01769f1cc969a8c4057fba61a4a35e3b6a73179549be1c7aa3c9b0091d8939cef7a8e186b1bdecdcfac800245cec3234c33a2186280b395f8fc13f92ec9da80e8c7385cec74c454dd5f032f398914791c2383755c62d43318479594aaf89d63ea8571b3b3397236c8195e0b94efbb2d0aa0b8aa39d13ab640ca68aa8fe6c8f5ccf7acc6990f79bf318811b642040868940220542314c048debb85e80e057e4d68e28bca33abf89a5fd87cf5bdb7f8c9ced245547b7627bc537d085a3d92e3f42ee715b5f618cacc9a66b290f4458bfda9de7b7d42ec3d958ad478776ac6f7a79c7de5b792e02411552e0cf61861b5c1eca5d2a0d3fc6b0169d01f680287b502d23903145b4ffba0a44ef0c5da41bd34db5d709a5f7694a274347b65599e99df782ec8e036e2ea9b0108226d48d0fc0413ba67a0106d51ac387cfbfdb69eb1675831f44a5adc8cdd687d0a0dabc9da2594d975cee51c2e4f083e1e6f73a3d4c499b4b43c8fbf1a9f737920e9f0d09b0cfc24162cecc8c275b21314b9a21fed8c3f216201b7a95db83920c9df4b9e8e943d247393ac517be61886d2d7a7d79c2852a470c914a02452b4f259828a3fafb8b50d83e7a7cc022c5bf9e520bafd5e238dcb70d5a8b1faa8ff62602f0106fe4992ac62ba08e6377d40100b3b697f9344cd6415719d49d770a80086aca41752c06c44bb82c54351089a87f0edfab8c42d84451931f6ea5e2fb2cb6f1cb853432fb3f808b7ffd67b6dffb1aba590b82e70a66f1e22949ef209dcb01498de0e937003be7620f4d1d78e1cc9d4b2520a14ccecccde899e22b8344a52cfa32c4c06d867e82c0adc114385e86453d4a410db6cae424bfbefc8a8b40ebe7581e252e84a70733bcb365dd88fe6559afa0e7982a963f77ac07c62d1fc3b35bd20d55f1ba5f9618ca6b937c1f0d9c65da1171b634ca5312fc49785297ef02de9e55dbbf6374817e67d59ebe5e82118b24c2643d9de762272d61accec34b30bc5bcfe711f8cbb1507fa5597b19270f74920e89aff9ba61c1a2bf9d41ef5c13ef631b0b38ba93d9fe6768aaa3e87bf5d04eea94ad797c2e68f925d8e056e0f6c8408f13dbafd540fc125953d2eade3bb878c155eb9191f59fbaf63897e208b2b08c18724a7b31fc3930d301447421fe0def8c6ad5cd0fd93921f4503c6e306a89896b8f5d3d4db33c86f70a4413a868ca3e84875ee0b82726a5016a69592414d8cabaa83f18a148dee21113f7aa4d47f12f1d3511c6d05d4d3021db19aba3175baba6b195b63b2c1e9eacca3a74ac3145b8c10c905f59d6412f59824b2ac1102456ea8939591bd7272d1b0406a58f7812846968cd9f99186e3b9337658db504b3938fc7c45c3f3c7d1f220bd6c66691f6f0cd394e8d653861ace32fd19bdb6bf167aadd01334339d406040c3a0d16d6006dfcba81df652609d85fe62f44fc5bc5eeb1dcba671cc27001805b395f7b46887f4be60d083233097e8873304276c6b255c9826d29b68a50997c61838c74f1c40373a6f2f987ee29cc38d61642898a9a0fd7a16e2c502148728da55632a405c830e641a4ef9967a01858cba16f06a7513ac33cad82943d70c7e5f67d8017fa875cc616d0be9d30639193978d0696c11d8fb9212e3900e4e3c7dbf13294e18f024de4aa2f39d36416e03e5935fc361cb006430ec8ae64c34fea0c52f78f98f41829a411e7a05f48370ed2135172d80bb02af40c098af42445fa3a84d39382dde832a4aa80136e30c22d394d5310edac5513d2a1853c2e86f772f51fa81f40d46025163c0e7e48478f5bb313c7305932caefd881af485a4b5c4802985bcdd4fe6cf183c0d6290e6bc30b805848ba5be15680a1f2400dda9f9275683765354c705b20b15fe73a585c0322aa65982f24bd17404f6a1d5537edae7e722f941d00b4f66b28eaa7f5c50a926e8c827373f8261950b09f31ecff0a4869ea29b550d5cf8fc2108d39a74575bc6505cce82f0fc98ee83bc86d556301584f0b6f5d2886753fb43bce6696900fafed43d72d5ea26501115756ceba9f6417dfd87bf1e46ed66ccc57d71b4b274e46215deced76334aec855a2e8c5f1862b0bbb3412f52273d86bd9365b8740bef8699e2722b2aee80e328aa95ae889e192e418c1f7070ecb2651f2f26ed9c0f03fa4543cd04b1342d9da1b7b7a6117644d3065c2561e91376b43bf1800b67e16a8dcaf15fc460e47ffb6051b6eba0b010f0f72825c4c377e8843f32ff037ba588187ee8777d7791b7c605ec8fad7fc315c08a200657e79e1adc054f9be39f51ef6716228bf25124e40329148401817c0725a8122d2dc9f37b6c1c34b2103503dd475fb97f2e21fabc1d63a0b1f3de36674e2b18ce25ea1511720cb37632989ff8384fde97a2fbf5ce687503b762bd7b1c7d559c895bade4fb63f085f0902815de8e03dc17e4d262eb90e6c6ca3c6c7a3b1c9c409a354b1ea3bced4646f5a5bfe4a487a8d13af70e7db9f204bc42455843562a8e97619da9e04dd6d102f15f9ac81a21531759d2da56f0e4cd3749b712c9600c0c244dd26010cfffc9838f60e49d9c6e6e6b7ff5cede20c1eb100b2a29a9bc5f9db77f0b8e6fd28337bbb4283c9abe6b34601524a3ee6235aaf16b36c7b336818f22678b7ae6f8c905cc14ee5f6cab01a878f57ceadcb85ae0d8713d2e972ed00a05654e8be6924339d355e9865ec51907c97e62e05788a2a7757f8058b1a463a4d5f3a52a8379cc2e93ae8ad88188cd78c098d4fa3ea5112e6fb22ff1a49317282a6e9261e212a5f9953ef139fe771d171a634568909be4d1b70a2812df873ad18003a6477e3e6e4c0b7fc35b610b7e3e1e3d4406fc45c20c15d3cf886086ebdb3731f74f9dd5b1524f18ac930e13cbcc8076a59ec7d14856c4ba6adff882f330b1945c1a3df50f44440517c110b8d524f924d46e05b685f1f49c86088800f523952500176d3d0445a32d400948ab6b519dfcac537f97a007785f35f2eabc54d8b6711de9941e8ecb00c2e2b606027637d60ee4106d02af7bb9f86996aa0b91edfca3d85f2589a4f8b9f520f18e9b826f5bfed20cab295c7d74ddcae4bf7e1e0252059269222b20802778b3d21bf8d4dcb7bf42c932bed591271cd9efd611f266353d4fcdd1f51f1f2437327c2fc51161f1c161433cea82be5c6483faa26e7624823170a9434dd1ee5937ac511bba612660a8d08041fb341c43a8b46e42d64d276e25aa4de3581b3dc564173800ca626d809b79d5664e1fb86e977eaec206acf1900729a631d0a672293283fa7c1362372599db5f939cd5470bb53033eb64fb7b2703eab0de6240456ee911374d1f56c749747ab6027fd1705e41d2e6b2dee407d45aedaf922cc99b7a01357c04f9de2a69904c1fbf5469d337cf1f87bd17c670765662bd6985291e82dddc300bfe302abe8a38e606967439410a7c353677edb204efea778f7ecce9ca6cdc14ed765ae802fa7c571ec5c70e196345bb75b77cbd64636500c2a0edb825cdb18202d790a1982410c9ba786bb4c2278e5508e90321936c94063641d88021674f45b15bd1d46fede025462ca42ef4c58292cb239c6cb79e78064f03fc62d4951f5c001d7d5ae6da68d517d2c23ef0da0bfce214abece8cfd298cc96fc8644ed7401a4a29306199301fa36d6e65160dcf4e84ebe336d00824a49987881edbf4d11a9921aa7735c5a144190e378b0a059613034d7e1ce48daab7a026b8e305b85da6fa4c5ceac8addd7db2c6dea2a9755401fd38eb87854b2a2bf3a189948448024c741ffddcbae2ecbc97e1bc92ea14351605cd7e819b6d6260e5a03c33e50cc4b0f81b42a9a09597079a8a343181623feede736a3a3520f584caff81b43e695f251e55015b76c7be1e1e573dce7221eeac6f2ffdcda6ae793ca98c3a18c1558685a25dcdedad08ef41b8972d775c5d804eee04e0585f181c33d6652382bee17c49b41275845b24b0dfec70ebc5ab2a82ccdde6e2522368e7e2dda98994987bc12cab4e952337cb833784ca7084d4075168377a65c8c1339c9205147d10599ff602640277b73ae010ce97a37d48c3dcceba01d876c69d1a0a00178b7c4dc2b2d4bad916f82a8ccebd39fd25a731351ef614e444f65df74eff521bc1ea8e6946b2f180fee4b2f1f363e53ef9b43a54d43f73324c62637c689a952d5a43756e4ab1d9b9cee4c58eec8b43c6774de986a809fef0fa12da5706cddeb21d69e3455f9ae742eb76d0075fbf77ee6e36286df3e7dc96b5ec0f0956276d4d1eeb26857a8d8690670dd1c20c085cef53dc72aebd9bef5b0d582f0258f8476bd071d097e1a294cd937022bd21768523cc4f3817925a0698fcdd9a24c76446060d77ece062ef449a48204ced8709fa999029215fc455feacba19eca33bc42d719f0c1a658464e851fed5a1b0148c6c63e441ca045c857f6d39bf39dcf2c7944de896393396b3348839f400d99874fa61b6229bbcea17676a578c297bc03c8f06567aaede24780c731ed07a6b07f11b78385cd3a7c62d5e394b0bbabdc2b99692644263eb0b2216bbc4c904f7fbe2c1d5fb9f08cc63e8f2b47bfed56a520b783b4b3eb4116d6ff7bb832840606c44674286d72e184db2210bb972dfc357680537826f09e51528667c794b469ddcd99f981865fa47789e724e5bab70416b35d5eec295f8e4e017eb93f6cd334240924d0d6c4a83053ae91b0fcc16b927084dbfaea6c88154f70915c1ac50599210fbf092a090c538a7654e52c9ffc39aa71c47d42df49c5276ed8be58d12fa63093c0ce6c07dde44d8cfa71eea225bd73be85e62f4aa5b8eb993fa68823d00f4f69232b9e371a15342089842164f31cdf0f8caa160d2f88fc6e4332d02fc5f85295efa02a335a5d87f1bb6e7e46239e5e8bf3e6d345ec7fc2b684b044d305eb7546945061a9b129b2162a8131e3b2d543c225a315d75807ee09a0f7bdfc7d8c7f613aee483a852806402bbc218086d3d3232c8e21a31abba1824e7df4512796e27a67bc2e0ced596f5224e54c862c465a5754307d905d446be3bbf507c5dc3231b75a5bc5651d284b0acc18afeb1bada6406ab56c09c608c36cd04316a3e1da49a9fd5d1864d079b1f8e4b0925b8bbf47545bdeea0a6f6e4a17c53a816bd5bb18b0a6ce6feb7c29680b11286ba26f03ad04dc6dc7a43e2e407c2349636884f9fca778cb0bf20f5ac193e3bf37f5896cb79ce03099aba09bda3472959ba7ab855bf5d06a8c70b46a6b5fdb9e29254337739bc0ba3c1d46e79fff3fcddcff1a2a4050c8d0d7d7e76bfb53870ac63ccbbd09911a4fe3b9742daf755e8aa9127f3f9cbabe418c277ae3c13faeb05d47a49215f0462b1ed934818c5b7b4d560c17416224ddb626aec825b84363172edc5c74e2263f631aed9194cb12244f380c0988b02f14961a41b89eaed1df7103ec243a8d52fbd6464fded3a9dfb4fe384c2ae54daebb1fcab396fbec4119c044240d0d0432ef9779c02cf7062a48c6784140ed513dbf1152359263762f7fcb50bcbc677927560f7415962be62263d5635f571697f700ce4f68b92b787dd9d6d0c115a4f86d7427de87481f414b3437e1d34779e4b7f354763223c6ef911ecac100f3538185c2c48bb3c1b762eb5e1fa24aecfe1dcab8a97ba91eba7e8e2d1d18f26204e88c7947eae52ebac48f2b3cfbf5089715c38a832bb8978d24c8c188b1f2683a46431a4c05b573cca63798ee07b44253d0deea86a594d8413b767b95379a01fe915729de02cc6765431cf75e792817d14328a08f50d2f84da5c654e38c54235468861e5c806893dd110adca9cd8e2d1a4a466744b1f78eff385c27a274cc59e6e888321398d5ddc33b981d44693e2676102c72f03a277c78bfec3bbb4dc1af1f962acb56489d43896ce347ec7aca334de9c4bfc4d24dc39bad6a1c5123e889c77e65fbd4d866c823ba3379e5b1b753d201e583021622217f603508c538b6ea7766f84672f367614868fe1ae0db4e634bbf88581ce1bfa4e9423382d86c1a7cceae47c0a29faa6ce34e523c29a3f7700b830f3c402206ccbf664692012abdbcb04f6b0633a8649f163350f04a3c574b18815c887bd5d5567cfb708b0bcc5afea7dd38f5028f7c2ae5a37ca77315096438a7b3b3bcba93ffb3c199f2f844c5d591341b4a875fe0e9d852fe9784a917b58377ca268ec4b86792abf98135a0bc54da1430db797c335dddd3c0e728a4b5408226c4a78bab2143e484e096be1a7b6a2864b055bea3b0a6ab37af6e172e3493e03cf6cdd53ec96525cee67b4529ca2f073c867039b0b04faa7e07a7ce6398d32062bff82136daf95536cbea3cbc459e3aa7cfbf005f2ae8389dbf37e077bab660c3505931e102e7315b688ce5530bb9bcbe592373c74b6173b55b04ad0f727dce56eaa319068995c68e33a2540141aa8d46d9438f0c82a89508569e793a3af3c5969e59dbbd8ca54ed4c921c06b38f02a47fe637a76a0c019d67c943a2c4f8fc0df33e4040f46c41b4f201b880450d78889c60ad2a0100c023b8a52f51acec2e3b5b5551cc23188b5ed9c44910953c789c9bd0eb5495f60de9c28e8ec88e47217b31b31186a8dab4f6257949c0b83f54637583b37efbadd3dcbe49c41d45d9d02d154e024a369ba158dabb17da3c53105df42e74ed58f4ff1974ef875ba48aad043a278c168ea2be819621ae2464d26a5d87007f054b824c9cd892c98ca0cdd161d16fd17a7a418a7244d64b2ecf8940605fba7ec3858276350de929af7e76bd5ca038a73407b4438a9a54243cb98cecccc2df8980776b7e2a28177ffd6488d3e69b5f3adeb3c576e0b2edb638b8f1397de39c37c1aea528390f66e6e716d26de4e2e0cac690c9fce198e5545b945bfdb01ab421067bc103b9f2513bf874d5391b11d3a111edfea02babc7329394101e0835a8d9e3dda2c5daf00d8c2bbbe82b64e50729c71ea39f0dac060a81d4f72a7466815a8dcbb07c619244664a6b4b852acfefc849b6fc16a81909c7521cfddfd8e7c61a56e08b8157e7f4f278337b15a255bc69e49d6ea0169e49f4aa1b5858ae723290983e402a5458d80e0ef84adaa0651df22f347dd529ffede3419fd83d5aef9492126155db9db1b571c63c3d39b895e6ebd5c99283c47cc010778885f7cbc5d5862ccaf15baa48cd8eb4edef2d3b73f5c504781002fd64565a0b361412647f5e20486abab77708fef64ee7f4f87eb8d21acd8a8dd27651df423ed7f398087c8da92799ed88547bfdfc15674ad1df4ec1d18dcab12c104f35ad2fa8a0e6b53f48c0b7f313346cfc208db8e1f15f5cd0eb1f113543610ee11ae38179c11efdcd3c02b5f3c4111df6a984911b97583e0182a06842aaee7a92808c6800e8e0e315d865a4b34534ee4be3fb6de5280a4ba0022dd6228f813bcf0af43ce7811c5928c49e420d731bb4e8419a1eb2e73aa3a3806bd6a4fb60e05778550b5a23c99cd526ae6418750a62763657bc9713279d1057f1782016328b492e12595a8ae8aebd88d32fe5b8a213cd8beb99d6665645a703c3a3334bca6d69d3be5e79d0ee854bcd7b87f9217f81bb14d66e513c87b4a8b158afcf4cd2de7008a7bc6ce4d8b32439570117c74dea6b88ca532e0508bd1ec37fd3c8b3d1fddc2193464e20fd18982eb3a83e4b3f10d24d80ce1ae2e169eaeb1a8b5824bd8ad44002f3b407ecbfadf275e965be95141ea61879de39aa8d936af533f9fb701ba147017638a723ec9dd9f6e0558a9cb138d09d4d6f3c668e2e26c053eb234d108fa2504b5d9fe5c01c099f2fad85606da4078f104a83aa0960c26b096c278caa6b1b0c89481aff561305edc696ca9d169274808b14d915bafdc9f37ecd5e16a9059737a6d074cb7c5c54d73d18704c7454e5913c9437e41128de8ed40f9134f7ff2ec24484bbb26bf1ce66e5b2483ac1d5d11771fab8f37874dd8c2ae06cda1721d21bcb60c3b53eaca8d6de8fa14d1056f23e31dbd9aa8472bd7ae3733b1752b189b38101328d6ed248edee65b4d7b5665a0ed5d60dfb92393b754add7bd8c93e66d6a11022c2fec0f4927a907b5f467f9cfe5e672a61eecc8948c3a93ebaa964bb2c0ab914f3f019d692debc76bf8ee5dcb5294d08c5453dc801d82c8ff2ad8138e92eefe98b26d4c77d4544ab47cd1c819619cc2e4e1aa9aa4948a496de40ff1612caf321516fa98a85c028213fa4d3ace1547a768762bd6b4a2d8f6b8d16808f71c092624eb7ff44427b74ed3c705395a823ef80191116120c96a892d28815d8278a5ad2bcbbde6311b63d90e91308e3d2d9a3527c00e8663d62d91834645893f9c6fe2b121d0fa466783641e194aa9fd79a5cbeb54f5ed34033cbd27d2af734cf7f9b61caf500f0daed30aaa52140b1af8c7a4d7c543bab799d25af6f2fc5ac5da1f88a77afb83266e2e0846782048c03e6e03b2e295358136a7eb1369b486e35931f784fcc5645ed370d763fff22c4f86da7007e492fe674adce9d822af4562be7ff2dfdd25d889cb7f454f0cfe9a32ab3d300138508d775c7b8b71a7f210642d27d56e57ebc15a511079f66c727414f4a7c825bd4e6817768463860a56e593ec6e7a7c8c2287793d13d04c5c1bec5f022776a595dab83cc012edda2a28a9c055c5801d5330587a35936a948b233472473eea87afc1d99751ae60c2c7ca75db23f32f3b9c91b2e92a7af5184ad813eafef7c0fc4cd9bd028a6f10e8ecce752536770d4e994d28ae412e135b1b679b1c3db30d4212d6942acacd848ba1a7f29c494c2c77bc48d4d3d3a94f6279ea5d6dcfac18784fe4444d174b59fe73b74d4ab32740b074ee76d1a6434e1dd712cc4edfe926ab0793bbea63b64ee8ada814581d625a0e3e610a1a0223862cf98eb83705e8874ce070a9165403b50ab76d873df755b3368384e88cba87ee502103d0558ad2693a27555eeb5f096383903ca9e3ffa204fc0ce3b79ee4e71c8e4afe19a0789a1249f8e29ba1f63b12ca98fac92f48224528b9944ce28d47a6210d654133ca1b06704bffa08eb4bc01f9a1bb67f3ed5178ce14fa88d163f4e58f4c01900eba73683ad3a954c46d0fc2d938f12064a6d4fb6ec42c2663c8d1875873d9e9d29b59902f9c89781de7a7446c560756cbe3a4ab2e51f7ba799791c255d80c3897dbab3d4125ae84e1dea3e79095c44a554ccc120bc9a0fb8a66adafdcda47485ab61fe09c8e4e0ea9909ed515bab8a571057bf4476f06776e511bc11f400a954b1dc394f062a2a865d79e91fdede5393240e726589b1875cdcfe1baa0649742aabe9f05eceeb6d0e0705beadae2afd76d03486ea7e529ec0d0c6701be8815f07042892ddf198221e3d18caa0303d87ed65b922bc2eb3a5c9d6dfa1a92b0f5b9295cdb8c218675ecd2416a8c3719aae3b930e354636d981722042ceb20cbb6b370af724e0a56d8d739c4d1229d8860b50879169d9b4fa682fec7275b2f0232369b59646b76645a7cde4a47b2c979775e992cd23eaba5630911d08c3dd6b175601abfad229769c35e26224fa0c3cf8670d2b78faae23492dfbfec6e0487d485f194a29077b9e5891e58633242e806f07c0be83354d14fb25b6f6f905106f6e093e270a0b48523dfc243e7bb1b9aa85cb222706c800e9b22ecaa7a055cfc5726c00c8e6f056ab55f5f43007d52e328e878d22b63b0763058fc1507ca9454e4a049c054ff36956482b8d1c8e69f13b7433b40f7443ff88613af76499eb3d34f16babd293435cbf689aa79fddeb8899229b699b907f2a34f11f259d3c5f58d56569b5570d27d509c13e3b64a7164ab7cee739373250dcfb8a5bd0720e833795ae5393508f0ca5971e63c42ad19283538706ff1439d90904acffe5be7d2da612589d773c0d589e98b9a76f52dfe9ffcf6c22674f7df306ed29810fcdde7f5a4de408ddf44d57bc4a685df27d53b5745cdeb80feb11d9f1000b214c6a4b2398c914c8b69dd689967793054ee998538f427bdad5c98ae8d852cb871dd69c5430e888aeb6bd7d3f6e2c8d7e63f7a2d02c17f9e178a06323bdda699afd0d34cff6ba48867fc40a1443a5a440ede82875a0aae57c0125d0097ebc02a03d0bfe1c82db2cbf7a93451dbdd7d1349e3e18de945c0aa34238867dbfd96ceb67c18da2ea5df6cb3ae99faf312fbf5f0ede1b2b76040fde978c17716a464a3eebe6221375a7235782943cf2faa6a5fb9ba74576b494ceba820c06852378e9968960aa4ee18ba57df37d51227e1b21dc8458a632c5d8b4552dbcb92e7a1e66b1768ab1efa3f29f0098aafe80db89c2b7a985d81e47eb04133ebc92c3c6eceb82448383465b407cfdc822a319017329ff092a28d202370ea860b05a398249db3444ed789f7e761178872f3d3f58d8f36da5d90974ca681a1917c6dfe81209108f38be66bfb4fc4b9dab91e3e356f848d1b4cc1fd697d39fd1c9ca72f8ef5e1987fc159c2aa1b1997e529e7aee5c1b4ef7cfb4d8ddc1cf6b5df9cb24cf8243c5f6744967d64e6af22c650ab789515fbc79ed0b71cc36ff88bf7d4b4aefd4960e6c77dbe13d9a5ea55087be9fc24a68d2e3a67900df598e381e3ab575479a132b4fac00da28403a6924abafda704738eddabfee4f674d87c4127eae13c7831d1ddd0e4fc030522482991a7fc8184c19afbb4ae633d678c8dc19d69a36d293fdddea0e8249321adb0335bd297c77e7cf992fddd05afe6822d22867102fa38640c082e253ce6e9ac5d8e05bd29ac7f4bd20356a1311b81e5192b77546b6b8ca477c1a5119b18fe6e4860a258e1d6ef6ba9af8b05161415445ef91dd0ff4e6ecbe9f4a4d40e8ac97b1e5cc9583ebed3ef942e6b634736f36579951148d5fdd81b985f8438b48e5ea81776325ff68ca730d1ee0bedfe9d859bde82a0822712a6807a11552abededf424c2419800c3a186f19bca1217a6ff0f2c4fcdf8e088659209b0d4b243cd364cf665835a8945c79880bda25f7046070e4b06e02de13441c0f5c93040c524e2847c6b48e420a15ba852d4f17005cb3307b3cf64fa962cb7162b576e4297ecd1bb64f52b17eb939722a0e9e1d49a3a7cf65e04868e5b052992a5a15f70e448262928924e8afa071c10f28cedf0b657b5ec6465c22690acc61c58ec7274d9e3850d3ae82972256e4aee2d16ee477b24210b46397ed467b08931f8d3afe996d7121c716fe4969899a85f1615af2982cbd14218526378fe4ac058e5426e60a31ad11bceb2318ac4a0aec03ddb2ab4dbe6d5d4cfb1c47d9dbcefc649cbc819cd1009bc910a270eae6971b3bf2e0fd28cdad037a50f1fed1eda43687abb0f132f9dbdd3f71ce6228f8cdc2aa77086b8fc94f827468a96405503b3020cd8f9e115109c39a0ebac2204903dcac7a57b51200b14a55eba1b414369ad3a5a3461abb01c42463881f57d142c8547522d3a3b7f319e71d38cba3c8f287bdc1fee7985255e31448dd7a59a70a25623a0c3f3103610efaa936d733e193a8abee517add2c61692c3101cbff25281c213485e2eabdd770dd14cb90626063d33d456228acf043b64655c7df1559f08f9f180c5da7e274e1e007de709e016bb715ab3739a379f47090f61a2cf1ae94c01d60b78533795cbbcd6681910d622f4740660f53df1c2d0d7ff94478792af4f6ac5f30c7b0f03b3ae45708d29a48658a553826a0f086c14d4a8108dae4e54a27e88a8132ba1b6d8d6a29433ea3d783ad2568b2915e695b9b7e2e51079356394a5ae7e64553fa8952d27621e63a6d4a66484491c8fe590ef5396de2e68a3da176f8daff816d2694810f544d143bfc422885880dd79f6c422cf6b7deec5d24585ddfab34ee530bafc00e14ea99dfc1082afe6e56ccf0950a5d1e7df202a03551d168628b7ae778c823859550783b3d63fffe33c780fa1f98aab9440dcc9c210a079409f2d48503b9d5768f8beac8540ea92a867bc4cb82e2bd5bb8e76348719f5abf0593640bdf23f5eba802ace8f8b497c31bb6ef207ab1aad0de2fd4629a9fbc95f0ff7e169424c58ee91df131167658046fdd0b5fdac3ab31b68d93c025accc44a62f9cb660fb705cc3f5f0366e6c2f167ba27468df9e4e35098aba14d77438888bdc220f0fa81acc8a9ad415601c2c2b4fcceebea87e92a160290b4ce8509dc5f9dff2ccf318e8155bd34b23b8b67b9911db5e71f44bbede31c9519b91a77739f463b0ac9154fe33b25e3080011b499e94ec0c4aad11f4f81bb195e7e5c2acaa20a43dfc03373cf76aea375712c696136317f1b6650269fdd22e4ebfdd3fc79dfa287e6e370b6edc16a7bd07c8a5e5925bac8432bf2ebf082d1f285ebbf939faf12ca28c49e623bfe8d63f38aea69bbabafd65a87695d5cbaca2c30737260c27eafd9edf2b0af8c6f3b9691ad7a706e27b3159d0856a59772df3b63369aa958a61412d1ef9505c8914bca7285efc41756348c577ff0216c980b8dad63c8be8d9d6972bdb6cedf94175209268175a33e941b91abb11772861623c6402bc3b26047d5861106df617f91e3306066a3108e3fe51a7b671f8e32c17798a18584315ac3617bcd0fa511966b03c7dfbcd8029e57bc6bc199c8edabc520a35779c81d537f697564e56e9a30cddf9589c1d5169b1e1f4d40d72d222de8773de448c24b1b533d558eb0968ad3f292ad8f876f87a5b0b31946f7c2623a7681c66562aff1cf3ac2ac3866487abf3644310374e1a1cb2dd1a415734d184fdd04a5e881510cb0222620c7df227932d019401d4a77ca08d9b7e12238744cb3e2ea9fba8c39b6e83146f7361cd4c559f28770f1b43b89e8fa03f2d16f596e0552d03677e8d719212ba69c8c4e05d577c999789a899236ab143be9b7080b963d9cf9c68ce785bca92ca7c94e6798aec04d3b3020d0a9d7d22f3668160eaaea20c95fc01d589f0a98e489ccef1d8f3d9d515cfcc2ccb3f22e2d8569dedf5b63cfeed7738c5e963548be1c21bed7583238eaed6cf86a9f71980415d793e08b56ce854bba3f10758122f0d18c6d74141ea2a016c062a42d6d189b4485fb05a6835dfeb4ace64af5d24dad025a7b399a7250e833c45990bd399edce96e52e0e61715b624cd687403e66984ed4acd543040219bd1224b24dabe4376b0c6c88a7bd77253f4fbaac66d3ee48a836a0d2bc0526eac5eedbfa9ae45a85ebb1e9184ffadfc5fec96cf57ac4d37b4ae4d2070d479bd63f4ba3adf2df7d7c14cb6e0dc956bb12fcfa1e77d98cfa87e38317d65d1acdda62c7d39fa42ff973983c1d9158f511a19f6ce95a1fbca64167b5ebcf77a6c6c7846153429c10dda78a4031fbd4c3fa7b2bd815dbdd25bca42b01bbbd16fa05acb2e528c50a02b4241931dbe1bc3661abbf1b036d5774d5d3e80760c7c8f8eaa3a68802379cb25030f22cb372f0cd3d1626a8bc1380b53595752c3b6720dfe56846d45b64b7975d0f09d85fb2c9e5233e2aab1fcf8ab371579e3e3f97852f423dba9c39996aa55b8169c12422e91193dc9eb620b636cbde78cde0a8512fea224038f8fe2fb70732bf6d98408d6e0646a6b4c081bcb8fb45ba49006cf9edf559fe211c276ace68a0d551452504bf66d202d81eea2b287b21671ac7d819fd5366e2e6b656564c988abd3b1f5917893fa2fb4591bef094a9905d09f166cc9f9f1191dbc3dad2790a44be5901de8e0eebfd7fbfe140d5b644e49208c7d70e886262d0297e963cf6a0f3a32a7adbb38cf2b57e93eeae4dc0d73451a9854c676c9b2d8e4658242b5a49dea696f8e95bdccb1e520a0afdceb647e14a71b4a4d74c0b25edc7039858b1ece4624b0f6d5c87ea5261b658c6d4fb68d9cbb5b2d32f172669eb76cc47b6e800ba5c391f0341b25e821f180af83aa86b8a026840b13ab3802d9f4c832bbf54f0713714890844b8a8e04cb2bccf41873efb382a90c6afe7786b49e6dc7718efb03250ed280dad413cdfcf1d063f979ef4ce5d077e98deb01fef10018c864672bfb846ee588d4007934c4c67230cb5fa054e103fa3a3c45eae2587c1d0a992974b77780a7a2d179d9d40eb4f383e0ccb66f8fd4cc6d2316063ccf1e104ff5223c3b5a4b153b81fa13030baf901b526753accb980295bc2e6276590f2eae82d6046bddfd0ba19feaaa9bb48c242d439d246896680edebc76b1ad94356b00ef9212d6cd6fc45951f5d18b08602630d3dc3e766b06454fe57cbe3ee836eaa8de3a5b7519bea06a824aa9fa8d3713ea0a16bdbd44c675490e1de038436f4fc6c6d17437c98af2fb0a7b1064d98af37c4c304113b46d4b933629f8a97e18c4eb6c2f1ab776998cd864773db47cfc502189bda0f0a4843f6afbe6ded2160ef35ed34036d98b6c52647fad4584cfd4a3bb18520dea380fffe78f86608edb98a2dc4baafce36362b479db22d1d2c3b8dbd845e78ff0e97e68999f67d46fcfdd9af45c8df3450974b48866d49f0acce5b0ffce8134057574adfc568538689e697e79c8d33c23b1e33ecd4a74b231423c0b807b4829ee6fef890bd490fbf7af732bdf1f1d260566122cf1e0ff4489db5e61a3503043d33ee38836f951fba5237cbb677f54e58ea1953602b90f2db9c91d12893b2c8ec9aca46616909a8d68a0e5998c82efbd93dcaea2f6f271d9d257d0e628dbeec4848c155a5ce47d340e9e020b31d84d9487c49f749b5366b636ff7ff649a5dae1782d2b04503e6c68438fe95e3677ecca3d8338edba38e8181ab7986e981d9bf2038c10a16be514af483175fa8fd3d7f48a9392580d5df6ebc684db38f9a89e96e64fb8761dd2d0d8c8ebed7a130bfc240f46ae0954ab13460f8bdd22b64d5c193dc26934ed58f8f8e251caecab52a093a945796617a8be302998536c35a16629a8485fdc1bf86c9f66071ab3cdf791a9b0966347bf93ac4c0f3c2aa370d68eb8e6350e2682a386947a89ffa20f5133a30d678344f84d8efb83418c021a5fa068394c3f080232102ac4a6377165ac6ba1140dd90f4f0952281553fbf91efd9ac7fdf993f7530e3556af2149a7dc14bcbcbfa984b6e9fbbc71846ef7ec58a61cea953c70d172d13e04e5601a3d27603df92da6a1fb8b3de47615be23a0078094d4f254187591d1977e4775ce9a906a0095773ef3712cc0a14054ec5e56d05271baeb630227e1a22f0978e858dccc35285caee48973ee9f533de51ae302850c1ff4e928867e89e26a3555bd3160dc64f03eae4f795d1047f3645e490cf1ce30123f039de4bef59874ec5e02fa76849e32984bdad50e7b76f18b659390694565accf0c77dc7d7ca613842b362892a7964aa62668f56a1a0c3ec00b8b1e863e013ea94c03ca507c0650c9286afd76b7ccd17c3056a84766d5409413d4de19a40e3283f26cee16ed00ce4c0993b5f08ae99b411c3a4d90a42f0e26721f41d1861b1439757eef81f7d76118aea5fb59f76f3e8c7003dcfba7e17dbf17ba28099cbb7bbe1ca25e96d0a9f9b03dd54a22bbb75923cbc8e2fe7c6a85e0001335ef6a79eae8d46f96951c89269a8315420f3fab28a0864c9100f76d035bdcf7a5f55364d7e3146ca8855eaeb2668cf6337fb91285911c49194bc38f95a9a09f5bb1cc2ffaccf04e1a7b786ca84e1d6bea7c19d725cdd66edd16327070561fbf0962505e9741377bfe383aed1be1ddf23c6005f0b09315e469e1204d3eec84a19ab70b292148f6a174a0bf74adfbc5837a82f0d14df97757279a9097a91a59f1107486eff8333a1fe823f0a10bf3ee0b5d306f35b682ae4791e49e1edc527155a9bcf23070227dd6dccd975a295cae9cf39e9bd1e4b689b014191ff52fb90c1f887080eb90778db364ad2a444a38c6c02b715e8bfb7b61861506cb2daa33f251921d29c6a0ad263b70b3d63d0c577e1948da5cb5dcfaed1986fb200cae94369b09513f6892584cb3af155f061505bf2541e6cb98e80cd45f28450345e306146386cf029c957ec64b258cdc450e1ba48379b690e405e764e71afb629add0a7330daa4167bec3b1e46bad0a3c7c2619dc37c6506cd58920d6f71507a1570c5cebc99c2db57a08b9d9160d039ae0cc6e62f02e3a44422a85fb7d9d9ecb64d1e75143e11ecee1d97591d516a85213c84ac4ff90f36f7be1da20d0f592a5cfcbe535828e3c8335b50dec30d7bbe30d0635e39005fc1ba04bffb51e1a49d60a8ccdc8c4ff32c4c2792dc9d8e0644da152f3d517f4719ca198a168fb9ba1b154b035ebb1bee25fd756d489b050c3967c8b05474f3e068dc89a9f9b212539fff7680d5323f70bb7d09690870ec77660bfc2e34e77699f86de06c1f68f23a65463fe9bbf021058ef0da59e135f918b5af9551fefe7ed47a1db96082cfd2e4551f6796dc41ad890777408f8f6f0f4140542437e11825281b0d502a42cdd9e09afc0767d71685119664d5da17254fc290851d8a00d79a6c919884aa89c529b137c7b4f95bf12402af10076576ce1337749b75bb8b75ebca07ab9fb3c8eb5001c0c2e677ce4c135625d0e15dbbff0ff42aa12baefcabe0812b68c11993b00f4a16d1a47b7a8186c367813ccfadd9e2e96940d6ac8c41396626c2e3eb613858f7168ca74412cde5f652fe22c1c45b8313c2fe1c64a9d911595869e94f9ba6ffd5cf7133b56b0e6086c05df0db305e0cdf20b81b24d7c16c5a518b01d0c4526b317cbe7320736ac777ce5f2d8bf255dbf50458343c6283aaf5e0ce1785dfaca5ecb70e23330cb556143450f890817fc8f5044684d64f5ff69cb20444f92fe9515050fd6946c5c2a4eb15ba04410e119c306a2f7d56b6b19b2fda970947c7c3f0522b7e3ee55a665c942afe4a694be174c9dee7c683bc55348a5bec0ac0e99094084f2e37e2a85e5dbfa25b1c6f4e36a22dd53d16ca395336f9ff2272e9f6947d6721288213bd5e871656044e5159ba4285f6d4916c85c368d8d7d1603774a5f21abbfd33a2afb32ff7116d2f8631f457d04c4dc03f177edea7ae024a4675be8891a34a49f4bbfe88dd8e74c4b2ac71a43f6a711bbbd5a7ec52fa25149b6dcb85687955bb7a12b88d012f729a69417f558ec49a9830f7198967fbeba94dd67775eaaffe43cb2ed6ba5782eee22c7d51515fb3a3b0559b88850ebf8cf9fbd96f2a6fa1b71fc68c8c5f59f0030fa46bba097202e4805747d86d6b1604e321b62d1c5564f512233fc6f311a9fba7ea09ecabf8884219d12a3692b39e871acc46427467e7d64440efd32efb726b45e6b89245ea71f68ba3728ac12c6d6f19747a90031afaa15e88d037c6a462bf1cbc6a70557b303bafea51f0e896c2fd44e0e1ec2c2e1b2dbec30d20de9d409864045559ed589acbf5b0a249fdd09ba9608ee91f1eafdd55ec2b8b8ba58d68281e448e3ed0865a5f89ef3066401b0a4a9cf69f999bd8f9b0d9800b202262a52ab6196fffd891a68e47887c14faffc8abd828fe613d77bbc6884c18cebbb3a1d9df3138839a4c127633c458b33168a9b15ad1de32bffe3b053aeed692657f6f61c07d837f5e578d609ef5b10553e4c7df00fdf64a88d41466abe292cc095b3931c6cd1047dd2a4ee4f83baf28e1365f0da374d9336be666d80f702420b9779ce5edc5f18bf343e16e4381fb95a980d586607a13fbfb6a6d21b10ae6f8d1cd990899fa50406f7cc26b86c31978dbe24e77ec5bec8cae46cc922330ef9e2a3ba6dab845b8aacfb0df4f6bf29a7af123b1f3ef5bafc097dfeedd06b88d3dfd4965bc23784e58d0665cdfec81d43e6d6fbb0189f6196c6d6fcf6acc71bd3668b1648a752b2d6acf6d0c46d8150a5156cdf87c0a05af73a41a6617c45ccd3f5abc11008756d9fc4c5370499862d68d57a24752101e5991d765cd8540a11cb3e50f9125d4122e9139c535be4091863a4378b3d099e5d412d5e0183fdef16968b671cf4eb9e68a8316478b04c1b78440246fb23098e82269c2c6ca44381181c3c67770576347f1c2429b18d617d2911ffba008ab70acce9647f50a14ea7fceb01360a52b12d667126fea49ae64c38327f1169c4c689366aa922d31a79ad32e95c4492fbce2beda8ceba282f6c0cd01a011f90638e438c6fbd31f4495f42e9115d6e8abdae8b1674bf2b30d5597af13f741393a15089647fccfc91870c721f59c34bbc047ce361d8f8e6a6e2a452d5edd90c57771db4c99336d39b4cbc642c55470321b44d4e7ee985fb17655c89b108bed829f7fcbe45f7522701bb3fa69fabfd72376c70a9291c0e69034655f945aa5a554eeb7e7a757f695507a4d82dfb00003156aff71e585a6792205648cf2cde2e5f0e0abe5bc82d2ee6b5e953ed2976a2d0b8bfde5191fdadf33233cf175a25e1f87597f0fc3b368c84d0dc8231116f531ff3b7f76d862226d878684ff3f29092bad8b8e6edd6f76f96ee0b932364796c79d57c6eedced0f20a26c3a8a3793ecad660313460c2ab6f50b0d2eb0e7c7e6c9b83065f6aaf437be4bbdf40579901045d8ed52036382b12a625a867e7c1c4766e5fcaa156923357d22f84abe70f5f98aebe24cec75d76d09ea74c7307e7e7f1a8c1a03b487dae846fc3a5fddbdcf42a11c271428832f75ce5a69a84d75520a0fce99f6976791da453fa5961339faf61591e3f0ba71ecc619f0ca83614bf746bdc41252552318ddfa6db2f96373cab78cd83c3ef1f95125da0db5316d8bc8e52919b6c1bee3125670803f8a2cc6ddf47d23a08a35ba7aa47b9ec316a73fa6ae9baa43c9e3ea2b874826a393b9781e4f77a99e320f8ef248bbf9b87c43bac44d74ed99993059a807d4e30a385b82727011219941ffb36b2d3a9554d9513c870f93dddcc50b01428a5025c0c1b11f2b8b0a44357854226a772e60ddde50f244b5e304272b2e2e07a236eced59c932c7d96b49ecfc5ea90a11dc60823c5fcee41d53d87b808d6575cfccffaee1430928d04b03360970acb5a7d78c68f56d959a473491c859aab12891f9179214f87c773645d7de5e7343241f2e53ecc1ecb90737550f5ee2e01030a0d8a01b70772a8a6b1f6b57e87984888a11507d7cf826d3938f633058030b5e40bb030b64b28c9006e74d7fe6605fab09d9569fbe090ac8b3443c84deec66c1997a17e8bb2c5831fce8b3dc39eab4383fcb4b1ba893e57474933f1694361c5559f0c3d4e4e4a31943a4641a91dff59a8b79ed2601ab8740730402012d1241bd12eba752d7538ae07eb05ee67863ed6c75d149b4bc253340301e0561095b76ce9fa91f232766d184a58e562221a4496a42f9cb16e1c9f2339c3c1e9f8d5d1e89480c9cb99f8ec5cdd1f89e181dfdac23cb54395d74fb5e4506bb13263479261678511068a3b1c5b0b74afd33b506329ba26fbc5600b80673c5c8c7473cda317fdb4014ca0a05babd7eb12c9233092dc7ed8dd705e0bfa447aff44796d88bf846d46c459162a1d796dbf4257391e2a6c386949ee79283550f09d926fd9fb0dc8b2253fb42c22519c0e8b44cdf7631dfc03e7bd933e01cb701b5799df1573f40cb0ffab6c660ab6e75b6acb495d308f4dfd876687119a49a4a4f35bc3e6eeb4c5aa576a2a82da26a420c34150df26d140447dcd4556e6fc9e478ad2de4c27855255e1233e6145521cbdf51b4111d43d57d65ce963a6022076ff4b1fd7bd96d61cde315ca4436075addcd74a889c2b151a88c8c06c891668a991a2c06fe51a87fe33b7d0523fc978301f391266a558208a3b197f72dd2d8ed994e778fecb5c3e39645f0300a97d87a436346fb273cebfe9d388ac99d73159f45a514c9d6444b2f226692578e4a3a965c7a6e1af2b6d81065aefeee557432444f6f54c7c65229ec99c253e345a65c0ad95ce2da5cbfb63adb1340901f9f0cddc179efe197b42d022c487d3f9a52dd308b6e68435fcd27a74d88b7a3c7602b451fc3c4bba2fa4d02d4e19e514eb91a2205c41c902c14ac1854ae6aa819954d4652bdaf6c662d61fabebdba6f212296d37dfb96a0507f5ad368a86151e1836256bbcd5a0631fd4762bf9d7294fb9a6ef6e8a1f5f7a2243d58496d616db789891f07723fa2b7eadea8bfa898c54b28358bed4302970e6c08455aabb978d840066b04bed3f901f6ce500511ea2590b73834b31ffbb1d45e7ff314caf78e11c11f936770395480553eccefb6b8de0cbe5950bac5a7278887133ea09089a00172ffdfea9e5ff05dc2f5ea38cc0828bede8e6f49f7449a834d447e2f105ecc2e9bf5d309d925644da89abbc559ab62f4c5b1a535340d676e4fe1c52539e0f2b5c887ee167db04bba983966e4cc4fa61d36ce6bf44328747d5ede4a49386bce35e11f2d8fad6f725e3fe4b51219897790cd6f51aeaa6ad7c081224ab492532b92bbcb75190e9ae63a9416abf10df5f91322b0cace5a1519e5205a203e4d24f661a3a04e641ec771090e65b69cfc7e590d5edf076e42f622a65564a6d0d84ff3ef11283f8a6dd420e553a729c0220b85844dfb3142bf6fb7f3abc2e13b79e3d940a1b38c78dbf3c542f1b74777c7c8b27353995961b7e5d046bcd4919ac760e51cd1dd0a16710c09ecb740d2af0d28acce26e3ee502dfa4a5d1af5a7c8b19ac3befa39af7757fe2df165ad5203d4f80958e6d39741166e51c7542794a8391fd7b9f877446629a3b43a59c124f9287a7cfddc6f65c6375d6c58dc6706c9d33c8c68dad6b597e8d6990b435008bca1e238f5e6e7f80326c2473688181992ef5aed5173f92d9c9e02b1301980c09ca33bade20948bc8ce09cb3194ac3f76eb623969950cc2728da03d23545abfdf10492a88b7c41e87ba5ba1e0c459dee7ab3f6b6a113df395e8cffbeaaa158b07e766df8c353a71d531a66f3190f12dfe7fb371ce786e26c96d8e726cbc50cca0527f56823575b24f94e2b0443d3aa2f67681c71f089eb21445893d904a782919ce9bdcdddc2fea3c2fc2669cbfb4d7efe92d2869c6294e9cd6090277d7b8551defc0f481c1ec8fde08cee1573d551349d275c568e24d44b1ec719f006cbf5fa45cf0878df5e1194745a13eb2e475ce48632d8cd65cc1af79245492dd98e3ac6ca1e486d68c6ef4ebe5611e5ee9e2a830c03b838f76cff4ec8d4146eaa56ad842aa2d9a9009b597eb216d97c473a62864e473aa4a7a41e36f72bda60b3ac85a88efcc15c56ec2f5e09f475686c707f55c68960ac92b44f40cf62f9c56dc059a2e7acf2a649792979285bcb476c7dbd1f04f72eab60d72521cb14b7b3938c4b23dc0c024f36270ca20fea1a7265510a80c95fbc7d1e83777057df7c48607b78453b7eaaafcf71a75b0d15d181aaff1b9e589a3f082e30607e0f9dd9b11e912c7b77ffc2227a6b5f8787333a33e9ded1377faaa47c7163bf37112aaa696611a9ab0500be9f2ede99a1fdd9024bd08c41fc7e225aa298a5431bf836367847241ea3462cbe9fd34b47b11b2641333a7bde0c5585da2737f440c3703d31e5a46e77382c631f5931bbd51144817c371c3507a301198bfdae38c930493ad97f76229c392b7dabb87ca91aae93e5f4b6ee923252c27dc9fc1a3e5693ae8a5e7eb460eb9635628c75ca9e255504dc981f38d01392b57ac5551e17952d4ed62cb0e62074bcd01057eefa866e0bd13c1ac34137f5d31c73639b979e386915c0ded5642f4bbd423a24135e1d5c57604cf0a2ed4e0fd7283460eb3d95935d6d7c6ef87ff7f881086e84ff5a0c2a76fea597f58f22daf2404b6749cfc01542d9dcdf694950e303133531a4831713ab0e22288d68f58ca65dd463aa36f3098c61649a849ba9b49b37f01b6f87c12443089daaaa847a54cdbf9b81d27742a58799209bd0cdf25431ae2bb5c76b9349eede96f565ca1a75d9f9da08b1c0f3b3ecba31368094d37e299f3686fa70cc333e916a946c2a0243c0fff3e2e20bdaa115c5abcd28f221236626d9b4bf0654c4699688a12b0c2149ee894ca86bc808c1788f963000638dda3b214723a23a680b1864144ca88a7ecd58b06bc4868396930351ff994c042d2eef04819e1bc68ab2326fff98506723cb22d175b89912f31fc667730613dd70ddcc81a2b2b4bea7a7afbde6c656d656a523d063bb6bf3252746894a0b71954ad740dcdc9df706f16be3d51d9940df8e5068cf6dc655867eb0893cddabf4e0e21f418f6ca70a8312fea12af7fbf5fa43d3fc3ec02fa135412d8c77b2758154f29fddfc0fc874d170cda643781091bda36583a44f514778a77d4d8e44efda8acc9df9a894e4fe908dad9fd2cc257a660354d57701cf9d6f1672640ba84430c970d89803f59f066104da902d9239051c6196ed75d440dea860cf1f0e41db6d467a263652fa918660f757ab8f76f43a9c2c9f6a123aea50bfda1ba59f45158276c1fee368474cfbc82727a6b223f6c8c8139b1b375da68ac09d3c38ec11ea20402f8a575e32aa1ac5157f340609d6606421325b328d96b75db8999f27ec8e949d0aab8ed1aeafeda510f866a1564a28b44df540fb274c82410517a75af123eebd397da7b85388dab9bb0d5a8bbe36c3a329120a60313f41fe04c87b25123a7489113a42ab41238b18f20886a97e8ef5f7fb65f03523bfbdee890ab8335f14f56018498002f68f76e48c8db0ff78676cb6e428a5acc9e4a978479c475c5f1fc54f89bede73545c3eb653859ec8b3d2ce9da2a5319032886948da549a4b7458ec06ae1b57d3d1f58507b5ff1b7675bcc46714e98ea3eb2022d33b6dd2b48af6c2b59d56cc7953161194a67962424f67b940dac453e8d76c11e61d6ca4619f299fe3080d10034b82ca7b685ac26d26690548b40ce7ce7ee18cb6b7d3f2836c31c80d8416f3f7d6694a4d056f84c35d52036a422d7caecaf8af6f8fdeeb50d1a9aad0e6a580a8e7e20ff109eaded5c2e6f0d404db7b0337aa3f7a9c3821634ad8bca914752b00c3eb0bea5a3f6bb3c6da9a63a299a704df2071759bf910312674a8a059cea690304708a68c1c4cb03067d1500852ca77fa4f3ea4d5d539dd2dbba4c6b7dccbce31d7ee542a2fd93c49b4e3bf30e6491661c40d539c3618bb9b64e8bbf70159ce2db28a4ecfdc90d4c9c7e8eeb03e9d62faad7f0a58db464a742b567dce6f186a8eb941285abcbaacf0dd0f20b419256e4e631efc06bec12f276a4d1e0e09997b92fb54f6e2843914b48edcea395b6198479cf475c2dd80672376870574b89ae8c841cdf1b3a941fe20744ba501f4fd811f9b276fd69d6e3cc6f70019be52cd5baf043a992fe93eae85a382db73fcb86eb75b646ca57c605ce38790863fbf42e3125ca4f4f3cba57b5decb1a0bcdc0d51dd25813c77bcb754af127a42237acf82edd1d04ff33a65b0820f7f9068b716e5dc595dc25f5b5f8fbb798ae5f3821d7f885c58c5f6d84a2052f32660678d214697251e44dd836fad98c5c2038b4056652011877b63522e8e0368af61309e731ccff0e22f3eabbd069e65ae58ec50684d94e501e8333fd334a2f13cb16bf24df8ee355d19add2464dc2a08eb16f6932046258f1ced373fde7929e71e2d254ad26a39046d2a1188e0c6303af6ed166c88d0179f66abb7092da18fa223c260ccfee2c0b837101cea345534ba633d1a132ed7d59bb6494e60e673dc4c775e7aa37def10fbc6220eb35098108aea62356e3e68fbb3418d87e341afe685b322660d5a1665e61904828a13df56b0f1fb0dabd001433012a6c0b8dbd60e081eb3804811eeefab6ce5f3256592b2db917ffebe817ba20ba9b0d6fb9913eead90bf7dbdd36deb281e604df891fe66f10bd3ff3c9408d64a599f130139139e33ef1856b995b9a7fa8562ac24cace4178821b4fe26d7d6c9255ae525cf5c69f2d8f964d9d5011710786f2bb817b04b236f1ed72ae3bc145ab18e0a7642c6537b5df41acd29cc5959256bbfb5cd7b5ea6144e42fe5f62c916a5fa87628dc3109a5f9491cd9c781570fa155ed6e6cfea0dc50de10365589c964bc30c69cf86fcdf84cf6246b4efdf90756f8c69581e720867bd95f0828d153207337c5be099841edcfa56c0eb1821018c5ba2fc1835473241003bdea7b56b1701079ffc090f7a193ff44621aad1713933fe8433a1c0a5164719e44e302cdbbac79c9a09ddcab3cc261cdc1471776eea49ea84e39fcf444494e7705f1f75c221230bf8ac6fa368bc157977c691c2e9ce0a16d28c290e1979d2332697db596a120baafcd045fcc45fa4143b90aa16dd6f03ebcb02929fe2ae68709fac86790924c58c5fdf43de8059fddb38ec2ab7ad3a2d3cef3e539b65087437095a3c0767e2d4302b0539783dc8100b44d63f79fc0d7ade702f876e4aa1805b67bd36c1f4e4f7b1b4f18fbf2fb89584bb607d8b23944efc2abf960fc119d3a9bc2fe4a12d333ba83aa290933cf3f73d50b43150790d2f901df3fd6356ab7292367c94923748832fdc3fc10fe1d965cbf736e82e2a970a5b75fe33db6e56840758faef50524bfe600cca5e97fad1abe7fa495090ef51f26abc543ac4b2f84e6f572c820e907e4d1e2fa47d9423abe2b70f509906d5ada4fbe24f5adbe7804c95a38f675652be6d263d74fbc82fdfb8fa109fde762c202da3b9a197cca881b7e2ab2d7b0b618aefd2f59ae79e72ac1de6730fbf6f86294e7c647e23fa11c33d1c78bc809a9bfb8b5e8b1c13c7fdfac4914c47964529b1e5c6d2cdf60bd63febfd039133f42d68798dba9258e72cfa10838d6576cf301be2ca6e8120fd56de945f136cd892b82b4fadb36866d486add427001f13c690095aade872560fbfefd5120a4b5497594152aa907bcc32a7599ff0600906516d1c8f67bfba27034a0818f0cf56f2c81fc38e01667e63a8cb188539fe900968c1c23442cc7e5ace1adc2a64a408e7828cbdf4c12492794dab66abfc6619fa99d6d9b614d803d91c8a691a2e9651264b99650787ae50331647869debe381f5410755e7c3051ee8b97c234c93c572e7bd2af821f7f2b898b7e8872aebbe7947d48718d9a4deaa29d1db848c9804ddd05251ca1c17e9288204ebaca3a2e8484e45d072e841db835cd83da8aa6ff373919e54d061fdb5ec44b53a4c644138b9cb575ca032d2e1b357f23470da7da9a8ae8bf30c3b14560de42e09897cf575ceeb9c1235269d5cc81b582f368b1482350683b395719b83bca3fd047a28b0b5743f769637b49cdcff16cf6c88144ee54ffc3de9b4e71729097751ad51c86893106303e9f5de4b683d9eb379149b18edb505d403c96d429d0a98a66d79e4ab6eca8e99c92008e7e71a2b44949087d41b38fd944221d5c183de51928e826283b38b9473f334797c6a20b51f48c5fee2ff0672b95028ae3645650c27315de362f0f246e981fdc738b701bd9ef9cee735e9c447b3a0a8dede719eea50cd6151e16a5f4fc01447367978e6f425464b6bc50e99fe8c0b335b2ac7f9ff7b43d5fd5a191ad66030cb880da3742719a115d84a04bf7faacaa7dafd97340f6977eadda002124ba8d62a13600c06071da7435855ddbc821c0f35695b51eab61da13fd366211b55c7edf7f4eef8654418603cb6f2b303b6876643493e7ba3185e89bf580250952ba08573b00332f2da0f1bdeb5703348e37cc4d538515f20d3e9c3521d28f429e55608043c96e983e00d03f85298eed222982aba500d8c3811d2a5b094b646d31aa7204d46e891f5bd1d0be11640e9811d9ad7fe7aab816bda718c7cd2a24bd3111f5022e0fa683a77e347396974aa14422a5a99f7db4b373922f92be04eb8931030314bb335c85303f2c30329cd31b898557b6bd509d3c999ccfbb52f26f09b3e322cb533a716a567a52ab7660fdad02a88edb453dec855dfb9acdfa46fdf74657a8e8316866770b481c0cbe5b2da96837564c29a169b77eb9c9797941173542966d6d03cd2bb218382c287e3a555f37d7efb528df079f9b57a3d1d35dbe60fbb837f5915a73f7051e734fcb1dbdc49a04472ee5693392d9952a6822455998831a1ab1aa573455589918ec9faeea3155e96e528f6ee3f942262de5e5c4a52a528fb9369fbc531cf816f81f352856bb173ed081f467f76eb6858c7fb6163c5a0dff58b3d0541f220b934208db564175b13d2b33f5da3e0c65fec70550595922ec96239123a412304422d58d36019ff7d7bfe3271054cff84677d6df314ecae48ccda278f91a17e8a9b99248c6edafc6d68906dddbd4a2ad58612458bfffbc74c99c2848d6bbaa7d500eb92309921f0c0048f1511f7bc32a7bc4d73b31a339c5d9449337de98741c65867f7fba2186819006fbd262af14f6194a88821d363ea8b29becd662a50f0ea1eea86c0b7f2fd551a2d83b70be47805f14a398a017a7aad4c6988e6d3ed5caaef4a5fcf5b09b30ea5200b52e22d53ba902628a5c966f7cc8ac5327c7f353770ef5ff8b39d9f645fccd626222156f08bb4431f4ab5d73e8f5c19266d31e12fdacd69614d8cafdca7f5b333eba20b4675146d9ad2f1956605890e608c95358e6dde684c0b833edebc45a63a301a5db2032f32e02d51a7a1869378e9b02ba41844b84c960a63b7a7495d3ecc5facf7ffc7e22dc714affbc727e04864f03f7cc94a73ff611c0ab7aa3e0c1aaaf9e9d92cc26e12233b155f182af1f47423c5cca482c896f557eb2480d01c248b1fdb855ab6df32fd7e80c7f00286447276e9616d9d2aebff3a6bf45e520c5428af98a446d8c0430594ccdd3bdad45f447090c6926b6829044aad4aa18ea461f5d9f1d81a0e5f40ef4a2cd516622d4aea889e3155ff06939386984a0666aff4d6237b72d4a31920cc692cc3ad2f25b0af9f689accd5b7c8542b72245efff4fb77be31787419a8cfdec6046d07a42569ec18f3b2fab6926680da5ea297352f2f9cf143e5282d4c8386ed59076479790413fabfb5a951e66f392955c37f09a09aa7f6b1d4505d23a2bd8d769fcb7e8016ce2af8206c8950020b7f70a8f87c90a15ea2de4510517b5fdeffb79c2cb9b66a5a2ec5fb204905c5e03e6461ae0ff58447eb2c9bb5fe4e5d8d4aefdf83a0e3f39ec725495a7b08e82fa1a20caab2061777ac124d77fea15f2cd79b5b539ff67328561a5a9432f651fa8a5d446561a57ca56f4384da2ff4719fbd70df6ea20c717aa2040afb62820fa61cb402637385460c8d93b39a8aa22f217159fa62fa649713b005692c42bf4c1f35cab5d7cd97f9350aa88a317748a5c8bd09bb4f7c9c557aad1e690a1d8a48626ea7e5605e595f68fe35b362f66edc16d18f6af80c3e9204c24fb9638842cd61ca0616dbb676ad997d820898cbb190aaa930548a04c0f470da91efcc9d800fa09e21603bd355da64c1e009d13e61e5960be2bbf613659c151c99e37f44c484ffb6c020140ff16984aefd341af3b3ddb9c363553deb2fcc73535675c840548c90ebeb5dcb7486a2afb347007cb5c89cfe3676c5799f1b07015d77ba79b7cab00b86d50f10d317b4763a99d97d138f9bc223d6c906eb6f275a0d68489f56c503cf2b318fd9543e22bef76053cd93d71698bb772758372a0d1cc35239df633dbd8ad5551a558e577c720b79b43b6b2204675709a1d56473b4e345ede4c800407ce3e94e6b548ae796d031e7ee159cdf4588939c4001ec4a53fdb785ec9df67c8daf5336278cf55d6f6878e789f94fa2e2e64c92aadfb1e409267bb78939938ec5ada5419f5a85253bf188a0e9a7c6877ca0d617fcabe36f69535b52099eb41b1509dd16acf637f38ffc34ce871ec029a88326b387f839a80a9f4b350e6a153bf16536eea63b5d6d0edab020cdf110b9b75b3c318d03a990749600a86d38a32007bcf84d8e8848b732e292bd3584e307acf5ca0b42ec6c6a3595ee2a92655fcfc0f119eafb3f608105eeab3f65dc3cbf424ffd8e92c49266b3f50a803adb252488de75680e68fd7b3caae90d01b82043c9ebddccbc283adb8415dcb29d144957534c3d9c448729ede431beb87a0e750999f46b8026f57425dc8159e2802fb2f52c1a3d9b1b1edbaf468628b55fd14f9268e144506a2af4dee75971a479a30875b560b5447feccfc6601dcb1e9ae213aa3ac2a178d9061ecdf869f559fe0ae77063ce68377f811dd1ad8fab7f4f3a9deda49875fadcfe828ffb518f137609aa9ce144caea2c21e353fba06620d6d44445f0d11d735a539384770d9aa5d053eb71de6e4fe8dfbb628dab39711b5776bb4c2dfa27d91acde18b7108289b9aeb7e0b8c3338271503c3fa741ac60682565a204019e38a009e6d32de5179468ed59759e84e77a6c828e9949ff0f897af54148fbd03a8accf0004516e38773416787e4bd79a1e537cedf06b10440e1f5873368aee654845e6ad197f12e3021fdde69cade7cb3c22bcf0daafe6ac61e26ed8716438be8faf75a4a05526c696dc72da5fd99e1198452c3aeca01026434af0097f7609632a00eab685e8f51dbcea91c546fcaa4f7d62b72b5facb4bf416d4cfa3e3ef148f8f19d09b7cd588b2f9753c5ea11cb1c00d3eaa4a2431d36f479398859248e93516ee946d0df9952e91c60cf996326efb01fc1c8f49a9aa5e2bf2bdcc6d05c125c6118e33f7997114b2e3375cd55f37dd5eee69cff16b42eed4fe15f780b93b12438d4ddfef4d8ba3629eb1e5f69ae1a647ca5f2f4653e081aa0c1782f42fca04e9bed5afa01e13f72f532f6514050e9873a777fad4ce23d41b3be0bb9e3fc531937e5000530d9cf22e24a9257ad58036ee7346958e7815647ab4dfddde3dfb6ccea4a5b4785166ab091813cd1c1d73048af1cd2b44a081fccf5a5f5b74e5ebecf917e95e7153c366c150e5a13e97be355aeba24a67764b5287c77bc02c5bd6905b0919becaf270d9297267220126fb81d1634c95b718e1740d671b2246f25776563ff248c690dbc10cf480b201e75437ba6190363c4b2505e4eb0c18e9642743a3aa7b20ce4fd6c45a78108db79e62c97204e146a535fef1f8099fdc0ab9f677db4ec04b2b1e1b72520bc3d30ecd6c9a1f95f7c3cf011e340316a510195c3d27ff3272ddfc1ab803b74d5005710265d4cf1e0a354ef80b404df11fe7d48b8e2843cca34cbd2be1d89b6fcbf193d4922bb2d974a76cda83296753ce616c6fa155616f1824af17148f583261df285a500ed9fe7786b9b6752d4c038013bcf7cadb53946b643f305460e72e3546a52a46ccf82d0cbe02c14e837d411cf8e54f073b91e65ff33c4e033a5011827d982065b06d07bdabfb8a1fa563884b719eb734981994450b7c366c6f362391f13a1c023490415c8fe69bcde79feac0b7336972a6b9b7798c41d06ffb5a05f0cd01c96a5bc659e074d823407eaa0a7744c8081bdee6315744fe248b8b201052dfa70de34fd8f9f0b5a05aca3e2a311e91a358595dce897452878e7c92786ca702dbe000a7a34738a44771f17df3006455e1e0ed32d9b0f85c9449365349d070917cf955bf991c5b86d24d47f42a1b9c8d42a383efe64ac02a768ea39e99ee529607ab2c2797a80cc5a42fc98c3f6c91a9554848e492bc4e8612767ec12e5fe3572a42cb36d09ebd4f76fc1918f38c2f9bb5d911b0a74c42b5e541129822b4d6b9b5612c5a58250e0c3e7ed61296c201e0468763b64eaa37357f0141e250f273724ed40294032e66038db757e4e2483f1b293f39262be2bf7cb0e4446ead84a538452a2603d0afa240025fab307e8e0120412cff04392592dad98c9f1c0284203214c468e21074b9d5a9523a0f26afec614bc9e9ca91625358b12dca243117048a655083e1542740e43539cff5ca5db0598bc94a653ebfd040634952acec91bc3b4120d5035345b37ae4d71b933480e1dad56109b5c387ae269db3cc3251dd3d0383515d70e693e1f9af8b5bcb2c9842be8e6510f983348f0a2261bac6d34e242cf577849fd3eb5fd8d2a8b8d15f71bbe82018d0ff170f47d0b63588c7b1b2324fb4c05aa17122cf26dbdb6f60a6d81bb87ff13341a07106a8efc3ffba79fdcc85d12139d8696f68728cc8705c696ac120d57900ea4affa429a7a85e248e93dbc53609070c66af9d0c16dbba056027a0e2f70accd9bb796f041f8f1e35eb713299afe47b69d5c596cf68b3ddca5f5f705e07999f36d732f764c580c273b125580fd32a7c49dbca3596b5a671fa9b3341a43c35a342c9c7eff1d938e19c178892ff92adf910416d1c7c69c49c313f78c2c9e2c574168ef4205cdcb8336a95d04d1435a6de98d9b528311d4bb5b3857f8812c1ec112565521e41ea3ec157cde32fada21e851c9ab8889cb1e3351eb50804222a22bd2849856d173f5bb8aa0089e7af97abd69b2fe1062b814d86a62107a8a81c1e62d71d6383582612a6b68a9eaba3a4ee24cb4c278f0351d97a5034204de6c2746c861cca2aed5921e1caac6c6ef1ea8ba1a9719c66b0cbe46cafb3d04939a50a9b08a0081f9afe5bd16c104a54eda4b5c4c2eb6e08d7e28af016eb2a1bb1da99422efbe855ff1079b549e00c558987ecb970db44870123eee1185238d1ed6c83900b57047d124f75456df63c9bd8e2fe8ebc26592976442891837fd591f99f6ccb44460d390af91454e1d91229c19e52990b3f39322ad7a622fa747dc35e795d8ade61d2c47ac1a51a256aa28adb7113bd80c1df216505f0603c4564653af24684742836301372d59fb9c123284b61cc010d5b42a612c03497dfcccb9d6a722cb00c649bb4feecc2ee7570a66ca33ef2a2de12fb68d4ca73e3ce47166b1aebe702f37b0f076c36c0750c14397b8ff6ea6434d663ef7f9c565a46c53df091db7972fa61a1c7e3e4a1333f13ed7e6570eb0b04a4d37b928f9c39ac33ef1ed525c93d29206e6a17394564ef696fe056bd121f13d292257bd1585657ae1075d0402bbc47023ba26438e30fd3e6dd52dec4b5fa11d4f422c88e61cdd09877c2b676dc8a9673bb595118c5b2cce97b4d1cdcfff41e43ca2160cd4fc074608ee48aac15a98b670c1e38779ac32014bc622e0a6db18fbf76449daf3dd568a44ba144d152d671e9d4c52ed4b9e1213bc206a20456248c798442b777bf9a7a61126aef4a4df24ec261aa371ebff706946fc91852f10d5484dfa3b3141f2463793b591c9408767c7338f83768e9dc7aa1e498e6a934717b1a8dc6dc9349304b1dedc2982e6d22a2e628924f3ed3913ad07e94483bb400ae241c0d39ee31e440e7c353797134bc9c22637d0fdc3e3aea4fbbc3112f15dbc1fbeaa115ad0d7cbd88b45c9e1e84fd86e4c4714c3844219d55da0e3df11d1d1c0ebf06a6273a848ec0e1a0c003539d62ca618a5ca921fafe325f44bba3a1e16692032eae46f03511d713a3230df6c73a99f516b2d0c5e6e2121b02169c5a20e1af45c1fa382075a1e936e480c6e56e686c2f61b6e8489d86db713ce0125f5d1f2c8041ef078b5a94a3a34654a1a63213b051cf75287d81019aa77f26d8ebc8357800476da419abba7ebcfaa85b4505c3ba3389957a2bcf993b081ca7718447149f12866367eb7a28152070e3b0c0bc3426b7ad3db1cec0d8033244a2c28b012b93ab397899dc4d95a10d47207963a803a4c9978392a26afd8120c8345da3ab3c67f7d2a454bed01047bc6c9992c6645fc125503b29dd544125531823951f7db1b0bd48b6ee09b8723ae96670eeefc1e22a9a9bd3b024b822b3100a90f5a4b39b24decbbaf7cda58da09c7da56f0fc98bb79a9c5519860de330c41a89550ead31926ef138300e0d73983d7ae7b296f189d8394323c1c67baddf548f1af95017cf7c032b3a02ecd4d92b6fed03cbc546b6629800c4ab457f28f28f334f17c552a3dc9c551c2cd8f9ff93313e33444f95a70a7e12c48382cb6d5d352ea442f83c72234530a9c7ab367cc3cd3cbc267ad4fc21b5d37482d822e66095559c7dfe2d4bf1bb95c955a43853f223bfb22f8e5dad5b6dfa93df67ccabddeb87b1384c8f4165455536086e5e497d068356937332038190fa84a88bef3c9bef277487516cb771a6c2a45554c7996b5184dfbd6fb26b3a463963db7a49d9a897e61a3e79d0c3bb5f60d1a5142a358606edd7bd9bcd280071f8edc85d15e866a33078228c4836da79bb25c54fcc6494d2b9417795b8af15edaa36be2209775e0c8bcf1eb9f9917f4c95b07f7b9072795bff70d1f5f072e46fa522870eda47d67c82e639310c79be8217b3a7a5c60b6fc4c76850d9f5be1ab13b3f9b158923965064eaedd6c71029877686577698f25ee4c98aa97013c456a39d91ac655551a390ba9adf6d50ea34d09119cbfdb08919f2fece79bace2e8300a0b522f73163296418c10f2e9b4a932cebb036a9ceaa1adb3312d4e6ad53ee5f3ac8930a33b12c1ffa87e59c35b9c7518da29f99c7e417ffae8009bf4196539307c08a12797b5e0c54b674736320b1d25bc95b0044263451bba8d66d3f58aa2b9db3922e1c6d77d5c57d013e1d6947a0dbf836c65079ac023d9c76ebd5ce73c39f10b815b4be3df3ff0a709c8f9b50af44cf411b1a9534a5e282bb655741e9c4b91eb873a89a0759d551b7413417c47ec46524d7a1e504df6af66a2871c87aa3e4fd3c7b2a78036bfdfa80f04554c3b51de075df67f0a863cdcd5bea18eecbc8a3cb53a3476ef62f6b18ade93f92a0b709f0d8c98012561d920ec7ec061e37b7c02ebb4cfc51e6f918cc04cf3a8c383a9f7f247652420125dc8a3c87717e9239ce3618af0ada416c642b3305411b924c17e62c1ea43341c6390a6205bb0a870e4906923c4e489b4a0a5a5eb5f332f6a1d162abbc686812a1d8790a34ff6fe3db25d1fbeedc3bc282fcc51cb6ea087e019b166cd8a10304d8bbda5ce187e83b61ee5473618f15cd4dfe865e85e6ac37c26c8535560bb21c6c10ab34fe1544294fcc5126b2012b989de4f7a8a5cfd9460254de21cf35d7cb743b2219663cc8108237d99557a211c6649a9389200747d411ba1d0d0a638ec1d272008e2efa8e12fc5010d33b74a02ec10fc4b38b791ea8c2535aec63ab2d06bffe09f79e656d06300808aa6bba68c07549e293f28b4167300e62fa0ba7819ffc2d3fa61e1acea7b504ba07ede87a1502c023bb2f38ccf68f83991cfb1e406af9034ae539819860a13eb839f9c36991a9ddce3edaa5bc178b8160874cadf225383b79430677ec0bc1aeb10ad81a9b634cf9b0a4686b20e7985422c8ef68bbd5face531e391c3c32eb47c8941bed931a5ff047590d81af691af04c3a63cf21b3f2a5a0ae12da842938ff8d4d2773729b7dfd0e00ff7e20ef33da3afcd9724140c55e0ce28998aa3af2ac637ad26d739550aca37dd3968f3eafc76ce66c7d2575277b6ff7dbc54117797f9f933a6f36bca2e156a0d84938b6783843fc876fb45ca16832a5c7c500d9f75fa26294d6c996b14a3e509f67b6962011caba58bca8876015300e2273cdc7c85f902efe3ef13bdef7c65610385e2412b66a2793498245c172e025b0f86279899d2b8be42bb2fc92236ca1618ac6e9cfd52d7c0e53ea7266583d0fba133bad8390181e7c653bc9dad587dec0fbb411261aad819884c07bc4e851afed82de4b7140e0746de8669cae5fe2aa6eb6447fac256a75405ad3207a00dbd03d710feb38cff846c3c324bfe53b0e7880fc57d43bc97b6be6f67fcf53515a927558c5bb2a61253478abe87ab6519ea890149ba932afe64f0e95029ba86dd92841faba882ce70b6ff5fd421df886d11d99babee11ebc09f57464a8c8727e1c7f3fe59f91cc8e8d807dfa49428f81ab51905bf50ba673ab05f6137e4e458133eb2049eff069b7e078cee8e2fb43baef7100e66c1209ff14ab2aee79d4ceca9f2fb3b4cd840b1e0f6250d4dbf44234cbafc7646a6438758f0585835a1b57ec8a8f8758e8010dd75ca6d0f130466541b02b60bc851f6fc17a003c3ddd35b9cce2889d5064567446e21a900b58899dc127d0852d190a72d858f76744cc34378fc4c8ad62fe28e70ba95fd19c08db30ce8f651299da272a07849d188e7dc524b959b3d7efbdbf7b797ed1d621d59de8a5394ff7c9282aa60bfe6a3c2c951286d94dfe9a0ce8555698dc27c2536db906a5d4393b38f6293b273be420a5a1873760d4cb6190459faf9123950c4ad9595d28271a504bc6246f4d7b9aba2d68a476bbc0e538cdc7ba811e4c5ea7ec47a32872f12f59b051fd69efdc4e7e1d89d89b7aa4d8a1f31dac2dde83f8c2f8df333d209ca26c2774b9bca949491e5294f7b020f82a33bdd8aad28df14f95b84d9a8385dd4af0ede530ac55a0de3ebe00707bc6316c50d4890dd6c809582d46bc94890725b9f5e6d718d7b8fc3b97ee453db8a9e891b15f3490467f47c5cc177767c9a1f86dfbba1a331d10b544752fd7036b6eea034df317a7386c5b48da7bba833c96b3e15bd85dd7ef69a8ddf4e99573b6e987746a903ad93043d8b40e1fd191aed291f1ff9ae326dba808a935668342315808f7c49950fdcf4dcb735940852b738dcc4a4ce097eb8ca884bceda93e874db489d648c63e50850033de226bc0301726441a874b845664b9b252a2e40011884e533132db6ab57877e22cb2c6cdc20213db876abf3d274808e9df0ebc97e43695d3e46cf01eeb15c477a6b0417ac56caf70465967ca8f44ec8d025fd3d2db6cc666cb36c589a179edd4324862f0d10de90620e26625813c5ba4f6b7866817aee75e5965eb712fc871c7f37c4ac5d6796b82344d37250e37a833110a9084efa70586ea0dee1291fcdc40bd07ba653c8a8a8da296905e697d267e980035d7baf6a20cb359401fea687ceb97dd3d604af72fff6110722b01dabd1596b0565b7c1d0ad0cc14a5c40049b8e60dd1997caeff2b3598aec92b9c292383ecea28f88c79580fad8643ce3d557ee9a96418379539d8957535fe49b46f0c07c1af8ee655e7e4696177f629db3e0a6a423a5e5cdc430fdb0df36cc0861252f789bcba84c23464943781832f9df810bcdbad51c6c7ed9dd120145fd01a8fd282165e55fbbdacfd205ed3f1c2545284034ab2f8b0a74eed95a64bc6de05cf3de31f4c5d7a66279da451a706ff8ef6f7d8fbb838ce97403378ddc8005bd601f2bf05add54da74585806c8d236791db30d96b9f01d254528101a77046288fca9c0412bb9b9fce4d75ad74d353e21749fb5e1e2de44f958888c05ec972f7bfa09aaef861ce38474268627bcd453a6c790195c4f57f4556ad00c9c23798a15364c9cd0770d0dd58d175e3c1320aa19171cf3e88c82b0949c2faace5d4d4a8727554458bd82765a9b83b3e3f124c67378aefa3eb47c427648498f412e6ecc521a5f55e170823db6896d059fc8950f4a257c86903a23a0e679a9476f060ea604753da4842ef7a728da10ec7b930945c7ee7e2776bd05ba4e187a8551d1b289df399247cde63433357b4125a4b99f1d47e188e287c19fc7a017fa184a05beeb89bed1e70e8d3c2a53bc91d9367e2c4296e5c2fe2e4aed02914eabefa70b68fb53400bcb0eadd5097ad9506aac7d7352e07efd8b3462f704b29be1277f5345d8b76176c31bf0b7b6880fd0a4a97e98708cacaf6c17121ad219272cdc5837e19de21252490d32b01e8f541bc0b2e99e6be7dbdb6be04a14d0cb3d6acb9a6dfce92438739d737dbedead9c3b537785868321d05355470bcfaf175620f27341274db708194ac1786ce780bc3f08405c760e61cba421fdb98fa22721557ef91de42047ed44128cb872dbd68df2d287e87f03a267e5e9aae977dce5759545c4c4c8bf8624d0e740f5b80bc40df4eb1832b2d9ee2b87d035df0cecd5e3c7376b81a280ef2f25d4ef641416dca918c200a94a1568f6a5c416163ef6723c1cfe6d4e00d46e32df1c869bad743eb41e6af123d3da756847aca1a554dca55443f78bd5d6bb10db1c4787f168ffadcbb0177c222978c441bf1bf35ac8ea8a36d83d9f4e59d04bfcd377777badacbf051f4e62002253e88440d834dd0acaec7f81874e08771267481484c0af637d9aaf35985a5e1ae67287f7210a709eff7d32e2867713840dd4ec294740d41eeff168c584e888ac834de5e9034c6152202f6f0f5223156c774838f44575a4ebeb8fc67474b0c5dc863a971eb134046c3d43bd9df6a9358b684b4cefebc5bc2d1500b653549a88fe4ebadf4f328f8f9285954d975e1669f6d918998e3fa7a92d6a1d21]]></content>
      <categories>
        <category>魔方</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 打印输出到了 Output Window]]></title>
    <url>%2Fposts%2F2a2e288f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间写代码，测试 maya 工具，总是突然之间发现信息输出到了 Output Window&emsp;&emsp;但是也不知道是什么原因造成的。&emsp;&emsp;因为使用的环境和工具很多，不知道是哪一个东西导致的，一直没有查出来。&emsp;&emsp;最近我很偶然地定位到问题所在的工具，于是去查了一下这个问题出在哪里。 问题根源 &emsp;&emsp;经过代码测试之后，我发现是某个历史脚本里面加了一行 reload(sys) 的代码导致的。&emsp;&emsp;只要在 Maya 环境下执行 reload(sys)&emsp;&emsp;那么输出就到了 Output Window 上了。 原因探讨 &emsp;&emsp;其实通过之前 焕唤 做 AppMananger 工具同步学到了 print 的操作是可以 override 的。&emsp;&emsp;print 背后调用的其实是 sys.stdout.write 的函数。&emsp;&emsp;如果将 sys.stdout 覆盖为一个新的 类 对象，并且同样提供 write 的方法。&emsp;&emsp;就可以将打印的操作变成我们自定义的操作。&emsp;&emsp;AppMananger 复写为了输出 log &emsp;&emsp;同理，Maya 默认是输出到 Output Window 里的。&emsp;&emsp;通过查 Maya Python 库 maya.app.startup.gui 脚本里面可以找到相应的操作 123456789101112131415161718192021222324252627282930313233343536# module: maya.app.gui## This module is imported during the startup of Maya in GUI mode.#import sysimport maya.app.startup.basic# Run the user's userSetup.py if it existsmaya.app.startup.basic.executeUserSetup()import maya.app.baseUIimport maya.utils# Replace sys.stdin with a GUI version that will request input from the usersys.stdin = maya.app.baseUI.StandardInput()# Replace sys.stdout and sys.stderr with versions that can output to Maya's# GUIsys.stdout = maya.utils.Output()sys.stderr = maya.utils.Output( error=1 )maya.utils.guiLogHandler()# ADSK_CLR_MGT_BEGINimport maya.app.colorMgt.customTransformUIimport maya.app.colorMgt.inputSpaceRulesUI# ADSK_CLR_MGT_ENDimport maya.app.quickRig.quickRigUI# ===========================================================================# Copyright 2018 Autodesk, Inc. All rights reserved.## Use of this software is subject to the terms of the Autodesk license# agreement provided at the time of installation or download, or which# otherwise accompanies this software in either electronic or hard copy form.# =========================================================================== &emsp;&emsp;reload(sys) 操作会将这些覆盖的函数重新用回了 Python 的默认操作。&emsp;&emsp;所以才会导致 print 打印输出到了 Output Window 上。 &emsp;&emsp;另外这里 maya.utils.Output 这个类应该是从 C++ 里面创建出来的。&emsp;&emsp;在 utils.py 里面并没有定义，并且 utils.py 也有说明，部分的方法诸如 executeInMainThreadWithResult 是来自 C++ 的 总结 &emsp;&emsp;reload(sys) 的使用场景是想使用 sys.setdefaultencoding(‘utf-8’) 解决 Python2 蛋疼的 encoding 问题。&emsp;&emsp;然而实际使用情况下很复杂，这个操作并不能彻底解决问题，所以 python2 环境最好就规避中文，避免字符处理问题。 1234567# NOTE 修复中问报错提示问题reload(sys)sys.setdefaultencoding("utf-8")# NOTE reload sys 会导致 Maya 无法将信息输出到脚本编辑器sys.stdin = maya.app.baseUI.StandardInput()sys.stdout = maya.utils.Output()sys.stderr = maya.utils.Output(error=1)]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 贴图显示提示超出 GPU Ram]]></title>
    <url>%2Fposts%2Fe932b6e4.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近做了一个拍屏合并工具，硬件2.0 渲染出图并且合并到一起&emsp;&emsp;美术要求要拍 4K 的图，所以直接导致显存很容易爆。 &emsp;&emsp;然后切换场景显示别的模型贴图的时候， Maya 就会提出警告。 解决方案 &emsp;&emsp;用 Hardware2.0 任意渲染一张图，这个操作可以清理占用的显存。&emsp;&emsp;然后重新加载所有的贴图即可。 &emsp;&emsp;如果上述方案不管用。&emsp;&emsp;重开 Maya 保管有效。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppManager 同步工具分析]]></title>
    <url>%2Fposts%2Fe5e36cb9.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 提示(神秘号码 + 魔方) 596e27f56e2a0f80d9b46fa25b28ac7716695ffce82cbd75ab9e38b266a4dda13a84930f53c2ab562978774b895b1a673d2628d2632d575d7106b379b74d79da8e6ac4c5c07e6a89b676d9a78792199471068b5899d9854bc8f327e8925d84b5dcf4ea112165e2ec8cd95d77a8a8eec68addfd3fe6e673a478406c0f2167e097ee0728e42030b9fef65ab8dca92cd30852be1d0588348007dbdfab2043f0939c6c1a3b9ee6438ec414b0aa5c0433661adc088fa522e277cc1bea1c8cb8c15c30d092e620d48f18a6e3422dc8d96676fc31f25dd3ffc909e35b5b5a752541292a4331e7cb7463f105266587607d732d3c19f4e214fb48d692fe851fec86298640c18237312f04c7576d30672fd1b9cb27fded6c222fe8a10e985c148d02c01b32345fd54e246546c6dfadde6f85707334e983ed23c79c2e3923417e2afcb2560a01ff3049085f2c5a726662c3d5616056dc08379090e583a80d4d6071d4ab6199988ef32174983b9603b4682f807c41237e48ba691be6389dd9b1e8bd3c955999fed407987e29e4073db15a9ce91582e64847bd8ed107b9ae839b5b6d0b93162b13dbabe0f7238f65fce88a3a0a9afe9450a6201b105f3a1c84a96596b74ffb9dd9905b4a228e58aaa66db64c81b3d57f27391d15621156264ad58e6740a417566069c83458d59a65ecba5f0286245dba44de34a8aeafebd568a8462978c451e770f7dccd224ed7e83ef9a1d5d9c88da7f458176c082b97ea5f63c3dccc4716dc94a3dbe5f9dbc5239a693e3e5e476f83c73411067eafb92a444f98f252bc9fd2d9b0da1b0e754dbc42b63e5a436e0f97713cd33dd633f9c3eac3c1e51fb12d0d4b97e18913b55d9cda76ca0711dab1ee89e9aefdcb1ca0841af04b8806d065b8eac377d4b6dcc7ad876da7a9dbb9ebc44c967ca424b0f6310a6ea7f0d8868637483fbe6a158d58a1702287dc7a0fc81336ad6455318702aded8b845c3c23fdf345183f16855495aa96cdfa2fdc74a36ab73f361b5d42d4035a6053eecc4607b68c30a451ebfeb9b8ce8dfd3079125c7d28361d813bca74618293f6c5f5e77260e01c0aef9fc0c09ac00b171f452188db208070f3f41aec65835571e7751425258fae83318f1446a6fb82fafd84e6825b33402fb9091f99573d94c650139015c6ae83549a1076843734dcb6141c7247ecc85e4b89177f1891b16a3d332239fd84fe4086ec04b896a20299b24a03eb20da67b9dcb6aa0bdbdacb260099e0bce2d62bb07156f707993b70106b49a037aca30e0d3f1a4d39984be9de2961b8e9c1c83a3e3d17c15d40832a26b9b56c0812ce36ed3aed6a7ed9943a01025b476b4142cd2632413f8f00e7c54e8678abfeb7711ad2a21c7a7a1f8973a24eff0e72a5e0e9283d43958b14004d71c27527f590113c512ab639057a1c1942b19974f663263eb9c70ced3e751d6e4e04c6c3192c25a0c136608c6b7eebc425fdf35c46b11e38964558d10e87b0d5e278804520b4712193953370ff8e9b8199fc8219f367a239d0145224af085f190f62857af0035eb3d8df6b867b69cfcc08752ed628e76e9b3b7c3a2c353d697b528084796828126a3aacba5dadd76bb39fdd6e99cb4a056dc484232ab8424d681089c064bcc62ce272310d8aea1489901b3818225c50f0451e1d809e601858e26258e1cc711c5844c60d23b9b428725446eaa985e53b6f84c0e271f27e56a027f55c20e711aca9c0dd312c3e88995432a12a6be261143f247d0220e2fa05dd320412ee10895931ef6845567506f617103204e296a5b3287e2d81a7b4ed2ab6ce1af2337cb22d598d1b2da866163d95ef49667f2c1c64edc431b3bf4d5fe73fe643fee076aa65477f6c0fb9334b17701cff9e7ca6aefd3e5c8e8a570f99c19317c5292bd1763e89bca960fa5be9b44708e61f1cd291121adaf3b6c7646e034f2de10db3dcf65d4fefe6a1ca4c5d6eca190a8d903fdaa9a72c8a107139fe7fc180aad2fa77f9827ec1d5f046f89a45e7605b4fe431a4446c28756e024a008bb1916e60979b8bb5febbf1153725a5d4a8014cecd7a9ef27c993fdbfba5bdddb16ceee28724ea5c8297d141a0a843f56b274053fcb85f98f1faf423350f9b3f793807ea6051b45e6e22b11d9886382b30665538bfd91d40e68eec2efffaaaa402f14c6cecc62a7e41a8b33906eb7994e76f4d1ee8dc8d187f2bb1d97cbe542dd71236e4b5a8c5dad0f43ed73a970e0369324b2c4978796cb2a870390e95a324c0b9e05008740d20b3a484dd79f94211c6e6cb9908392556594d22471567bdb62f1ba4f15d9370e2e714a916c85fb09c248a44d7c9c8b17a80df80c31f7358220e746654cd8c45a2e4913e3a35a3131f47f7d01f47e5236625db30796ff18f5210ca096f90900d3ed33789294733c3b766e4f61853d0fc64fb777084f8a66ecd026cfb5621c2668e4c923d9b8caee54ec0904bcd9faa5f2c48d18e1b043f67018f03c8dc58fe0e7b047f3cd1eb5a031a00f48290ad6e6812bc89f77069845a334440d81f29d605151afff191c956e5f82e35b1154ca1f037f56b80e354b696a259c0fd4ded42a525fedbe9786275041f3ae06c1e552880e092d2eb56e340e93df5f5a2e5914fbc95c1f5452b2d05374051b07b9978fcb6e800b3a68889877154445758c72a6ec1581e93cfaafb5e18e3ccbe4cf15552bf06184c79d89faa7e96a4607f5cf0c2f65d467e597e98877a6c4c318cf3b76a84a0fcde4a1dc444edd2de3ad0591a2d969b770309084ab6977845457ba5b08fd945bf096961f7bf3bf0310fa403f63b93f8de71fe46d48cd87d0fc0468964f977903a1dbbb71d432468598ccc59f1d7d30df95816078f77184adf9e18563f083ec5eab2d97c7184615c0f08a32d1267b57cada53898bfaf428655fbe927fe47c60f983142725c558f072262294f4d454dbf8d117c96021136b55db527dc63c488b456177590ec09c8fc0123810bbd4aa83819e41a550ccb0ca130efe1aed7f911f34a5aafc9e1ff7ce20d2c6e693a892a4182538868d5058541eb47254b482e901b31d1ae319d5ad8f56a62d313ef0bd20d545613455b94b739fb8f32c878b20ace4e077460038b0ade08b9c5d34e21a6184dfbf66c9d5b3d22246ef47d1f176cc4cbb02c0c6849f0eb6bdde05630c89316329fb213fb9a6bbb59c82ffa58812e4b402eecb8815545927b7f5aed035f2de34f9db6e50517c898c2b29b348fb67673e557cb34245600a1ef5d6524af7ebef3e6f4af5d0dd52f0f5de837307ecb22be03a7d885746c4431e2714a26cbfb4a22ce3886525eab21f1d451c8500a39d8fef50cffee90abe08ddacbf5c2635e1fde73af385eaccd3e022d77ac143b74f953f530161bda8439643fc0b2d2539d1fa714233e73e47b8058576b6c24fa3780bc566c6b064fabff4875e086d237251691baecc9c5f4a8e1ad68f0d8fa32fd2b143ff6d430cc75f5bf601daf8c33d526b9d4ba0cfe26d6553dd663eeabd92b56054735c6425d6800701150b59d916b6c4b09a7e0f1f3179207ad474de32f8dcfbba42c7bb3117372bdc7059bca86427b6f3af9d3929129063412ad6873afbfe9063030d3e4a6bbeb6c7e66c721d41023a38cd8676e6a1116c73f9eb35439368facdf20f804c2520423be068feb1c7b506d2a9b4ceb4b2c0ef9815bf974943262756795ba773be31b29e9ecf2d3b5e6c56f83953f5be6a0b153bab753fca01d81d1b2480e975ea62bda1c124c823a2caf85262a08f28ef463a4e0cba72c82c229a986e3642da90fba08bd41e4920d10a2d03085d370ccbb27a37947b55bcf869a945cbb11f7316fbc22ae4f8db5b7268ebfee2ef73c5493386962898924f98486965bc60e2861da16d3d96a772bab24c9614982324d7cd353fe5a38f4bcacd85d0535389c2b68ea59a68496972347e42c0ff8688700eb393591b43fca2d8dfd82f98b09b00f046105766381157e22c947d1123acbcacc022e31fe8af29257295602c08c3297463c4e8c74fe69c596facb9bf8795be64bbaef8d745eb5c8c426870f0944e7fd730d29c9d92b0838650414da48f07f0c27e1373b3e681ae31a7e10460df2868f4737a1ba56c5f14b14db25aa2eeea686829a5698834f4c763914588c728c7ade75f9d9559e16d26ec0f3514d4de8a455f38772937e1e434b956eadbaa01ad36963c7664412558f9952f145d6ffcee6141a8a583cb240798d44e903994562c508febacea835251053e189e129becb41e07086d6fc940fa233e9892c22e13aafbf27efb74aa03850a96ba2a5e07e1f8309a5b2c256996a3e025034b60adbb9d3108e3f62c1a82e76abfa87908f0954b4667c213deab168482ad9b50748e7124d30f675de1a78631f38559ea18b8e2d51e89794388b0137f4d1bd9e9f7f313826b5e15d635db51ef9122e38dcd6c6b3acf46840c331b7b69a47335f2759712639524e3f890153beba8e49b5ee25679aa62dc2df766e1db461009f62b16c377ec6e9e87ecc4929948ea69a483e69e23eab20c6a13b586a27f2bb9766389a0bce55f3943d09323ad742965fbb19ea116e5cdaa3b364561b43c1a2f7a2fe6ca9a275c6cc13a727385c08652c0b6fccee611a2dbfbcc3cf61c647027de0638b90581b4f75bdfac40ec2bfe83d63610df7a2dfec6271d45ba9f41eb09b838b1c9c0dd0c3ff4d92bfa83b0eba134a4f7ad6dd35b48233cd2cd4ebe427bedcb3d5c345a9ddef5f7690b7d7c3fb230a4a62be2e0912f03781bbb4118cef1d9b0d550b5435eaa23a0671b2a7c91cd0bb07d6d031a6b61cfdb90a273cd5cedb873a9c0823ecc0b4747a0f0091d88b5e90c48b10144de580ff08aa1bafd7829bc353b85adfb02d6fec527d09bd3fe6fa244e5fd7eb26f2bc5466ccc31c83be10f90aa41b6dd05c759d968bed5794368ef92683c1b92a61139ae8421f9ab5d12cb180ad3784d548a5927d3f50016dffd6883ef348f2221f4bccfb840c560ecdd979662792645e497d8f971334be94cff7615e0855c4b67cc48cbb3a270e5f4c044e5e645456f1558ed7251c063e15ff83f4d3e5041eba515538b9fa8318ed125b657f80ed5016bbc1687ceec404e87e92481ee79d4d0c0f1bd4e756ebfdd42db2b29fa410bac090367953d6f602b3a23763d1c0b44760e18d59a3204efd42e5de96f0b9ff4406ca7e8874d1547713a77dd6710d31879986bb2e6f980a6536d80d7b71ff2b0179100163efdefb42fd4080d4fef07cc96ed4ff88717fa9a6e5a2b066eff093cc801d726e78b124b711f4fa815fe561fce05ff9059983df7dc00b5d4b20906b4157adc22c70f03ed61f676f384e8ca1f06e6332ef69602cb7e82ba0c7c50529752de137b7d9e41138d41fb1d77c5bf291a1342f6d73dd633c1e5a92d278b51f67bb133276dae64918bca9239e386ff576dea8f70bb569facc849482e9a17a9b5ff99b1fa7e7e6e29fd4efa35b53f5d629b45887a66f1715ccedade0fec47aa9ccde817afdaeca2a53e9162318847a025c789f144e6dab3e9a67fe2be0baaeafea2d381dd84f22f354cc67484d75e5a6a34626db7dc9071a2a727c4ff7a66bbfa01bb2929713d896f24acdc8d584ab31037e712b3052602b91bf8cdb3b3e575eb9850e7c69298f181609f43d89a03903de8cc2f2a3bf77a1a9e43263c4917e4fb2d96755e36ae60c04604e998b3281f7d6f64c8c5d26a7c4a96a7e55c538c0b9e083e5a9db46c3cb3d25ac158086a71e39bef14f556202d17904caf5bccc04fe684d2cc419e6f21f5cc9fdd23858140bd51119795c1eb4703a2efc1803453129937a5fb5d6a269d1c6be8966b942442fc2b4977e5979a90570a216c75695512910dc5c868c0bcb38b9ad443e59ee43604604a026ca3c80f1acea8ca2b58f17a1d1b3c75c05687f3705f582131bb2ad156182cd0382c943470ab993d582a1ed9c7acb972cdfa79680e42acf839171d697f303b87ae848bd411c3de375523948a4db43c0e403a999a8f63ca53ad809cc818d6a4e15adf046d71bcc0362b734e374dec2f30ce18820d2f977ca44d5620dd4ba4abb9f622353a51b0801518de787819fdc5942cd0e36ddb1bc272b707a9aa5f2bed98f5996a538d4ebb3b105f4fe93c7d0baa6e10fbc7823fbb72022bead9a2adc0f870902233cc168a9d81c749bc2283a1c818b8bea75b32f8ea16a6dd52a9d9bf729d0c6b1b7e4f17947dbc8bc65dce78ec9502a735b19a35c66a2471098272d53b4016d69981da9d1d5def9b58665cdb53326157fc3482aca22451afd119ef635631aa46367186b42f4b95693e72f898c9a8bda8c4f74b4309968ab1e73121a73b911c63bbc2155b561d54a1968e7535a4fccef26616f57774abacd940728bb65d9b3020c19bddd3c88ee307e2c3f8ea5f7fd3fcfd60995a345c4c74296b1d850369c418d1de3193ddff664824accd1692f36c369dd16647019c8ba18b4f32c81b9872db884bfd5a367dac8549526efd3468b2736d84ab96f1df021fb72d24e753c6d8bd217cd9ecb3417bd5c30e7ab8ca5803c7bb1272f44cac6e33fdd105125f019d1537f51db7f3a9ed0a409f74116c4f514bf03fe35634b821a3d8b5e3ace460abaa260d72ea80b1286b1307886501c35b4eaccbea463690d03b054b45522c5f9f45e1fa408084d216da1e77a8dc0961d707932eb7f29ec40b07aeebc030f530a885425ef4ca10d7855e3fa4dc290fa25f7cda988e178a58d3cc127217e9b4e60c935a4f9dc8b6a8af1d74d4006018915dbf0f7a1d69b86c16f079b7188b2f95941666493260ba648076fcf33506f8b1fadb3ebb43b7784f43d711722dee5c440efc2c622dbeb2acfaca1e776a504c17cb5fe18439490e6330ea0db2092347e2cd7506dcd2fc539852bdc3ebbff4485f90c1c190e51fbee31a914ccb246a57eba70112360e8b428bd98bce5a2bdff64a483283932659e05876f4d599fd3959f26990a5c85e272c4752fcebb205f00773e942f39024e39f9aa8010e88cacc1a20052226f570a72905e32e2d264908f2c54f2b95f89f560c0a1e2de1b7f9fd2d82a6902ae14abdf3ca2eff21f1baf81d8407e8e525457f854c88b6612e6eaed7d03d7f005b1c90836306037239e68f91323b50647d0aa77fde37e9108b8512d2a88ee68f67a55569ede0ca6e917b0c6e5670a8fc1d5167f43ead4d7f7a816f39de088b6e484569965a2bba430ad5fe7f103353e3af351c81dcb7ef3164b68885a6ddee6d1a929c9bc4f0d610a79a03a1bfaf6c7106daf0711bbc9764ac1632303137b94ae795c6cbf220eb6e7a09bed2dbcf9c795fd4a5445cc016e27f68134e7a12826a7ec5d03dd6b79ab1b22b2f6f652c5bbebcca27ca3aa4e39f7aec8832597c852e996d51e0f9aadcd28e6f456505edace09e1199bad1dc398f46c173165b5259a010c271e681adace630e559998c73379b842f0d845547985d0352f8eaa25465645830401284fe8027c3c9f8151ff2ec7c46170a309444f96c98b44bffe51162fc43e96645140b94cd8b5d551ff4c42212bc4ce822f4f77a868c4dc0e33a750de9c64b130c4619348f340a093df286e2972f69c21b15b9a7ea7e2387fccaa640519039c523d50677aa9f75fa66cae9c68b60a63192e052681bf772056f8f1961d4dbb5c0fe0a892971cc4a572a2afce1d70036032b076a765f52fb3c470f6d1164e3d1327dbefaed2fad63ab1b4cac6aa83337ab2b6c26f06dc3e9f13ab7d8c1c28b3eb6bab136dd64d47b846bf2cc5f1a86de73155ea220018ff180b9d902ff3cbddfaa845a838036ee0baf87bc6c91d9a796ed6ce410a53c27494c3ad77b256940d5ded00700b0b4feaa56e5e9f378f65b8e5e7e7f8da2e73e2a1372144a1e5b59c07f7e03fa80addac7102bd30215b98d76d1ee80adb6d7e4dbcc7bd865ae6bdc4ed4f757b64863527de6c758b74478d6c1c65f75d4797d8993024228ebb2c89d8761de364e32908d93ff9025250cc682771d1580d385e8936fabf74ac39303c4995a7af4b2f9e45247560fd573541868b99df622ea739110ee73ae19b1fc24b37792c153ef36fab4a37150e0dfb20afaba0cb0f2776723782970cc3fd5ef91969e8e3ce596d0f29637a6796f7387e1255080c85535fff954dae77fd087e27e38b6defdc5fb63806b6204876dfe4c9ce6480936818e56d9a14326e170d890d84c5bbae505fbcb1a8b3bb46906ece0a8f1557fec438862322701a5008fca73ddad48e66a57566183ff77000c823c8523014f39020c948bfbeb88d02f1f7b6cb63f9a58992cf9a4c3831d95410bc166074bd62746a32d6228aea4f17a6d1c3bf06e56d5d98b137cc3d6fc10e2bb0440d5c895b5785ea63e5f823ddca52bbec60cdff0513c91e99415d1a44f615707c3d5f6f3aacede2ccbb5d1765a64d8322cb0fd46ab7df26d64e1bc23d6b534fb943fb050f322bceb716124caa677c099c4bdd1ef96e60ee0d1ae83174de29230d979d927b2f14615a03f19bf1d7f83d07a5aed83be92f8ea729f1a38c3967134edab0e09baab79d32ae4ce95a4aecf2fe54ff6999a42c623bead1e5b0d03ff8b795ef32b60acaacc653c4bc02b0024867c1ff0e6298555d9683eb13cd47ca63993db5318f6c5fd165da6ab10af056bacd53066f3a58dc0dce283bb3d4c46738d9252132cfe4b6b44f12dcb809b7454300c406a5aaacd44328147ebcb923434a9e0cc5ee47d278b77412b449f5d7c82f77a3fa3b4261b6e9648f46bd23730f1cdb010cbfbacde6053758766f74d0296bf274641ca71d82bef59c8ac7d757a5575a99d7cc3252e315f5b8efd41f91eef57ce17639b32111250262d6269882a74ea716bb6881dc8feb6fbd8f7e29cb7d240feb513b89b4a6bc6b3b705db1d78eaafb10e61a98fec9af872c586917e3358d96ddf3594044beca5603ee29f9a925fd4b29ab87499e759cc9c6ef1d38b567f3e924856646d5ad7cd68d73bba18591243ff312359f40d9209079b2de1e32cacd0f3204f2635d60b26fa9f756d8ad33277519db08dc2b27ad69cad7b388ba32ba3bf1d11be3117c8f9911bb69a3a21777620582fbc0e5a2ad8051fe21f0fd5b937a93734cdc69d5d4e2ff97499300d5f6f38113171d0d243d29041d44bab31de97831d83fce94796fe9f5bd7b0176792bd1033d16a36da7ebc7332624f3482b51a22eb7433ada8ddec8f3198a98f3cb97080cb445099a71522c25ceb5102782b89caff3f185ef1199de9fd0743b780abe1b4d535abfe71e96a5dcb4ce13d7fa71a3419f9e77b3f3ab8e437375b37be6f553b2eb6a428193bf122a552512467493c7e2240fc4dca11036e665ee51f64c928701c9a08d92248016e9bf584908a26354ef0aa5da2f644382c0bfd15e419a94e3b3f8668485ab83622d8bd78bc8b5d9dff1ed55b43eadd188d43838e5d86552333db64006c186fd1f11970eeaeeea12121bb3b1a0a3b2ac167ad6bf8e291e94e145968d8fdb8a4b54c589343d55bc2833d29d453e7a35a454f559f678d9ab01f07ac80ddb950ee640ac0f275c5cffe87b6fdfb68c44431005a9f3037a14f0c029e57ee9f01f6f5508523552b2762cfa0f63eaf96150ba0827bae1a100daa6c62a3406e998622d584070039a6b135cc798928ef3885d9f4af81ce5c11e0b2c402d46ba53bdfd7efad88a4d413ca9c1ed03336d935cfd5c00b38b55fa6efce8a863c1b25891e1699d903058e3862e4248add4e60b79e6d90ed8f386178414e5e829da6125914855e3bf8766da338723443174cdf8c846dec9846f067cb8bba41987b655fb2c7887271f20a7dfdf0321f71a3581a97da98e09eace59d58794434f93af78be153cb7b2d77118ae30992e8206a26136c4c31b444a1259b9f8336f5cf11f0d43c622d8cac79ce45e23a8d5115d8afae873884d2b02b046f1bcf9142c5377f645398c89fe41d8f04977a85d3a877a60f0e734de1897fb47a3e9e7a88ba8ea89e45412618929c45ddcb3505f0b9fab1eb02269a9799a532f05527a69b275d6911d591e0210aa79fd76a39fca9672e04ed60f7a4b4820db38cff5b594538555213aa69e8066df8b2b5af1616048d7e2bce9cb68518a77bb9f7bfde4aca2ef14f4c70e25272962e376b1946f545540f8f8347c81d0f5f91574fcbd58d27c60f5a5aedb3eff96dc630d68b17932b734939ba2e0ba6a8f981b6e3d677d3f8cd2cc6a5b60e75d05139fadc0db13690e57e4bc376d36ac1d20ccbe1f3e42213ca666bc38d98f4dee4e96289acae4406a6f0d9129c2f0959d8afbf80212a6c56d0b89503fdc917e2a219c5a61f80a1b9fed3245fc6d11666b1614a1d50631a277031817db55a652aed7c9b1df2ea16a4927c8c1afa2e7741435e6ce565b3f8012a7ba9ce6ef713fa4a60b2fa0122a24d25ec25fae7cef68931e9bad9d44f581106d81ba191210877e28a82e6622c21da368ff0400d8da6c1cc087e3fb7103bbfb9009c27b477e5d49f23b64823f8088e2e21f634b378b298d6295e8f484f744495b41d38e18331b28348a8ad5f9705c2567636af03282fc2ad7a9e071a954c9341f140ae15502b3dab509b6078914bb8c780cf86c29331afff4fce51c5a03217a7e7d1d062a38b55e34e1420e45b753996e12472d755f9faf1f5d913bf0b1f06e033e3b25139f4370b734b7b08a6e7157d94302f94f03c51af186c32353ecc768ccc5e043fbee11c5b674911899c3d6efe358a2b3247b1bebe8ab299ba82faa949a3cd1119685fb3b6b885219e1b8b133995681f9644a35ffd6f03bf274adb25a5724aeb26480a19419b31fdafe1d6afefe0e6d8cb75cb328fc92aaf51ec29440b316804a654bcc57e6ad7bb46e4a9efa25dbcaeed119fb966e7ceac772a530640207a35007390c9faaf1b8489c1f05717d873eed6e6c8328f7e9ec2ebc1d59d95f335b55703654ac2396e87c3ada69ff93f0bcffde2a66a37dec435d67d909d34fa4c71ae703f91fde312a738d5de81da19922d4618bc6774fca0fd5be443b47047088721913b60420a78a26f64248a6f1a3ae7f5f9794e9423d4b9efc824f6a7f83208d61132a792a84988bec7a2d52b2b22df5b01e18719086326d97d03b76a7944bee397a7b05adce64470f3695fe1a6b5c873c159dcf9a3e5699f13a5878048cf01b77c94a16c9bb3b02dd30845a8749b361e5fd74a88fe2a4bcf7e6f7822b6c55fa67b1b4eb856c48115bc95ddfdc0c39f5bc74327e802fda3a8b59b24e4d814a70edb99fe21ee27b5052de1240738cd217e24733d0b702501a3126cdb27034f7359028ea72980b3c0078d741be1cbf4bd45db8b6a5ec2384e344b36997a5898f8af6e91d01307bdbf5115f6644095b01690d80fcfc395e8424595163d73e0f2958f7d600c066a74c8300e04733a4b90ce9a80bb068de2aa26a4f76410da84a23902e8de252172afa21491d893c1dffc228c45dfae7eee3a00430d641098ff426e24a2d51e9d6d1000b75c793e274085b9c5a36a7ef0f31683cd886656937cf189f84fde5c1e47ea52f0bc25698b0bf0ef9109fd9041e20c564a2bdb3ef81abcc3995bebab0f005713e44f6a2a5793038e433589c2e81ee71e8ba5227150147f143778fff99057807ced6ffd6694e19b9055aaa0cc5b2d4c49afd68493e9e2d0876460722046cab4d2f4d383169feb77753f29941aad13895ef2d272b807a2d9189b1f7a32ea0ad88bcce0d5d80ce54ac24bc5b0a5c71e98e9480bf7da3f4c5434062e88dc67220fda1d8d8bc1f1df8395f5458cbf1013ff5c0aabe8b019dca28f032c67b3d4c76fd6dfcd50dff73a3abd484c8b9e6165b927e545c7450b95b365f4bfe1675be70b95241f1b6af3e0946662714fa241b8d146158ace4db423a77e11c15216c2716f324b886f31ccea4dffc5efda2ee96bdb22d5df40391f23289127a25c41a93d63e16cb38e865906266effa4e9169e3e8fba12aa478c561fdd6f939ebbe3a08dee7e74085ec64abda33929bdcde71d1c3a2280c963d58a777b088e40f94aadd02585eb8249e572fe21843ca3cd60c3f3ddee1e8215af7ce4106b649709210067e1a21a8ea82e19c9bdadfbe52da17769778f1f832d552b31f3c6c01028878b2e011fb50d4ff8f6b79c0e422e13ece3918e06cc0a6701086d875faabb8994dbe8849d91eb2fc0963ad9dd90c535a83ec115d20cf52ff04f064ae18b5c90383f9e97fad40696730be59659eff8e934b64addd4fa3f8dae59fa1ac51f4104eb72c4d8a83df2c70483643b651481374ff43a47183449e4486e9a0d5c2f702e3cce3cf2815712d1db24f2e293108520819cb793f703e13f30964d5efeeba9f7f25b3db50cad3440294f56d1ed14343170eb4ec025a53f49d8675db6a1a5727559c60c8286456656c6a8f47df486b967a7ff1cecff400978d18f3e997a908a53a669f3da98e5bdfacf6743a6caa384231c23269654a85d3ff68774212cd5463dc25f0945562aeb70de708ed2e4d0d39235ff0008dafef0f4957b8007855ff017d9b766862bde920b87a9b088f3213fe6b4e66ead81bf9486b79cb79ebcb1b967d743255cc5326667adf862f125774911a0626137e8c07801605adbee2f70a064cef56111f5813158e6289f0eaff5c4c403faf2d7d185fa0e18fa61df6f19327c1203a07b9151265ed6d706d0fb43124b93463efc329008eaabbd761dcb6b570c56c4a70fef507625f340c274f4635a1f6f17f217f0e1d0485010837051e76c17cd03c5aa0c72dce8c65be207acb48006ece144c87dc4a5d03d1627202be93742def364d07231e85d3e7c2ebf81915e4d3a1b9462012524cec7245969429612cb4985365855ca3b3f4bf9db2f068db80c69f56d1c63ba9592ad108af8a67f1b0d25ea4f930db4270082f7f46d687feed6dfb3f78a6e5d1bf18fbab3c6a71a2aa13ed7cc678f9a60dcd14a0fdcb40fb28e9ce47dcc98f7d2257e2ead29a023c36352772d99a13512da1c7893174ea9e56911c17d310943da896ca2e5eed97ebae38990741e50c5d3d7f3d4b196bd1b1ed5bf59ceed70393892720eacec354418115ff695a70fc3583ee903343110f1c2d53563e9538511a7c0c40dfdd47c91ba88fdc6ffd2952a7f7392be62d6cdb7a36711f6f5d53b40e8cd3a1c506be7da790818225a88163fe3bece4350354118abbae672fb29d2bbec3be1f7cdd27ead1532389966c062dc94345f15d5910320dc4fdac5d4966fad4ecbead7a469f1c6f19a18351a325db466d09527d68aede7823b4cf14e21fbbe9d8f6661c40c7bc4e47b7dfb909b711859d789854f96832dea68c2c79df9d3f6389637cd4b93c2a98432730a0f44b89eef12a7b8049f511eb23128900af1e12a5689e6e984d8a046e768fde4cba7a268ffd23ff1a1ad53fc9fdea2663afd41cb8320f2a98d5871aa4af5aced16d01ca3a30590d5b7a963163c31bdd33559771a0ed1863052ab1057d2851578a2a7e1b97c4576406e0e9aee3ce563a386b5fae2eb77897ff5e25bef15f82434738a7a8d83c3349b5d9fc650d248e1eb2f1b599618cee1430fe30b7dfcbfd1e4f5239dea3372ca133eb20a6f65f12583a5e09c0397d91a72714ce7870feee8131ec6e398a0dd22a1f612172963245f0f16f81dd775227153c41ff6cbcb9af15bbc1117c0d2d4bd6a4edfd935714c3b25e314db4fb508289e3a4ad91a6cdd68dbc50d374168758e1348ea122aa69d1edc27cac4e5c27da0e4098b7d832d2e7fd99cb94908ad86f040d1e1e16ea5a1a04447d378ec7f93f4c9d531efa1d1f830ceb31b9855a54f523b3419f6d4d0e2495139b8529a4b6cd5d3e1a9939f5985d4a4eb56b8d0400ee14072316e82567bfea83102b2219d31e2321ca76f8bd7336c44f436c4935cc3b3fdd25d15bf332187e66b1bb9fc496f59ebfaeddfaeef631391e543184e96c0987ff2077d5ec0b3846c3794a57fc4798ae75de9880ad1b7deed3970110412e5b6cb50b318c8f5d862e59936e29c936c7c5c5834c7457dde2fcd1cd3135067725b961fccafd99443fd4aa1de43686ff8d8e844e866881d9cf7f3f5a1b848a879982fd2706bcf425d74c406a8ad992675da45a853554961687521c00b331de0a5a584bf66da04afd27ca76bbfe5fe9cec6b2a7eceaf4d54aeb2ea1951ead86cc6a57f2ac00cf7da46dea13868442505ecdfc6f037765341b48c9a87f61ea8012fa4b50e430d107a1b30913844fa527bc58264c3e449483619d1f7338d6b419161ee637f78a892ef68ecc82e064a2ef5461a195dd3338b170d49480d1b396a55c1a708500f94b36b6710a6dd3aff4b0841007c9b268376b118e991315806778d807c90a428344722ee3e7bb9146ce6dcd21eb39afa01eb783c6dabb00632ff7b5a7f875d9ecd2ef1637737b4981c929d6d47c40d3c819e6d34783bdc060fbacfff823f04485291db7965e01bb218d2ac43d0d35a9b032da178f6ff6bd35f804b717e3e8b1e2bcc3f315be11729a83e2d0e3d2cf752731904743cb97cb9e17a43c61a62ca6c6b7d06ce135cfb41f5a5c4eac9efd824d41f3cb2d3b043477eb03b55e6b436bd8e332d5730bba6933cdecff2d1b223f841153b601c05c163d398f8911b01d533670ea67dbe5b0d67cb9f582adc43e0ca988ce37e1c915c0bd596858feec7c9e285b794eb0595216eb4734c30df6afe51aa4916c7f93792ebd3424f5ddb56ffade939c4fe1dbeb59dde5215f392a9130b35f5de307d8a133f18d93284d9d8bebad217bacef660a6b38101f88faebe699bd8601bde2253936f43dabe2fef6f1eaed77d868c383417fdde58805d5d30ef6fea17be8582476dcd450e7f7033ca69665747155179fcd3fe6edb46d9184a4c5427f5b23506b8893225d35033c318445b1cb126958b437f04379505c301c98068a43a0fc3ef29a422f5b33f642dda276fd0efc4f5a43dea9f1a256b8b9511de140bb2bd91ab85ec6168471611fccac2a02051e631ff4ba9fde8acbc806be10d20482ff11b27b2a3263310cec08d6e400be30cb0e72864a440fc76ea320f0b4a4b1799b820841d711585d71655e024a15cfcc0f6266d43857c1aca5def89b844d5c6330b2d9aea1cfd06afd2f95e6059c021a399f7342b4a970d39c5de27ba1521cfa36779f98eaffacd31b352f7dff14529d536b2c3eb917b7c548ffa9e88474e9773be80fbf914b102ebb9113dd43bb5a41cc4e8e320dea8a0edc1cbda8be539ce77e1bb566d89cf0edafffeadb5a69e4fe87a57e27d7ada9a2051c5a8c979f0d4b71e0bbc498b207ccefdb58b5103e252a6083d66cd49ab00e7cd31e257f4f78d387ed76ec31f9d14c07defbbe387d40c68739171accbafe8426fc69b7ec5efa1558234d1d103ac7a4fd486ea2350f2d1b47822fe15c92020afd0fd128ebfdeca46ec633123aec8a7468d22844d0b0acdc394b241670d90362af5bda85e7ada44699f82a6352758826847dc544be282022808233e5b8652dc3dfe868f978e97a54d409d6d3765542461567d41e6477fd7204aa23bd4a85ec94e9b2bd8d1eebc3206ca0ec392760fc5c8cdd7d0bd7cdab9cc2f832dfa10ef1ab57825e40fa8633e56021525e1117e6bd5260b797dca11f78d64161cfdca099af9a5ef4c45a974b8d0efec26b7cd6136e037b71293940ccc95ad646b7621f0af116626ddc8e69d4f16da7ac2130a8732150b4ccc1317957d57289d1f993ea70c48e9a3286756dc983ad7750fcadaaad9fd03c24aed9e8126b16ca0b5ff35f1ce9f9ba21a7662ae557d753fc78452750a4082965ac3e92793231b185324532f723e149d2979c8fa3eb1fcb1ecad841369919bc2c16a26bfe7649a12f7cd504c60afa75c05c88edcc8e026a25dfa988aa967e0c03688cb373fa89ba919b70bdfe172684e0387c21165eaf77d02141d83813e15b5f453712c21de46c25892ffd3dfa9c791df56b68ddaf914a44c7b93b1075011b71cac7f1ef0705038023b26d6c9dedde257d2744c120826de36e3ffd3688b6ad5caa2f14508d5e5f19674a80d922c2ca5818d6b819fe514d89a18e382825ae927d481031cefad4a56f0eb40bf2fc155d714658f9ed5afc7265acb1ede2fe2f6fafd05f4f1a573c846b6168978ff9a86bffa334ec4b0aabb919affe6901dd34dac47099f02e2104e2eaa0e245b39ebf1d2e387e75cf01dd3833658236f3dedbe09ebcdc562a9f3166d582abaaa908d3257a54db42b9203918f59d8b1c2349caab0f18af483b450aa513b753f16340e4906db40b487af0396566e5c2dad7be1bbcdc3a0ff8bb30b9e1f7bdd8d00d5b9dfad185410fb8c17149dd179e0da198977e2785fd69b6e2dce3fd5fec5a736539f9322bed576fd770f44db728d4c48532f228b0339ad000738657c6a87bbf99cc6f627e3c4946922b6405b14ab23900ee0fdd331facd9bd47e7a894e0f8c03a92ea29f82e852615596f8f766fd85fd554bd0cb5db44adbea54c64eb821ad564374f207622a3db4aaa72ee87a072dd8dcebc22d593d99ad156505c093b4748a54b540e919a10dd3557f242227bd7ce64b1933cc7f7bf2d79290e4e2e9a02da57c61d467c39a87e1452df785a6b50359df0d60f25987a2e34d4141d6872244254e4d61a94eda06427e5335b242f9c848e99ad521b362431800e04363ffa3306845ff33621f3eea6c77f33d6a26f893530991494f0a550a6eaae62a004fdde3c3126fbfd36fd2acd9549df9a55b31c1c95254a06a93445838b758000e686efe95b4407d18503d10ea810070a6970205ac2c37f15e18fa8e53c8bbe5116cd1659700d576e4f1d29b16dc6011c5cbb65410962ed8c840a2f1a13cc690d7d2f1fc1c28c8ffd9fd6eeef30ccf77454055976b4ff76f31ad69684e07a11db6478a088cfc23513a51bcf99804fc23ca9a718ac52349050d1ba876024f255fabdb10ba64fb162af684d7e5864fd22862d321b93d137a3a1f469c4a0f665efba688499e04f044d5f2456589199c70e9a6cd37be7a372ffca0933e4e3ae89ab63575df7a0918dd179cf67e0b1ee48599574ed950648f1b09b5494a8a7d0b2ef6eede77b188ec4af70535215a96f56acf0346d6d427c237979b232aaf872766a4a44649028b10856ee55503dc32f241988799e85ead47194bde22bfb07ce2bc20480c6938e2431cd1c550b5fbc085ab08a703fbc5356d609114f015fd550d01f541dbb03e591b48c6fbea3a94aead5f4227aa3354648cdb7f4951ba9f4288f1b67c9dce99b17a901b7b4063a4e354a28f60910fe9984fb3fc828cc99d76cd63306bd05ed8ff65807f58ac6ac118b3af0054b3a983c6bb05a07af614bfd959be6c14a2358344e2d0817e58cb8a4f32e57921297589d2a24ed2b5246442940ee88633b55d88d7e3f9f663f564f8910add5b7985d5f4a5db763a5a2aaf495466cd002a8f27eba8fe82ac0f4f9df11bf49ff015d451983f8a751d5ac75998c8d018fb82d96f35b682f6914efaa1f05f5ed0c3be9be9ee2998ff1d75f8136bf72bffdb3cefef3d34b2963a38064010cc2aeb523e3c5fbd8e531d0adf381006eac9f4df0955fcebf673f702b907e142d837793f8bca9aaabf8285f62d7400db9a34cfee8141f8c33a1cc2fe24cf4bd4cf69165b43d650f4e6a7d05a2229d00ffb0d6f3ef90490c49a1a063329ef5a54ba0b8a3adec2a0fa0e03d60a5174acc6a10c9f06ac1f9f2ba1da2b4654ae60896425b5d3db63a0735d97285afd6b44e0580604d46c6d8a8557a1a77f3ff44e972a51940b1e0b90cfb3579f30d13dbafdae19b9f21a7bb8f4a536243c0edf4d5dfe6a4317a14213297df9037bb06b89f13fab28fb408ed64246e4154f81fd7c6dff90d95454bc733d6c0b882c58056564291c361369c996cb27f2c21ef63bd7c98f05aa439be41108a1f8e2dab02e343794a6693d6e9a442fc9b5ac73935d04cd67398cda6fdeee6e8c66596f3e2fea07265d0eb6ca70851259e631c3d27cccdc634dd18ac1b7275a368383034cabffde3e320fb3170b3e8b3fd7a79ac63997e8afe25af42a0105d4e72c767fe249460a25aea9d0da2a0e5a038d63e0316366cc685c978260d17cce0be4e389d6d022a55f3826d79aab1aa456930a58585e39acbc13460643523c2431384771a6eb9daae0212fb5d89ea6e4527a76b25b0f61e82927fb46e943ab7e25ee37c109cf8cb2f3c99d6ab0a9021228cda5aeaabb5b8e99c83f3e8e8056aaebf339c19efbed6bf3b97af41b52c686a0cab149204686c028dec2504eda7c39174ee16142523b1240f2e70418437aa1773fbf4037ed48800998ca67962806b01ead6966225ee3179b4665b1716191c713fcfa2cf82121703de63765da5500230337806a3b454749f5fc92aff7595d9a7cd8ff492853cd586e0082ef932cbbaeac51e0bc5135e5ba0044acaf3a3212749de31700f34691f3addef644efaecc02cc65343567b4c35f7a006df5d427a494a25466086c6e7be394323c219b5d87e58f01685dce63945f8d378151a54c6860b9bb4fdb73765fe9e4f0dbd30d4d065b24528f8925880cc07fed5529f7e9a29f3a1c0ae4efa8e840d390fd9501d835bb807fdf770f1599ae0ef2f032669f283fbfd5707a726ec72116d2cacb0fe56ba8af4088df5119a0127418efd9784a46a100f5e14f31efa8330aff130c17f7e1c5f56d2d26f501017ff453d0f5c3ba60afa5424b9c9ad87c504ec934f1b5da72283beabb2881343ffd2207617d07a244fb886382a980b85fdae4fb077b61cdde7809f7dc1f7b0cf7457f57d53c06b2244d2ca6563feea7b2338282122e60f56292fc20c3147bf58494bca1c9249c8b197951f34efbd5f9c8c1225d7a8519fbf8477b4e78228578719cbd0253bf99f4b20375e7ce2dab2099cbf55e91f9d08d4b0ef5e6284189bf7c31e75c989bf99036d55ad7625fada2b7c1b2538825064fd1cb8d4c1f9339841dffbab040fbd1d1b3336a8987b89367d0283fbe6f41bdb65cda25c895f9db456da887b68b11b2270b402c4cde3a2fea677ee8a568fcc91c53f8aa59b7c4d41e4373a4d601f926270c915bda5662f2d109d80ffcf8edddf0e7968415837df7c8314e228195fe2bcfbcb54fad5a8cac9159e05ea0eae14fe5607ab96f7f448a06600a395dacc7f3bb636b6dfe837a9624ada1270a37813873d148067119de7ad4ff4a440c707dda2ff367928f3f61b2792e37f6da1b616eafb0f9e8c3eb189c33cb9cf7c4220e1ccf6189c7c8a1362c76e166d57f52876ec66bdfc05e3eb460b2cd7a4f02fe8a5aa7386a93baaf7d71332aad59175dff712a505ad844cac9d8b86b81e0774afcbac26ffd80bf80a823e73c4a8c1dcbadecba77d9257f0c0d99ab4d9eee9b7083344f1fdda1440a4815792e55d4a0680bde42534208da93a02751c363b54eb5504bb5b472fb8e8099b8888e59d01fd2f52d96dc0da38f2f3eab89d9383314db0d0560c24fe681bf7023d7cfe4b33238e241ef07f3e67037268aa2df400b2876185b11145e50eafa83b405427ec440fb0bc123893135d081e43d0d8afba5613e6481a5e698ee659a6765ebec7624a56d18a398af0dee31b462e94fd2e23e22baf16c68de043d765eaab3d8c7d6a0501309fe4218b27ea1756452ae630ee3e3573e8c58ddd3aa4fc59fddea29ae33ed3332f538261543cad3772b27aeb8e9d6045d96305d26d03d1209c9d5990bfa2c1ad7bcddf390ffcfaf63e580d19b0466fea2a6733ac7014a803a95bebc4d2c212ec02a8955b836a202463685e5d0d133589eb8b52eb83367b9e443409f21a5220f63cd8d5422ccc8478985ab13921afe7353c2b78e902c85607ef0731f6bb115a0e3b06ef81da28eae00aca90e855dec2736398c7acc084cbbb1d10d0b663a3f2a6d80369a8ae601f1b5a70c4f0c925a2491d34f66c351280458575f6f0ca2645e57c13d3060c0b770345d5015853a16fcbe3199df3f94ba7b198ff985172c6f1a17c84e511b13699aec4c81d12974d5c0fd707c4ac4a6ac5997de2b11ed2061c9d7ef7754afc08ada94ddb5f5a2af313630023513bd3d4b1e125fcc8ae4432d8ebdc1d70a1d856272f37db16c837861c6e86fd38d019d998e2650b7ca78af2da646ea82f1cf8ef877e9d256da42ad9ff3f4947a0d3d30e83a64fb1ed0948c5bee72b4506559041a865bcdbcbde0b6c1dc4af38297ac39ed2c5f17f0754a278613fac04d5ac7a0b9801a7c8399f7125813007a498f86de8cc01a48dbd768942ff37bd8568cda0ee4e8f085c883aab7d9bbc8033fafef9d50f16988f0b42e1f1ffd066573f3a9a033fca89649493ac0a4a43b99314d99f26f3ff9ab1ca16a5c4947534eca02760d88e804b43fde30a8e42c6e1ca989f7df141c3d4f41c3de84c47c0d22a59dab3e26b7ceb26d223fb7a5f16aa8a6678a1a49567ba57c4c348a73125fbfa4eed74382ab03e9c8d8568faa6fe8cc4a40644467d9eaaa3bfc85bc5e871fe877d3ed5f4b26d4cb66241d4ab8b5f543de213594f821c56c173212850736f99bfd2c6ca1d452026a3bd50e19076d4c5a8929906b730571291709ba69015d924a716186680ced2d68d3576eefee139ea8ee515febede9db8b98308ebfdfa775813f4d8b1103fe76ee821eae5efb05256d243cefd082c3278522694ac46aa823c4adbf4d1d3d0dd7bafd611c142e03bb103ae7088bb76365d54d1cd6fc953f1d126e18348ac79113498496e111e632fa84ad2dff1c09565903fd6d9cca31ea03301ee97e803ea1815be4c4f37b022a38da8b3cb71bc5661fb88573ce00a7789749c3f2f617cb874b34d5a9196c4e5cd100c58c6ff70be9a0ab0823e29d67c6ba7e9febcc22ed11775ca601ca0974dc0a687b32312df5ceb9722c0e70e35af96101a741619bf7baab81427076958dd49b3ef40418f1084a6e0fc6ae0bd2f2c6c8049dab97ef439023132741631e29030bb4c9d7ed3769c2549307f93afb70ca5e757948e109106741f47d2f6c53a93db0342568307cd0d5c16e0f8b09bb78c20c903c53213ee517c6c3f71da1ec16d3c92d0574ca4691524bad33f151df796342a04005b31fc82de3efdcf5c29f1e0790e2f23e38f27be73949bdae969f8fe63c1818852166869ef7c8c510b74756a2e3ac4d51f75ec4a68d6eb37b82fcd2b2a68d3e080e891ae9d2415ef149c8deace4057fead808e3e708b150740ad2fe608603c1e2874d4d098032b7f80629dbbde7719582bfecf5cfa92c768f1e36ddd3f327ab45ea316fa3c27b250ac8000353be326b94bf757bf72909265a204e864f53363c98112cfe7ffe739fc4b791cc6455bbb5706653dde7cc733c1cbdf7a9fb187964684d494703ec29dc41d9f4beeac84592d20a3d1edfc71eac2ce653ac939a173aeb4ec835f26d18909383f02d2d5479109e34891b4fb4a99ce1cb3273853a8bcbcf5db5310f703ce6141f8d77f57a8a76c7b825ece258ebff60f39f9faf59f1b53f2441a566844e447360f523c8cd6ae1536b0a6b55ff6d124af59c3f23f75365e57ab351dd96c58f9e3c5c06bad0291d8975103bfc56238ff1c85d076c96e847c5930e00009da885f1f4dc0ad9fc2fd19b5e8d864f6be441633df2b05163d357c09d5aceecb910bcd81087dc3c5b6a5f5efb7c63fa57016ddd2926ee1acafe332e6eef58e2c1e38a51510c7173da5c6d42e673a9ba37478625f6fdca7bbb977327fddd25be782f1ade8846a997e433ef1b1ac587aa9314f23ecaca44f89cddaf2a1e6a95507679e83f6dda4d5a793dc826f754a7cfd2b9070efdc2b42573df7341a25ed9fd7e9ea7171c8bfca5cf0b69b6dcb0afd46474f63b54915086c0fe231da6dcbebeca68ee3caca66d910da056f88644952866bbcd9076471a1557108af1ac6f8141b88a4ead1ea48f5463c6711608c75657d71e10f2845834f3fdb027cb7d57316f30e7efd25882d4bb2f702eafd8edc3b285c69175862eae100cbc27ab6301db5c97851da43d1e341e9727d9e9f2b0ee6aa3d9f99289476c4942c7c6c7e229a728680f23b0499c5424a7ce39741b912eacb87892ad76542907a061189140d7155760d16313f9d8747fcea96f18ca9a29455ff5af9275597fca0388ae92440953fc4ebe226257b98d0f0a6878b7702367817efe7bd9a84f5c069ad4f7ee097dee8f7a909b74de2f9e0a78caf5bcc84b0a5d9056801008dfcb5b6a289864bfe348eed63a7086381582556ec7b86bb07438b66c73cfb8317ea4ec9f35fbc4369fda12f62e3143b0b538520750a6a5b61995fc00c304c7ed60ac532733afb24c1a1e2250fbe9d553b17e57de7a444268ccd533c24512047e10e7bfc13472b3c0ff0c76453d2209bbb58aca7c890ebbe223b5ba739e2b532f26ad1644f8aa86a668b201b07c1f66c8367c56581f374ae638c2457d24cfc0b919b7005ab680a397dcd18998ee6b69ef44b0305eeaf24aff2bbd2e5fcb209144db1b958aa762cce3e434cd28ff4282fd59855d122cdd2bed32c2f71a25ef81554031a92b69b9ba12b92b8ec9128d78cbaa80d8845dd82780a1d9d254699c9c7f74f85485c8cda27b3226f79fbd9b63785e231034b6747225301e4017cf9d4c9dc491aa99f299bb2d4974cf0e5bb2186441ffc0b05735565734e63ecceffafcd7579ef5644be3021203d7b59776a2c5381fd8968567d10798754d318e08dab8de11389cb25f313874bacea6eb90202061b5a3514eda8ad2993081654b09fd5dbabf5e608e3ec0afa590187e44126e2a8d99233106a53cff5f90db5e58cb8ed8f628936520a712b26a6f4f5d07d43f3bd5ebf1c26e701f11adeb3cb619acf70f47cdba8b0116e461759226850da4754f4738b0ab331ca5275d4a2efb1f630eef47e5503cd7d0c6dd4a830e6058b9222c06af67926819ca31d1e671ff8a2193698692247eb7f5149d1e87fb44ea2d8eb81171e7819a31c55a857586d57c2fcf1fbd92dba956d6bfa203a89d34fdb65297607fb4efc0026e275c1f524f4b5bdd6050a73788dd238b491de4a068697adab2f73dd1419c2c3c90b58e0db55ef41690032366aa9f4adcad62becd7f2fb9555d573c48ba22226004d7bf8a7ee1938465db1c4bea97894e5c25532b12582388bb2cd0554213c5973f65685435c823e73fb0d9377ecf719d5aeeff8e96e991d15245f0a9456d6969f067cab178c974f294796edcff7ab1a8a730d85a7b3786e53d45fe9cbcf48553b9aa80d26ebc9096f8af59efd636709aeea2ac0ff6b715aad6957fe0cc03f87c2fd28fe38ddf54237bccbccff8086e8bdaa048697878f835660d529f3634f29413011cc0bb1b2ef89d9f9fdaedee41172af541ff63245538d160758da78458c5ea682de2e90e3effec3f24b600ed47020bf9af3f01d985c5a779488d07aa689af6a1514908e536a3e73ab6d32adec8f8edeb2a2716553f3ace0b9a4a3273bf450eb79c59b39b940a05918840cd1a1f47114d71f05c86b7e1b557d4f80e67524f5c2b58225f3662fc85942147d9c40c20472b0ce9adfe8590ae1b2ee4e8fcd50f518ad1f030777b5ca82f91d979ba073be4e813ff66dcaf06bce4183eecb4d6b1506fd7c4bce330afe1536b7abbfe4e122fed1ef46c08d92c019042ee66947ba2de678b931981c13bad697194d862762c912fec6c01887a57a3f6e4037d65959b6c5a0e0acc8152980f1792f5d869b3cd7176e9bb0af362a00b7063e2c15e5d92109adbb434f5d3abe0a14a1446047a7bdc2f86013ef5623643021548e755e7f3eddcfd732b521485d3c30bd4d3d8f94d02d3f249c4817102d3558e73f01ef71565013bbea578f232f77be76fc0db44b750ab9731c4ac7f59d402617dbd0a359e64c8ec5e6cc6632baf053f4ea67f41cea81612887e38b4a7327cb0063f90a8b2180f1287c1fca6bcfdd82333ba9e9a582b5c94e7bb2e8ff00e7c5889b3f1c5348a5f1246b7e6b9cb976a06ce80b25c461a226a2896925f0370fd1b4854c5276cfca69675fad6d6b183acfda6588b6aa58e162ad644b8f668c7ceb4d6dc123f435bf36feaefc86456e909f0ec829c74a0e783d73cf589b03343a64cf1505de7e61c6bfa0f515f48a984ff767a3499e5dacd440a4b2f43d39097a85f16e7fedc8ab9e92ad084263da9d85ac5ecb1cb76de7de44833ddf9a23a90684a275b3fe2cd1b3a3f9f284ad86c412abf43c39f8d0aaee10abb63f137caf8e3436468d56aa8a3c23d7f00a2f3b8b67f210a2ca594ef7bb76c15bf12d93cbc9734de88fb82d60c9ebdc33c01c1ad721fc2815884dad0eb03e014f11d6aaed2106305562ac088dd804d6444f7957926b151c6e1c73536a659a669e25e1841184345f6a08b294c9b95568ec22b9df620f103066413f5bd80577b19e340b84afd15a61169f7a589674d77a95d615e51f78c1eddda28c9786cd4614ebd7c4a05b7ed2cfeac2ec21807739936efc35277641fcd862d9b9a603f983b6e15025a37abf194f3f8c380501119ac2bbc77efdaa60d1a3bb525b3e08b7a263fd8bab7f07f7e5645ce55593172111073fbabff4e2569a094ed1a8a0930f83819b0b0999e81f5f511270170e837989410d78fd5f1cfb300d86f01a85d7e1da0760590ceeaff9c4c7e7c880a91f113f521a3cd170e2f55996abede55a82bee76cf4894b17ab71e2b7b15bc3fe8e922402c83180cb25f3171322db39e600b99e8287559ddbf26d326064589996c2998c0726c55747e73ec2b896148541ef2c113183d09f2b48b5e087cf8e0e8fd7c3909156c32efc5da7d7e0a5368034e53e7e26643df82be7b88f8da9823ab4ce01d90551f64c80cb11109adadef2ba4227a72cb241d6cce25fa56db384e116a9e3762aaf634e3959985b25cc80c512f73ce9af31df62c6695e685e3324ebfaa64e0f1167f62382fbdc98a41c4fd990305fd11d2b549d1ad6ae50a11aa8d79f331ee441190123f37214c04e84c4253612161a759e17c3bd9793c8c879fe804a3d1a76b36356332f78a06b49ce8dda8386f6bb30d31a7bb0e4a79f8260a421789148984dc77f3823a4d93a3b213e69d4b3290c18dc11086f3073e7d63c364e455254c836b474ee76af500a5d10f52bbee09725a4c540ce44469ebdb01673bc9a1b3486d528003b329836cec5b36406b1254fa80fe0a4727f39e4d30380407596c0c81f936fec5d087bb8f6176ebc6b60e16338f8645e295c53797fb554c6dc96691aab80928bd31951903f02f9cccff3307af7324b91a41e25cfce52fbdb0be306ed61fc9cdc7f5dc665a3fb1c638437acebb377d863d53bbc26d05abbe8fb4ac4867cee2487aba6272c0518f6215392f88eaeee837fc673e07bd4995e3251150358b4b3d41bd322bc300cf80470fbe66744ba8ec4636ec9c78f14840c23dba8802dbc43073bc88a1cb3234489699bc72031a5fdfd178282bc33e738b7bb7fd8e215f951142b28b671eadc98194ecb8a5d9fd333069cb4de562415f0ff3eec5ab8a2d6cc8f612671ebc2555faf0af115f06fa02270ae1b54402a7afc52a92133fd326f5c79c28cec2d94926c9fcddb867318418580bcb2a1dd364f73891674af7872c1c7ce8f93a52cfb3eddd999634c8d38d53f48a61235b957b359d7c2f3562e84fab6309708ec34b7f82877044c430a789ebdb696503883cb41a56f1bf52815cc1a4e4498fb368fb52c2edbf679abbe249747beea03a2c4857ac123ac20eb2bc8178b36a33cabb0314d79a4a8ec41fc8ba863556ad72ca9c45185176a94b8f93f2b60aa4e27d07a65f5683ea8aa14a5735459411db9a50a6e8e87e9255c531d579f11d21d74a5657acde36b68103afa7b139d3d9b9147ee91a83a7f6844c9eb931cf50f37686c700daa2c62e0eb9468ce921009bce4a6d0ede9283e456da25ab33dc81f642843a5a7f79de4f7c7e85e4e394812f3133a8933fb4cac9af8ace441019ee5eabac71f6c2615e7dea82f75eee0c4375da85c89c9bc19cc25e5853de789c639544eb1071115c8696074fbcff6e86375855ecf0e49a88b8253c38b3039c98aa37676684413fc726d4159d3c99039adc6aeba47ee5edeebfa2e58fb9b002e75b3695c80d011358c7b88debd15dcba6c875fcbed29e7b02400183c029af349db7c3135ffb105e8f197f86d805ea70135ef4293a2256780f2b237129552d895a5d57cd93f3b41cc6e95610f7c2359e5268d565a601db94f54bc6cf571dc0ba217c6d993d8cedf955946f7b69dc5d08090164a3a0788523b603199064680bfe573a0062a59e2117958961959291078969ecd3a273c8b635f6b7efe83233e1600d7b3a3c2ec38f76668d246d7d49bac7988701d3a2ff4a375564c23f423746c4cde0d06c49e785abd02eb7b486322b73e15680f5c5dbed06b98f5b67ea9d90c357ed07d0b82b19e5824fb7990d5870ade06349588ed4c299abb38c2ad71ede0aa65b49dfc1f515239517e5520faa947ff710c6c7a2898700f273d6af3078f13b8520f9f1696f56597f276b5dd7267006cb2f467b4814a8d5bc17f3228cd62e5a68c845fb059c7925d8013d395b937c0737fa4765b011cdd5edbfbf8649619d93eb5ba2fb87acc0e8299f320e062fa01bd3b1e5b6aaf5e776c8432c64ba8bb328cc60034476248cb6d724b43e9b634aeac05065702246c6f90a830c4ebcba2070188119a1834405aa1e105b47c5eb207c98f6fd9ad314a1a311d40ac8a6135acf199867d356ea7667c5d1b2f7c7001fef4211d33cf35bafdae568d741be9a42eb87215a86fdb32d5261524912bd25768a211613b633fcae6abbae115329fbd342b50faa8df75c3ceca71b2e50616eade1d37d6a43836bbbd55c55535d66b1dd6c53445edeac251d526619e3f4f6caaa2962a4101a7219be72b12c50848091318453fafc445a4d954679304999dc843a480ba34cda226d9a790a8cea40916143e2c936da1c69138c8dcf721c48dedeff9215adaa6131fc12ef06101f05b3343ba9fa4d0abd0fef0d2cf0749f78ca981148f1eaa184a796a51a1e2f999f95d8773656fe65fe03ed8d6239695d36564ac3a87859c6c0d79970e0332fb7045b3e3bd52424cf87e6ccda0734c72cb11e59750c08d7a7712ad6b091462f86da85806162492f25864fc31961b00b895e4f35b343fc81b094c42154846afded3b45a8469720d542c2cb995522a9b2cb1605efdad192d9163e436c56d758b3f05403f4820083]]></content>
      <categories>
        <category>魔方</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 模型显示炸面]]></title>
    <url>%2Fposts%2F233af232.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;以前使用 Maya 的时候偶尔也会遇到过 Viewport 2.0 抽风，导致模型显示全部炸开的情况。 &emsp;&emsp;这个只是显示问题，选择模型进行有时候就好了。&emsp;&emsp;但是如果经常这样破面抽风的话，会让建模的体验大打折扣。&emsp;&emsp;然而这也还是个历史遗留 BUG 的问题，实测在 Maya2020 的新版本就没有出现过这种情况。&emsp;&emsp;然而项目上使用的 2018 版本老是有这种问题。 &emsp;&emsp;以前也没有能够找到固定出问题的文件，而且很多时候重开 Maya 就可以解决这些问题。&emsp;&emsp;然而最近美术提供了一个固定会出炸面问题的文件，而且这个炸面还只有在他的电脑上可以复现。&emsp;&emsp;这个模型文件只要换一个材质球， Maya Viewport 显示的模型就不正常了。 &emsp;&emsp;切换 Viewport 的显示渲染器，则是正常的，基本可以定位到 Viewport2.0 上的问题。&emsp;&emsp;做模型的说再切换 UV 的过程很容易出现这种问题，项目上的角色用的是 dx11 shader 也不排除特殊 shader 下导致的问题。&emsp;&emsp;不过根据我以前自己建模的经验，并不只是 shader 会看到这种问题的，以前搞 Arnold 渲染的时候也出现过。 查找问题 &emsp;&emsp;因为没法在我自己的电脑上复现，最开始怀疑的是 显卡驱动 的问题。&emsp;&emsp;然而相同的显卡也会出现类似的问题，高版本下就修复了，种种的迹象都不太像是 驱动问题。 &emsp;&emsp;于是我在网上搜了 Maya 论坛上的 Issue 资料，将可能的情况全部罗列出来，然后去找美术的电脑进行测试。 OpenGL 切换 (因为切换不能使用 dx11 shader ， 解决方案没有意义 所以没有尝试) 不显示贴图 调整 Viewport 2.0 参数 崩坏状态下拍屏是否正常 (硬件渲染2.0 依然是崩坏的) 线框模式 关闭 border (调整 mesh 显示参数) 动画的 DG 模式是否有用 调整首选项的显示参数 去除 selection highlight 是否有用 &emsp;&emsp;修改 border 的显示模式之后就把问题修复了 解决方案 &emsp;&emsp;和做模型的沟通之后，才发现软硬化边显示的模型操作会影响到这个这个选项。&emsp;&emsp;我切换之后就修复了，而且切换回来没有再重现炸面，是个比较诡异的 BUG 。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-Tkinter 贴图通道混合工具]]></title>
    <url>%2Fposts%2F4e26c2a5.html</url>
    <content type="text"><![CDATA[用来快速合并贴图 前言 &emsp;&emsp;忽然接到一个需求 写一个 PS 的工具。&emsp;&emsp;自动合并图片序列的通道。 &emsp;&emsp;之前写过一个 PS 的小脚本，10-20 行的。&emsp;&emsp;解决了 PS 动作进行批处理保存贴图，输出的时候却带有副本的名称。&emsp;&emsp;用脚本替换掉动作的输出，就可以保存出不带 副本 字样的图片。 &emsp;&emsp;但是感受了这次给的需求，做 PS 的工具感觉不太香，如果不是 立足 于 PS 的环境，做 PS 的脚本其实并不是好方案。&emsp;&emsp;毕竟 Python 也有 cv 和 PIL 等等的图像处理库，直接 Python 来处理那不香吗~ github 地址 GUI 开发 &emsp;&emsp;这次界面依然选择了 Tkinter 进行开发，因为最近做 Bilibili 字幕上传工具。&emsp;&emsp;我发现 Tkinter 用得好也可以实现和 PyQt 差不多的界面效果，但是 Tkinter 打包起来比起 Qt 可小了很多。 &emsp;&emsp;因为有了之前搞 Tkinter 工具经验，这次开发就很快了，毕竟需求不复杂界面也相对简单。 &emsp;&emsp;这次依然利用之前搞过的 ConfigDumperMixin 类，实现 GUI 界面的数据记录。&emsp;&emsp;然后统一数据之后将数据存储到 临时目录里面。 &emsp;&emsp;关于进度条处理，这里使用了之前写好的进度条类 123456789101112131415161718192021222324252627282930313233343536373839class ProgressDialog(tk.Toplevel): canceled = False def __init__(self, *args, **kwargs): self.parent = kwargs.pop("parent", None) tk.Toplevel.__init__(self, self.parent, *args, **kwargs) # NOTE 阻断其他窗口 self.grab_set() self.progress = ttk.Progressbar( self, orient=tk.HORIZONTAL, length=100, mode="determinate" ) self.progress.pack(side="top", fill="x", expand=1, padx=5, pady=5) self.button = tk.Button( self, text="Cancel", command=lambda: [None for self.canceled in [True]] ) self.button.pack() @classmethod def loop(cls, seq, **kwargs): self = cls(**kwargs) maximum = len(seq) for i, item in enumerate(seq): if self.canceled: break try: yield i, item # with body executes here except: import traceback traceback.print_exc() self.destroy() self.progress["value"] = i / maximum * 100 self.update() self.destroy() &emsp;&emsp;用 classmethod 方便实例化对象&emsp;&emsp;通过 yield 实现迭代器直接直接放到 for 循环里面使用~ 图像处理 &emsp;&emsp;图像处理上使用的是简单 Pillow PIL 图像库。&emsp;&emsp;其实混合通道不难，可以晚上搜索一下，又很多文章 链接&emsp;&emsp;我这里只是读取两个目录里图片的序号批量匹配，然后融合通道之后批量根据序号进行输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@error_logdef img_combine(self): output_path = self.output_path.get() input_path_1 = self.input_path_1.get() input_path_2 = self.input_path_2.get() if not os.path.exists(output_path): self.output_path.set("") messagebox.showwarning("警告", "输出路径不存在") return elif not os.path.exists(input_path_1): self.self.input_path_1.set("") messagebox.showwarning("警告", "第一种贴图路径不存在") return elif not os.path.exists(input_path_2): self.input_path_2.set("") messagebox.showwarning("警告", "第二种贴图路径不存在") return # NOTE 匹配图片命名序号 regx = re.compile(r".*?(\d+)\..*?$") input_path_1_dict = &#123; regx.search(f).group(1): os.path.join(input_path_1, f) for f in os.listdir(input_path_1) if regx.search(f) &#125; for i, img in ProgressDialog.loop(os.listdir(input_path_2)): match = regx.search(img) if not match: continue num = match.group(1) img_1 = input_path_1_dict.get(num, "") img_2 = os.path.join(input_path_2, img) if not os.path.exists(img_1): continue img_1 = Image.open(img_1).convert("RGBA") img_2 = Image.open(img_2).convert("RGBA") r_1, g_1, b_1, a_1 = img_1.split() r_2, g_2, b_2, a_2 = img_2.split() R = r_1 if self.R.get() == "1" else r_2 G = g_1 if self.G.get() == "1" else g_2 B = b_1 if self.B.get() == "1" else b_2 A = a_1 if self.A.get() == "1" else a_2 image = Image.merge("RGBA", [R, G, B, A]) img = os.path.splitext(img)[0] ext = self.image_extension.get() image.save(os.path.join(output_path, f"&#123;img&#125;.&#123;ext&#125;")) messagebox.showinfo("恭喜您", "合并完成") subprocess.Popen(["start", "", output_path], shell=True) 总结 &emsp;&emsp;这个工具的功能不复杂，一个早上就写完了。&emsp;&emsp;简单记录一下。 补充 2020-12-30 &emsp;&emsp;混合通道使用 imagemagick 命令行高效秒杀这个需求。 分离合并]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - 【Houdini】Entagma AHTYA 系列教程]]></title>
    <url>%2Fposts%2Fdd8eb095.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近罗列了 Houdini 全面学习的教程菜单 链接&emsp;&emsp;目前还没有明确的学习计划，毕竟想搞的东西很多，总是会有些莫名其妙的东西占据了优先度（没错说的正是前两周突然就干起来的 字幕上传工具）&emsp;&emsp;好在没有计划，否则相比计划已经慢了大半截了。&emsp;&emsp;其实早在做 Minigame 的时候就意识到要把 Houdini 给学起来。（当时还想将程序化操作加到 Minigame 里面，结果速成还远远不够放弃了）&emsp;&emsp;然而那个时候还没有找到合适的学习姿势，当时还花了很多时间来研究 draw.io&emsp;&emsp;打算将 Houdini 的节点网络全部截图加上注释说明，这样笔记就可以非常非常详细，虽然很浪费时间，但是和写博客一样应该是值得的。&emsp;&emsp;然而事实上我却是一味逃避，即便我又花了很多无谓的时间将 Houdini 教程整理好了。 &emsp;&emsp;诚然打破舒适区学习新的东西比较困难，但是 Houdini 我并不是全新手了，为啥还是没有以前初学时候的动力十足(:з」∠)。&emsp;&emsp;直到最近我才大概想明白其中一点点不对劲的地方。&emsp;&emsp;学习 Houdini 这种复杂的软件和学习 Maya 或是 Python Qt 开发都是不一样的。&emsp;&emsp;无论是 Maya 做绑定、调用 Maya API 还是 PySide 做界面 其实都是有一定的套路，无非是查查文档，或者看几个教程熟悉套路就 OK 了。&emsp;&emsp;但是 Houdini 不一样，它是条条大路通罗马的。&emsp;&emsp;比起教程按部就班地学习教程的过程，我认为对教程的案例结果进行反推会更好~&emsp;&emsp;所以这一部教程，我第一次尝试用这种方法来学习 Houdini ，希望自己可以坚持下去。 教程地址 &emsp;&emsp;AHTYA 其实是 adding Houdin to your aresenal 的缩写，并不是什么神秘代号。&emsp;&emsp; 创建集合体 &emsp;&emsp;创建一个集合体面片，我之前看了 Pluarasight 的 Vex 基础教程，有提到。 链接 原来我发的链接挂了，这个是中文翻录的链接~&emsp;&emsp;通过 Vex 的 API 可以构建集合体。&emsp;&emsp;看教程的时候已经记得代码操作了，好歹之前有做过笔记，有点印象的。 链接 1234567891011121314151617&#x2F;&#x2F; 创建一个面片vector pos1 &#x3D; set(0,0,0);vector pos2 &#x3D; set(1,0,0);vector pos3 &#x3D; set(1,1,0);int p1 &#x3D; addpoint(0, pos1);int p2 &#x3D; addpoint(0, pos2);int p3 &#x3D; addpoint(0, pos3);int prim1 &#x3D; addprim(0, &quot;poly&quot;);&#x2F;&#x2F; 注意添加顺序addvertex(0, prim1, p1);addvertex(0, prim1, p3);addvertex(0, prim1, p2); &emsp;&emsp;通过上面的代码可以创建一个三角形的几何体，注意 Wrangle 节点要选择 Detail 模式执行。 &emsp;&emsp;教程的做法是用 add 节点。 &emsp;&emsp;这种做法更加简单直接。 多面挤压 &emsp;&emsp;第一眼我看到这个效果，我的想法是用 for 循环遍历每一个面进行 extrude 操作。&emsp;&emsp;随机操作可以用 随机数 加入 for 循环的遍历序号来实现。 &emsp;&emsp;通过 foreach 循环的 meta 节点可以获取遍历的序号，作为随机数的种子。&emsp;&emsp;显然这个方法没有利用教程提到 Houdini 数据结构，是比较蠢的方法。 &emsp;&emsp;创建属性属性随机可以用 Vex 更简单来实现。 1f@weight &#x3D; rand(@primnum); &emsp;&emsp;教程里面是用 attribute create 节点在 primitive 上创建一个 weight 属性。&emsp;&emsp;再通过 attribute random 来实现随机数值随机。 VOP SOP 变形 &emsp;&emsp;这个效果除了 Vop Sop 用 turbulance noise 还可以用 mountain 节点，但是显然没有那么灵活。 &emsp;&emsp;教程里面贴心地介绍了 Turbulance Noise 关于 turbulance 参数的原理 turbulance 属性每次增加就等于多叠加一层frequency * 2Amplitude / 2的 noise 细节 &emsp;&emsp;叠加完之后颜色有些差池，但是 pattern 是一致的。 &emsp;&emsp;Vop 移动模型需要用到 dispalcement 节点 &emsp;&emsp;gain 节点可以在 将中间值 在 最大最小值直接进行过度 &emsp;&emsp;bias 节点可以在 上下 最大最小值直接进行过度 （最大值最小值是两个平面） &emsp;&emsp;Ramp Spline 类型可以自由编辑曲线实现起伏高度的完全自定义，实现上面视频调整山峰高度的效果。&emsp;&emsp;加入 abs 节点让高度 负数变为正数 ， 效果就是山谷变成小山丘。&emsp;&emsp;通过 twoway 节点控制数值输出。 &emsp;&emsp;这个效果加入 3D Noise 来扭曲 1D Noise&emsp;&emsp;最后也可以在最后输出 加上一个 Turbulance Noise 调大 turbulance 参数来增加 Noise 细节 衰变范围控制]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - B 站字幕上传工具]]></title>
    <url>%2Fposts%2F55790015.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个月的文章更新开始慢了起来，因为做这个工具花费了我两个周末ε=(´ο｀*)))~&emsp;&emsp;做字幕工其实是很早就有的想法了，还记的2年前了刚准备去深圳的时候。&emsp;&emsp;我还专门用 Python 做了 Lynda 和 Pluralsight 两个教学网站的字幕抓取工具。 链接&emsp;&emsp;现在回过头来看之前的工具真的很初学者，而且已经很久没用，估计 API 更新就用不了了，那个时候还不会用 github ，所以源码只在我的移动硬盘里面有备份。 &emsp;&emsp;至于做 B 站字幕上传工具的想法，其实好几个月前就有了想法（可能是看到别的 Up 主涨粉比较快吧(:з」∠)）&emsp;&emsp;不过我自己真的对视频字幕有洁癖，还是比较喜欢看原汁原味的视频，如果字幕压缩到视频里面无法清除，还真有点受不了。&emsp;&emsp;特别是以前看教程试过字幕挡住了视频操作，体验很糟糕^(*￣(oo)￣)^&emsp;&emsp;既然 B 站支持了 外挂 字幕功能，我的想法总算是可以实现了 ~ &emsp;&emsp;经过我不懈的努力，最终效果可以参考 B 站的这个教程 演示链接 &emsp;&emsp;选择这个教程是因为比较短，方便我测试。&emsp;&emsp;实现的原理其实不难，就是直接将 youtube 的 vtt 字幕文件转换为了 B站 的 bcc 后缀的 json 字幕，并且通过了不少时间的调试，实现 逐词 出现的效果。 Tkinter 界面开发 &emsp;&emsp;这次图形界面开发再次使用了 Python 内置的 Tkinter 来制作。&emsp;&emsp;毕竟工作上一直使用 PySide2 ，偶尔换换口味体验不同的框架还是不错的，而且 Tkinter 比 Qt 小得多，打包的大小也足够小。 &emsp;&emsp;其实看界面也没有多少东西，无非就是几个组件重复套用而已。&emsp;&emsp;不过 Tkinter 有个比较有意思的点，它的组件可以接受内置的 Variable 类，这个类的执行 set 改变数值的时候可以同步到关联的组件上。&emsp;&emsp;用这个类就实现了面板的数据绑定了。&emsp;&emsp;有了数据绑定就可以比较轻松地用统一的规则将数据存储到文件里面了。 &emsp;&emsp;所以我写了一个 Mixin 类可以将组件的数据 存储本地 也可以从本地读取。 12345678910111213141516171819202122232425262728293031323334353637import jsonclass ConfigDumperMixin(object): """ConfigDumperMixin 自动记录 Tkinter Variable 配置 """ @staticmethod def auto_load(func): def wrapper(self, *args, **kwargs): res = func(self, *args, **kwargs) self.load_config() return res return wrapper @property def config_path(self): return os.path.join(__file__, "..", "config.json") def get_tkinter_varaible(self): return [var for var in dir(self) if isinstance(getattr(self, var), tk.Variable)] def load_config(self, *args, **kwargs): path = kwargs.get("path", "") path = path if path else self.config_path if not os.path.exists(path): return with open(path, "r") as f: config = json.load(f, encoding="utf-8") [getattr(self, var).set(val) for var, val in config.items()] def dump_config(self, *args, **kwargs): path = kwargs.get("path", "") path = path if path else self.config_path data = &#123;var: getattr(self, var).get() for var in self.get_tkinter_varaible()&#125; with open(path, "w") as f: json.dump(data, f, indent=4, ensure_ascii=False) &emsp;&emsp;这个类会自动获取类下面的 tk.Variable 进行输入和输出。 &emsp;&emsp;另外组件写法上，这次接入了 contextlib 来用 with 关键字。&emsp;&emsp;通过缩进让组件写起来更有层次感，不过回过头来，其实写一个组件类封装会更加简洁。 B站 API 调试 &emsp;&emsp;上传字幕没有人测试过它的 API ，不过可以直接从浏览器 F12 的后台里面截取到接口请求。 &emsp;&emsp;在这个面板按下提交按钮，即可获取到请求链接。 &emsp;&emsp;点击之后网页会刷新，会导致之前的链接记录全部刷掉，所以要勾选这里来确保请求信息存留。&emsp;&emsp;利用右键输出 curl 命令可以在 postman 里面重构请求环境。 参考链接&emsp;&emsp;这样就不用人工添加 cookie 等等的登陆信息。 请求方式：POST 参数名 类型 内容 必要性 备注 aid num 视频av号 必要 type num 操作方式 必要 一般为 1 csrf str CSRF Token（位于cookie） 必要 data str bcc 字幕数据 必要 bvid num 视频bv号 必要 sign bool 签名 必要 一般为 false submit bool 提交 必要 一般为 true oid num 分P编号 必要 &emsp;&emsp;经过我的整理接口信息有如上参数为必填的。&emsp;&emsp;data 数据为 B 站的字幕数据，本质上就是一个用 json 记录的 srt 文件，额外记录了位置和颜色信息。&emsp;&emsp;而且目前编辑器还没有修改颜色的功能，可以实现一些 字幕 上的黑科技，不过我还是觉得黑白搭配挺简洁的。 &emsp;&emsp;另外比较坑的地方是 字幕有大小上限的 ， 如果视频很长的估计会没法上传完整的字幕。&emsp;&emsp;我想要 逐词 切分也会占用很多大小空间，随意我设置了字幕如果上传失败就用传统的切分方式上传。 bilili B站 视频下载 &emsp;&emsp;为什么要下载 B站视频呢？&emsp;&emsp;因为 B站 自动进行画质压缩，我可以下载低画质的视频来方便生成字幕。&emsp;&emsp;而且有很多老视频的资源我都不知道还有没有(:з」∠)。 &emsp;&emsp;我过去下载 B站视频用的是 jijidown 的。&emsp;&emsp;但是这些图形界面的软件没法用 Python 进行控制。&emsp;&emsp;于是在 Github 上搜索相关的 bilibili视频下载的仓库，找到了 bilili 这个工具 链接&emsp;&emsp;简答审阅过 bilili 的源码，我觉得作者的代码水平挺高的。&emsp;&emsp;用了不少的 Python 骚操作，让代码清晰可读。&emsp;&emsp;使用起来也比较简单，可以参考 -h 的帮助说明。&emsp;&emsp;用 pip 安装之后，可以直接在命令行调用 bilili 来进行下载，多线程下载速度很快。 autosub 自动翻译 &emsp;&emsp;github 上有个很多星 autosub 仓库，但是那个已经不再维护了。 链接&emsp;&emsp;几经周折，最后找到了一个国人维护的 autosub 仓库，而且还加上了一些第三方付费 API 的支持，非常不错 链接&emsp;&emsp;autosub 的使用可以方法参考作者的文章 链接 &emsp;&emsp;为了方便使用，我直接将 release 版本解压到自己的仓库里面来使用了。&emsp;&emsp;基于 命令行 来调用，默认的方式使用 Google 的 API 进行白嫖翻译，但是我好容易接入之后，发现这个翻译效果和 youtube 的机翻比起来还是差得远。&emsp;&emsp;也有可能是 autosub 的音频切分导致识别的时候缺少上下文导致的。&emsp;&emsp;终止最后的翻译效果让我很失望，所以我后续将开发精力用在了 youtube 上传和下载上。 youtube 视频上传 &emsp;&emsp;youtube 视频上传搜 github 比较高星的是前两个 https://github.com/porjo/youtubeuploader 和 https://github.com/tokland/youtube-upload&emsp;&emsp;我后面使用了 Go 语言开发的版本，因为 Go 提供了 Release 版本，方便我去调用。&emsp;&emsp;不过配置上传工具真的挺麻烦的，我在 github 仓库上留有记录 链接&emsp;&emsp;需要去登陆 Google 控制台创建一个 验证应用，然后开启 Youtube API。&emsp;&emsp;下载验证应用的 json 文件并放到 运行 exe 的目录下 (或者在 exe 里面用指定 serects)&emsp;&emsp;然后输入一个视频路径上传，会跳转到网页，从网页里面通过验证，然后获取到一遍神秘代码。&emsp;&emsp;通过 exe 的 -headlessAuth 指令输入上面的神秘代码会生成一个 token 后缀的文件。&emsp;&emsp;完成这些操作就可以愉快地上传视频了。 &emsp;&emsp;然而经过如此曲折的折腾之后，上传了 6 个视频， API 就会出现无法上传的问题。&emsp;&emsp;查了之后才知道 Google Youtube API 一天提供了 10000 Quotas ，然而上传一个视频需要消耗 1600 Quotas&emsp;&emsp;上传 6 个视频就用完了一天的免费额度了(:з」∠)&emsp;&emsp;所以经过网上查阅，最终解决方式用 selenium 操控浏览器模拟认为操作。 链接 &emsp;&emsp;通过上面的链接可以定位到写好的 Github 仓库&emsp;&emsp;链接里面用的是 Firefox 让我有点不爽，但是查了代码感觉不是很多，所以打算自己写一个 Chrome 版本的。&emsp;&emsp;结果发现 Chrome 经过 selenium 启动之后无法完成 Google 登陆验证，会提示当前浏览器不安全。&emsp;&emsp;在 StackOverflow 找到解决方案 链接&emsp;&emsp;通过 Stack Overflow 的 Google 登陆来要开 youtube 的验证，我验证过是可行的，但是最后还是用回了 Firefox 图省事。 &emsp;&emsp;后来我发现 B 站的字幕有大小上限，但是用网页端可以上传我测试用的字幕。&emsp;&emsp;检查后台发送的接口的数据没有 form data 的数据，Header 里多出了 content-length 字段。&emsp;&emsp;没有任何的解决想法，只能想到用 selenium 自动化上传来解决问题。 &emsp;&emsp;使用 selenium 自动化需要先用一定的规则匹配到页面上的元素，比较常用的方法是 xpath&emsp;&emsp;然而 selenium 启动是在是太慢了，我做元素抓取的工作实在是等到黄花菜都凉了还没好。&emsp;&emsp;所以我去搜了一下 Chrome 的扩展，还发现了非常方便的浏览器扩展来解决问题。 链接&emsp;&emsp;F12 后台的 element 标签里会多出一个 chropath 标签，选择页面的元素会自动生成相应 xpath ，非常省心。&emsp;&emsp;我在 B 站的字幕上传页面里面一直无法用 xpath 定位到相关的元素，最后用了 chropath 也无法定位。&emsp;&emsp;后来再查，发现这个页面居然是 iframe 嵌套进去的。&emsp;&emsp;B站的字幕编辑器链接要用这个 &quot;https://account.bilibili.com/subtitle/edit/#/editor?bvid={bvid}&amp;cid={cid}&quot;&emsp;&emsp;这样才可以使用 xpath 选择器来触发相关元素的点击效果。 &emsp;&emsp;好不容易完成了 selenium 控制的自动上传，结果才发现有些更大的字幕用网页端也无法上传。&emsp;&emsp;网页端的上传速度不如 API 接口快，还是用 API 接口更方便，所以我又改回去了。 youtube 字幕下载 &emsp;&emsp;这里我又踩了很多坑，我记得以前 PLB下载工具整好的时间，我挂机下载了很多 Pluralsight 的教程字幕。&emsp;&emsp;不过我用的不是 自己开发的垃圾工具，而是用了 youtube-DLG 来实现字幕下载，下载的数量之多以至于我账号都被封了(:з」∠)&emsp;&emsp;因为短时间内看了访问了大量的教程页面。 &emsp;&emsp;youtube-DLG 是 youtube-dl 下载神器的图形化界面工具&emsp;&emsp;震惊！ 写文章之际访问 youtube-dl 的主仓库居然因为版权问题被封禁了(:з」∠)，前几天还 clone 了源码，可惜 issue 看不到了。&emsp;&emsp;难怪我发现 youtube-dl 问题越来越多却维护得很不积极。 &emsp;&emsp;我前几天找到了国人维护的魔改版本 链接&emsp;&emsp;也拿来测试了，然并卵(:з」∠)，折腾了我很多时间。 &emsp;&emsp;我来给大家从头捋一捋用 youtube-dl 下载字幕遇到的坑。&emsp;&emsp;youtube-dl 下载公开视频的字幕是没有问题的，但是一旦涉及到私享字幕就不行了。&emsp;&emsp;根据 youtube-dl 的说明获取 cookies 也没有用。&emsp;&emsp;然后查了 Stack Overflow ，通过 –add-header 添加 cookie 也没有用 &emsp;&emsp;后来就没法子了， Github 上关于 youtube 字幕下载比较高星的是这个 链接 浏览器扩展&emsp;&emsp;我装了这个扩展的确可以下载到 youtube 的字幕。&emsp;&emsp;于是我又查了这个扩展的源码，看看是怎么获取的，里面的代码不多，比起 youtube-dl 恐怖的代码量好多了。&emsp;&emsp;作者的 readme 有获取说明 链接&emsp;&emsp;直接获取通过 js 获取页面的 ytplayer 公共变量居然可以获取到 字幕 的信息。&emsp;&emsp;信息里面直接有了获取的字幕的直链。&emsp;&emsp;但是这个方法我没法用 Python 来搞，最后还是的查了 youtube-dl 的源码来实现。 &emsp;&emsp;原来是先访问视频页面，可以从页面里找到下载字幕相关的 https://www.youtube.com/api/timedtext 开头的 API&emsp;&emsp;然后再通过这个链接加入 fmt=vtt 下载 vtt 字幕 (默认是 xml 格式的字幕信息)&emsp;&emsp;另外加上 tlang=zh-Hans 可以获取到中文翻译的字幕。&emsp;&emsp;最后我用 postman 生成代码加上我的 youtube cookie 就可以将我私享的视频字幕拔下来，私享也不用担心视频的版权问题。 &emsp;&emsp;在 postman 上我已经测试能够获取到字幕链接了。&emsp;&emsp;然而在 Python 里面获取的页面是一堆乱码。&emsp;&emsp;这个问题也折腾了我好久，没有搞明白。&emsp;&emsp;我查外网 Stack Overflow 没法将这个问题描述清楚，查不到有用的解决方案。&emsp;&emsp;后来我直接查国内的 Request 乱码 ，虽然中间也有些不靠谱的，不过最后还真找到解决方案 链接&emsp;&emsp;原来是压缩导致的乱码。 链接&emsp;&emsp;根据链接的操作直接注释掉 &#39;accept-Encoding&#39;: &quot;gzip, deflate, br&quot; 可以解决问题，主要是 br 的问题。&emsp;&emsp;后面就比较顺利，后面直接粗暴地通过正则抓 timedtext API链接。 &emsp;&emsp;有了链接加上上面提到的两个参数获取出字幕，再将字幕转换即可。 字幕 转 bcc &emsp;&emsp;字幕转换主要依赖了 pysrt 和 pyvtt 库&emsp;&emsp;这个直接将每一行字幕解析成了一个对象，获取和修改都很方便。&emsp;&emsp;获取了信息之后需要将时间转换成为 秒 单位即可。&emsp;&emsp;bcc 字幕没啥特别的，其实就是将 srt 转为 json 格式，并且加多了一些信息进行描述而已。 123456789101112131415161718192021&#123; "font_size": 0.4, "font_color": "#FFFFFF", "background_alpha": 0.5, "background_color": "#9C27B0", "Stroke": "none", "body": [ &#123; "from": 6.399, "to": 7.829, "location": 2, "content": "hello everyone" &#125;, &#123; "from": 7.829, "to": 7.839, "location": 2, "content": "hello everyone" &#125; ]&#125; &emsp;&emsp;就是将 vtt 字幕转成逐字出现的 字幕 效果花了我不少的时间进行调试。&emsp;&emsp;因为需要我用正则去匹配 vtt 内部的 tag 来生成新的字幕。&emsp;&emsp;最后有些大视频还因为字幕文件太大上传不了，着实有些遗憾。 总结 &emsp;&emsp;以上就是我花了两周的空余时间做好的字幕上传工具。&emsp;&emsp;操作逻辑就是先将 B站的视频下载上传到 youtube 上，并且记录下 youtubeid 和 B站视频id 的对应信息。&emsp;&emsp;等到字幕生成完成之后，在遍历一遍记录好的 json 文件，然后将可以上传的字幕转换上传到 B 站。&emsp;&emsp;现在虽然已经换成了 selenium 自动化控制浏览器上传视频了，然而单日最多只能上传 50 个视频，这个过程只能慢慢来了。 &emsp;&emsp;另外，这个工具结束之后，还是很希望自己可以静下心来好好地学习 Houdini 了。&emsp;&emsp;视频教程系列我都准备好了，只等自己开干起来。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠕPython/Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome 浏览器扩展 实用推荐]]></title>
    <url>%2Fposts%2F3c806643.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;我原本还计划要出一篇关于 Windows 美化指南的文章。&emsp;&emsp;但是我个人是实用主义先行的，美化没啥用，还要用软件修改系统底层的东西。&emsp;&emsp;随着时间流逝，我还是奉行了简洁至上主义吧，没有把美化贯彻到底，所以 windows 美化指南也就流产了。 &emsp;&emsp;这一篇文章来总结一下最近一直一段时间好用的 Chrome 插件。 &emsp;&emsp;以前我常用的浏览器是 360 ，没有别的原因，最早开始用起来的。&emsp;&emsp;后面收藏夹等等东西全部都存在里面，形成了依赖，所以就一直用着。&emsp;&emsp;后面网上查了一下，发现 Chromium 浏览器的收藏都是可以互相迁移的。&emsp;&emsp;国内几乎所有的浏览器都是基于 Chromium 内核修改的（没错吐槽的就是国产之光红芯浏览器） &emsp;&emsp;后来来了腾讯之后，还是支持一下腾讯的产品，所以就转用了 QQ浏览器了。&emsp;&emsp;虽然在网上看到很多文章推荐 微软新出的 Edge 浏览器。&emsp;&emsp;不过我还是没有找到让我非转不可的理由，所以我目前还是使用着 QQ浏览器 。 Vimium Google 商店 github 地址 &emsp;&emsp;这个插件是集成大成之作，整合了多个插件的功能。&emsp;&emsp;在还没有知道这款大名鼎鼎的插件之前，我还是通过好几个不同的插件来实现一些便利的操作。&emsp;&emsp;自从发现了这款神器之后，我就少用了好多个插件。 &emsp;&emsp;这款插件的功能非常多，但我个人并不常用 vim 所以并没有那么深的键盘执念。&emsp;&emsp;所以其实很多功能我都不大用得上。 &emsp;&emsp;Vimium 有非常不错的搜索功能。&emsp;&emsp;通过 O 键可以快速搜索历史，就可以通过这个 vomnibar 来快速进入搜索页面 &emsp;&emsp;搜索引擎配置可以在 属性的 Custom Search Engine 进行配置，不过我个人可能更习惯使用 listary &emsp;&emsp;另外 yt 快捷键可以快速复制标签页，这个我有很喜欢。&emsp;&emsp;不过我通常将这个快捷键改为 alt+shift+D ，习惯使然。 &emsp;&emsp;有点不爽的就是 X 键，会和我另一个插件产生冲突，而且本事也可以通过 ctrl+W 来关闭标签，所以我就把它干掉了。 &emsp;&emsp;另外 Vimium 的搜索功能支持正则表达式，有替代我另一个插件的功能。 根据 github说明&emsp;&emsp;搜索模型按 / 键启动，并且在最后加上 \r 即可启用正则表达式匹配 &emsp;&emsp;只是匹配方式不太适应， Enter 键确认匹配方式之后，按 n 键来跳转匹配结果。 Tampermonkey &amp; html5视频播放器增强脚本 Google 商店 &emsp;&emsp;油猴脚本插件绝对是重量级，它相当于脚本容器，让简单的 JS 脚本也可以使用 浏览器插件的 API。&emsp;&emsp;而油猴脚本千千万万，能够让我爱不释手的只有一个 - Html5 视频播放器 github 地址 Greasy Fork 安装地址 &emsp;&emsp;有了这个视频播放器增强功能，我看教程再也不需要下载了，操作习惯是按着 PotPlayer 来的。&emsp;&emsp;功能非常全面，我大多数时候只需要 视频加速 功能 和 Shift + P 在 youtube 上开小窗口模式。&emsp;&emsp;不少快捷键和 Vimium 冲突了，使用的时候需要 按 i 键开启 Vimium 的插入模式，防止快捷键冲突。 OneTab Google 商店 &emsp;&emsp;这个工具可以一键收容当前所有的窗口，然后按需要进行打开。&emsp;&emsp;用得不多，页面开多了不舍得关闭的时候还挺有用的。 Smart TOC Google 商店 &emsp;&emsp;这个小工具可以自动生成文章的目录，有时候看别人的博客没有目录浏览的时候还是非常方便。 JSONView Google 商店 &emsp;&emsp;测试接口的时候还是挺好用的，自动格式化 Json 数据，看得更舒服。 二箱 Google 商店 github 地址 &emsp;&emsp;鼠标右键在 二箱 的标签下可以提取当前网页的所有图片。&emsp;&emsp;快速获取当前页面可下载的图片链接，并且可以直接拖拽到本地。&emsp;&emsp;省得我用 F12 在 Html 里面找地址了。 &emsp;&emsp;另外 二箱 提供了全网快速搜图功能，非常赞~ 二管家 Google 商店 github 地址 &emsp;&emsp;这个和上面的插件是同一个作者开发的。&emsp;&emsp;这个管家可以对自己本地安装的插件进行分组，快速开启不同分组的插件。&emsp;&emsp;如果安装了很多插件的话，使用这个管理非常好用。 Octotree Google 商店 github 地址 &emsp;&emsp;这个插件给 Github 网站扩展了层级树结构，方便浏览项目下的文件。 总结 &emsp;&emsp;其实我对浏览器插件的需求很低，日常使用上用得最多的就是 Vimium 和 H5 播放器 两个&emsp;&emsp;希望这次个人分享对大家使用浏览器有所帮助。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 旋转崩溃]]></title>
    <url>%2Fposts%2F92926042.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这篇文章记录个 Maya2018 及以下版本的小坑点。&emsp;&emsp;解决方案正如简介说的，非常简单，但是不知情的情况下可是花了很多时间来查这种莫名其妙的问题(:з」∠) 问题描述 &emsp;&emsp;Maya 在复杂的带约束绑定下，旋转控制器很容易导致 Maya 卡死或者闪退。&emsp;&emsp;某些特定的文件下可以复现问题（最近才拿到了一个固定崩溃的文件），大多时候并不能准确重现，导致之前无法追踪问题所在。 解决方案 &emsp;&emsp;将首选项的 运行方式 改为 老版本的 DG 模式即可解决问题。&emsp;&emsp;包括之前做的眼睛UV偏移测试也有同样的问题，默认的 Parallel 并行模式在 2018 以下的版本尚不稳定。&emsp;&emsp;Maya 2018 以上我还尚未深入进行测试，不过固定崩溃的文件在 19 下不会触发崩溃，可能官方修复了一些 BUG 吧。 副作用 &emsp;&emsp;如果将运行模式改为 DG 即基于 Dependency Graph 脏值运算的方式，动画是单线程运算，所以帧数会掉得很厉害。&emsp;&emsp;还好我这边的游戏项目没有影视那么重，只有个别动画受不了，要根治问题只能考虑进一步升级版本。&emsp;&emsp;2019 加入了动画缓存，可能对动画师更加友好。 总结 &emsp;&emsp;感觉水了一篇文章(:з」∠)&emsp;&emsp;不过这个问题的确卡了我大半个下午，踩这种坑也是让我难受的很，感谢经验丰富的厂长，快速帮我定位到了问题。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minigame 总结]]></title>
    <url>%2Fposts%2F460115f3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;经过长达两个星期（包含国庆假期）的爆肝， Minigame 项目终于搞完了。&emsp;&emsp;虽然之前 Minigame 刚启动不久就已经写了一篇概况文章进行总结，但是后来事情不断增多，就没有就行跟进文章了。&emsp;&emsp;没想到腾出时间来， Minigame 项目已经基本做完了。&emsp;&emsp;下面就记录一下这次 Minigame 的开发经历~ 前期准备游戏存档工具AI人工智能角色行为Unreal游戏素材资源 角色素材 (写实)牲畜 (页游)大唐人物3DMAX古代大唐中国风人物角色 动作骑兵弓箭手手持剑盾武士动画15组角色行走动画攀爬 Unreal Engine虚幻游戏引擎扩展资料2017年10月合辑第一季忍者动作 shader 效果雪地 场景植物山脉 (low poly)武士道 lowpoly (页游)大唐无双场景高品质中国风场景游戏镇魔曲 (写实)日式建筑 Unreal Engine虚幻游戏引擎扩展资料2020年1月合辑第一季日式建筑 UE4幻游戏引擎扩展资料2020年2月合辑第二季亚洲神庙寺庙亚洲建筑景观日本德川幕府江户旧东京城市建筑场景 &emsp;&emsp;当时在人人素材网里面找到一些比较合适可用的素材。 场景 &emsp;&emsp;在前期准备的过程中，我们定了以影子战术这种潜行暗杀游戏为核心玩法。&emsp;&emsp;虽然也找好了一些 low poly 的模型素材，但是为什么不直接从游戏里面直接拿呢？ &emsp;&emsp;我知道这款游戏是用 Unity 打包的，于是我去网上找了如何破击 Unity 游戏的方法&emsp;&emsp;破解 Unity 游戏资源的软件有好多，但是最好用的还是 Github 上开源的 AssetStudio&emsp;&emsp;免费而且更新相当频繁，抓取得素材也非常全。(就是动画似乎没能成功抓取出来) &emsp;&emsp;抓取之后可以获取到影子战术的场景的FBX ，将 FBX 导入到 Maya 就可以获取到可以用的资源。 &emsp;&emsp;因为我把资源都抓取出来，所以就打算直接抄里面的资源素材来用。&emsp;&emsp;于是尝试用这个进行关卡搭建。珠玉在前，最后几乎就是照着抄了原来的场景做。 角色 &emsp;&emsp;我们比较早确定了使用潜行暗杀的玩法，并且将题材固定到了荆轲刺秦上。&emsp;&emsp;为此我需要找一批合适的角色模型，并且对角色进行绑定制作动画。&emsp;&emsp;角色上虽然上面找到的素材已经有一些也有风格的资源，但是整体呈现不太 low poly&emsp;&emsp;而且角色需要围绕秦朝，带有一些古代士兵的模型，于是找来找去，还是往秦时明月上找到了好资源。 资源链接 &emsp;&emsp;这套资源虽然是手绘贴图的，但是角色足够多，这样可以解决风格统一的风格。 &emsp;&emsp;上面是 Maya 整合出来的部分资源。 &emsp;&emsp;有了角色资源之后需要进行 Maya 角色绑定，这里还是采用了 Advance Skeleton 插件来解决控制器的问题。&emsp;&emsp;通过 ADV5 的 Name Matcher 可以让 ADV 的骨架同步到 Unreal 的骨架并且进行约束控制。 &emsp;&emsp;然后需要导入 Unreal 官方的 Mannequin 骨架，将骨架适配到角色模型上。&emsp;&emsp;这里有个坑点，原本是打算是只匹配左边，然后右边的骨架删除镜像过去的，但是这么操作会导致 Unreal 的动画不匹配，应该是动了骨骼的朝向导致出问题了。&emsp;&emsp;后面还是老老实实地调完左边再调整右边的位置，强迫症表示有点难受。&emsp;&emsp;骨架摆好位置之后可以直接和目标模型进行绑定了，控制器生成，ADV已经做好了按钮，照着顺序点击即可。 &emsp;&emsp;有了控制器，自己做动画也会方便很多。&emsp;&emsp;后续就是花时间刷权重即可，因为我们的模型都是 low poly ，所以刷权重比较简单。&emsp;&emsp;刷好了主角的权重之后，其他角色都复制主角的权重就已经差不多了，在把一些边边角角修补一下，就可以了。 &emsp;&emsp;最后放进引擎的 NPC 18 个 | 主角 3 个 | 士兵 5 个&emsp;&emsp;为了减少秦时明月的辨识度，我还通过换头大法，凭空制作出了几个新的角色，所以 NPC 会有那么多，不过并不是所有的角色都放到游戏里使用。 动画RPG动作 官网链接NPC动作 官网链接武士动画 官网链接 &emsp;&emsp;上面进一步收集了偏 low poly 的战斗动画。&emsp;&emsp;动画这边经过我在项目组的经验，如果所有的角色都可以用同一套骨骼，那就可以实现动画的互通，这样适配动画会很省事。&emsp;&emsp;UE 这边也搜索了相关的动画蓝图系统，无意中在一些 Unreal 合集里面发现了 Advance Locomotion 3.0 的包&emsp;&emsp;万万没想到这个动画蓝图库居然到 4.0 之后完全免费开放到官方的商城里。 链接&emsp;&emsp;Advance Locomotion 整合了各种运动的变化，4.0 还加入任意攀爬系统以及脚的 IK 系统。在游戏动画的圈子里相当有名，以至于网上都有不少分析这个的文章。&emsp;&emsp;Advance Locomotion 是以 虚幻的官方 骨骼为标准的，如果我将上面的 Unity 动画全部重定向到 虚幻引擎的官方骨骼就可以同时接入 Advance Locomotion 的特性。 &emsp;&emsp;于是我写了脚本批量将上面的 Unity 动画骨架重定向到 Unreal 上。&emsp;&emsp;当然这个过程并非一帆风顺的，需要解决一些问题。 &emsp;&emsp;首先就是上面找到的 RPG 动作 和 NPC 动作的 FBX 文件动作只是个 locator 动画数据，并没有骨骼。&emsp;&emsp;所以我要想办法将 locator 层级转换为骨骼层级。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: utf-8 -*-"""选择 locator 层级 生成跟随骨骼"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-09-08 15:34:00'from maya import cmdsdef hierarchyTree(parent, tree): children = cmds.listRelatives(parent, c=True, type='transform') if children: tree[parent] = (children, &#123;&#125;) for child in children: hierarchyTree(child, tree[parent][1]) else: del treedef retrieve2Jnt(tree,jnt_list=[]): for parent, data in tree.items(): parent_jnt = "%s_jnt" % parent if not cmds.objExists(parent_jnt): cmds.select(cl=1) parent_jnt = cmds.joint(n=parent_jnt) jnt_list.append((parent_jnt,parent)) # cmds.delete(cmds.parentConstraint(parent,parent_jnt)) cmds.parentConstraint(parent,parent_jnt) children, child_tree = data for child in children: cmds.select(cl=1) child_jnt = cmds.joint(n="%s_jnt" % child) jnt_list.append((child_jnt,child)) # cmds.delete(cmds.parentConstraint(child,child_jnt)) cmds.parentConstraint(child,child_jnt) cmds.parent(child_jnt,parent_jnt) retrieve2Jnt(child_tree,jnt_list) def main(): hierarchy_tree = &#123;&#125; hierarchyTree(cmds.ls(sl=1)[0],hierarchy_tree) if not hierarchy_tree: return jnt_obj_list = [] retrieve2Jnt(hierarchy_tree,jnt_obj_list)if __name__ == "__main__": main() &emsp;&emsp;输出带动画的骨骼之后将关键帧 bake 下来输出成 FBX 文件。&emsp;&emsp;然后将脚本写成批量操作输出一套带骨骼的 FBX 文件。&emsp;&emsp;最后就是要解决这套新生成的骨骼如何匹配到 Unreal 骨骼上的问题了。 &emsp;&emsp;有了骨架文件之后需要做一套新骨架约束到 ADV 骨架的重定向方案，最初我是想着用 HumanIK 来做的。&emsp;&emsp;网上查了一下，发现 ADV 有内置对接 mocap 骨架的功能。 &emsp;&emsp;因为生成的骨架并不是 mocap 骨架，直接用 ADV 归零匹配是会有问题的，所以需要骨架和角色以 T-pose 的方式进行匹配到一起。&emsp;&emsp;然后就可以用 ADV 做好的一键约束功能将两套骨架通过旋转约束进行同步。&emsp;&emsp;最好了这个模板即可。 &emsp;&emsp;最后就是用脚本批量导入前面生成的 FBX 骨架动画，然后将角色的 Unreal 官方骨架输出为 FBX 即可，这个 FBX 导入虚幻就是重定向动作的文件了。&emsp;&emsp;这样就可以得到好几百个重定向好的动画文件，动画匹配其实并不是很完美，但是我们俯视角的游戏下其实问题不大。&emsp;&emsp;另外武士动画系列的文件带骨骼，比较好处理，虽然全部输出了 FBX 文件，但是最后由于动作太过浮夸，并没有采用。 &emsp;&emsp;输出了 FBX 文件又担心策划不会使用，所以写了个 批量 拍屏脚本，将动画文件套入到我们的主角上，输出了一批视频文件。 &emsp;&emsp;做完了前期工作之后，大概中间有1个多星期没有弄 minigame 了。&emsp;&emsp;一直到临近脱产才开始将前面搭建的场景合入到项目的 git 下面。 国庆前脱产 &emsp;&emsp;终于 9月25日 进入了 Minigame 脱产开发阶段。&emsp;&emsp;结合之前搭建好的场景，我计划教会策划使用 Maya ，然后直接复用 影子战术的素材来完成场景的搭建。 Maya 搭建场景输出到 Unreal &emsp;&emsp;影子战术的素材非常多，最初我考虑用 Maya 缝合影子战术的场景，然后统一导入到 Unreal 里面。&emsp;&emsp;我考虑使用 Maya 的 Assembly Reference 的方式将相同类型的素材整合到一起，方便切换堆砌场景。 &emsp;&emsp;所以我又写了个脚本一键将 影子战术 的场景中选中的模型导出到制定的目录，并且将模型位置归位到原点上。 &emsp;&emsp;工具还配套了一些修复材质透明等等的辅助功能。&emsp;&emsp;在开发这些东西的过程中，策划搭建不了场景，我只能安排他们去游戏里找可以用的资源（结果这些时间都浪费掉了） &emsp;&emsp;使用 Maya 搭建场景是影视的工作流程，在游戏开发里面反而还会多出了一步了迁移模型到引擎的操作。&emsp;&emsp;而用 Maya 搭建的模型，即便是用了完全相同的模型，引擎也无法识别出来，还是会以独立的模型进行分配。&emsp;&emsp;不同位置的模型全部会变成一个单独的 StaticMesh ， 而且导入到 Unreal 会把电脑的 内存 吃满，流程非常不合理。 &emsp;&emsp;然而导入的时候如果勾选 Combine 选项，最后只会生成一个 StaticMesh ，相对不会那么吃内存。但是碰撞会变成一个整体，又出大问题。 &emsp;&emsp;最后痛定思痛，我需要在 Maya 里面找出相同的模型，然后通过 Locator 定位在虚幻里重新排列模型。 UE4论坛链接&emsp;&emsp;这套操作参考了论坛小哥的方案，通过 Socket 命名可以让虚幻识别到对应的 locator 位置。&emsp;&emsp;识别 locator 排列模型则是通过 Unreal 的 Python 来实现。 &emsp;&emsp;寻找相同模型的方案我是通过 材质 + 点数 进行判断的。&emsp;&emsp;虽然不排除相同材质下的模型点数可能相同但是模型却是不同类型的情况，但是这些特殊情况很少，到时候就单独拿出来处理就好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# -*- coding: utf-8 -*-"""材质拓扑一致的模型进行实例替换"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-09-17 00:00:27'import osimport jsonfrom collections import defaultdictimport pymel.core as pmimport pymel.core.nodetypes as ntdef error_log(func): def wrapper(*args, **kwargs): try: res = func(*args, **kwargs) return res except: import traceback print(u"程序错误 | 请联系 梁伟添 timmyliang\n\n%s" % traceback.format_exc()) return wrapper@error_logdef main(): export_dir = r"D:\_minigame\_scene\test" # TODO 遍历所有的 Phong 材质进行场景导出 # mtl_list = [mtl for mtl in pm.ls(materials=1) if isinstance(mtl,nt.Phong)] m = pm.PyNode('bas_ca_wall_stone_12m_00_mat_wet') mtl_list = [m] for i,mtl in enumerate(mtl_list): obj_list = [obj for se in mtl.connections() if isinstance(se, nt.ShadingEngine) for obj in se.connections() if isinstance(obj, nt.Transform)] if not obj_list: continue grp = pm.group(obj_list,n="EXPORT_#",w=1) data = defaultdict(list) for mesh in obj_list: data[mesh.numTriangles()].append(mesh) # NOTE 清空小于等于 1 的模型 obj_list = [data.pop(verts) for verts,m_list in data.items() if len(m_list) &lt;= 1] # TODO 获取每个模型的位置 for mesh_list in data.values(): try: loc_list = [] for i,mesh in enumerate(mesh_list): # NOTE 居中轴心 pm.parent(mesh,w=1) pm.xform(mesh,cp=1) # NOTE 命名为 Socket_序号 方便虚幻识别 loc = pm.spaceLocator(n="SOCKET_#") pm.parentConstraint(mesh,loc,mo=0) pm.scaleConstraint(mesh,loc,mo=0) loc_list.append(loc) m = mesh m_name = m.shortName().replace("|","_") m_name = m_name[1:] if m_name.startswith("_") else m_name pm.parent(mesh,w=1) pm.select(mesh) # NOTE bake 轴心点 pm.mel.BakeCustomPivot() mesh.t.set(0,0,0) mesh.r.set(0,0,0) path = os.path.join(export_dir,"%s.fbx" % m_name) pm.mel.FBXExport(f=path,s=None) # NOTE 创建一个三角面来导出 Locator tri = pm.polyCreateFacet( ch=0,p=[(0.0, 0.0, 0.0), (0.10, 0.0, 0.0), (0.10, 0.10, 0.0)],n="LocContainer")[0] pm.parent(loc_list,tri) pm.select(tri) pm.hyperShade( assign=mtl ) path = os.path.join(export_dir,"%s_loc.fbx" % m_name) pm.mel.FBXExport(f=path,s=None) except: print("fail",mesh_list) continue if __name__ == "__main__": main() &emsp;&emsp;上面的脚本用来输出一个材质的 Locator 效果。 &emsp;&emsp;接下来将输出的 LocContainer1 模型导入虚幻即可。&emsp;&emsp;导入的效果如下图 &emsp;&emsp;在虚幻引擎里面导入大量FBX，通过 ImportAll 按钮导入有时候会导致模型的明明和原本的 FBX 并不一致的问题。&emsp;&emsp;为此我又写了脚本来实现遍历目录批量逐个导入的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: utf-8 -*-"""导入 FBX 手动导入大量 FBX 名称会有对不上"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-09-17 13:59:15'import osimport unrealasset_tool = unreal.AssetToolsHelpers.get_asset_tools()def buildImportTask(filename='', destination_path=''): options = unreal.FbxImportUI() options.set_editor_property( "mesh_type_to_import", unreal.FBXImportType.FBXIT_STATIC_MESH) task = unreal.AssetImportTask() task.set_editor_property("factory", unreal.FbxFactory()) name = os.path.basename(os.path.splitext(filename)[0]) # NOTE 设置 automated 为 True 不会弹窗 task.set_editor_property("automated", True) task.set_editor_property("destination_name", name) task.set_editor_property("destination_path", destination_path) task.set_editor_property("filename", filename) task.set_editor_property("replace_existing", True) task.set_editor_property("save", False) task.options = options return taskdef main(): path = r"D:\_minigame\_scene\test" export_path = '/Game/Map' for i,fbx in enumerate(os.listdir(path)): if not fbx.endswith(".fbx"): continue task = buildImportTask(os.path.join(path,fbx),export_path) asset_tool.import_asset_tasks([task])if __name__ == "__main__": main() &emsp;&emsp;成功导入之后，需要按照带有 locator 的 StaticMesh 记录的位置进行场景重排。 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: utf-8 -*-"""https://answers.unrealengine.com/questions/75214/view.html使用 locator 流程导入 模型 节省资源"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-09-17 10:13:14'import osimport unreallevel_lib = unreal.EditorLevelLibrary()util_lib = unreal.EditorUtilityLibrary()def main(): for asset in util_lib.get_selected_assets(): name = asset.get_name() if not isinstance(asset,unreal.StaticMesh) or name.endswith("_loc"): continue container_path = os.path.splitext(asset.get_path_name())[0] container = unreal.load_asset("%s_loc" % container_path) if not container: print("失败路径 -&gt; %s" % container_path) continue container = level_lib.spawn_actor_from_object(container,unreal.Vector(0.0, 0.0, 0.0)) r = unreal.AttachmentRule.SNAP_TO_TARGET for socket in container.root_component.get_all_socket_names(): mesh = level_lib.spawn_actor_from_object(asset,unreal.Vector(0.0, 0.0, 0.0)) mesh.attach_to_actor(container,socket,r,r,r,False)if __name__ == "__main__": main() &emsp;&emsp;然而使用上面的方式 spawn 模型到场景里面，位置没有问题，就是旋转值会有偏差。&emsp;&emsp;但是处理到这里已经花费了我大量的时间了。 &emsp;&emsp;原本打算在花点时间把旋转的问题也解决一下的，但是第二天开了会之后，所有的规划都被打乱了。&emsp;&emsp;起因是开会的前天晚上，我们把搭建好的初版模型给被别人看到了。&emsp;&emsp;别人一看就说，这不就是影子战术吗？&emsp;&emsp;这个回答如同闪电一样，让我们所有人都不好了，虽然并非不可以做移植，但是终究还是抄得太过明显了(:з」∠)。&emsp;&emsp;所以第二天开会之后，讨论的结果是放弃掉 影子战术 的资源。&emsp;&emsp;毕竟我们做的是中国风的游戏，影子战术的模型太过 日本 风了，辨识度也有点高。&emsp;&emsp;因为这个问题，我还尝试过将 影子战术 的贴图转成马赛克 来混淆视听，最后经过讨论还是否决了这个提案。 &emsp;&emsp;于是我们又需要找适合新的模型资源了，而且折腾了这么久我还是没有把 Maya 到 Unreal 的流程跑通，既然换资源，程序建议直接在 Unreal 里面搭建场景。&emsp;&emsp;我想了想还是觉得自己不要折腾了，所以也同意了程序的方案。（即便我把 Maya 的流程跑通了，其实并没有方便多少搭场景的操作，顶多是可以用 Asseembly Reference 来方便切换模型而已(:з」∠)，这么一想感觉自己被 Maya 束缚了，虽然前面做了大量工作都要放弃有点可惜，但是固执己见只是拖慢进度而已） 推倒重建场景 &emsp;&emsp;推倒重来之后，需要新的场景素材来搭建，而且 国庆临近，工期变得非常赶(:з」∠)&emsp;&emsp;而我们还没有想好到底是用我一开始找到的 low poly 素材还是找一些 偏影子战术 中国风的场景素材。&emsp;&emsp;经过一个早上折腾找资源，最后还是由我们的主策 星楠 拍板用 low poly 的素材。&emsp;&emsp;然后其他策划就帮忙在网上找些能用比较适合我们风格的素材。 Japnese_TempleLowPoly_Asia &emsp;&emsp;最后是上面两个素材最符合我们的要求（现在的场景充满了上面两个素材的痕迹）&emsp;&emsp;确定了素材之后，我将之前的 Low poly 资源（那个原本是 Unity 的资源）分门别类地整合了一下，发给策划们单独搭建场景。&emsp;&emsp;最初我没有将角色模型给到他们，结果他们搭建的场景过大，还好后面及时补救了一下。&emsp;&emsp;于是场景构建的工作逐渐步入正轨。 Unreal Placer 工具 &emsp;&emsp;因为素材都是分门别类地放到引擎里面，策划找起来不太方便。&emsp;&emsp;所以我想搭建一个工具，方便策划来搭建场景，所以就加班加点做了个 Placer 搭建场景的 Unreal 工具。 &emsp;&emsp;为此我参考了 UnrealEnginePython 的插件，通过蓝图实现资源缩略图的获取，然后在 PySide 里面重建缩略图。 &emsp;&emsp;策划双击面板的缩略图对应的资源就可以将模型生成到场景里面。&emsp;&emsp;我还打算把模型对齐的功能做上去，考虑到有点难，我还是先将自己的工作成果和 PM 同步了一下。&emsp;&emsp;PM 给我的回答是功能很鸡肋(:з」∠)，这些功能并不是很重要，没有也照样可以搭。&emsp;&emsp;虽然很不愿意承认，但是说的是事实。 &emsp;&emsp;所以后续我的工作回归到重头戏的 动作 上。 国庆期间 &emsp;&emsp;Minigame 项目的场景还没有出来，我还是很焦虑的，虽然策划说只要一天就可以把堆量工作搞完，我还是不放心。&emsp;&emsp;尽管如此，国庆还是来了。&emsp;&emsp;今年国庆我很早就规划好要回老家，需要花三天时间。&emsp;&emsp;没想到出游的人实在是太多了，三天回家的时间有两天都在路上(:з」∠) &emsp;&emsp;赶回深圳之后还要抽空搬家，真是挺赶的。&emsp;&emsp;原本打算这三天把一个 Unreal 动画的教程给看完的，但是路途颠簸，加上自己太累了，还是没能完成任务。 角色动作叠加 &emsp;&emsp;我们的游戏动作完全依靠 Advance Locomotion 框架实现的。&emsp;&emsp;框架上已经实现了 Overlay 系统，因此要叠加更多的动作，应该也是在 Overlay 的动画层上添加。&emsp;&emsp;这样可以确保角色下半身可以移动奔跑而不影响到动画的播放。 &emsp;&emsp;最后做完是上面的效果。&emsp;&emsp;叠加的方式其实可以抄 举火炬 之类的效果。 &emsp;&emsp;动画蓝图里面会根据当前 跑步 走路 攀爬 的装填然后去这个动作特定时间的动画曲线。&emsp;&emsp;这些动画曲线控制了注入 IK 系统等等的过渡。&emsp;&emsp;直接复制这些部分最后在动作输出的时候叠加上我们要播放的攻击动画即可。 &emsp;&emsp;攻击的时候上半身叠加攻击动画，这样角色就可以以奔跑只是进行攻击。&emsp;&emsp;虽然看着抄过来很简单，这个过程摸索花了我很多时间，特别是双手动画需要开启 IK 。&emsp;&emsp;最初不知道是相关的动画曲线会开启，摸索了很长时间。 &emsp;&emsp;触发动画则需要通过一个 布尔 变量来实现， 动画蓝图的 Tick 里面有不断同步角色蓝图变量的操作。&emsp;&emsp;这里我依葫芦画瓢加多了个 攻击 变量，攻击的时候让变量变为 true 就会叠加攻击状态的动画，通过 delay 让变量变为 false 恢复角色状态。&emsp;&emsp;另外因为之前重定向了很多的动画，我通过 Blend Pose By Int 节点通过输入随机数来随机抓取一个攻击动画。&emsp;&emsp;发挥动作丰富的优势。 角色随机状态 &emsp;&emsp;考虑到动作士兵的种类都比较多。&emsp;&emsp;如果加入随机状态的话，就可以组合成各种各样不同的士兵。 &emsp;&emsp;于是我构建出新的数据结构，更好地随机角色的状态。 &emsp;&emsp;通过构建 OverLayTable 可以区分出左手和右手的攻击动画，并且获取动画的长度方便进行 Delay 结束。 &emsp;&emsp;设置 Enum 状态判断角色左右手， Both 则是双手武器，动画也会根据这个状态来进行随机。&emsp;&emsp;通过这个方式可以随机出大量不同状态的士兵，士兵的 SkeletalMesh 以及单手武器也都是通过蓝图随机添加上去的，增加关卡击杀的体验。 &emsp;&emsp;士兵的随机语句通过 EnemyWordTable 来获取。 &emsp;&emsp;根据关卡名配置，这样不同关卡下角色说的话也会有所不同。 &emsp;&emsp;角色的死亡动画也通过 Table 来随机获取。&emsp;&emsp;因为死亡动画有些许穿模到地上，所以加了 offset 数值来偏移角色位置，不过后来加入了 ragdoll 自由摆动，基本不穿模了。 &emsp;&emsp;另外在 NPC 的一些细节上也进行了优化。&emsp;&emsp;比如 NPC 没有主角靠近的时候会随机做 吃东西 挠头 的动作。&emsp;&emsp;碰到 主角 之后就会直接望向主角做 交谈 的动作。 材质风动效果 &emsp;&emsp;这些也是一些细节上的东西，不仔细观察其实根本发现不了。&emsp;&emsp;但是加上了之后就会有更真实的体验。&emsp;&emsp;风动材质我在 Japanese_Temple 里面的树叶材质上有。&emsp;&emsp;我将相关的材质节点拷贝出来，接入到其他的植物模型上，把细节拉满。 技能效果 &emsp;&emsp;技能上我们主要做了 扔石头（吸引士兵注意） 和 撒粉（减少士兵视野） 的功能。 &emsp;&emsp;扔石头需要实现石头飞到目标区域的效果。&emsp;&emsp;在 Youtube 上查了一圈，还是推荐使用 ProjectileMovement 来实现。&emsp;&emsp;然而 ProjectileMovement 一般用来做子弹的效果，是纯物理模拟，没有确定的终点坐标。&emsp;&emsp;最后在论坛上查到了一个有用的节点 链接&emsp;&emsp;SuggestProjectileVelocity Custom Arc 这个节点可以算出两个目标需要的速度。&emsp;&emsp;将速度接入到 ProjectileMovement 里面就可以实现完美的抛物线。 &emsp;&emsp;遗憾就是开启碰撞检测的话，石头会被中途的障碍物挡住，如果不开启碰撞检测有不知道石头什么时候到达了目标点位置(:з」∠)&emsp;&emsp;现在想了下，其实可以通过 tick 计算坐标是否很靠近目标点的坐标来实现触发的，不过已经太晚了。 &emsp;&emsp;撒粉需要一些特效效果的支持。&emsp;&emsp;然而 Unreal 的特效我懂得很少，所以还是抄效果比较方便。&emsp;&emsp;于是又找了个特效素材包。 vfx-impacts &emsp;&emsp;撒粉其实很简单，就是在目标点区域将上面的打枪特效随机堆上去即可。 总结 &emsp;&emsp;以上就是 Minigame 的全面复盘，有点流水账的感觉。&emsp;&emsp;Unreal 的蓝图无法用 git 进行二进制合并，结果合作开发会遇到很多冲突问题，非常难受。&emsp;&emsp;网上查了官方在很久以前做了个 蓝图 Merge 工具，然而已经很久没有维护了。 &emsp;&emsp;Unreal 用蓝图做游戏，说实话自从去年校招匆匆学了个入门教程做了个小案例之后，就再也没有深入碰过了。&emsp;&emsp;这次 Minigame 我也学习到了很多东西，收获匪浅~ 2020-10-16 &emsp;&emsp;昨天 minigame 评审，虽然很努力去做，还是没能拿到奖项，有点可惜。&emsp;&emsp;不过也是情理之中，竞争对手都是神仙，甘拜下风~ &emsp;&emsp;昨晚小组聚餐， PM 还是挺沮丧的，我们的主策划复盘了这次 Minigame 的问题。&emsp;&emsp;主要还是 评审的时间比较短， 我们需要在短时间内显示出我们玩法的创新点和爽点。&emsp;&emsp;然而我们还是有很多没有完善的地方，特不是作为动作游戏，动作上没有调优，缺少反馈。&emsp;&emsp;创新上也没有特别的亮点（虽然我们觉得手游上很少有这种潜行游戏，然而这的确不算创新）&emsp;&emsp;所以虽然可惜，不过这个过程还是有不少收获哒~]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>minigame</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
        <tag>✒博客/minigame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 编译 c 相关 Python 库 & pyd 编译]]></title>
    <url>%2Fposts%2F1a24f2d2.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近突然心血来潮，想要给自己的 Maya 装上 numpy 。&emsp;&emsp;大概是因为 python3 要进 Maya 了，在革命到来之前，先来熟络一下 Python 一些常用的库吧。 &emsp;&emsp;默认情况下 Maya 的 Python 是无法导入包含 C 相关模块的库的。&emsp;&emsp;直接导入一般会提示 无法找到 dll 然后报错。 &emsp;&emsp;这里参考了网上的一些文章，大大简化了我操作的难度。 参考 Maya：第六周 作业 - 單壹崽崽参考链接 pip 安装 &emsp;&emsp;Maya 的 mayapy 默认没有安装 pip 工具&emsp;&emsp;参考上面的链接，可以使用 get-pip.py 的脚本为 mayapy.exe 安装上 pip 工具 1mayapy.exe -m pip install package &emsp;&emsp;这样可以用上面的操作方式操作 maya 的 pip&emsp;&emsp;不过 python2 很快就要被淘汰了， pip 作用已经不大了 (:з」∠) numpy 安装 &emsp;&emsp;继续参考文章，给 Maya 安装 numpy 的操作。 下载 devkit 获取到 include 里面的 Python2.7 头文件 下载 Visual Studio 对应 Maya 的版本进行编译。 下载 numpy 1.16.6 最后支持 python2 的版本源码 （我在 pypi 下载的） 1"C:\Program Files\Autodesk\Maya2019\bin\mayapy.exe" setup.py build_ext -I "C:\Program Files\Autodesk\Maya2019\include\python2.7" -L "C:\Program Files\Autodesk\Maya2019\lib" &emsp;&emsp;准备好上面的操作就可以通过 mayapy 命令来执行 numpy 源码的 setup.py 进行编译 1"C:\Program Files\Autodesk\Maya2019\bin\mayapy.exe" setup.py install &emsp;&emsp;编译完成之后执行 install 自动将代码安装到 maya 的 site-packages 里面。 踩到的坑 &emsp;&emsp;我的系统里面已经安装了 Visual Studio 2019 ， 但是编译的时候依然提示 Microsoft Visual C++ 14.0 is required&emsp;&emsp;最开始我参考外国网站的链接，尝试安装 VCForPython27 工具 参考&emsp;&emsp;然而安装了之后编译依然提示缺失。 &emsp;&emsp;最后找到这篇链接 安装Microsoft Visual C++ Build Tools 2015&emsp;&emsp;安装 Build Tools 就可以顺利编译了。&emsp;&emsp;当时我先 编译 了 Cython 是成功的。&emsp;&emsp;后面尝试编译 numpy 还是出问题了。&emsp;&emsp;提示: Broken toolchain: cannot link a simple C program &emsp;&emsp;最后在 Stack Overflow 找到一篇解答，完美解决了我的问题 链接&emsp;&emsp;主要是 mt.exe 程序的路径没有添加到环境变量。&emsp;&emsp;在解答提到的 windows kit 路径下可以找到 mt.exe ，添加到环境变量之后就可以顺利编译 numpy 了。 pyd 编译 &emsp;&emsp;如何使用 mayapy 来编译出 pyd 这位大佬的文章很有帮助 链接&emsp;&emsp;编译预准备的步骤 简单明了 解决了我的痛点~ 拷贝 Maya2019/lib/python27.lib 到 Maya2019/Python/libs 拷贝 devkitBase/include/python2.7 中所有的文件到 Maya2019/Python/include &emsp;&emsp;准备好上面的操作就可以 mayapy 执行 Cython 编译了。&emsp;&emsp;需要注意的是不能在 maya 里面执行编译操作，因为 sys.executable 是 maya.exe ， 执行会出错的。 1234567# NOTE 编译当前脚本路径下的 test_pyd.py | 输出 test_pyd.pyd 文件from distutils.core import setupfrom Cython.Build import cythonizesetup( #name = 'xxx', ext_modules = cythonize("test_pyd.py")) &emsp;&emsp;上面就是 build.py 脚本写的代码，test_pyd 的代码就是简单的 print(&quot;hello world&quot;) 1"C:\Program Files\Autodesk\Maya2019\bin\mayapy.exe" build.py build &emsp;&emsp;执行上面的命令就可以在当前路径下生成 build/lib.win-amd64-2.7/test_pyd.pyd 的文件&emsp;&emsp;在 maya 导入 test_pyd.py 可以打印出 hello world &emsp;&emsp;另外大佬提到要注意的点，无法编译 __init__.py 脚本，并且 __file__ 只能在函数内部获取都是我之前踩过的坑点~。&emsp;&emsp;try 异常处理 pyd 会出错这个倒是还没有遇到过~ &emsp;&emsp;另外大佬另一篇文章有提到 pyd 编译代码相关的坑点，上面链接也有所提及的，非常受用 链接 总结 &emsp;&emsp;这篇文章算是对以前踩坑的一些归纳汇总吧，方便以后遇到类似的问题进来查询~]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 如何让Python代码加速运行？]]></title>
    <url>%2Fposts%2F84378342.html</url>
    <content type="text"><![CDATA[原文链接 Python 是一种脚本语言，相比 C/C++ 这样的编译语言，在效率和性能方面存在一些不足。但是，有很多时候，Python的效率并没有想象中的那么夸张。本文对一些 Python 代码加速运行的技巧进行整理。 0. 代码优化原则本文会介绍不少的 Python 代码加速运行的技巧。在深入代码优化细节之前，需要了解一些代码优化基本原则。 第一个基本原则是不要过早优化。很多人一开始写代码就奔着性能优化的目标，“让正确的程序更快要比让快速的程序正确容易得多”。因此，优化的前提是代码能正常工作。过早地进行优化可能会忽视对总体性能指标的把握，在得到全局结果前不要主次颠倒。 第二个基本原则是权衡优化的代价。优化是有代价的，想解决所有性能的问题是几乎不可能的。通常面临的选择是时间换空间或空间换时间。另外，开发代价也需要考虑。 第三个原则是不要优化那些无关紧要的部分。如果对代码的每一部分都去优化，这些修改会使代码难以阅读和理解。如果你的代码运行速度很慢，首先要找到代码运行慢的位置，通常是内部循环，专注于运行慢的地方进行优化。在其他地方，一点时间上的损失没有什么影响。 1. 避免全局变量12345678# 不推荐写法。代码耗时：26.8秒 import math size = 10000 for x in range(size): for y in range(size): z = math.sqrt(x) + math.sqrt(y) 许多程序员刚开始会用 Python语言写一些简单的脚本，当编写脚本时，通常习惯了直接将其写为全局变量，例如上面的代码。但是，由于全局变量和局部变量实现方式不同，定义在全局范围内的代码运行速度会比定义在函数中的慢不少。通过将脚本语句放入到函数中，通常可带来15% - 30% 的速度提升。 12345678910# 推荐写法。代码耗时：20.6秒 import math def main(): # 定义到函数中，以减少全部变量使用 size = 10000 for x in range(size): for y in range(size): z = math.sqrt(x) + math.sqrt(y) main() 2. 避免.（属性访问操作符）2.1 避免模块和函数属性访问12345678910111213141516 # 不推荐写法。代码耗时：14.5秒 import math def computeSqrt(size: int): result = [] for i in range(size): result.append(math.sqrt(i)) return result def main(): size = 10000 for _ in range(size): result = computeSqrt(size) main() 每次使用.（属性访问操作符时）会触发特定的方法，如getattribute()和getattr()，这些方法会进行字典操作，因此会带来额外的时间开销。通过fromimport语句，可以消除属性访问。 12345678910111213141516 # 第一次优化写法。代码耗时：10.9秒 from math import sqrt def computeSqrt(size: int): result = [] for i in range(size): result.append(sqrt(i)) # 避免math.sqrt的使用 return result def main(): size = 10000 for _ in range(size): result = computeSqrt(size) main() 在第 1 节中我们讲到，局部变量的查找会比全局变量更快，因此对于频繁访问的变量sqrt，通过将其改为局部变量可以加速运行。 12345678910111213141516# 第二次优化写法。代码耗时：9.9秒 import math def computeSqrt(size: int): result = [] sqrt = math.sqrt # 赋值给局部变量 for i in range(size): result.append(sqrt(i)) # 避免math.sqrt的使用 return result def main(): size = 10000 for _ in range(size): result = computeSqrt(size) main() 除了math.sqrt外，computeSqrt函数中还有.的存在，那就是调用list的append方法。通过将该方法赋值给一个局部变量，可以彻底消除computeSqrt函数中for循环内部的.使用。 12345678910111213141516171819 # 推荐写法。代码耗时：7.9秒 import math def computeSqrt(size: int): result = [] append = result.append sqrt = math.sqrt # 赋值给局部变量 for i in range(size): append(sqrt(i)) # 避免 result.append 和 math.sqrt 的使用 return result def main(): size = 10000 for _ in range(size): result = computeSqrt(size) main() 2.2 避免类内属性访问123456789101112131415161718192021222324 # 不推荐写法。代码耗时：10.4秒 import math from typing import List class DemoClass: def __init__(self, value: int): self._value = value def computeSqrt(self, size: int) -&gt; List[float]: result = [] append = result.append sqrt = math.sqrt for _ in range(size): append(sqrt(self._value)) return result def main(): size = 10000 for _ in range(size): demo_instance = DemoClass(size) result = demo_instance.computeSqrt(size) main() 避免.的原则也适用于类内属性，访问self._value的速度会比访问一个局部变量更慢一些。通过将需要频繁访问的类内属性赋值给一个局部变量，可以提升代码运行速度。 12345678910111213141516171819202122232425# 推荐写法。代码耗时：8.0秒 import math from typing import List class DemoClass: def __init__(self, value: int): self._value = value def computeSqrt(self, size: int) -&gt; List[float]: result = [] append = result.append sqrt = math.sqrt value = self._value for _ in range(size): append(sqrt(value)) # 避免 self._value 的使用 return result def main(): size = 10000 for _ in range(size): demo_instance = DemoClass(size) demo_instance.computeSqrt(size) main() 3. 避免不必要的抽象123456789101112131415161718192021# 不推荐写法，代码耗时：0.55秒 class DemoClass: def __init__(self, value: int): self.value = value @property def value(self) -&gt; int: return self._value @value.setter def value(self, x: int): self._value = x def main(): size = 1000000 for i in range(size): demo_instance = DemoClass(size) value = demo_instance.value demo_instance.value = i main() 任何时候当你使用额外的处理层（比如装饰器、属性访问、描述器）去包装代码时，都会让代码变慢。大部分情况下，需要重新进行审视使用属性访问器的定义是否有必要，使用getter/setter函数对属性进行访问通常是C/C++ 程序员遗留下来的代码风格。如果真的没有必要，就使用简单属性。 12345678910111213# 推荐写法，代码耗时：0.33秒 class DemoClass: def __init__(self, value: int): self.value = value # 避免不必要的属性访问器 def main(): size = 1000000 for i in range(size): demo_instance = DemoClass(size) value = demo_instance.value demo_instance.value = i main() 4. 避免数据复制4.1 避免无意义的数据复制123456789# 不推荐写法，代码耗时：6.5秒 def main(): size = 10000 for _ in range(size): value = range(size) value_list = [x for x in value] square_list = [x * x for x in value_list] main() 上面的代码中value_list完全没有必要，这会创建不必要的数据结构或复制。 12345678# 推荐写法，代码耗时：4.8秒 def main(): size = 10000 for _ in range(size): value = range(size) square_list = [x * x for x in value] # 避免无意义的复制 main() 另外一种情况是对 Python 的数据共享机制过于偏执，并没有很好地理解或信任 Python 的内存模型，滥用copy.deepcopy()之类的函数。通常在这些代码中是可以去掉复制操作的。 4.2 交换值时不使用中间变量1234567891011# 不推荐写法，代码耗时：0.07秒 def main(): size = 1000000 for _ in range(size): a = 3 b = 5 temp = a a = b b = temp main() 上面的代码在交换值时创建了一个临时变量temp，如果不借助中间变量，代码更为简洁、且运行速度更快。 123456789# 推荐写法，代码耗时：0.06秒 def main(): size = 1000000 for _ in range(size): a = 3 b = 5 a, b = b, a # 不借助中间变量 main() 4.3 字符串拼接用join而不是+12345678910111213141516# 不推荐写法，代码耗时：2.6秒 import string from typing import List def concatString(string_list: List[str]) -&gt; str: result = '' for str_i in string_list: result += str_i return result def main(): string_list = list(string.ascii_letters * 100) for _ in range(10000): result = concatString(string_list) main() 当使用a + b拼接字符串时，由于 Python 中字符串是不可变对象，其会申请一块内存空间，将a和b分别复制到该新申请的内存空间中。因此，如果要拼接个字符串，会产生个中间结果，每产生一个中间结果都需要申请和复制一次内存，严重影响运行效率。而使用join()拼接字符串时，会首先计算出需要申请的总的内存空间，然后一次性地申请所需内存，并将每个字符串元素复制到该内存中去。 12345678910111213# 推荐写法，代码耗时：0.3秒 import string from typing import List def concatString(string_list: List[str]) -&gt; str: return ''.join(string_list) # 使用 join 而不是 + def main(): string_list = list(string.ascii_letters * 100) for _ in range(10000): result = concatString(string_list) main() 5. 利用if条件的短路特性123456789101112131415161718# 不推荐写法，代码耗时：0.05秒 from typing import List def concatString(string_list: List[str]) -&gt; str: abbreviations = &#123;'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'&#125; abbr_count = 0 result = '' for str_i in string_list: if str_i in abbreviations: result += str_i return result def main(): for _ in range(10000): string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.'] result = concatString(string_list) main() if 条件的短路特性是指对if a and b这样的语句， 当a为False时将直接返回，不再计算b；对于if a orb这样的语句，当a为True时将直接返回，不再计算b。因此，为了节约运行时间，对于or语句，应该将值为True可能性比较高的变量写在or前，而and应该推后。 123456789101112131415161718# 推荐写法，代码耗时：0.03秒 from typing import List def concatString(string_list: List[str]) -&gt; str: abbreviations = &#123;'cf.', 'e.g.', 'ex.', 'etc.', 'flg.', 'i.e.', 'Mr.', 'vs.'&#125; abbr_count = 0 result = '' for str_i in string_list: if str_i[-1] == '.' and str_i in abbreviations: # 利用 if 条件的短路特性 result += str_i return result def main(): for _ in range(10000): string_list = ['Mr.', 'Hat', 'is', 'Chasing', 'the', 'black', 'cat', '.'] result = concatString(string_list) main() 6. 循环优化6.1 用for循环代替while循环123456789101112131415# 不推荐写法。代码耗时：6.7秒 def computeSum(size: int) -&gt; int: sum_ = 0 i = 0 while i &lt; size: sum_ += i i += 1 return sum_ def main(): size = 10000 for _ in range(size): sum_ = computeSum(size) main() Python 的for循环比while循环快不少。 12345678910111213# 推荐写法。代码耗时：4.3秒 def computeSum(size: int) -&gt; int: sum_ = 0 for i in range(size): # for 循环代替 while 循环 sum_ += i return sum_ def main(): size = 10000 for _ in range(size): sum_ = computeSum(size) main() 6.2 使用隐式for循环代替显式for循环针对上面的例子，更进一步可以用隐式for循环来替代显式for循环 12345678910# 推荐写法。代码耗时：1.7秒 def computeSum(size: int) -&gt; int: return sum(range(size)) # 隐式 for 循环代替显式 for 循环 def main(): size = 10000 for _ in range(size): sum = computeSum(size) main() 6.3 减少内层for循环的计算1234567891011# 不推荐写法。代码耗时：12.8秒 import math def main(): size = 10000 sqrt = math.sqrt for x in range(size): for y in range(size): z = sqrt(x) + sqrt(y) main() 上面的代码中sqrt(x)位于内侧for循环， 每次训练过程中都会重新计算一次，增加了时间开销。 123456789101112# 推荐写法。代码耗时：7.0秒 import math def main(): size = 10000 sqrt = math.sqrt for x in range(size): sqrt_x = sqrt(x) # 减少内层 for 循环的计算 for y in range(size): z = sqrt_x + sqrt(y) main() 7. 使用numba.jit我们沿用上面介绍过的例子，在此基础上使用numba.jit。numba可以将 Python 函数 JIT编译为机器码执行，大大提高代码运行速度。关于numba的更多信息见下面的主页： http://numba.pydata.org/numba.pydata.org 12345678910111213141516# 推荐写法。代码耗时：0.62秒 import numba @numba.jit def computeSum(size: float) -&gt; int: sum = 0 for i in range(size): sum += i return sum def main(): size = 10000 for _ in range(size): sum = computeSum(size) main() 8. 选择合适的数据结构Python 内置的数据结构如str, tuple, list, set, dict底层都是 C实现的，速度非常快，自己实现新的数据结构想在性能上达到内置的速度几乎是不可能的。 list类似于 C++中的std::vector，是一种动态数组。其会预分配一定内存空间，当预分配的内存空间用完，又继续向其中添加元素时，会申请一块更大的内存空间，然后将原有的所有元素都复制过去，之后销毁之前的内存空间，再插入新元素。删除元素时操作类似，当已使用内存空间比预分配内存空间的一半还少时，会另外申请一块小内存，做一次元素复制，之后销毁原有大内存空间。因此，如果有频繁的新增、删除操作，新增、删除的元素数量又很多时，list的效率不高。此时，应该考虑使用collections.deque。collections.deque是双端队列，同时具备栈和队列的特性，能够在两端进行复杂度的插入和删除操作。 list的查找操作也非常耗时。当需要在list频繁查找某些元素，或频繁有序访问这些元素时，可以使用bisect维护list对象有序并在其中进行二分查找，提升查找的效率。 另外一个常见需求是查找极小值或极大值，此时可以使用heapq模块将list转化为一个堆，使得获取最小值的时间复杂度是 。 下面的网页给出了常用的 Python 数据结构的各项操作的时间复杂度： TimeComplexity - Python Wikiwiki.python.org]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>✒博客/©转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 引擎重启]]></title>
    <url>%2Fposts%2Faa6b138f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近在虚幻商城看到一个简单而好用的免费小插件 Restart Editor&emsp;&emsp;经过之前的进阶菜单折腾之后，我觉得 Python 实现也不难。&emsp;&emsp;所以我就用 Python 来进行扩展了。 Python 脚本重启引擎123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding: utf-8 -*-"""自动重启引擎"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-09-18 15:53:10'import sysimport subprocessimport unrealfrom UE_Util import error_log, toasteditor_util = unreal.EditorLoadingAndSavingUtils()sys_lib = unreal.SystemLibrary()paths = unreal.Paths()@error_logdef main(): # NOTE 保存对象 check = editor_util.save_dirty_packages_with_dialog(True,True) if not check: toast(u"保存失败") return uproject = paths.get_project_file_path() editor = sys.executable # NOTE 启动当前引擎 subprocess.Popen([editor,uproject,'-skipcompile'],shell=True) # NOTE 退出引擎 sys_lib.quit_editor() if __name__ == "__main__": main() &emsp;&emsp;重启引擎之前先判断是否有资源需要进行报错操作，如果保存失败则跳过重启步骤&emsp;&emsp;然后获取引擎路径，这里通过 sys.executable 可以获取到 UE4Editor.exe&emsp;&emsp;继而通过 subprocess 外调命令行启动一个新的虚幻。&emsp;&emsp;接着就是退出当前虚幻。 &emsp;&emsp;其实脚本并不复杂，我也看了 C++ 插件的调用方式。&emsp;&emsp;C++ API 里面直接就有一个 restart 相关的函数，调用就完事了~ 配置 &emsp;&emsp;结合之前弄好的菜单扩展，可以通过配置 json 文件实现 C++ 插件的位置配置。&emsp;&emsp;唯一比较遗憾的是 Python 无法添加自定义的图标。&emsp;&emsp;虽然有 ToolMenuEntry 类里面有 setIcon 的 API ，但是 Python 暂时还无法扩充自定义的 style_set_name&emsp;&emsp;所以图标只能设置现有的引擎 style_set_name]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 蓝图库封装]]></title>
    <url>%2Fposts%2F88b44c10.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;并不是所有人都喜欢写代码的，有些时候可能蓝图操作起来更加简单。&emsp;&emsp;尽管蓝图无法进行 git 的合并还是很不方便的。 &emsp;&emsp;通过 Unreal 封装蓝图可以反向让蓝图有了 Python 的功能。&emsp;&emsp;一些逻辑比较复杂的操作用蓝图链接会非常晦涩和复杂，可以将其封装成一个蓝图节点，方便不懂代码人进行使用。 &emsp;&emsp;最初我是完全没有想到还有这种用法的，是偶然间一个师弟问我问题，提供了一个蓝图封装好的脚本。&emsp;&emsp;这才让我大开眼界，这篇文章才有机会面世~&emsp;&emsp;后来我问了师弟的写法是从哪里来，可以参考这篇文章 链接 &emsp;&emsp;由于是 Python 进行封装的，所以这些蓝图节点不推荐在运行时的游戏逻辑上使用。&emsp;&emsp;推荐在 editor utility 相关的节点来使用。 蓝图库封装 &emsp;&emsp;虚幻引擎本身可以通过创建蓝图库资源来扩展蓝图。 &emsp;&emsp;在这里面进行扩展的蓝图，也可以在别的蓝图调用到。&emsp;&emsp;但是本质上还是 蓝图 分装自己 而已。 &emsp;&emsp;用 Python 封装不需要生成这个资源，只需要继承 unreal.BlueprintFunctionLibrary 文档链接 &emsp;&emsp;废话不多说，直接上代码。 123456789import unreal# NOTE 生成一个 Unreal Class 对象@unreal.uclass()class PyBPFunctionLibrary(unreal.BlueprintFunctionLibrary): # NOTE 蓝图库分类设置为 Python Blueprint @unreal.ufunction(static=True,meta=dict(Category="Python Blueprint")) def TestFunction(): unreal.SystemLibrary.print_string(None,'Python Test Function Run',text_color=[255,255,255,255]) &emsp;&emsp;打开一个蓝图，右键输入 Test 就可以找到上面 Python 生成的蓝图了。 &emsp;&emsp;点击按钮触发的蓝图就是 执行上面封装的 Python 代码&emsp;&emsp;通过这个方法可以利用 Python 的 API 实现蓝图不好做甚至是不能做的操作。 &emsp;&emsp;比如可以通过 Python 的 json 库输出 json 数据，借助 socket 库进行远程通信，也可以借助一些第三方库实现更多骚操作。&emsp;&emsp;比如通过蓝图调用 Python 图像库处理图片。 &emsp;&emsp;蓝图其实也可以通过 Execute Python Command 节点来执行 Python 字符串。&emsp;&emsp;但是用 Python 封装的 蓝图 节点还可以返回出内部的数据，一些复杂的运算可以用 Python 封装。&emsp;&emsp;因为蓝图每个运算符都是单独的节点，连接复杂的运算会变得很混乱，另外 for 循环也可以通过 Python 进行封装简化。&emsp;&emsp;当然这些操作其实都可以通过 BlueprintFunctionLibrary 资源 连接蓝图 来实现。 &emsp;&emsp;蓝图最弱的地方是读取外部的文件数据，通过 Python 可以完全弥补这个问题。 1234567891011121314151617import osimport unreal# NOTE 生成一个 Unreal Class 对象@unreal.uclass()class PyBPFunctionLibrary(unreal.BlueprintFunctionLibrary): # NOTE 蓝图库分类设置为 Python Blueprint @unreal.ufunction(static=True,meta=dict(Category="Python Blueprint")) def TestFunction(): unreal.SystemLibrary.print_string(None,'Python Test Function Run',text_color=[255,255,255,255]) @unreal.ufunction(params=[str],ret=str,static=True,meta=dict(Category="Python Blueprint")) def TestReadFile(filepath): if not os.path.exists(filepath): return '' with open(filepath,'r') as f: data = f.read() return data &emsp;&emsp;我在 C 盘建了 txt ，写入了 read from text file 的数据&emsp;&emsp;通过 Python 封装就可以读取到里面的数据了，省得用 C++ 去写。 &emsp;&emsp;ufunction 的参数可以参考文档， 链接&emsp;&emsp;不过文档也是简单得等同于没有说。&emsp;&emsp;其中比较值得让人注意的地方是，如果参数使用 数组 需要用 unreal.Array 来封装。 123456789101112131415161718192021222324252627import osimport unreal# NOTE 生成一个 Unreal Class 对象@unreal.uclass()class PyBPFunctionLibrary(unreal.BlueprintFunctionLibrary): # NOTE 蓝图库分类设置为 Python Blueprint @unreal.ufunction(static=True,meta=dict(Category="Python Blueprint")) def TestFunction(): unreal.SystemLibrary.print_string(None,'Python Test Function Run',text_color=[255,255,255,255]) @unreal.ufunction(params=[str],ret=str,static=True,meta=dict(Category="Python Blueprint")) def TestReadFile(filepath): if not os.path.exists(filepath): return '' with open(filepath,'r') as f: data = f.read() return data @unreal.ufunction(params=[unreal.Array(str)],ret=str,static=True,meta=dict(Category="Python Blueprint")) def TestReadArrayFile(file_list): data = "" for filepath in file_list: if not os.path.exists(filepath): continue with open(filepath,'r') as f: data += f.read() return data 注意事项 &emsp;&emsp;如果对已经使用的节点进行修改需要谨慎，目前 python 还不是很稳定，可能会导致很多报错。&emsp;&emsp;另外 Python 的蓝图封装是动态生成的，重开引擎之后，相关的节点需要重新执行一遍 Python 脚本来生成。&emsp;&emsp;否则蓝图就是红色显示，不起作用。 &emsp;&emsp;Python 封装的节点如果使用 Python 的库就无法在运行时使用了，编译就会提示报错。 &emsp;&emsp;不过如果是使用 unreal 模块的封装还是可以运行部分的，就是限制太大了，而且这样和纯蓝图没有什么区别。 1234567import unreal@unreal.uclass()class PyRuntimeBPFunctionLibrary(unreal.BlueprintFunctionLibrary): @unreal.ufunction(static=True,meta=dict(Category="Python Runtime")) def TestRuntime(): frame = unreal.SystemLibrary.get_frame_count() unreal.SystemLibrary.print_string(None,str(frame),text_color=[255,255,255,255]) 总结 &emsp;&emsp;以上就是 Python 反向封装蓝图的效果。&emsp;&emsp;我个人还是不太习惯用蓝图，可能主要还是对 虚幻 不太熟悉吧。&emsp;&emsp;而且 Python 的文档比较全面，参考 Python 文档补全了 蓝图 文档过于简略的问题。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】-2020年9月回顾-10月学习计划]]></title>
    <url>%2Fposts%2Fecc4c5a4.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 8d06f50d4a952b8773628d11ceca8b2a700768b949a2ae9348fd52e4043d37ea78a7b102b51552dd8bcc1d863cbe4e17978d558bfa6a31031ca097b63245f315f20c5fd255b80d0ba78df260c7650ef1a3dc73dc994a4211efc822a9c33feae2deeee665730749ed2a14670973a08069b48f79849d4f8164ec0363e632f68b64c52ed4dde10220706d988ba43e9e32005f27c8cefaff19b48cd6a84b2984ff3dc75a9f24c282305f9185652066824f5e0c5d94c319af1e0f53b8d1783c225e647dc4dee38a8a20532ec137b739ea60fff3575674944f8d5ddefc9fdf9f2ebf1f761127f17ff9bf7d1945f44a96e7fabb863cd896a3fdcfcf61a77a47c20b86e9f42324e223b910da2663a9e9a3526c8040a8a829d6e866037f65ab11c6297fe0b2300dd165ee11114f533c487246313c6884b04b49ffa9e29f2fcb5249e168960bee523081881e71926261cdd4a339db4aeda02f91712bf45a481ded4d5518e046a3385dd69a5949c4dd1d4425ff94a4b4a93e05fb4174da85ddc4612c6dac67be2b3d1d86118eb9755e22cd53f5e4d3d22f968ba17d4081640351d92b7f343a91707bc0119ceeee99aac711c8c43c6114f3ead4851a414edb165bfa436f11a2cfe8482e19326c67d96ff7749c494401a68b6e7eb03e47ab0b5563731e2f7a790151cc16f738767b15e5b45ecfbf8e98e76106fa9259b06bc56283efabfd6df3ff295b9ea0db8cafffe4ebd55931ee1da1742dc53fde790e8d729787827b87dc3d1977d33ccda3af92ac6f831d9e4b17f4774bb2cdb3b35e831b189f10aee702df371824fee0e2fe4a419bf4787399fa15c51dd249d6b178b655642c4ff600535647a0d60bdb2fc1a7c6a874efac4b5e96898de179a3eb73e2109cf111cb30a6b63fc3cc09705a302505651327d77e6f4b5fade17c11c8243b38c7355df560e0bf6c87486b0e01b66f8610f95ad20351bad09db0d872e64d00fd2666fb1b54dd47cc649a19baa671cb220d3938b692d91083a37aeee8be3abbb0d19cd7da08dc275ca4e8dfda1289f6be85137292f59dfb3e73186805489e03a14d6aba7ae1e67da5c4b175259fd93e215dadda2ff0cb423606ec0173263037226e8c5a80e53dd44c300786765b1c6d6eeb730837c5601c939b97ef45f27e3c608cb3b4bff7f0f2cb4fc173dc9a713ab47508a98d9e3eff08143a24904a04d2bff61602891136da670ebcd3053db6857d45a281cd44c54a0da91e86c13a07d1673ec6fbde14fadd85fc479ff1cdd6f9d528f05f766a15f6fdfe340f104d2c577413677ec899ec85ec98ea846e69d22d7a04182b28f0b02fd0b003dfeebdad16e66a28ed53c2342a75cc810dc1ade4b12740ae13e8727fe66ef280ae3a5f4fd8b1abcda610d02403a0db8558797436d5366baeaaadd2f4d4998212c93c0e95afb005eb1674a48bed3eb7810d0f47a0b32a1edd0c3e91e1039eff7fe20f73282f7ff4e722b642d43081887067bfd62d08b5d16e08846fffb7d2eadab1c2ac74dccc95dfe3c2d4cd8830ef5111a3a71ed8929192c73e0bb0fe0462df089c76a998cd513b81625e48f29196a7cc8fee7f59f8d7c8ab0dd9bc714134c377c01eec4aef6ae6eb273d4457795849466d692ac5752add615b0ab60a299dc788090b631d129852ddf5ef824a0b7d8930a986bef86eb3613179138da1544f1b48da783b5aa0e7012e617d9cb87ba6873d82254672ebeacf16e1a3cb5d5b5f7eddc406468e8d0d96d2d8eb202375e117d90a61bc8fd89b5a67de6aa1f25ff4041635d8d5021d35a562852e1255eb111d80e0687c5dca11f774e656996e73706a43dd2b459f60e3b07cb7e6d96887713a2d6ac9515067c4d9694aa454265fd3cec012913acba65e3eb33350276c862fbec96904d08d21ca5d94aebf451d9c48b966e88e80286359a827de54c303b8aa6c7c795c6f027d484541d2ea93c2971fca14b47928c5f65760d18e663ecbf69536f2a8dd19092630f7f28fb447943bd1f662bcc5dca85927c7677f6b04d3ad260b502414b5faf0358354e170d373f23f56807cbd69f748c8b1fc68874672b348bb53ca12971b0e4029cdbfe0b9f466199db5a69c1fef0862171fcba5d456df707c5b7e33f0fb4f6b6baf5c4ec34acc80e8e0d87fe23f4ad4b1e575c84e684dd77412cd6d789c7a9577de6d2b13abedfc402ef427ba633225b453fa9de2e2cf56926e3e1ea36b8aa0c03dbe3137fb11bbeb850f5c098dc1679d386cf44d778bebbb104cf1a91b7613707461ee9a1a69777291488706c3b6437eb925780e9c228447974c4826b2260085b9dd9f2a28c72e6e384663715562a24652b7e711334d97c7b7f2f967998d21320e1f4fb116f32cda798779ccab6feab1fde1784fdf3a724cad4fa8c817460f810520b8c796d6151803f00b75946b2792d2a4ca99be2cca4c71ca354ee04cb1d116a221dc6ca4650280ceb1ad9c03552a56808126e62553a8582489bbf86b7de484c3dd3bdde7aae8aab54fb230a95ab0ff9e6a18beb53b626caa3eea00bad768ddd07268cfe35f750582875ff52febb426d3804a4b240b1f5ee81dfffa63706c238c6feea3d6994fd0f89e9a74e9ff11e1b4977a0108f7a1f90599a519fb1d618c8cc69386053412643140116078d5d4daca5350b15bf5eb96d472b8b9a2399b46b341faf304e6da89ecd7a0a8ca7fde795816e10529e20ae5c7dd0c78acff84109992f72735f657ce3c3d93d11f4cf9567c19690462dcbed7212def84511d92938ef862153dcb0e03e2943b975720c2acb46fe08c1c55ff2b524725b969f2331f7818eef7b921f47abfc674b49370366641fc57cc77df1be9b65f515478101c7f84ac52511058ffd95e71b21d11b1b275a1c5b0a4b723999efe4bff4fe399e13a8fbbdb6b6c2c7fc4d39fd875c974c92e64d15a51dbedc12ff588a62c015e1bbf8b3fd1123fa7f282c13dbc64c45a9532946667ddf438ee347e19bdec0f7f683c5f20c0f4f0ce20ee8e99570e420708c3661684aa586be1a26b80855b83f1354dde6de80afeff3dc2023974824c7e897a28bcb1e0e446db09f6905035f3343b84cc4b001958c00ea8e29064e17c6bf59f76f0b30749c6e64fb8aae44afcffee8fe696d1cba1b53dcb16e1a86b1cc095651c6202b3f7dd839fa89686ee1806e1a0fb32e47776bd171d554380b42f9818469fecbc9bee53287e2a294b39f64ed84a1fa5a9b4d7cfc4fe397ff6184382ddc2ba58b5cdad0587bd7690f6307eeee8519cdb47a46aaed450ad5d7e54197fc0bdb6b5af22f4743ab523877872ec08e566abc1a2a91d0648931b699b326da7a801f6142a0254ac64127d3e3a7886ba902440e08b96bbc3a2e2c5e9d68a768702036522c11833a98800e72b2f9c43736d5ab6efb770a43151e00bca6e68d0ba764df064ac8774a95bfa11120ffd2ebe337fbf8252c85a47199b1b6b23e64fc976fe36be2101c9390c6857a04f9a51039900cb346ee64e0c1fc99a1065dce85dde7a87965a01c56b2080d22ee286f1d4b4bb3d0f3fe6fc9b9bf168897fa39dcea4e2f7a0f9ff217aad8007d66ce2065bc935cb984eb6f9a556a9748af77829c04f4ab76e24fa3bada4eabe99a3ebe0d85dd8ef61e8077372f3bf3b7a011d34f417547ceb2a36145aa4ba84ccec3d8c975731baedb29c498601847fd2ae3bb8d21defd146601a5ddb7d41e30c6943a863d5c1a5e2b92dff0118ea48dcdadc13993035fb043e2cf38c03627a707a60b16481bb335e1a75d691c386fd960c9061b30812493505c3c83d4de5eeed644f0c345fd199a27334a5c793446f8ec09b7b068ec4e05214e645ee1a2c7227d31749513a5963283df303a767406e58e9421bed4abd4e9bd63667b1a2a040b68f5fae91d326e4e03fc2b427633f7bd0dfe5b0233c56ceb22c33423caf3b150046eea737a3cc64e487071f041fe6ab3fa1bb6a022b08bb9fd20ab9e473e234c86a613c8db38caa4adcb5822ddb4f796ab5a67a8c79a528fd655931e87e5f663febb2e1ca8c18bce76f45e263f5ba3f5ff00d7c782e3e6e5c8c6855ecac8b41be0210946ca183af0ca378265958343dfbf0d49bdbafadccc70b3594466d65dcc228a4a12256f64c8727d8d76d5fbda0efe058ff5d084094b03f9a6fd556b4837768a1d51c114d5cc39c8f2a54928596dc377a5fa8a0e98ec3500a7b72b1e15c024ce8a2402168f5fede32d57db5e04aa60f368acfa90c355531c0ba0e96cdf76280c7ffd6513145b9209f8d863cfb7cd160c5725840805580f33905ec01eb6bacaedb32698a5a31f0e34c288cf05f5a08bab0f3c6052c8ec38d5c8532812f63a96948a2401bdd3f9d5c37e34dbf4b92869f21a26951851932229e67b4695f54dd92ac003338cb0fd873ab0e47d8b6b1d7ee8e547525a37718b39178232721dfac66dfc45e309a268d478dac8f124f0ddf7919fe570e46d2222e72a4d1deff76a8143e40a46fa52355a035dcc2fe21da7ed0176591f03c4681c172ccafadc1e30ee367b2134e01dcfc3758ece6072bd117634f00bca05fb4ef0c6808242f02e7cfbca027cfd40ffc4ad54f71cd78c9eb32fb051a5a0dc5530c77d49f960bba280f71f8b5ec9180044e2c3a8a953c3a65ffecb3b2178ee8b24e8f4ae0869e90e94550ab587283fdbce5b4f9d52496877d506e8855209f8e97ab04a67ed84349ef8201bb3a2260e68586ffe1d3d68946cd8ad1b31cfbe9c9df27e530c4be769e5256e3ed9afa24d9120384c86aaee0abdc83db11c8fa5036da5ed45d2621cee7e5685e2a5834a0a3ebd3d8417705d98de9a9c5138f33440a355131e1dddc5b42c6baecc09683526b152db270cf7c4eccc5782a6757869e759e83f1c0497b6e3809bfea9f8c4d0f9f0b0b01]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 基于 UV 偏移的眼球驱动]]></title>
    <url>%2Fposts%2Fec421c94.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;传统的角色眼球做法，特别是次世代一类的，通常会做比较复杂的眼球模型。&emsp;&emsp;我目前的项目是做手游了，为了能够 hold 住资源消耗，所以眼球就完全是个面片了。&emsp;&emsp;面片怎么实现眼球的挪移呢?&emsp;&emsp;本文就来探讨一下怎么利用 UV 节点控制眼球贴图的偏移，并且通过控制器来进行控制。 贴图偏移 &emsp;&emsp;Maya 控制贴图的的 UV 的方式是通过 Place2dTexture 节点&emsp;&emsp;这个节点默认添加贴图就会自动生成并且连接到 贴图 的 UV 属性上。 &emsp;&emsp;通过 Place2dTexture 可以实现贴图 UV 的多种控制效果。&emsp;&emsp;其中我们这里需要用到的主要是 Offset 属性。 &emsp;&emsp;通过控制偏移属性，就已经有点眼球移动的味道了。&emsp;&emsp;但是当眼球运动到面片的边缘的时候，会出现左右接缝相接了。 &emsp;&emsp;要解决这个问题需要将 WrapU 和 WrapV 属性关闭。&emsp;&emsp;这两个属性主要实现了贴图在多象限下的重复效果 &emsp;&emsp;关闭了之后，超出边界的地方会变成灰色。&emsp;&emsp;变成灰色是因为 贴图的 Default Color 默认设置为灰色的。 &emsp;&emsp;这里的操作主要参考了我看的第一个 Maya 教程里面的投射贴图的操作 链接 &emsp;&emsp;如此 offset 就没有问题了。 Locator 控制贴图偏移朝向 &emsp;&emsp;默认是两个 UV 属性的偏移，让动画师去控制两个属性 K 动画显然非常不方便。&emsp;&emsp;怎么通过一个 Locator 实现类似 AimConstraint 的效果呢？ &emsp;&emsp;这里就需要 Maya 隐藏节点的 closestPointOnMesh&emsp;&emsp;这个节点在创建节点的面板上是找不到的，不过可以在节点编辑器里通过 Tab 键输入找到它 &emsp;&emsp;这个节点接受一个模型和一个点，会自动计算出距离模型最近点的相关信息。&emsp;&emsp;其中就有我们这里所需要的 UV 信息。 &emsp;&emsp;然后将输出 UV 的填入 Offset 里面&emsp;&emsp;直接填入会有数值偏差，因为 Locator 的中心区域是 UV 0.5 0.5 的区域，需要分别减去 0.5 才是对的。&emsp;&emsp;所以需要建一个 plusMinusAverage 进行处理 &emsp;&emsp;这样就可以通过 locator 控制 UV 眼球的运动了 更新问题 &emsp;&emsp;设置完上面的效果之后进行 K 帧，发现视窗没有及时更新。&emsp;&emsp;需要将 Maya 的刷新机制改为 DG 模式 总结 &emsp;&emsp;其实这个设置不复杂，如果需要双眼单独控制需要做两个材质贴两张图。 2020-9-24 更新添加缩放功能 &emsp;&emsp;美术想要通过一张贴图复用到大多数的角色眼睛上。&emsp;&emsp;这需要解决贴图的缩放问题。 &emsp;&emsp;通过上图可以看到 Coverage 是从 0,0 位置为原点进行缩放的。&emsp;&emsp;为了修正偏移，我用 TranslateFrame 的方式确保缩放之后的图片在 locator 中心。 &emsp;&emsp;然而使用了 offset 配合 Coverage 会导致边缘无法覆盖的问题。 &emsp;&emsp;这就牵涉到 TranslateFrame 和 offset 的区别了。 &emsp;&emsp;这是使用 offset &emsp;&emsp;这是使用 TranslateFrame &emsp;&emsp;可以看到 TranslateFrame 可以避开 Coverage 裁切的问题&emsp;&emsp;所以我后续放弃了 offset 属性使用，全部用 TranslateFrame 来实现偏移以及缩放校正。 对接虚幻引擎 &emsp;&emsp;参考文档 链接&emsp;&emsp;将 Place2dTexture 的属性连接到骨骼上，导出动画的时候可以获取到骨骼属性上的曲线。&emsp;&emsp;根据文档勾选 Anim Curves 窗口的 Material 选项即可将相关参数传递到 Shader 里，还原 Maya 的控制效果。 2020-11-14 &emsp;&emsp;回来补充一下，因为后续想要实现一张贴图带四个眼球，通过 shader 采样实现在一张贴图下切换眼球的效果。&emsp;&emsp;所以用 Maya 的节点已经不可能实现这么夸张的效果，这个时候就需要 dx11 shader 来帮忙了。&emsp;&emsp;通过 DirectX11 的 hlsl 语言可以实现我们想要的效果。 &emsp;&emsp;举动上也做了很多优化，比如说眼睛的模型精度不够的话，使用 closestPointOnMesh 会有跳动问题。&emsp;&emsp;所以我复制了一个面片，然后通过 wrap 变形器实现绑定模型的同步，这样可以在复制面片上进一步细分面数达到更好的控制效果。&emsp;&emsp;后面是直接通过工具一键生成眼睛控制，在绑定环节之后进行添加，方便修改。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Rigging</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya MASH 获取粒子位置]]></title>
    <url>%2Fposts%2Fd02db994.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这次的问题是之前一起实习的朋友发来问我的，我上个月就帮他解决了问题，拖到现在才来记录一下填坑记录(:з」∠)&emsp;&emsp;说实话我是没想到有 Houdini 不用，居然会用 Maya MASH 插件来做效果的。&emsp;&emsp;朋友说那是因为那边的模型管理可以用 MASH 解决简单的效果，就不用劳烦特效部门了。 &emsp;&emsp;不过 MASH 也是不争气，虽然有 Python API ，但是 Python API 居然也会有 BUG (:з」∠) &emsp;&emsp;我让他做了个小型可复现的 Demo 方便我去研究，大概的效果如下↓↓↓ 测试文件下载地址 MASH API 的问题 &emsp;&emsp;网上搜索一下 MASH Python 就可以找到 API 文档了 链接 &emsp;&emsp;MASH 的 API 也不复杂，比起 Pymel 来说简单多了。 123456789101112131415import MASH.api as mapiimport pymel.core as pmmashNetwork = mapi.Network("MASH1")min_time = pm.playbackOptions(q=1,min=1)max_time = pm.playbackOptions(q=1,max=1)for i in range(int(min_time),int(max_time)+1): pm.currentTime(i,update=1) mashNetwork.getCurrentFrameData() loc_list = [] for pt in mashNetwork.position: loc = pm.spaceLocator() loc.t.set((pt[0],pt[1],pt[2])) loc_list.append(loc) pm.group(loc_list,n="frame_%s" % i) &emsp;&emsp;按照文档的用法，应该可以用 getCurrentFrameData 的方式更新对象内部的 position 数据。&emsp;&emsp;我使用 locator 进行位置可视化，可以看到生成的 locator 都是固定在原始位置上的。 &emsp;&emsp;位置信息没有根据动态进行更新。&emsp;&emsp;后面我只好去查 MASH.api 的代码看看是怎么实现。&emsp;&emsp;一查发现原来也是用 OpenMaya 获取对应节点信息的。 &emsp;&emsp;于是我用节点视图查看了一下节点连接获取的信息。 &emsp;&emsp;network 存储的 waiter 名称就是我们获取的 MASH1 节点。&emsp;&emsp;在节点视图下获取它的信息可能不是正确的，因为 BulletSolver 在 MASH1 后面。&emsp;&emsp;所以我打算获取 Repro 的信息，应该就是最终的数据。 &emsp;&emsp;经过 pymel 的一番折腾，可以通过下面的代码获取 MASH 点的位置信息。 12345678910111213141516171819202122232425262728293031import MASH.api as mapifrom maya import OpenMayaimport pymel.core as pm# NOTE 删除之前生成的 loc pm.delete([grp for grp in pm.ls(assemblies=1) if grp.startswith("frame")])data = &#123;&#125;min_time = pm.playbackOptions(q=1,min=1)max_time = pm.playbackOptions(q=1,max=1)for i in range(int(min_time),int(max_time)+1): pm.currentTime(i,update=1) mashNetwork = mapi.Network("MASH1") # NOTE 这个是 MASH1_Repro 节点 node = pm.PyNode(mashNetwork.instancer) # NOTE 获取 MPlug 属性 obj = node.inputPoints.__apiobject__().asMObject() inputPointsData = OpenMaya.MFnArrayAttrsData(obj) positions = inputPointsData.getVectorData("position") loc_list = [] # TODO 不能直接 for 循环 | 会导致 Maya 崩溃 for i in range(positions.length()): pt = positions[i] loc = pm.spaceLocator() loc.t.set((pt.x,pt.y,pt.z)) loc_list.append(loc) pm.group(loc_list,n="frame_%s" % i) data[i] = mashNetwork.positionprint (data) &emsp;&emsp;这里通过 pymel 的方式获取到 OpenMaya1.0 的对象， pymel 的操作比较便捷，省去我很多前期的获取操作。&emsp;&emsp;得到 MASH1_Repro 下面就是获取节点内部的点信息。 &emsp;&emsp;inputPoints 是个复合属性，为了获取出 position 的数据还是折腾了好一会。&emsp;&emsp;后面是参照了 MASH API 的一些写法获取到了。&emsp;&emsp;最后获取到的顶点数据 positions 不能直接进行 for 循环遍历，会导致 Maya 崩溃。 &emsp;&emsp;以上就是这次 MASH 获取顶点信息的踩坑过程。 总结 &emsp;&emsp;垃圾Maya ， 换上 Houdini 吧~]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【置顶】 智伤帝 | 博客全面指引]]></title>
    <url>%2Fposts%2Fintro.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;很高兴可以在这里与你相遇。&emsp;&emsp;这个博客是从 2018 年中旬开始了我的更新之路,至今已经有 年了&emsp;&emsp;目前依然怀揣着巨大的热情和努力在自己的这片小天地间记录变化。 &emsp;&emsp;本篇文章将会不定期更新干货，望大家能够受益。 // NOTE 计算博客维系至今的时间 let curr_date = new Date(); curr_year = curr_date.getFullYear(); curr_month = curr_date.getMonth(); curr = curr_year + curr_month/12 - 2018.5; $(".year").text(curr.toFixed(2)) $(".year").css({"color":"orange"}) 使用指引 &emsp;&emsp;我的博客是基于前端 Hexo 静态博客框架技术搭建的。&emsp;&emsp;可以在不依赖服务器的情况下实现博客的分类和搜索。 &emsp;&emsp;通过 jsdelivr 免费 CDN 结合 github 实现快速的图片加载。 推荐指引 2019-11-12个人精选 PYTHON QT 开发教程 &emsp;&emsp;这个系列教程是我自己花了一个月时间的准备筹划所编写出来的 Qt for Python 教程系列&emsp;&emsp;从零到进阶的开发路线，当然由于后续时间紧凑，也没有弄得非常复杂，后期结合Maya等DCC软件的案例太少。&emsp;&emsp;目前计划重置这个系列的教程，后续将推出视频版，预计将在今年内上线。&emsp;&emsp;作为粉丝的你，记得催更了。 HEXO博客搭建历程 &emsp;&emsp;这个系列记录了我博客的各种变迁与升级&emsp;&emsp;不忘初心，砥砺前行。 观看笔记 - Python For Maya Artist Friendly Programming &emsp;&emsp;最用心的教程记录，当时初学 Python Qt ， 连 Maya API 用起来也艰难得很。&emsp;&emsp;这里面记录了自己很多心路历程，推荐给大家。 公众号推荐 &emsp;&emsp;下面就是我推荐的一些公众号二维码，各位客官如果有兴趣可以扫一下。 我的个人公众号 公众号未必和博客同步更新，但是可以肯定公众号的文章都来源于博客或者转载于其他有用的地方。 TD大佬的公众号，内容很棒，只可惜数量太少。 猫大牛逼，TD十戒真的强。 教程指引 有待补充。。。打算出一个系列的文章进行说明 博客说明 &emsp;&emsp;这个博客是基于 Hexo 的 black-blue 主题下进行修改的 （这个主题又是基于 SPFK 主题修改的(:з」∠)）&emsp;&emsp;博客已经修改 butterfly 主题，可以参考我 Hexo博客搭建历程系列 &emsp;&emsp;博客目前挂载在两个地方 FXTD-odyssey.github.io blog.l0v0.com &emsp;&emsp;这两个地方同步更新，互相备份。&emsp;&emsp; github.io 是借助 Github Pages 静态页面挂载的免费服务&emsp;&emsp; l0v0.com 是我的个人域名。 &emsp;&emsp;评论系统是基于 github issue 的 gittalk 以及 基于 leancloud 的 valine 实现的。 最后 &emsp;&emsp;我的干货分享到此结束了。&emsp;&emsp;大家如果还有什么建议，想要交流的，可以在下方留言。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 进阶菜单扩展]]></title>
    <url>%2Fposts%2Fcad78e0d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近抽空深入研究了一下 Unreal Python 的菜单扩展。&emsp;&emsp;扩展菜单的主要方法我之前的文章有提到过 Unreal PyToolkit 插件&emsp;&emsp;当时主要参考论坛的一篇帖子用 Python 实现下拉菜单 链接 &emsp;&emsp;其实有个地方让我很困惑， menu 获取需要通过 ToolMenus 的 find_menu 实现 1234menus = unreal.ToolMenus.get()# NOTE 获取主界面的主菜单位置main_menu = menus.find_menu("LevelEditor.MainMenu") &emsp;&emsp;但是 find_menu 传入的 menu 字符串是从何而来的，完全就没有概念了。&emsp;&emsp;我最先想到的还是从 C++ 入手 ~ C++ 源码探索 &emsp;&emsp;首先在 VScode 查 UToolMenus ， 然后通过 F12 可以定位到头文件。&emsp;&emsp;头文件名为 ToolMenus.h ， 可以用 ctrl+P 去定位 ToolMenus.cpp 脚本&emsp;&emsp;ToolMenus.cpp 脚本里面可以找到 FindMenu 的函数。 &emsp;&emsp;可以看到是通过 Menus 字典来记录引擎中所有的 Menu 名称。&emsp;&emsp;然而比较头疼的地方时 Menus 在头文件里面设置为了私有变量，无法通过 Python 亦或是 C++ 插件来获取到里面存储的值 &emsp;&emsp;迫不得已，我改了引擎源码，实现蓝图调用，然后通过 Python 获取字典存储的值。 1234567891011121314151617181920212223242526272829303132333435&#123; "ContentBrowser.AssetContextMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_0"', "ContentBrowser.FolderContextMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_1"', "MainFrame.MainMenu.Asset": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_2"', "LevelEditor.ActorContextMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_3"', "ContentBrowser.AssetContextMenu.SoundWave": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_4"', "LevelEditor.MainMenu.Window": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_5"', "LevelEditor.MainMenu.Help": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_6"', "AssetEditor.SkeletalMeshEditor.ToolBar": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_7"', "LevelEditor.MainMenu.File": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_8"', "ContentBrowser.AssetContextMenu.LevelSequence": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_9"', "MediaPlayer.AssetPickerAssetContextMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_10"', "ContentBrowser.AssetContextMenu.CameraAnim": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_11"', "LevelEditor.LevelEditorToolBar": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_12"', "LevelEditor.MainMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_13"', "LevelEditor.MainMenu.Edit": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_14"', "LevelEditor.LevelEditorToolBar.SourceControl": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_15"', "LevelEditor.LevelEditorToolBar.Cinematics": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_16"', "LevelEditor.LevelEditorToolBar.BuildComboButton": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_17"', "LevelEditor.LevelEditorToolBar.BuildComboButton.LightingQuality": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_18"', "LevelEditor.LevelEditorToolBar.BuildComboButton.LightingInfo.LightingDensity": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_19"', "LevelEditor.LevelEditorToolBar.BuildComboButton.LightingInfo.LightingResolution": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_20"', "LevelEditor.LevelEditorToolBar.BuildComboButton.LightingInfo": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_21"', "LevelEditor.LevelEditorToolBar.EditorModes": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_22"', "LevelEditor.LevelEditorToolBar.CompileComboButton": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_23"', "LevelEditor.LevelEditorToolBar.LevelToolbarQuickSettings": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_24"', "LevelEditor.LevelEditorToolBar.OpenBlueprint": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_25"', "LevelEditor.LevelEditorSceneOutliner.ContextMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_30"', "MainFrame.MainMenu.File": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_31"', "MainFrame.MainTabMenu.File": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_32"', "MainFrame.MainMenu.Edit": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_33"', "MainFrame.MainMenu.Window": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_34"', "MainFrame.MainMenu.Help": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_35"', "MainFrame.MainMenu": ToolMenu'"/Engine/Transient.ToolMenus_0:ToolMenu_36"',&#125; &emsp;&emsp;现在除了 LevelEditor.MainMenu 我们有了更多的 menu 选项了。&emsp;&emsp;比如上面显示的就有 ContentBrowser.AssetContextMenu 还有 ContentBrowser.FolderContextMenu 以及 LevelEditor.LevelEditorToolBar&emsp;&emsp;由此可以得出， 应该可以用 Python 扩展这里相应的菜单的。 Python 右键菜单扩展 &emsp;&emsp;基于上面的 AssetContextMenu 和 FolderContextMenu 的信息&emsp;&emsp;我们可以分别去扩展右键资弹出的源菜单以及右键文件夹弹出的菜单。 1234567891011121314import unrealmenus = unreal.ToolMenus.get()menu_name = "ContentBrowser.FolderContextMenu"menu = menus.find_menu(menu_name)entry = unreal.ToolMenuEntry(type=unreal.MultiBlockType.MENU_ENTRY)entry.set_label("测试 entry")# NOTE 注册执行的命令typ = unreal.ToolMenuStringCommandType.PYTHONentry.set_string_command(typ, "", 'print "entry 触发测试"')menu.add_menu_entry('AssetContextSourceControl',entry)# menus.refresh_all_widgets() &emsp;&emsp;本来 UI 修改需要 refresh_all_widgets 才会更新，因为右键菜单是右键生成时候会自动刷新，所以不执行也不影响。&emsp;&emsp;后面生成 Toolbar 扩展的时候踩了这个坑。 &emsp;&emsp;另外 AssetContextSourceControl 这个名称是 从何而来 的&emsp;&emsp;这就需要在编辑器配置里面开启 UI 名称的显示 &emsp;&emsp;开启上面的选项之后，右键菜单就会多出 绿色 的文字标注菜单的名称。 &emsp;&emsp;文件夹菜单扩展也是同理，将菜单的名称修改并且找到菜单相关的 section 进行添加即可。 Python Toolbar 添加 &emsp;&emsp;上面开启了 UI 显示之后，右键菜单可以显示了，但是 Toolbar 的显示依然是没有的。&emsp;&emsp;这就需要重启一下 引擎。 &emsp;&emsp;有了上面的标注就可以通过上面类似的方法添加 Toolbar 按钮 12345678910111213141516import unrealmenus = unreal.ToolMenus.get()menu_name = "LevelEditor.LevelEditorToolBar"menu = menus.find_menu(menu_name)# NOTE 生成类型改为 Toolbar 的按钮entry = unreal.ToolMenuEntry(type=unreal.MultiBlockType.TOOL_BAR_BUTTON)entry.set_label("测试 button")# NOTE 注册执行的命令typ = unreal.ToolMenuStringCommandType.PYTHONentry.set_string_command(typ, "", 'print "entry 触发测试"')menu.add_menu_entry('File',entry)# NOTE 添加刷新才能立刻看到添加的效果menus.refresh_all_widgets() &emsp;&emsp;执行上面的代码就可以在动态给 Toolbar 添加按钮了。 通过 Python 获取引擎生成的菜单 &emsp;&emsp;上面获取菜单名称的方式是通过 C++ 魔改引擎源码才能实现。&emsp;&emsp;这样限制非常大，有没有更加友好的获取方式呢？ &emsp;&emsp;我看着上面 C++ 获取的字典，不由得计从心生~&emsp;&emsp;menu 的引擎临时路径是有一定规律的，通过这个规律应该可以用 Python 动态读取到生成的菜单。 12345678910111213141516import unrealdef list_menu(num=1000): menu_list = set() for i in range(num): obj = unreal.find_object(None,"/Engine/Transient.ToolMenus_0:ToolMenu_%s" % i) if not obj: continue menu_name = str(obj.menu_name) if menu_name != "None": menu_list.add(menu_name) return list(menu_list)print(list_menu())LogPython: ['LevelEditor.LevelEditorToolBar', 'ContentBrowser.AssetContextMenu.LevelSequence', 'MediaPlayer.AssetPickerAssetContextMenu', 'ContentBrowser.AssetContextMenu', 'LevelEditor.LevelEditorToolBar.CompileComboButton', 'MainFrame.MainMenu', 'LevelEditor.MainMenu.Edit', 'LevelEditor.LevelEditorToolBar.BuildComboButton.LightingInfo.LightingResolution', 'LevelEditor.MainMenu', 'LevelEditor.MainMenu.File', 'AssetEditor.SkeletalMeshEditor.ToolBar', 'MainFrame.MainMenu.Edit', 'ContentBrowser.AssetContextMenu.CameraAnim', 'LevelEditor.MainMenu.Window', 'LevelEditor.LevelEditorToolBar.BuildComboButton', 'LevelEditor.LevelEditorToolBar.BuildComboButton.LightingQuality', 'MainFrame.MainMenu.File', 'LevelEditor.LevelEditorToolBar.BuildComboButton.LightingInfo.LightingDensity', 'LevelEditor.ActorContextMenu', 'ContentBrowser.AssetContextMenu.SoundWave', 'MainFrame.MainTabMenu.File', 'LevelEditor.LevelEditorToolBar.SourceControl', 'LevelEditor.LevelEditorToolBar.BuildComboButton.LightingInfo', 'LevelEditor.LevelEditorSceneOutliner.ContextMenu', 'MainFrame.MainMenu.Window', 'LevelEditor.LevelEditorToolBar.LevelToolbarQuickSettings', 'MainFrame.MainMenu.Asset', 'LevelEditor.LevelEditorToolBar.Cinematics', 'LevelEditor.MainMenu.Help', 'LevelEditor.LevelEditorToolBar.EditorModes', 'MainFrame.MainMenu.Help', 'ContentBrowser.FolderContextMenu', 'LevelEditor.LevelEditorToolBar.OpenBlueprint'] &emsp;&emsp;我想要的效果实现了~&emsp;&emsp;这样就不需要魔改引擎代码，也可以获取出到大部分的 menu 名称。&emsp;&emsp;而且上面的数组只是默认开启引擎下的菜单，如果多打开一些编辑窗口，还可以获取到更多的 菜单 。 &emsp;&emsp;由于不知道到底有多少个菜单生成了，所以我默认定的循环数是 1000 ，基本是够用的，而且遍历速度很快。&emsp;&emsp;另外还有部分的菜单是 None 无名氏，估计是注册的时候没有给定名称，也不好判断是哪里的菜单，所以我就过滤掉了。 通过 Python 扩展 AddNewContextMenu &emsp;&emsp;AddNewContextMenu 就是没有选择任何资源的时候在 资源浏览器 右键弹出的菜单。&emsp;&emsp;刚好我遇到了在这个菜单上进行扩展的需求，所以为了用 Python 实现踩了不少坑(:з」∠) &emsp;&emsp;从这个名字可以知道，默认开启引擎的时候并没有加载到这个菜单。&emsp;&emsp;使用上面写道 list_menu 函数是获取不到的，除非在 资源浏览器 进行右键触发。&emsp;&emsp;这个时候 list_menu 就会多出这个 ContentBrowser.AddNewContextMenu 的菜单名称。&emsp;&emsp;这就产生了很严重的问题，无法实现 C++ 插件的菜单嵌入效果。&emsp;&emsp;不可能让使用者手动右键生成一下菜单，再让他点击什么按钮触发，将需要的 entry 添加到菜单里呀(:з」∠) &emsp;&emsp;后来为了能够完成需求，我还是用 C++ 来解决了这个问题 参考知乎这篇文章 &emsp;&emsp;不过搞定了需求，周末还是抽空研究怎么通过 Python 来解决这个问题。&emsp;&emsp;这个过程还实现了一些有趣的效果，比如先注册生成 menu ，导致右键菜单变成了我自己自定义的菜单了。 12345678910111213menus = unreal.ToolMenus.get()menu_name = "ContentBrowser.AddNewContextMenu"menu = menus.find_menu(menu_name)# NOTE 如果已经注册则删除 | 否则无法执行 register_menuif menus.is_menu_registered(menu_name): menus.remove_menu(menu_name)menu = menus.register_menu(menu_name)entry = unreal.ToolMenuEntry(type=unreal.MultiBlockType.MENU_ENTRY)entry.set_label("测试 entry")menu.add_menu_entry('',entry) &emsp;&emsp;其他菜单也可以尝试着这样魔改成自己的菜单。&emsp;&emsp;如果可以配合引擎快捷键触发不同的菜单，还是有点意思的。 &emsp;&emsp;上面魔改的菜单要恢复也不难，将自己做的菜单 删除掉 ，默认右键就会生成回正常的菜单了。 &emsp;&emsp;问题是这个折腾依然没能解决实现我想要的效果(:з」∠)&emsp;&emsp;后面还是想往 C++ 的方向入手，能不能在右键菜单事件添加 回调事件，配合触发 Python 脚本。&emsp;&emsp;也的确在 C++ 文档里面找到相关的回调函数 链接&emsp;&emsp;但是要如何接入 Python 还不是很确定。 &emsp;&emsp;后面思路一转，还有更加简单的实现方式，可以用定时器来做。&emsp;&emsp;虽然定时器不是个好点子，听着就比较浪费资源，但是考虑到 Python 遍历 menu 的速度快到没感觉。&emsp;&emsp;定时执行嵌入操作的卡顿应该感知不到。 1234567891011121314151617181920212223242526import unrealfrom Qt import QtCorefrom functools import partialdef add_menu(timer): print("timer running...") menu = menus.find_menu("ContentBrowser.AddNewContextMenu") if not menu: return # NOTE 如果存在停止计时器 timer.stop() print("timer stop") entry = unreal.ToolMenuEntry(type=unreal.MultiBlockType.MENU_ENTRY) entry.set_label("测试 entry") menu.add_menu_entry('ContentBrowserNewAdvancedAsset',entry) menus.refresh_all_widgets()# NOTE 使用 Qt 的定时器实现 js setInterval 函数的效果# NOTE Python 原生实现比较麻烦，用 Qt 的 Timer 比较简洁timer = QtCore.QTimer()timer.timeout.connect(partial(add_menu,timer))timer.start(1000) &emsp;&emsp;完美通过定时器实现动态嵌入菜单。 PyToolkit Json 配置优化 &emsp;&emsp;通过上面的一轮折腾，之前 PyToolkit 提供的菜单配置完全可以更加灵活。&emsp;&emsp;于是我又重写了之前 json 配置的读取和生成，通过递归的方法，自动处理多重嵌套菜单的效果。 &emsp;&emsp;具体的配置方法我写到了 PyToolkit 的帮助文档里面 链接 &emsp;&emsp;上面四种嵌入可以完全通过 json 配置来完成~ 总结 &emsp;&emsp;利用 Python 做菜单扩展的确方便了很多，但是 Python 也并不是万能的。&emsp;&emsp;例如我之前研究过的 Sequencer 菜单工具栏嵌入 扩展就只能通过 C++ 来实现&emsp;&emsp;因为 list_menu 没有找到相关的菜单名称。 &emsp;&emsp;最近博客因为各种原因写好了文章却没有更新，更新频率也下降了(:з」∠)&emsp;&emsp;希望后续可以整理规划好时间，继续坚持做博客的记录。 2020-9-21 修复引擎崩溃 BUG &emsp;&emsp;记录上面方案的问题，如果引擎加载地图之类的大文件，需要比较长的时间。&emsp;&emsp;如果在这个过程中触发定时器的 嵌入 操作，会直接导致引擎崩溃。 &emsp;&emsp;最开始我查了 C++ 源码，打算做一个 C++ 函数判断引擎是否处在加载状态。&emsp;&emsp;我参考报错的 FUObjectThreadContext::Get().IsRoutingPostLoad 进行判断，结果还是产生了错误。 123456789101112131415161718192021222324252627282930313233343536373839LoginId:9f3ca733407852eca305588adf6ea300EpicAccountId:6d3892f3bd8843aea3ad36ed181ea5b8Assertion failed: !FUObjectThreadContext::Get().IsRoutingPostLoad [File:G:&#x2F;UnrealEngine425&#x2F;Engine&#x2F;Source&#x2F;Runtime&#x2F;CoreUObject&#x2F;Private&#x2F;UObject&#x2F;ScriptCore.cpp] [Line: 1755] Cannot call UnrealScript (RedArtToolkitBPLibrary &#x2F;Engine&#x2F;Transient.RedArtToolkitBPLibrary_206 - Function &#x2F;Script&#x2F;RedArtToolkit.RedArtToolkitBPLibrary:IsRoutingPostLoad) while PostLoading objectsUE4Editor_Core!AssertFailedImplV() [g:\unrealengine425\engine\source\runtime\core\private\misc\assertionmacros.cpp:100]UE4Editor_Core!FDebug::CheckVerifyFailedImpl() [g:\unrealengine425\engine\source\runtime\core\private\misc\assertionmacros.cpp:450]UE4Editor_CoreUObject!DispatchCheckVerify&lt;void,&lt;lambda_2781c71baf617450f2ef557efebba817&gt; &gt;() [g:\unrealengine425\engine\source\runtime\core\public\misc\assertionmacros.h:161]UE4Editor_CoreUObject!UObject::ProcessEvent() [g:\unrealengine425\engine\source\runtime\coreuobject\private\uobject\scriptcore.cpp:1755]UE4Editor_PythonScriptPlugin!PyUtil::InvokeFunctionCall() [g:\unrealengine425\engine\plugins\experimental\pythonscriptplugin\source\pythonscriptplugin\private\pyutil.cpp:579]UE4Editor_PythonScriptPlugin!FPyWrapperObject::CallFunction_Impl() [g:\unrealengine425\engine\plugins\experimental\pythonscriptplugin\source\pythonscriptplugin\private\pywrapperobject.cpp:254]UE4Editor_PythonScriptPlugin!FPyWrapperObject::CallMethodNoArgs_Impl() [g:\unrealengine425\engine\plugins\experimental\pythonscriptplugin\source\pythonscriptplugin\private\pywrapperobject.cpp:326]UE4Editor_PythonScriptPlugin!FPyMethodWithClosureDef::Call() [g:\unrealengine425\engine\plugins\experimental\pythonscriptplugin\source\pythonscriptplugin\private\pymethodwithclosure.cpp:180]python27python27python27python27python27python27python27python27python27python27pyside_python2_7pyside_python2_7QtCore4QtCore4QtCoreQtCore4QtCoreQtGui4QtGui4QtGuiQtCore4QtCore4QtCore4user32user32...... 省略 &emsp;&emsp;因此我需要找一个方法，判断 引擎 处于卡顿状态，然后阻断 timer 函数的执行。&emsp;&emsp;好在通过 tick 函数可以捕捉到时间差，判断到引擎是否真的卡顿。 1234567891011121314151617181920# NOTE 这里代码归纳 省略了中间代码global last_ticklast_tick = time.time()def timer_add_menu(menu_dict,timer): # NOTE 判断当前是否卡顿状态 | 如果卡顿就跳过执行 # NOTE 避免处于加载状态导致引擎崩溃 !FUObjectThreadContext::Get().IsRoutingPostLoad -&gt; Cannot call UnrealScript while PostLoading objects global last_tick tick_elapsed = time.time() - last_tick if (tick_elapsed &gt; 0.01): return # ...def __QtAppTick__(delta_seconds): global last_tick last_tick = time.time()unreal.register_slate_post_tick_callback(__QtAppTick__) &emsp;&emsp;如果 tick_elapsed 变量超过 0.01s 说明当前 tick 卡顿，就可以跳过后续的代码的执行。&emsp;&emsp;但是项目里实测不太稳定，推荐还是用 C++ 的方案较为稳妥。 2021-4-11 补充 &emsp;&emsp;上面触发 C++ 的 BUG 原因找到了。&emsp;&emsp;主要怪我，应该用 unreal 内置的 tick 函数来触发而不应该用 QTimer 做定时触发。&emsp;&emsp;QTimer 触发有可能在引擎卡顿加载状态，导致在 Tick 之中触发了查询函数出错崩溃。&emsp;&emsp;只要也用 register_slate_post_tick_callback 的方法来触发菜单寻找就不会崩溃了。 12345678910111213141516171819202122232425262728293031323334353637383940414243fail_menus = create_menu()if fail_menus: global __tick_menu_elapsed__ __tick_menu_elapsed__ = 0 def timer_add_menu(menu_dict, delta): global __tick_menu_elapsed__ __tick_menu_elapsed__ += delta # NOTE 大于 .5s 执行 | 避免频繁执行 if __tick_menu_elapsed__ &lt; 0.5: return __tick_menu_elapsed__ = 0 # NOTE 如果 menu_dict 清空则停止计时器 if not menu_dict: global __red_add_menu_tick__ unreal.unregister_slate_post_tick_callback(__red_add_menu_tick__) return flag = False for tool_menu, config in copy.deepcopy(menu_dict).items(): menu = menus.find_menu(tool_menu) if not menu: continue # NOTE 清除找到的menu menu_dict.pop(tool_menu) flag = True config.setdefault("menu", menu) handle_menu(config) if flag: menus.refresh_all_widgets() # NOTE 注册添加菜单功能 callback = partial(timer_add_menu, fail_menus) global __red_add_menu_tick__ __red_add_menu_tick__ = unreal.register_slate_post_tick_callback(callback) __QtAppQuit__ = partial( unreal.unregister_slate_post_tick_callback, __red_add_menu_tick__ ) unreal_app.aboutToQuit.connect(__QtAppQuit__)]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 替换动画资源骨骼]]></title>
    <url>%2Fposts%2F121100f4.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在 Unreal 引擎中，动画资源导入之后，就无法对其指向的骨骼进行修改了。&emsp;&emsp;在论坛上上查了一些资料 链接&emsp;&emsp;大多数人推荐使用 骨骼重定向 来生成新的动画。&emsp;&emsp;但是旧的动画会被一些 定序器 或者 蓝图 所引用，怎么将这些引用转移到新的 动画 上。 引用替换 &emsp;&emsp;还是参考了上面论坛链接提到的，删除动画文件的时候，如果动画文件存在引用，则可以选一个新的文件进行引用的替换。 &emsp;&emsp;选择一个新的动画文件替换之前的引用。 &emsp;&emsp;不过这个操作其实并不完整，我们可以打开引用查看器查看文件的引用情况。 &emsp;&emsp;之前的旧资源会保留一个 Redirector重定向器 指向新的资源。&emsp;&emsp;这会导致无法使用就资源的命名了。 &emsp;&emsp;而且这个无法命名还很诡异，因为目录里已经看不到有这个名字的资源了。&emsp;&emsp;默认 Redirector重定向器 是看不见的，想要看到它需要在过滤标签里面开启它的过滤。 &emsp;&emsp;这就很难受，因为我们替换资源就是希望新的资源和旧的资源在命名上能够保持一致。&emsp;&emsp;后来又经过我的一通搜索查找之后，发现文件夹的右键菜单有选项可以清理掉当前选中目录下的重定向器。 &emsp;&emsp;执行这个命令删除掉重定向器就可以将新的资源改名为旧的资源了。 Python 自动处理骨骼替换 &emsp;&emsp;既然上面的操作可以手动实现，用代码自动替换问题也不大了~ &emsp;&emsp;首先需要找到替换引用操作的 Python 调用是啥。&emsp;&emsp;这个函数的名字并不是我所想到的名字，找了好一段时间才找到 链接 &emsp;&emsp;unreal.EditorAssetLibrary.consolidate_assets 这个函数就是我的目标函数&emsp;&emsp;新资源和就旧资源数组，就可以实现引用替换到新资源上。 &emsp;&emsp;替换成功之后，怎么将 重定向器 清除呢？&emsp;&emsp;我先从 C++ 的源码入手，看看清理引用的时候，到底是调用了哪些 C++ 函数。 &emsp;&emsp;然而上面截图的调用并没有在 Python API 里面找到相关调用，只能写个蓝图节点来实现 Python 调用。&emsp;&emsp;调用这个函数，需要获取出需要清理的 重定向器。&emsp;&emsp;我当时想先从 Python 获取到 Object ，然后直接传到 C++ 里面进行处理。 12345678# NOTE 引擎内部路径 | 这个路径是我的测试目录路径destination_path = '/Game/TestAnim'reg = unreal.AssetRegistryHelpers.get_asset_registry()ar_filter = unreal.ARFilter(class_names=["ObjectRedirector"], package_paths=[destination_path])# NOTE 通过 filters 过滤出目录下的 重定向器 | get_assets 获取到的是 AssetData 类型redirector_list = [redirector.get_asset() for redirector in reg.get_assets(ar_filter)]print(redirector_list[0])# LogPython: &lt;Object '/Game/TestAnim/Replace_ThirdPersonWalk.Replace_ThirdPersonWalk' (0x000002CF62C19E80) Class 'ObjectRedirector'&gt; &emsp;&emsp;上面的代码可以获取出类型为 ObjectRedirector 的对象。&emsp;&emsp;所以我当时将这个对象传递到 C++ 蓝图里面进行清理。&emsp;&emsp;但是这样清理会导致清理失败~&emsp;&emsp;估计 get_assets 这个函数触发了什么东西，导致 Redirector 被占用了。 &emsp;&emsp;后来不得已我只好改成将路径传到 C++ 函数里面，通过 C++ 加载路径获取对象，就可以了。 123456789# NOTE 引擎内部路径 | 这个路径是我的测试目录路径destination_path = '/Game/TestAnim'reg = unreal.AssetRegistryHelpers.get_asset_registry()ar_filter = unreal.ARFilter(class_names=["ObjectRedirector"], package_paths=[destination_path])# NOTE 通过 filters 过滤出目录下的 重定向器 | get_assets 获取到的是 AssetData 类型redirector_list = [redirector.object_path for redirector in reg.get_assets(ar_filter)]# NOTE 清理获取到的 重定向器unreal.PyToolkitBPLibrary.fixup_referencers(redirector_list) 1234567891011121314151617void UPyToolkitBPLibrary::FixupReferencers(TArray&lt;FString&gt; ObjectPaths)&#123; // NOTE source code from FPathContextMenu::ExecuteFixUpRedirectorsInFolder TArray&lt;UObjectRedirector *&gt; Redirectors; for (auto ObjectPath : ObjectPaths) &#123; UObject *LoadedObject = LoadObject&lt;UObject&gt;(NULL, *ObjectPath, NULL, ELoadFlags::LOAD_None, NULL); if(LoadedObject)&#123; auto Redirector = CastChecked&lt;UObjectRedirector&gt;(LoadedObject); Redirectors.Add(Redirector); &#125; &#125; // Load the asset tools module FAssetToolsModule &amp;AssetToolsModule = FModuleManager::LoadModuleChecked&lt;FAssetToolsModule&gt;(TEXT("AssetTools")); AssetToolsModule.Get().FixupReferencers(Redirectors);&#125; &emsp;&emsp;基本上通过上面的方法就可以清理掉 重定向器，后续将新的资源的名称同步改为就资源名称即可。&emsp;&emsp;另外补充一下在 Unreal 引擎里面不支持 windows 系统的反斜杠 \ ，使用 os.path.join 拼接的路径很容易出错&emsp;&emsp;我网上查了之后，可以用 Python 内置的 posixpath 来拼接路径，确保输出的路径使用 斜杠 / 总结 &emsp;&emsp;以上就是 动画资源替换 的操作。&emsp;&emsp;有相关的问题欢迎联系我交流~]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Minigame 概况]]></title>
    <url>%2Fposts%2F3ec26151.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;minigame 是校招生必须参加的一个内部比赛，属于组队一起在一个半月内做个小游戏的比赛。&emsp;&emsp;今年校招生大概有 四五百人，这其中有各种岗位的大佬。&emsp;&emsp;规则大概就是将这一批人随机分组，分成六七十组吧。&emsp;&emsp;每个组都会有相应的 客户端程序 、 后端程序 以及 策划。&emsp;&emsp;至于美术因为招的人比较少，所以有些组就被迫没有美术了。&emsp;&emsp;在这个分类中，技术美术居然分类为美术(:з」∠)，好像没毛病，然而又有不妥。 &emsp;&emsp;在这其中，技术美术的资源最为抢手，因为通常来说 TA 都比较全能吧。&emsp;&emsp;然而我的定位是个 工具&amp;动画向 技术美术，严重偏T，但是我又不太懂引擎，简直就是瘸了一条腿(/ω＼)&emsp;&emsp;我感觉自己的技能 美术 技术 两边都不讨好，工作的内容和游戏表现没有太大挂钩，做的工具大都属于流程优化的东西。&emsp;&emsp;所以在参加 minigame 之前，我可谓是愁死了。 组队 &emsp;&emsp;组队之前会遇到什么样的队友，其实是完全未知的。（抽签随机的）&emsp;&emsp;我组上的队伍配置还不错，总共 7 个人，2个策划 1个运营 1个客户端 2个后端开发，最后就是我技术美术了。&emsp;&emsp;所以我很不幸变成了团队里唯一的美术。&emsp;&emsp;我是没法做 2D 的，做 3D 的话就只有 low poly 这种层度可以做，虽然不限制网上拿美术资源，但是品质太高的美术资源根本无法驾驭。&emsp;&emsp;所以后面定美术风格的时候，我直接把我们的美术锁死在 low poly 了。 &emsp;&emsp;经过了最初的认识，到后续开了一些会讨论我们到底要做什么游戏之后。&emsp;&emsp;我对大家都有了进一步的了解。&emsp;&emsp;两个后端是纯网站开发的后端，完全没有游戏开发的经验，但是他们还是挺积极参与到 minigame 中的，不排斥我觉得挺好的了，可以抽出一些时间一起学习协作。&emsp;&emsp;客户端开发是我们引擎组的大佬，膜拜就是了~&emsp;&emsp;运营也是完全没有开发的经验，不过她主动承担了 PM 的角色，我们组唯一的女生~&emsp;&emsp;两个策划非常专业，特别是和我一样的是本科的策划 星楠，很会讲故事，分析问题也经常一针见血，省了很多扯皮的时间。 玩法讨论 &emsp;&emsp;最初我们想玩法的时候，也会想去套前人做的优秀作品，很多作品会涉及到一些有社会价值的游戏，比如说前几年上线的 《见》&emsp;&emsp;可是这样想的时候就很无趣，为了套故事而想玩法，但是我们根本就没有好故事，没有会编故事的人。&emsp;&emsp;星楠最后压轴发言，直接提了一个游戏玩法 《影子战术》&emsp;&emsp;这款游戏属于 刺杀 潜行类 玩法，目前的手游还很少有这种玩法的游戏~ &emsp;&emsp;我自己则是想做类似 《武士刀零》 这种强操作快速通关的游戏。&emsp;&emsp;经过一番争论之后，还是决定做 《影子战术》 这种 RTT 玩法，因为的确这种玩法很新颖，得到了导师的认可。 &emsp;&emsp;定下玩法，我就开始去找素材去套。&emsp;&emsp;还是找到一些不错的 low poly 素材的 武士道 庙宇 初始 Demo 制作 &emsp;&emsp;这个 Demo 只是我将上面的 武士道 模型从 Unity 拔下来，放到虚幻里面。&emsp;&emsp;然后简单做一个漫游效果来给大家看效果，游戏的游玩还是得靠引擎组的大佬去搭建框架。 &emsp;&emsp;自从去年做了一遍入门教程案例之后，就没怎么制作打包 Unreal 的 Demo 了。&emsp;&emsp;以后有时间还要多看些相关教程才行。 接入Unity模型 &emsp;&emsp;武士道系列模型是个 Unity Package&emsp;&emsp;所以下载下来之后还需要在 Unity 里面加载(其实 package 就是个压缩包，只是没有整理好层级，还是直接放到 Unity 引擎里面比较省心) &emsp;&emsp;然后网上查了一下怎么讲 Unity 的工程打包输出 FBX&emsp;&emsp;github 上可以下载到输出用的插件 UnityFBXExporter &emsp;&emsp;然后就是把整个场景导出为 FBX 文件。&emsp;&emsp;这个 low poly 场景还挺大的，整个足足有 100W+ 面。 &emsp;&emsp;然后我把 FBX 整合到 Maya 里面，修正贴图的路径，然后再导入到 Unreal 里面。 &emsp;&emsp;不会弄这里的材质，所以 Unreal 用的是 默认 的 材质 + 贴图 打包输出游戏 &emsp;&emsp;我这里使用了第三人称的模板，所以默认启动游戏就会生成第三人称的角色控制器。&emsp;&emsp;我其实完全没有研究过这些东西，还从头摸索了一下，做一个自定义的 GameMode ， 再做一个 自定义的 PlayerController 和 角色蓝图。&emsp;&emsp;这其中比较难搞得是，如何切换游戏的视角控制。&emsp;&emsp;不过还好，可以在官方论坛上找到处理的方法。 &emsp;&emsp;后面又想做界面，于是又回头把之前自己看的 入门 教程翻出来，看看是怎么接入 UMG 界面的。 &emsp;&emsp;快捷键触发是通过 Level Blueprint 里面触发的。 总结 &emsp;&emsp;这里就简单记录了一下 minigame 做的简单场景漫游，主要是给组员感受下这套素材合不合适。&emsp;&emsp;后续我主要还是负责美术资源 模型、动作 这一块，程序上就靠引擎组的大佬了~]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>minigame</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
        <tag>✒博客/minigame</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建多重嵌套 docsify 文档]]></title>
    <url>%2Fposts%2F578b1a97.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;关于 docsify 文档构建，大概两三年前就有弄过了。&emsp;&emsp;那个时候开发了一个很粗糙的 three.js 库，因为当时做外包。&emsp;&emsp;所以我就把自己的小库文档用 docsify 框架搭建好了，虽然现在回想起来做得很一般(:з」∠)(全部是 es5) &emsp;&emsp;后来在华强也继续沿用了 docsify 框架搭建内部 Python 流程的文档。&emsp;&emsp;当时 docsify 本身无法实现收缩左侧菜单的 tab ， 我当时还用 JQuery 进行了一定程度的 优化。&emsp;&emsp;然后文档生成的方式则是通过 PySide 写了个图形界面，通过 re 正则表达式去截取源代码相关的 doc string 。&emsp;&emsp;自动生成文档 md 文件 以及 目录文件&emsp;&emsp;当时不知道 Python 有你只的 pydoc 库，所以这个文档生成工具也是命名为 PyDod 了~ &emsp;&emsp;直到最近和 师兄 交流，还是会觉得博客记录的只是一些开发的坑和心得。&emsp;&emsp;并没有能够实现知识的系统归纳，所以还是觉得有必要搭建一个系统性 wiki 文档，只是框架类似于 cgwiki 网站一样。 &emsp;&emsp;搭建好的文档链接 wiki.l0v0.com wiki 文档搭建 &emsp;&emsp;虽然之前已经踩过一些坑了，但是还是太久没有搞过了，还是打算正儿八经看着文档去构建。&emsp;&emsp;然后我发现 docsify 可谓是更加完善了，这次脚手架工具都已经搭建好了。 &emsp;&emsp;但是使用脚手架之后感觉还是不太方便，感觉太简陋了，啥东西都没有。&emsp;&emsp;于是还是将线上的 docsify clone 下来进行魔改。 接入插件 &emsp;&emsp;官方的文档上提供了很多插件。&emsp;&emsp;于是我就将一些有用的插件接入到我的 wiki 上，这个花了不少时间。 &emsp;&emsp;陆陆续续将下面的插件接入了 docsify-themeable docsify-glossary docsify-tabs docsify-valine docsify-pagination docsify-count 多层嵌套 &emsp;&emsp;我以前写 markdown 没有 header 顺序的概念。&emsp;&emsp;特别是 glossary 术语插件要求要用 5个 #####&emsp;&emsp;但是这样左侧的侧边栏就失去了 层级的概念，也就是无论是 4个# 或是 还是 5个#&emsp;&emsp;侧边栏的东西都是平级的。 &emsp;&emsp;后来我查了 docsify 的 issue 里面有个做佛经科判的大佬，做了个支持 108 层级的效果。&emsp;&emsp;虽然 108 层级也是基于其他插件实现的，但是整体扩展效果还是很牛逼的~ &emsp;&emsp;后来我发现只要有层级顺序 # 构建 header 就可以让侧边栏有层级了，所以我在科判上花费了大量无谓的时间，最后还是什么东西都没有了~ 线上编辑 &amp; 文字字数 &emsp;&emsp;线上剪辑 和 文字字数 没有合并到一起的插件。&emsp;&emsp;于是我稍微魔改了这个插件，将两个功能合并到一起。 pagination &amp; addtoany &emsp;&emsp;后来构建 pagination 打算将 addtoany 分享合并到一起。&emsp;&emsp;于是将 pagination 的仓库 clone 下来。&emsp;&emsp;进行了自己的魔改和测试。 总结 &emsp;&emsp;这次写得东西都比较简单了~&emsp;&emsp;因为这些修改都不是太难。 &emsp;&emsp;后续文档要完善的东西还有很多，比如我想做一些文章翻译、还有自己知识体系的整理~]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠴编程/docsify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 批量改名工具开发]]></title>
    <url>%2Fposts%2F345523ad.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;好久没有更新文章了，最近的文章也差不多两个星期前了。&emsp;&emsp;主要是上周去团建了，然后我去尝试用 docsify 框架构建自己的 wiki 文档，把时间都用光了。&emsp;&emsp;wiki 文档算是搭建好了，中间对一些插件做了自己的优化改良，所以花了比较多的时间~ 链接&emsp;&emsp;不过目前还没有任何内容，打算慢慢进行更新，是一个长线的事情，可能需要等自己的只是体系更加系统了之后，类似 CGwiki 的文档一样规范整理。 &emsp;&emsp;然后团建回来之后就患上了重感冒，果然团建暴饮暴食再加上泡了温泉可能着凉了，所以这周也算是过得挺糟心的(:з」∠)&emsp;&emsp;另外最近参加了公司内部的 minigame 比赛，我这个工具人的定位就尴尬得一批，我属于美术分类，但是我的美术能力根本指望不上(:з」∠)&emsp;&emsp;而且游戏制作相关的东西，包括引擎开发相关的还有很多东西需要补充。&emsp;&emsp;估计还要再积累一段时间，后续到国庆的日子里得不定期更新了~ 改名工具 &emsp;&emsp;这个工具之前看了个教程有提到用 Unreal Python 开发批量改名工具，而且还可以根据文件的类型进行前后缀匹配。 改名视频 前缀匹配视频&emsp;&emsp;不过这个教程做得很简单，我想通过 PySide 的界面将改名工具做得更好一点。 &emsp;&emsp;最近做了一个 PyToolkit 工具的推荐视频（顺便还恰了饭），成品演示视频↓↓↓ wiki文档链接 Template 报错坑 &emsp;&emsp;我在左侧配置了命名变量，可以根据变量的名称配置自动嵌入到重命名工具上。&emsp;&emsp;最初我想到的实现方法是通过 字符串 的 format 方法来实现，但是 format 在一些特殊的情况下会报错，不好进行处理。 12"&#123;&#123;INDEX&#125;sd".format(**&#123;"a":'123','INDEX':123&#125;)# Error: ValueError: file &lt;maya console&gt; line 1: Single '&#125;' encountered in format string # &emsp;&emsp;最后通过魔改 Template 的方法来解决这个问题。&emsp;&emsp;Python 的 string 模块自带 Templete 模板类，是方便以前后端 Html 模板进行处理的。&emsp;&emsp;怎么用网上也有很多介绍 python的Template使用指南&emsp;&emsp;当然这个原生的功能还是比较简单的，源码是通过 正则表达式 匹配的。&emsp;&emsp;默认情况下可以自动替换 Templete 字符串下 $ 或者 ${} 的字符串。&emsp;&emsp;因为是带源码，我可以在它的基础上进行一些处理，就不会导致 format 黑箱报错的问题。 1234567891011121314151617181920212223242526272829303132333435class ReplaceTemplate(Template): def substitute(*args, **kws): if not args: raise TypeError("descriptor 'substitute' of 'Template' object " "needs an argument") self, args = args[0], args[1:] # allow the "self" keyword be passed if len(args) &gt; 1: raise TypeError('Too many positional arguments') if not args: mapping = kws elif kws: mapping = _multimap(kws, args[0]) else: mapping = args[0] # Helper function for .sub() def convert(mo): # Check the most common path first. named = mo.group('named') or mo.group('braced') if named is not None: # NOTE 修正默认 Templete 替换报错 default = "%s&#123;%s&#125;" % (self.delimiter, named) if mo.group( 'braced') else "%s%s" % (self.delimiter, named) val = mapping.get(named, default) # We use this idiom instead of str() because the latter will # fail if val is a Unicode containing non-ASCII characters. return '%s' % (val,) if mo.group('escaped') is not None: return self.delimiter if mo.group('invalid') is not None: return self.delimiter # self._invalid(mo) raise ValueError('Unrecognized named group in pattern', self.pattern) return self.pattern.sub(convert, self.template) &emsp;&emsp;基本上就是在源码的 subtitute 稍微改动了一下。&emsp;&emsp;确保替换可以返回出我想要的字符串。 dayu_widgets tableview 的小坑 &emsp;&emsp;这次使用了 dayu_widgets 封装好的 MTableView 来显示重命名工具的数据。&emsp;&emsp;使用的过程中发现了写小问题，迫不得已，还要重新封装一下 MTableModel 来解决这个问题。&emsp;&emsp;后来我将问题提到了 dayu_widgets 的 issue 里面，得到了作者的反馈。 &emsp;&emsp;作者毕竟是个高人，一眼就看出我不是人道行不够深。&emsp;&emsp;作者还写了案例代码，清晰表达了可以通过其他更好的方式实现我所想要的效果。&emsp;&emsp;感谢作者的帮助，这里受教了~ 总结 &emsp;&emsp;重命名工具已经弄好了好一段时间，然而这个总结文章却是姗姗来迟(:з」∠)&emsp;&emsp;而且这里也没有总结出什么比较好的东西，中间有一部分代码是直接拿了 Digital Tutor 一套 Maya PyQt 开发教程的代码&emsp;&emsp;可以实现英文 26 个字母 序号 自动递增的排序，超出 26 的情况下会自动拼接为 aa ab 这种方式。&emsp;&emsp;这次再次深度挖掘了 QtDesigner 的隐藏功能。&emsp;&emsp;通过魔改 ui 文件成功实现了 QSplitter 的效果。&emsp;&emsp;同时还加入 QSettings 实现插件的配置。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 修改蓝图组件属性]]></title>
    <url>%2Fposts%2F139a3d44.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;记录一下这周搞到头秃的需求。&emsp;&emsp;需要修改修改蓝图组件的属性。&emsp;&emsp;过去我修改组件属性都是通过 Actor 实现。&emsp;&emsp;但是 Actor 需要在 Game World 当中进行修改，而这个时候其实是已经实例化了。&emsp;&emsp;这里需要将值赋值到蓝图当中，等于下次生成 Actor 的时候已经自动带有配置好的初始值了。 &emsp;&emsp;原先我觉得 Actor 修改就是分分钟的事，蓝图相信也可以直接获取进行修改吧。&emsp;&emsp;然而我是图样图森破了(:з」∠) 修改蓝图组件属性尝试 &emsp;&emsp;我之前修改资源的属性，比如说修改 Texture2D 资源，都需要通过 Content Browser 获取当前选择的 Asset 资源。&emsp;&emsp;然后通过 Python 的 set_editor_property 来实现修改。 &emsp;&emsp;所以最开始我也是沿着这个方向去尝试的。 12345import unrealassets = unreal.EditorUtilityLibrary.get_selected_assets()print(assets)# LogPython: [Blueprint'"/Game/sequence/NewBlueprint.NewBlueprint"'] &emsp;&emsp;通过上面的方法可以获取到当前选择的 蓝图 Asset。&emsp;&emsp;但是去 Python 文档查 Asset 完全没有任何有价值的方法可以获取到它内部的 Component 链接 &emsp;&emsp;最初是想通过 Actor 的 component 看看有没有办法获取到 蓝图 内部的 Component ， 然并卵 ~&emsp;&emsp;于是我开始走弯路了。&emsp;&emsp;我想到蓝图编辑器窗口既然可以获取到这些 Component ，应该会有相关的线索的。&emsp;&emsp;所以我开始查阅引擎的源码，希望能够从中找到解决方案~ 蓝图编辑窗口 SCSEditor 源码查阅 &emsp;&emsp;首先要快速定位蓝图编辑器的源码位置。&emsp;&emsp;依然是使用老办法，通过 Tooltip 来定位最快。 &emsp;&emsp;然后可以定位到 SBlueprintEditorToolbar.cpp 脚本，并且可以定位模块在引擎的 Kismet 文件夹里面。&emsp;&emsp;由于这里面的代码已经非常多了，所以新开一个 VScode 在 Kismet 目录下进行快速的搜索。&emsp;&emsp;下一步我要获取的左侧的 Component 树状图的结构。&emsp;&emsp;于是我又找了个简单的 Tooltip 来定位 &emsp;&emsp;这里可以直接定位到 SCSCEditor.cpp 脚本，&emsp;&emsp;然后就开始了我更大弯路的阅读源码，其中还去找了右侧的 Detail 界面生成逻辑去看，但是其实是我想多了。&emsp;&emsp;我只要找到 蓝图的 Component 是怎么生成出树的即可。 &emsp;&emsp;后来总算找到了对的 函数 OnApplyChangesToBlueprint&emsp;&emsp;当蓝图的 Component 有任何的变动应该就会触发这个函数来进行 组件树的更新 &emsp;&emsp;Component 更新相关的逻辑就是红框框住的部分。&emsp;&emsp;可以看到这其中有一个关键操作。 123AActor* Actor = GetActorContext();// 代码省略 ...AActor* BlueprintCDO = Actor-&gt;GetClass()-&gt;GetDefaultObject&lt;AActor&gt;(); &emsp;&emsp;这个操作通过 Actor 获取类，然后再通过 类 获取 DefaultObject 来进行操作。&emsp;&emsp;这个变量的命名就很灵性，于是去查一下 unreal cdo 相关的内容，然后可以追查到 AnswerHub 链接 &emsp;&emsp;根据最佳回答可以知道， CDO 是 Unreal 的 Class Default Object 的简称。&emsp;&emsp;专门用来存储 类 的实例化初始值对象，也就是当 类实例化的时候，会通过反射系统从 CDO 对象中取值。&emsp;&emsp;所以针对蓝图这种就更为重要，因为蓝图其实是一个 C++ 类生成器，可以简单理解为 Compile 的时候生成相应的 C++ 类以及对应的 Class Default Object&emsp;&emsp;进而通过 Class Default Object 来衍生出其他的实例。 &emsp;&emsp;所以修改蓝图 Component 的属性，本质上就是要修改 Class Default Object 即可。 Python 尝试修改 CDO &emsp;&emsp;通过上面的 C++ 源码，我想到在游戏场景里面获取 Actor 然后模仿上面的方式获取类。 123456import unrealactors = unreal.EditorLevelLibrary.get_selected_level_actors()for actor in actors: print(actor.get_class())# LogPython: &lt;Object '/Game/sequence/NewBlueprint.NewBlueprint_C' (0x00000209683ADD00) Class 'BlueprintGeneratedClass'&gt; &emsp;&emsp;果然 Actor 获取到的 Class 是特殊的 BlueprintGeneratedClass&emsp;&emsp;然而在 Python 里面也提供太多特殊的调用方式。&emsp;&emsp;我用 dir 列出这个类可以调用的方法，发现还有 get_default_object 方法，继承于 unreal._ObjectBase 链接 123456import unrealactors = unreal.EditorLevelLibrary.get_selected_level_actors()for actor in actors: print(actor.get_class().get_default_object())# LogPython: LogPython: &lt;Object '/Script/Engine.Default__BlueprintGeneratedClass' (0x0000020943CB0100) Class 'BlueprintGeneratedClass'&gt; &emsp;&emsp;然而类的显示路径虽然变了，但是实际上的类型是不对的，我要获取到 Actor 类型才是对的。&emsp;&emsp;于是我又搜索了一下关于 Python 蓝图 修改 CDO 相关的信息，还真的搜到官方的工程师提供的方案 链接&emsp;&emsp;没想到官方工程师给的方案更加简单，可以直接从蓝图路径中获取到 CDO ，只需要在路径上加上 _C 后缀 ，Actor获取也给省了。&emsp;&emsp;我测试了官方的代码，通过 unreal.get_default_object 这个方法获取到的 object 是 Actor 类型，是对的。 1234567import unrealbp_gc = unreal.load_object(None, "/Game/sequence/NewBlueprint.NewBlueprint_C")bp_cdo = unreal.get_default_object(bp_gc)print(bp_cdo)print(type(bp_cdo))# LogPython: &lt;Object '/Game/sequence/NewBlueprint.Default__NewBlueprint_C' (0x000002096AEC4D00) Class 'NewBlueprint_C'&gt;# LogPython: &lt;type 'Actor'&gt; &emsp;&emsp;本来以为官方提供的就是最佳解决方案，困扰良久的问题总算解决了。&emsp;&emsp;最后证明我还是太Naive &emsp;&emsp;当我获取 Actor 的 root_component 之后，我发现没法获取 component。 123456789import unrealbp_gc = unreal.load_object(None, "/Game/sequence/NewBlueprint.NewBlueprint_C")bp_cdo = unreal.get_default_object(bp_gc)print (bp_cdo.root_component)print (bp_cdo.get_component_by_class(unreal.ActorComponent))print (bp_cdo.get_component_by_class(unreal.SceneComponent))# LogPython: None# LogPython: None# LogPython: None &emsp;&emsp;上面测试用的蓝图比较简单，我当时用项目的蓝图还是可以获取到 root_component 但是获取不到它的子对象。&emsp;&emsp;于是到头来 Python 还是无法解决这个问题。 C++ 获取 CDO Component &emsp;&emsp;我又追查了一下 C++ 的 API 。&emsp;&emsp;发现 Actor 可以通过 GetComponents 获取 123456789101112TArray&lt;UActorComponent *&gt; UPyToolkitBPLibrary::GetCDOInheritedComponents(AActor *CDO)&#123; TArray&lt;UActorComponent *&gt; ComponentArray; TInlineComponentArray&lt;UActorComponent *&gt; Components; CDO-&gt;GetComponents(Components); for (UActorComponent *Component : Components) &#123; ComponentArray.Add(Component); &#125; return ComponentArray;&#125; &emsp;&emsp;但是只是这样还是没法获取全部的 Component ， 一些后续添加的 Component 还是通过 Python 无法获取。&emsp;&emsp;于是我又开始去查 SCSCEditor.cpp 的源码，因为我相信既然可以生成组件树，一定是可以获取到 Component 的。&emsp;&emsp;但是当时总是想着 Component 的线索去追查，完全没想到这个东西居然和 Node 有关。&emsp;&emsp;所以就踩了个巨坑，浪费了好多时间，然后最后实在没办法了，找了程序来帮忙，然后程序也没有搞过，还是得自己查。&emsp;&emsp;最后又从网上挣扎了一下，没想到找到了解决方案 链接 12345678910111213TArray&lt;UActorComponent *&gt; UPyToolkitBPLibrary::GetCDONodeComponents(AActor *CDO)&#123; UBlueprintGeneratedClass *ActorBlueprintGeneratedClass = Cast&lt;UBlueprintGeneratedClass&gt;(CDO-&gt;GetClass()); // NOTE https://answers.unrealengine.com/questions/558236/how-to-get-a-component-from-a-classdefaultobject.html TArray&lt;UActorComponent *&gt; Components; const TArray&lt;USCS_Node *&gt; &amp;ActorBlueprintNodes = ActorBlueprintGeneratedClass-&gt;SimpleConstructionScript-&gt;GetAllNodes(); for (USCS_Node *Node : ActorBlueprintNodes) &#123; Components.Add(Node-&gt;ComponentTemplate); &#125; return Components;&#125; &emsp;&emsp;SimpleConstructionScript 获取到 USimpleConstructionScript 这个类&emsp;&emsp;这个类是 蓝图生成 Actor 的时候调用给 Actor 添加组件用的。&emsp;&emsp;这里并不包含所有的 Component ，只有一些蓝图额外添加的 Component 才会放到这里。 &emsp;&emsp;还好有人已经做好了获取的参考代码，要我自己查到是这么个逻辑估计得天荒地老了(:з」∠)&emsp;&emsp;于是通过上面这个蓝图的暴露就可以获取到 蓝图 中所有的 Component (但是是没有层级关系的)&emsp;&emsp;直接获取的 Component 中用 set_editor_property 设置值，就可以实现蓝图 Component 的修改了~ &emsp;&emsp;由于项目使用了一些自定义的 Component 组件，每每都要去查 C++ 源码看有什么 property 可以设置是非常不方便的。&emsp;&emsp;幸好之前推荐多次的 Unreal Python 教程已经提供了解决方案 链接 12345678910111213141516TArray&lt;FString&gt; UPyToolkitBPLibrary::GetAllProperties(UClass *Class)&#123; TArray&lt;FString&gt; Ret; if (Class != nullptr) &#123; for (TFieldIterator&lt;FProperty&gt; It(Class); It; ++It) &#123; FProperty *Property = *It; if (Property-&gt;HasAnyPropertyFlags(EPropertyFlags::CPF_Edit)) &#123; Ret.Add(Property-&gt;GetName()); &#125; &#125; &#125; return Ret;&#125; &emsp;&emsp;最新版本的引擎提示 UProperty 改名为了 FProperty&emsp;&emsp;目前编译可以通过，估计下一个版本就会直接报错了，所以这里我稍稍修改了一下。 &emsp;&emsp;通过这个方法就可以确切知道组件下有什么属性可以通过 Python 进行设置了。 2021-6-1 更新 - 不需要 C++ 更新 &emsp;&emsp;最近才发现 CDO 对象可以直接获取到子对象，不需要 C++ 辅助这么麻烦。&emsp;&emsp;不过这个获取也只限于继承于 C++ 的蓝图，如果是蓝图里面手动添加的，依然无法直接通过 cdo 对象获取&emsp;&emsp;但是如果是实例化到场景中的 Actor ，倒是可以直接 get_editor_property 获取到 12345678910import unrealasset_lib = unreal.EditorAssetLibrary# NOTE 这个蓝图是新建继承 character 的蓝图bp = asset_lib.load_asset('/Game/test/NewBlueprint1.NewBlueprint1')bp_gc = unreal.load_object(None, "%s_C" %bp.get_path_name())bp_cdo = unreal.get_default_object(bp_gc)print (bp_cdo.get_editor_property("CapsuleComponent"))print (bp_cdo.get_editor_property("mesh"))# LogPython: &lt;Object '/Game/test/NewBlueprint1.Default__NewBlueprint1_C:CollisionCylinder' (0x000001844AE95D00) Class 'CapsuleComponent'&gt;# LogPython: &lt;Object '/Game/test/NewBlueprint1.Default__NewBlueprint1_C:CharacterMesh0' (0x0000018469623040) Class 'SkeletalMeshComponent'&gt; &emsp;&emsp;获取到的对象可以直接进行修改。 12capsule = bp_cdo.get_editor_property("CapsuleComponent")capsule.set_editor_property("capsule_radius",10) &emsp;&emsp;如上可以设置胶囊体的半径，但是需要关闭蓝图窗口再打开才能看到视图的更新 总结 &emsp;&emsp;一个人搞 Unreal Python 就是痛苦无比，所有的雷都得自己解决。&emsp;&emsp;解决需求根本无法评估到底需要多少时间(:з」∠)，这次就踩到了天坑.&emsp;&emsp;真正解决问题的代码其实也就那么几行就够了，但是走了弯路就耗费了好多倍的时间o(╥﹏╥)o&emsp;&emsp;ε=(´ο｀*)))唉，但是就像我昨天吐槽的一样， C++ 的开发效率实在是太低了，能用 Python 还是尽量用 Python 解决了。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal/blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Sequencer 菜单工具栏嵌入]]></title>
    <url>%2Fposts%2F434462e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;关于菜单搭建，我之前就写过一篇文章关于如何使用 Python 搭建 Unreal 主界面的菜单。 链接&emsp;&emsp;但是倘若要实现更为复杂的效果，比如在 Sequencer 的右键菜单上扩展，或者添加工具栏。&emsp;&emsp;要实现这样的功能 Python 就无能为力了。 &emsp;&emsp;既然要用 C++ 实现，就必须要推荐一下官方提供的扩展教程。 B站链接 Youtube链接 github链接&emsp;&emsp;教程稍微有点老了，是 2015 年的，不过我把 Github 的代码拉下来，稍微修复一些编译的小问题，基本上是可用的。&emsp;&emsp;作为引擎扩展是绝佳的参考，另外最近逛论坛的时候还发现了一个不错 Python Editor 扩展插件。&emsp;&emsp;在 Unreal 里面实现 Maya 工具栏的效果，也是引擎扩展非常好的参考。 论坛地址 github地址 &emsp;&emsp;不过 Python Editor 在 4.25 引擎下编译会出现大量错误，头文件的索引很多都不可用，还有一些代码的小问题。&emsp;&emsp;所以我把这些杂七杂八的错误全部修复了，参见我 Fork 的仓库。 github地址&emsp;&emsp;时间不足，有空要好好研究一下这个插件，做得非常好。 &emsp;&emsp;这个需求和我上次研究的 Unreal 自定义快捷键拓展中诸多相似的地方，可以结合到一起看 链接 Sequencer 菜单扩展 &emsp;&emsp;虚幻是开源的，所以即使再不济，也可以在源码上进行修改。&emsp;&emsp;但是改动引擎是非常不好的操作，说明架构设计上扩展性不足，堂堂虚幻引擎怎么会沦落到这种地步。&emsp;&emsp;所以在官方论坛上搜索一下，可以看到官方工作人员给出了一些使用提示 链接 &emsp;&emsp;官方的回答有提到大部分 Slate 都预留了 FExtender 来进行菜单的扩展，不需要修改源代码。&emsp;&emsp;可以通过 C++ 插件来实现，并且插件实现可以迁移到不同项目的引擎，相比之下更友好。 &emsp;&emsp;到这一步可以去查 Unreal 的 C++ API 文档，看看 Sequencer 的 API 有没有提供相关的方法。&emsp;&emsp;通常优先查 I 开头的类，因为这种类属于接口，将内部函数转换到外部使用的。 &emsp;&emsp;所以可以在 ISequencerModule 里面找到目标。 &emsp;&emsp;这个函数获取到 FExtensibilityManager 基本上就和上次扩展快捷键一样。&emsp;&emsp;需要定制一个 UI_COMMAND 然后通过 AddExtender 将 UI_COMMAND 定义的命令添加进去。&emsp;&emsp;同时 FExtender 构建参数里面 FMenuExtensionDelegate 中定义菜单嵌入的生成代码。 12345678910111213141516171819202122232425262728293031323334353637383940// NOTE 获取 SequencerModule 以及 FExtensibilityManagerISequencerModule &amp;SequencerModule = FModuleManager::Get().LoadModuleChecked&lt;ISequencerModule&gt;("Sequencer");TSharedPtr&lt;FExtensibilityManager&gt; Manager = SequencerModule.GetObjectBindingContextMenuExtensibilityManager();struct Callback&#123; static void ExportCurve() &#123; // NOTE 点击触发执行的函数，这里我通常是定义调用特定路径的 Python 脚本 FString Script = "py \" xxx \""; GEngine-&gt;Exec(NULL, Script.GetCharArray().GetData()); &#125; static void ExtendMenu(FMenuBuilder &amp;MenuBuilder) &#123; // NOTE 设置 Section MenuBuilder.BeginSection("FXCurve", LOCTEXT("FXCurve", "FXCurve")); &#123; // NOTE 设置点击菜单栏 MenuBuilder.AddMenuEntry( LOCTEXT("ExportCurve", "Export Curve"), LOCTEXT("ExportCurveTooltip", "Export Curve to FX Blueprint"), FSlateIcon(), // NOTE 设置点击触发的函数 FExecuteAction::CreateStatic(&amp;ExportCurve) ); &#125; MenuBuilder.EndSection(); &#125;&#125;;// NOTE 获取 SequencerModule 以及 FExtensibilityManagerTSharedPtr&lt;FExtender&gt; MenuExtender = MakeShareable(new FExtender);MenuExtender-&gt;AddMenuExtension( TEXT("Spawnable"), EExtensionHook::Before, TSharedPtr&lt;FUICommandList&gt;(), FMenuExtensionDelegate::CreateStatic(&amp;Callback::ExtendMenu));Manager-&gt;AddExtender(MenuExtender); &emsp;&emsp;上面的代码可以在 Sequencer 的 binding 菜单上嵌入 Entry 。 &emsp;&emsp;嵌入的 Spawnable 位置是怎么填写的呢？&emsp;&emsp;其实看了官方的引擎扩展教程就可以知道怎么操作 ~&emsp;&emsp;需要在引擎的配置面板上开启显示。 &emsp;&emsp;需要在引擎的配置面板上勾选显示。&emsp;&emsp;然后重开引擎。(不重开 动态菜单也可以更新，不过 Toolbar 之类的就不行) &emsp;&emsp;这样就可以看到菜单背后的代码标记了。&emsp;&emsp;方便定位菜单的嵌入。 工具栏嵌入 &emsp;&emsp;其实有了菜单功能的嵌入，工具栏嵌入也是大同小异而已。&emsp;&emsp;不逼逼，直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142ISequencerModule &amp;SequencerModule = FModuleManager::Get().LoadModuleChecked&lt;ISequencerModule&gt;("Sequencer");TSharedPtr&lt;FExtensibilityManager&gt; Manager = SequencerModule.GetToolBarExtensibilityManager();struct Callback&#123; static void ExportCurve() &#123; FString Script = "py \" xxx \""; GEngine-&gt;Exec(NULL, Script.GetCharArray().GetData()); &#125; static void ExtendToolBar(FToolBarBuilder &amp;ToolBarBuilder) &#123; ToolBarBuilder.BeginSection("Keys"); &#123; ToolBarBuilder.AddToolBarButton( FPyCommandList::Get().ExportSelectedKeys, NAME_None, TAttribute&lt;FText&gt;(), TAttribute&lt;FText&gt;(), FSlateIcon(FEditorStyle::GetStyleSetName(), "Matinee.ToggleCurveEditor") ); &#125; ToolBarBuilder.EndSection(); ToolBarBuilder.AddSeparator(); &#125;&#125;;TSharedRef&lt;FUICommandList&gt; CommandList = MakeShareable(new FUICommandList);CommandList-&gt;MapAction( FPyCommandList::Get().ExportSelectedKeys, FExecuteAction::CreateStatic(&amp;Callback::ExportCurve));TSharedPtr&lt;FExtender&gt; MenuExtender = MakeShareable(new FExtender);MenuExtender-&gt;AddToolBarExtension( TEXT("Curve Editor"), EExtensionHook::After, CommandList, FToolBarExtensionDelegate::CreateStatic(&amp;Callback::ExtendToolBar));Manager-&gt;AddExtender(MenuExtender); &emsp;&emsp;Toolbar 多了一个操作，需要创建一个 UI_COMMAND&emsp;&emsp;然后通过 CommandList 来映射执行的回调函数。&emsp;&emsp;这里我直接用了 Unreal 内置的图标，具体的名称可以参考引擎源码 SlateEditorStyle.cpp 里面的定义。 总结 &emsp;&emsp;可惜目前 Python 还没有暴露出相关的 UObject 类型来调用。&emsp;&emsp;所以没法用 Python 进行扩展，不过也可以参考 Sequencer Scripting 插件的做法，将 FClass 转成 UClass 进行调用。&emsp;&emsp;后续有空再进一步研究吧，c++的开发效率实在是太低了，而且我的基础极其不扎实，需要一些基础教程巩固一下(:з」∠)]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal/Sequencer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 警告提示优化]]></title>
    <url>%2Fposts%2F534db3d0.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近折腾 Unreal Python 工具开发，又遇到了一些问题。&emsp;&emsp;工具开发经常需要提供一些弹窗来提示用户。&emsp;&emsp;但是因为 Unreal 的 Qt 环境和 Maya 之类的纯 Qt 软件有很大的出入，所以是不能互相兼容的。 QMessageBox 的优化 &emsp;&emsp;这就导致过去常用的 QMessageBox.warning 的操作方式不太可行。&emsp;&emsp;因为有时候需要在完全没有 Qt 窗口的环境下弹出窗口。&emsp;&emsp;后面我发现可以即便没有运行的 QWidget 也可以通过 QApplication.desktop() 的方式获取 Widget 来依附， 所以原先的方式还是可以用的。&emsp;&emsp;缺点就是没有通过我封装的 show 进行触发，窗口是独立于 Unreal 的。 &emsp;&emsp;所以基于上面的原因还是不可避免需要重写一下 MessageBox 弹出的效果 1234567891011121314import unrealfrom Qt import QtCore, QtWidgets, QtGuifrom dayu_widgets import dayu_themedef alert(msg=u"msg", title=u"警告", icon=QtWidgets.QMessageBox.Warning, button_text=u"确定"): # NOTE 生成 Qt 警告窗口 msg_box = QtWidgets.QMessageBox() msg_box.setIcon(icon) msg_box.setWindowTitle(title) msg_box.setText(msg) msg_box.addButton(button_text, QtWidgets.QMessageBox.AcceptRole) unreal.parent_external_window_to_slate(msg_box.winId()) dayu_theme.apply(msg_box) msg_box.exec_() &emsp;&emsp;我可以通过全手动的方式实现 QMessageBox ，这样可控性更高。&emsp;&emsp;通过 exec_ 函数实现 Qt 事件的占用，确保用户关闭窗口才能控制引擎。 无输入 优化 &emsp;&emsp;上面的实现效果已经不错了，但是还是不太完美。&emsp;&emsp;这种弹窗依然需要用户进行操作才可以将窗口关闭。&emsp;&emsp;如果窗口可以自动关闭就好了~ &emsp;&emsp;我查了一下 Qt 的功能，发现 其实 Qt 自带有 alert 函数可以实现定时关闭的效果 链接&emsp;&emsp;但是我简单测试了一下，这个函数完全不起作用，无论是 PySide 还是 PySide2 都是(:з」∠)&emsp;&emsp;希望有人能帮我解答一下这个问题。 &emsp;&emsp;虽然 Qt 默认内置的操作没法实现上面提到的提示弹出自动消失的效果。&emsp;&emsp;不过强大的 dayu_widgets 已经封装好了相关的组件，用起来很方便。&emsp;&emsp;比如 dayu_widgets 提供的 MToast 案例 &emsp;&emsp;但是同时也遇到了相关的问题，Unreal Python 不存在运行中的窗口，怎么才可以确保 MToast 在当前屏幕的中央触发呢？&emsp;&emsp;经过我的研究，可以活用 QDesktopWidget 获取当前鼠标所在的 屏幕，从而实现 MToast 居中显示的操作。 12345678910111213141516171819toast_dict = &#123; "error": MToast.error, "info": MToast.info, "success": MToast.success, "warning": MToast.warning,&#125;def toast(text="", typ=""): # NOTE 获取鼠标的位置弹出屏幕居中的 MToast 警告 global MESSAGE_TOAST # MOTE 获取鼠标位置 pos = QtGui.QCursor.pos() desktop = QtWidgets.QApplication.desktop() # MOTE 生成一个临时的屏幕 Widget MESSAGE_TOAST = QtWidgets.QWidget() # MOTE 将屏幕的长宽赋予到临时 Widget 上 MESSAGE_TOAST.setGeometry(desktop.screenGeometry(pos)) toast_dict.get(typ,MToast.error)(parent=MESSAGE_TOAST, text=text) &emsp;&emsp;上面的录屏是我两个显示屏，在不同屏幕上的弹出提示效果。&emsp;&emsp;如此以来我就可以根据用户的屏幕弹出提示信息，更加人性化，而且这个操作不依赖于激活的窗口，交互体验很好。 总结 &emsp;&emsp;最近又折腾了很多 Unreal C++ 结合 Python 操作的东西。&emsp;&emsp;越是折腾，越是深刻体会到 C++ 开发的痛苦，虽然运行效率很高，但是开发效率真的很低。&emsp;&emsp;每次编译需要几十秒，项目的引擎还没法做到官方直播的视频里面开着引擎热更新。&emsp;&emsp;编译完之后还重新开引擎，如果不重开反正也会报错强制重开(:з」∠)&emsp;&emsp;以前 Python 遇到代码的崩溃循环的时候，我已经非常抓狂了，但是试错的效率还是很高的。&emsp;&emsp;今天遇到了 C++ 代码的崩溃循环，耗了一天啥也没干就没了o(╥﹏╥)o]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】-2020年7月回顾-8月学习计划]]></title>
    <url>%2Fposts%2F7d11940d.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. febd0595494e4d07842e9345e60cb698d05c548992ab167bc31959678ead890df3260cfb97d51f734a20912c4c5e9e44e78c7b259604db7e5399a88a3ac722fc8a9be3e2b63cfa8f6c72e659e8f1993fac9dcac2d06964695a705e9781ae0582f303326ba206819ce0e29b499be4a901c3a459296b9f1c3f594b1504463b679e4c6234270af91b87ec9bfe8679cbf8e32adf0e4ebad575184beb2e4c808423e880f5491828540c1b5664597285f44ea18a69a3804ccbbeed4337e61432d0896519b0e6660d34046ab3cc1d390c8908d0dfccf20037707dd93f3293cba9ac4c5102d80e3b971c284bdf633b354ea59875c5323d902f24a5f6b9ab93bb030398678697a3fbe8f3598b43ef2143a95a4731b8412b9a3cc0696f94cd78c17a22c6a6b0be645410e6e66fd07dd44cc33c4b0b58195f688a121d2d45a7276de624f8dd094b0dc999997fca568f1a872101e499c3da27dd5723e0f7bf8840b0873732cd1e649e414bfae3c833ea0e7bf3a150e4bc23e1cc127b63de9ea4d134f7bdd6c5d95d5c3a46be9494a0ad55fdee7555ce7f6e31204fbd9b46234868b67f19a34f388d99e138751c0dad34474c3a0dffa46649862d7be09be6eb1366ecb73a5a42f881a4fe041ee279fffd9c3dd73ec9e11bbd4bddc8446d1d990b42209335f4a113cfe7cd13bc190f6f753e92952e9255a11e719429830308c1465c02a60d5edc1dd9d4669c2620af2b267cf023dcd5bbe66481fbae94214250d62d66e8240d2a36ed5a5e42c0ace3e5e04e8121603205d73c0015ddef743e0f8e3d6f9b001246ddbe7659cbd583efde33e2006858ba17678625cbc7dca3889706c9d3417917b72e3f0025ac6c7f40ad251885a6314f5c958b2eee74fd5f090a47d414914fe88afbf033ac560c08d981678f17a6f0bbed2a27d0809b2d6c04b877fca4ed5b8b91b79ec21c24a5b2b2ecfba4f6409fce54799b88e29dea031f484430a37dacd74d4101532cf4bbddf01e3ff55727ba71aead77b6915876e58599b0f987dbcbf9824b9e27c1b905de93329020f698e787216baefb634a2bc7597a51032d6fc24b82f81ad1467322aa01db2bc92bfde37b76220ff719b90112611965104a5e4e1a539bba45b8bffe6a68db2bd2ed3d1ee5759b2f2c1d0b497e25df65098350ffdd37240b2f1446da863991299936993ce546d72f3b9cf6cd0159e698139f52e97c581f26425e135223ae53b1e5fd7046c60e6ac203fd7c2d76932b6a92278d6283f5a192b12c14cc2f38e87f3c0a0ac3bc17d640faf960980084f908d03d979e9bc319715e07566f4cf464e3c8b7d68097bc76fd6c35418b0c7eaaa018265edfeccfcf6d7c4c5789a09bfe586999064717df8d3e7bebd2a0206f67857260c5408d91991bbb697f8164490eb452df6c3f20628d05c40b306456500f492f86e95b3aa2eae1d07becbd67dd21e7d8f3e9b38324c156ba2f12c841ada859db046ab9e3d6565156091db2a0b2f40cfbda9c8948a423b6718e0c0a171e75caf4744908607da8328a62c4238c2225ed3a64369974bd258e4472d7d72f31465cf0e54731e2d3690297d96b7a361b4c53383664e25c50d2f85b64c8a014f3f1c5e8ea49873cdc7ff2bc9d5e3068788f9ac620a95c93c13a837e0a26d0247c488339f2a679ef9d83a15a0c4c96f1a06e2f00c4199769e26304cb7fe605c147adc01d68a73cb699451886103ff62fe2742bbbb9c6f73343fce6fdaa0842ed89bf70412b3a8a5e56b2457173bb239c4491fb72945c7bb3a2f042bda5d8fbb31066f06803f32c35783e0a577748971a16cab02a01ec5c39a2dc6d0ee6374f1fba23a0a378b5153da754c02d105e8f1beb6afe4d90d575124fc610bc1a21ab58d6f0742773c2559ded11b45073e04283d417364d173dda5648beec12120990299ef4fc201fdba4ca49e8861ecab82de7eb3d7a25cc47277cbcb15112036ec76bc8347b32670599922289f82284c3451817a05cbf51ed2aad5872ed4b31684c71d9045a317ac207784e3ec0a2aa1c81589d06f7dfaedf2b9fa39427a8b11edba8f3f57edfe6aa0e676c7ee11a30ce5fb07472cb49f953064001e67cdcb2777e566f13c7a9fbe8cd1ded16c8d654055bf6719293e8d66b2c888b9759685ca70479556b340165c4cfabcae97eb85e1aa8b113f3053d350173c868237c32684ae68bf8eff3d3093fe6710f39bc20942f513bbb48cd3028413f41f4adb0665a9883233b0c287ec84182d20947e9d8af9bce360bfb7e7b09227981e4aefb595d966de763e4e12e999729f1447928019d06c6b86640e65c96031962ebcf106b8f4beec2c1b7aa7104a5995cb59cc29e0e81d5bed92f6445e8a128141661bba3fbb49297f4dac7bec4652413eca26bb4b71dc31d17dcc11d4e54849a91199b840d57d312cdfd7d7005c52e265cda8f58cf9fb226b10a9cb5368299ba654122471c5be55b1296efcb5f4f376fa84783b66fcd144c16c932bdb590306ce7bad44e3888c5d4d4c4aa3a88b0f2382b950b9e57638e907c78194a929a803ef296c5ec3f979bcad4310897c806fd65aa871f0a1a763384bba32d895a15838994444314447d53605752cc28cb5c44955a66e23bd8d92bc8d325cd1d0f4cfe979b8edd4a88de40854cb5b5a6450ed0e0ff11dc8f35b1622065247d2bc6d24f5955f23f266f47dd2e3ec8ae5f10d61feacbd21cd17bb12f489a76037a47ba41878a95c4105f61d28ccc85fc1458d7ab71c0c8e095256fd0c0484adce8066a5f12d7e15c42ae628433e15494e65212838a3aa5ebc0443b2639450f7d76a63c94741eb00b63561e0b424707ccb5da119b80b6291f7537a35aed12cddd490310b6002418ff28a1270d0ffba5b804d8a7ce7f2284772ba8a03c6d19ac31c191ac30cf8bd65c62f62f06b958d954b9ecddb2d1891d5cf97d3292f61c621239e4e1572193cff98a9f57eaca9c2f0330528e60345be0e5cce58633ce539d087a71da2b325f5d469f9f1b94e2998dd393795ecba388f214842063b46470c43a7760d11588416e1254cc4dcee6a7b5309a973a52df008bd9f24d4a32f245008b229f72fe268faec59da1ff58b8a77138c9289bebefb1df590f4b46a4a3d86a64a3372df549e875bf81165d76d779652f16d409f174f4d3a3db091a6d8e324525d07f044ad01ae7e993f6f5ea5d55663451b9845204e571d4321e3f0a44d7c7e38c119c8efbea167cfefa3ec4f1d4d23d9d26a34a3c3dc5c7c45b9a59ad5e8e4d1216ccb0b3d5f499c6014365295bfb9691236b36400b28479e1de8dac8b93fbdc69185028a4b836ecdcc3e0ea1e22e56fb14660305c1374a2af4d5b8fd9462f1e501a341aeec9da81bc677a7507f9b5bdee604c39820c79e74bb112126260fe7bf4c99065622fc3a3310bc5bf0a948e0617330f4da2b3950688c11951e520ab3eed4d8114c05ccb3e5cd2e5f4eef6d3a6b9b0aaeac0fd0b74501f9e0854a97ab34b77fe4c4cf1db6fd7d7896345d3c3e42356fefa80b8cd38d7c23a54bc6e6336fda81e284e088c5cf019bcfded18120dccb116fb7fd2afc6378b80dac5aca5cb8a4852ce8d48549e428ee3452e213138311e0371031b7fe84c795e645ba88f7516f911c3e82a894ecee19f48b607f95dd08ad501abc4f34eb49c108f32a5e71966dc130e13e1bb9486a3d218ef84e8c88cecff3b639f164d2423777c1891f07fc91c6710a728d8dae11b99f092d0552a2d8c9958f2aeaba07fd30e05bcf8d583b52a16c4780f3602c478ba53094dd7d389235e85c1d5f7f3c5d47ce028eaad290edbceeccfe3b6b9bbc18660a612a67727085360a5095066d6d7774ef4d5b268182478b09f6077cb7d0cd9194ceb9b6d71861c99cc88389a246fc8f1d4f85868b3d2c2d4aba92377f9e91892195a92dd3406aaf820edbff25fd9ad8f2373ff894408d15c23213ac89ad49eab883aca4a2dcdf6d902254ccc92462b6c1ce78090e96be5a42d989d53040e44fcbd1f9c949e49517a8f3ec4c12a37b7507ab55cad62aa69b51d31454f18602794d68c16aea513475f53c321fd7414f721879db2210308946d383485b5367ca3aae30b96d531e5d12116ce19dd48f28e4df666a5233bdeed92c30b5a459a09a669a89dd70f11d9e375072faad8f8ee5b31d1fa12918843f105c99b9637bc148f2bac77200d577dfae9035d5374a67f52c9eb714794b67b2c02b7ce566aa49ed608d556b94ac67cc9ce3c1257dec18842ff9af38ece46556c7356625a722a076a54919362e450f55f8a77e3ae216ae010237dc537d573b68f11f5df2d3158272da392eaf5ed6d2d1d43c9d1eb07d81cb782fde763b9f4b063397c9bf8c7fbcc8e0cc838db97d27eb598fd4cd191e25e10017a8848aa08342bb0fd32f0fc61e590c1913661f667f777495616b0eafd4de2a372e5c8811991fda3c67da55ae808849d9dcf29101cf903f9323aaa6c0a579f7a7d010e14c0e401af37509e179940b8df6a3069526d57626f907f2cb46cfd139d11b263dd15b73d2d7081d0f72b4bf14f0a60a33f91a2f73ff031888d4f61df839e2ee452afe0f5f506fa35710a4a5bf63385aca22d21961f304850361f63391c80342577cd8c1fe275febc7a90002353dd3c3efe8a929fdcdbf0eed8eb3a85bf93eb153c97b58f5e8a1897e9896909adfdfe179355b34ed87f1d5a5056294eb0b7e3f366a6ce487b764db2242de0be608e8241a789dfd1931de7d35698bb7f1eb1b48a1f868eda4ac64d47b83b53dd6de2bb99b1811ae238ceb42d88ea79ddc455ae074f1b67f9bb2e26fc697d1fa856423acd8536e81b2946a09624f94e52359250066a96ac1ebc77ec6dfbba5b2cf2c33b934a2a9c753a128c0ee14c73920280fdbb85e96e10ea14901fdbf4fa060bb845fcbbcb82ecee7d61d7db7bc8a376b3b5b6ab040b5ff3c1440bda09f8c0603a490d53f9ccd30ecf530f52d6008fd4a0b6b684eddc68ef01e1f96f83bb28209b8f930f100431f4c2cf4bf7192af8d98412e71e5baba5e2d9c240d2510c18ecaa7e280996b2ef6e40a5e13f81702e99342ba103f0f3dba136fc3636b5563dc2fcebf94c7e32c4cc029fd3cb24944e2d9503b38d837fba1ddde762dc70e017f51a2d231b7b5b43f290fce7f95fa8d71b54e39069dbcab7842092e993d91a81561da10105f5ef80e55830f513327458202c52173754f079670ebeea83ed2eedd0ce30c2feb52aff76efd6203c179e3affba2358524bb56867ab0a23fb649fd14b932929a199b777cb8244d1c58ae3934ca4a645e3f911df9f5d0d9c0dcf3963dc8d1fbe3e5a726f0e34130182b8d0081e7a43cebde91d05e74bae61fafc5535e949ef929b6062c64b978440fead9bb44c9c45972dc2e35feed09ef1df05b1d27e754d741ff721979a0b10390c9798ec4a47bea370ea00713cb67bd566253334ed7f40a8141375e0b557bf465879ad7322335bca1ac10fd69c214b07340219880856fad7b73fc920276713e01a6b4e59aca1a3dcd629a071010b8af6439c310fc49fe01ce7bf743a021017c4c2287bf3b2c625f678533c542643ef358367bdb98a4cd4cc2aab6c34c9b1ce8f6f2049974406ca7a142ab46fc8a5276c365cba5541d72a23089bc72632641e6b299a2d9130d8c02499444c30eec8c897b6a4e55ae64f49cc5195a649b8948134d85a3f928c1d2a6bae00aa18298a788eb88db0f2cbdbcaad92a66000cafc459ca9eaf05834062f3e8a59122c7e969f0a70606d566502585781b853f39eda5bd5c01557b924346554e8e2a6a3fd9d7352a46a1482a0eabfc646bc39a106f61be34ff94529a280de96fc43f8304acef5ab4c48bdaab872ec6ce27cb67bad465a07bfb782bac9747a0122014ea316ddb7e1c3bdeff27c9a45f19fda60a17b3087f78ed1cba3e1a6b663a5fc73796ed323a34afd0fb7017a8006f773c1a718b475e53438b4fbe4f4ddf147c12bfb8071dacc19cd4746a3317d15203b65190e9252d98110bd2b5064a73a7576e208c2f82851e9e19a7b60de9d24a70858a9ac68528dd1752cd66b00bb8988e40cea8e7b3065f1176bffa5779078f881b96cf46e12cd58102309b86310213b08cc7fde399381c99fe175b794baa287b8846ee11fe8f3ef0b6788a851a6f017ac3a398ff0028f24fb8084a7ea8b8722ed6066238cec76fd83d4474dae9c0300bceb634345ed0e005e708853098954dda84aa25388855b1fc31fa5d4d97b7a411633c1d4e50ae901326fe82a808a440a17a648a62631bd8a37db53e8b33e2f9b88bf8301061d557769afe1346a8d3980aa3e8f0b3e17907311e8924e09ad8fa1c9dc8c4f77d3407f3b4d50162059585f3e32bb3415bcdbe2a82369fe64da7db3b52ff06fd5f4973bbc7ac950afd26eb07c8e3aa794e47c72a906085979917e9b666eef3e248e263f69490ee5658bab5df80e6f4e3fd5942c53d5bc96f07c1493fb2cca92d618eeda9341e99c87a5a9576483fc5ffe673ed7581a25d328fd7487a6a923f340b097978cb2520837cb8b35749b2b7db338c5ec6a495e45b885e202a0b7a7b7b85bdfefc5197eecfe1289ac6d61a20e4e49ea009f2aba9ba0ddac5cf795a293a45c3c781c6d11ddd8c67559ac892f5537106110c04624b99a27e2fa62e26c3a26c3d0b7d1d2952757fbe12d0fdaed649594ee5c20a107f270fb7f24b55f0b40cdaf156f44d77c244ddccd5f2a6f1c5c869c1012aa18b5ae8fc201a026b28e4ce29c22a013ccf6d64ef936800cfbbed4a10324c03a058ff2f4735798c86ed6c4f823bcceb4347ce44d1824a605129ad19be25a8483c03328cfffa164f5cd6db5d2ab018bf095e13fc993ea70a3d02f0ebe35d8d5be1a61d76ffc280809889ddfcfefee697b912d76b4ab172f4520fc532df79e7aa7f66640672bcd3f7195c4c4c5ea108576549017d40d33db8370d4605c398ecba3790a36d61d6f988899709917fb4dc831a3909a94ed060ed91881ec668758bc61b8793d0b521df110f535c2c4a946e2e5ef598580a3474b3e684f652ea01a87ff18579c0eee746e17c4bc9e19731a2bf7a66890b93da5d91d2349be4216a6217ff407c903e5ca6c9921d39c226dde8156e90c444ad6a95196cd8db68116c3f530ee6d7b9bba4525bf21cc0d93d6f28129f12e50caa01afdd652ff1ae7764a669699d6ddc944dc7015a9101eac334e51b63d3120eeba523af09f55851c57a780c5269ddc76fb0cbbb231ad22df554873d5d45aa6d59fd18609880686b80d8ab7a4483630d3c7b292f5ae80c5934f1242e6138808aed95044be038462106d30ef4e70d4e6e0d92362c1db6d6d905e8e0f134666aeecca8e19d6b1181d38c92b7be5cc29e910c464a88367d4a1e6cabf794ff8f006567dcad6ac31eca6d7ecb89c067c070069f4ff281bd0a0dbd7b69d60b9834a81b9fdfcbab69561ffdeb45c741ce3ad34bf23e75347e23be0b156726593329027f6b36bc45e206aa21110e2b536b8afd17dc00f554d57adbef810c650f7842fb9fdd2428401db3eb854f40c76ecb9b0e4eacdc09295add2134829aa24f8abf829ef8d2fe49d1dc28fe1c426b69dfbb8ca0dba0c63e77ac052f378750cf98bfd6dc5304906237e8902a88bc8b8bee0d5929619e21d4be5575de6445879c0c30f141b445eab0ba30bbf5bcb722cc8012b3ab7d337ad6c7fa99bda6d70bb47916f600bb7cfc6d409150402dcc3f45c1de3ecab491e6386b982487199355df65a3dd5b8fbfda43ab26fb68cb9b5c1d91cb5f4150e67871793cd7debd153622b86c9b12d3c4c352e9ed93996ccd380545aafac8197859e1abd7cec9e9b682d7aa61491cb721438b3b49479e39c5d2d10ef011b23fe2b717cabc0b0605c107bbce1b2b51b456d760d0ef4739c68569e222576a74ef267c2edddb3c42eea9d162739591c86b6efdfe455eea5235416e35d313d2265667e3d33500cf0a51060f49381441fa75e01e32152da98912193e3a5b02e64fb141fa2f31f3ee69376399fc22b9833382c0a5b51f1d3e47defab40f844d30ff754385b8d5e2f59203]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 路径定位启动器]]></title>
    <url>%2Fposts%2F5905c2c9.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Unreal 引擎有个非常蛋疼的点，就是文件无法直接通过路径进行定位。&emsp;&emsp;虽然 Content Browser 可以直接搜索文件，但是文件如果很多的时候，搜索起来其实并不方便。&emsp;&emsp;反而很多时候是别人把路径的截图发过来，还需要自己手动去点点点各种层级目录去到目标位置。&emsp;&emsp;这个过程真是太痛苦了，于是我就想写一个启动器来解决这个问题。 &emsp;&emsp;怎么样定位到 Content Browser 的对应位置，其实并不难。&emsp;&emsp;Unreal 的官方 Python 已经提供了相应的处理方法 链接 &emsp;&emsp;只要输入 assets_path 路径数组，就可以让 Content Browser 自动选择对应的物体。&emsp;&emsp;不过 Python 有个缺点，无法选择文件夹。&emsp;&emsp;这个问题可以参照 Unreal Python 的教程来解决 ~ 虚幻引擎使用Python开发 How To Use Python Inside Unreal Engine 4&emsp;&emsp;github 路径地址 &emsp;&emsp;所以要实现这个工具的难点在于如何通过快捷键触发 Launcher 实现输入交互。&emsp;&emsp;实现的效果大体如下 ↓↓↓ Qt 快捷键触发 &emsp;&emsp;毕竟 Maya 开发用多了，快捷键触发首先就想到了使用 Qt 的事件进行触发。&emsp;&emsp;之前开发过 CommandLauncher 插件，通过 eventFilter 可以实现诸多黑科技 ~&emsp;&emsp;所以这次也想照抄差不多的思路。 &emsp;&emsp;在这里才发现之前开发 ComamndLauncher 还是踩了一些坑。&emsp;&emsp;应为是开发启动器，所以要实现点击外部的时候就要自动消失的功能。&emsp;&emsp;我之前是通过 eventFilter 来过滤点击事件实现的。&emsp;&emsp;其实 Qt 有更简单的实现方法，这个是我看 dayu_widgets 的 MDrawer 实现里面学到的。 1self.setWindowFlags(QtCore.Qt.Popup) &emsp;&emsp;只要组件设置了 Popup 标记，组件会自动变成没有窗口边框的模式，并且点击组件外部会自动消失。&emsp;&emsp;所以 Qt 都贴心地把这些功能实现好了(:з」∠) &emsp;&emsp;上面都是题外话了，这次还是打算用 eventFilter 来过滤键盘事件。&emsp;&emsp;从而实现在 Unreal 引擎的任意位置敲快捷键可以触发 Launcher&emsp;&emsp;然而现实并不如我所愿，组件一旦消失了之后，eventFilter 获取到的事件就只有定时的 Timer 事件了。&emsp;&emsp;键盘输入等等都将不起作用。&emsp;&emsp;考虑到 processEvent 执行，我也尝试在 tick 里面将 processEvent 启动起来。&emsp;&emsp;然而还是不行。 &emsp;&emsp;看来很可能是因为没有 QWidget 在运行了，QApplication也没有阻塞 Unreal 的执行， 而 Unreal 本身也有一套触快捷键的机制，也可能是被 Unreal 的机制截取了。&emsp;&emsp;反正 Qt 的快捷键只有在运行的工具界面上才起作用。 Unreal 自定义快捷键触发自定义命令 &emsp;&emsp;所以要解决这个问题，只能在 Unreal 引擎上面入手。&emsp;&emsp;通过自定义快捷键命令来触发 Launcher 。&emsp;&emsp;但是 Unreal 怎么设置快捷键呢？&emsp;&emsp;最先想到的就是 游戏模式下有 Input Event 相关的蓝图。&emsp;&emsp;可以进行任意按键的扩展。 &emsp;&emsp;然而我在 Editor Utility 里面测试并不能这么触发游戏用的键盘事件，只有游戏蓝图可以触发这些事件。 &emsp;&emsp;那如何才能在 Unreal 中注册一个快捷键呢？&emsp;&emsp;于是网上搜了 customize 相关的关键字。&emsp;&emsp;结果只是找到了 虚幻引擎 设置里面可以设置已有命令的快捷键。 &emsp;&emsp;既然能找到引擎可以设置快捷键的命令，那么可以沿着这条线索去搜索引擎源码里面包含这些快捷键命令，去查它的快捷键是怎么实现的。&emsp;&emsp;于是我找了个比较好观察的命令， F 键聚焦命令。 &emsp;&emsp;首先查 C++ 源码 &emsp;&emsp;可以定位到命令的名称，下面就是要找命令映射执行的。&emsp;&emsp;虚幻的聚焦命令其实是在命令行里面执行 CAMERA ALIGN ACTIVEVIEWPORTONLY&emsp;&emsp;所以配合着定位就很快就找到我们的目标代码。 &emsp;&emsp;基本上通过上述流程就可以知道虚幻是先声明 UI_COMMAND 命令定义命令的描述和触发基本信息。&emsp;&emsp;然后通过 MapAction 命令来映射到触发执行的命令。 &emsp;&emsp;但是这样还是没能解决我们的疑问，快捷键是如何触发到，又是如何触发 MapAction 之后的命令的。&emsp;&emsp;因此需要追查执行了 MapAction 的 LevelEditorCommands 的调用。&emsp;&emsp;这中间踩了一些坑，不过这里就直奔主题了。 &emsp;&emsp;LevelEditorCommands 是专门提供给 LevelEditor 这个 Slate 调用的命令列表， 查 Slate 的类可以查到有很多类似 Qt 的事件回调函数。&emsp;&emsp;从我们这里快捷键相关的 OnKeyDown 函数可以找到 Viewport 快捷键触发的时候会执行 ProcessCommandBindings&emsp;&emsp;ProcessCommandBindings 是 FUICommandList 这个类的派生方法 &emsp;&emsp;从上面的截图可以看到 ProcessCommandBindings 会获取注册的所有 Command ，然后注意判断当前触发是否符合 Command 的描述。&emsp;&emsp;最后会调用 Command 的 Action 来执行。 &emsp;&emsp;这个就是 Unreal Slate 快捷键触发的时候进行的处理流程。&emsp;&emsp;所以如果要自定义快捷键，那么需要将相应的命令添加到 LevelEditorCommands 里面。&emsp;&emsp;于是在查一下 LevelEditor 相关的文档，可以定位到 AppendCommands 命令。 &emsp;&emsp;源码上就是直接进行将额外的 FUICommandList 添加到 LevelEditorCommands 上 Unreal 自定义快捷键命令扩展 &emsp;&emsp;由于第一次进行命令扩展，最好能在源码里面找到个相对简单的例子，然后抄一抄代码。&emsp;&emsp;于是我搜索 TSharedPtr&lt;FUICommandList&gt; 找个简单的例子，还好很快就找到非常简单的例子 AdvancedPreviewSceneCommands.cpp。 &emsp;&emsp;这个例子刚好是 A 开头的，非常好找。&emsp;&emsp;而且代码也很少，只有三个 UI_COMMAND。&emsp;&emsp;后面就是模仿着这个命令扩展写一个 cpp 和 h 文件。&emsp;&emsp;再然后就是 Plugin 的代码里面引入这个命令，然后获取 ILevelEditor 执行 AppendCommands&emsp;&emsp;这里遇到了一个坑，如果插件初始化的时候就执行的话，还没有生成 SLevelEditor 组件。&emsp;&emsp;所以获取不到，会导致程序崩溃。 &emsp;&emsp;所以后面我将代码放到 Python 激活的 Tick 里面调用。&emsp;&emsp;下面是截取加上注释的代码 12345678910111213141516171819202122232425262728// ... Python 执行 initialize.py// NOTE 获取 LevelEditor 模块FLevelEditorModule &amp;LevelEditorModule = FModuleManager::LoadModuleChecked&lt;FLevelEditorModule&gt;("LevelEditor");// NOTE 通过 LevelEditor 模块获取当前的 ILevelEditorTSharedPtr&lt;ILevelEditor&gt; LevelEditor = LevelEditorModule.GetFirstLevelEditor();// NOTE 通过 LevelEditor 模块获取当中的命令TSharedRef&lt;FUICommandList&gt; CommandList = LevelEditorModule.GetGlobalLevelEditorActions();// NOTE 定义临时的结构体用来传递回调函数 (也可以用 Lambda | 只是 Lambda 报错无法定位)struct Callback&#123; static void RunCommand() &#123; FString LauncherScript = TEXT("py \"") + FPaths::ProjectPluginsDir() / TEXT("PyToolkit/Content/UE_Launcher/launcher.py") + TEXT("\""); GEngine-&gt;Exec(NULL, LauncherScript.GetCharArray().GetData()); &#125;&#125;;// NOTE 映射 UI_COMMAND 和执行命令CommandList-&gt;MapAction( FPyCommandList::Get().OpenLauncher, FExecuteAction::CreateStatic(&amp;Callback::RunCommand));// NOTE 将命令添加到 LevelEditor 里面LevelEditor-&gt;AppendCommands(CommandList); &emsp;&emsp;以上就是在 Unreal 上注册自定义快捷键的操作。&emsp;&emsp;和 Qt 不同，这个快捷键触发命令是根据 Slate 划分的，不同的 Slate 需要加到不同的 FUICommandList 里面&emsp;&emsp;所以我这里的添加只能在 LevelEditor 下触发，如果打开什么蓝图界面之类的窗口都无法触发这个快捷键了。&emsp;&emsp;我这个流程做全局快捷键的确不太方便，不知道 Unreal 有没有相关暴露方法来简化操作。&emsp;&emsp;也有可能 Unreal 本身设计就是不期望有全局统一的快捷键触发的。 Launcher 启动器 &emsp;&emsp;完成了上面最难的操作之后。&emsp;&emsp;启动器本身反倒是没有什么难度了。 &emsp;&emsp;主要是判断路径是否合法，如果不合法给用户提示，如果合法就进行跳转。&emsp;&emsp;这里支持判断文件的 uasset 本地路径和 Unreal 里面获取的引用路径。&emsp;&emsp;背后都是转换到引用路径进行判断的。 &emsp;&emsp;开发中也有遇到一些坑。&emsp;&emsp;默认的组件方方正正的，不太好看，于是我想加个圆角。&emsp;&emsp;网上查一下也不难， Stack Overflow 上有 链接&emsp;&emsp;但是这么处理并不透明。 &emsp;&emsp;但是这么处理并不透明。&emsp;&emsp;网上查的结果都是 透明背景 1self.setAttribute(QtCore.Qt.WA_TranslucentBackground) &emsp;&emsp;但是我已经设置了，还是有黑色背景。&emsp;&emsp;后来发现居然是 setWindowFlags Popup 的锅，只要在加上一个无边框命令就正常了。 12self.setWindowFlags(QtCore.Qt.Popup|QtCore.Qt.FramelessWindowHint)self.setAttribute(QtCore.Qt.WA_TranslucentBackground) &emsp;&emsp;这么设置之后的确是不会有黑色背景了，但是却变成了全透明。 &emsp;&emsp;后来在查了一下，原来我上面 Stack Overflow 的链接操作是要在 PaintEvent 里面重新附着颜色才行的。&emsp;&emsp;我当时注释掉了设置渐变颜色的代码，结果就变成全透明了。 总结 &emsp;&emsp;以上就是这次开发路径定位启动器的坑。&emsp;&emsp;其实启动器开发完成之后，后面的玩法很多样，只是不知道美术人员是否喜欢这种类似 Listary 启动各种命令的操作。&emsp;&emsp;最近在研究通过插件嵌入 Unreal 的菜单，下一篇就来讲讲怎么扩展 Unreal 的右键菜单。&emsp;&emsp;其实和 快捷键 的操作有共通的地方。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 骨骼 Socket 自动化工具]]></title>
    <url>%2Fposts%2Fafa45ca4.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;自动添加 Unreal 骨骼 Socket 的功能，我查了一下，发现第三方的 UnrealEnginePython 已经集成了这个功能。 github地址&emsp;&emsp;然而官方的插件在这方面还有很多限制。&emsp;&emsp;比如说官方的 Skeleton 类就根本没有相关的 Sockets 数组可以获取。 文档地址 &emsp;&emsp;刚好最近收到了一个需求，需要实现通过 Excel 配置的文档批量自动生成对应骨骼的 Socket 效果。&emsp;&emsp;为了实现这个需求，还是跳不过调用 C++ 的 API ，不过这一次的操作可以借鉴 UnrealEnginePython 插件的实现方法。 C++ 源码查询 &emsp;&emsp;这个操作套路还是之前的套路，先通过 UI 显示的名称然后反向去查询源码的路径。&emsp;&emsp;如果右键菜单的名称不好找，可以去找它的 Tooltip ， Tooltip 的名称比较长，比较唯一。 &emsp;&emsp;然后就可以通过 VScode 进行定位。 &emsp;&emsp;从这个 UI 命令中，可以找到 AddSocket 这个关键字命令。&emsp;&emsp;可以搜索一下这个命令，并且在 UI 命令的模块下可以找到相关联的脚本。 &emsp;&emsp;于是，按照我之前的经验。&emsp;&emsp;就可以想办法将这个类 FEditableSkeleton 引入的插件里面，然后就可以调用了。&emsp;&emsp;另外这个类是 F 开头的纯 C++ 类，因此这个类是无法作为蓝图的输入和输出类型的，只有继承自 UObject 的对象是可以暴露到 Python 里面。&emsp;&emsp;《大象无形》文档里面也有所提及。 &emsp;&emsp;同时这个 AddSocket 方法并不是静态方法，因此需要一些特殊的实例化操作，才可以使用。&emsp;&emsp;虚幻的实例化有好几种方法，不同的情况，用不同的方法，具体我也不清楚，但是作为工具人，这些源码功能肯定能在其他的源码里面找到答案。&emsp;&emsp;所以我就去搜索 FEditableSkeleton 这个类 &emsp;&emsp;首先排除了这个类本身的 cpp 文件和 头文件，剩下的使用参考已经非常清晰了。&emsp;&emsp;应该就是 SkeletonEditorModule.cpp 的实例化方案了。&emsp;&emsp;后面就是复制粘贴抄代码的事情。 解决无法编译的问题 &emsp;&emsp;然而经过我一通操作，将代码弄到我的蓝图里面之后，我却发现我居然无法通过编译。&emsp;&emsp;我测试了好多遍，都提示我这个调用方法有某些缺了头文件之类的，无法识别。&emsp;&emsp;我仔细核对了 build.cs 文件以及 C++ 引用的头文件，应该都没有什么缺失，于是我只好再尝试其他的方法。 &emsp;&emsp;可能是我这个构造函数的操作方法不对，但是我看了搜索到的构造方法基本都需要 CreateEditableSkeleton 这个方法。&emsp;&emsp;于是我进一步沿着这个思路去解决它。 &emsp;&emsp;于是我尝试用套这个构建方法，结果编译通过了~&emsp;&emsp;顺便到引擎测试一下是不是 Python 可以添加 Socket 了，然后可喜可贺，居然实现了。 123456789USkeletalMeshSocket* UPyToolkitBPLibrary::AddSkeletalMeshSocket(USkeleton* InSkeleton, FName InBoneName)&#123; USkeletalMeshSocket* socket = nullptr; ISkeletonEditorModule&amp; SkeletonEditorModule = FModuleManager::LoadModuleChecked&lt;ISkeletonEditorModule&gt;("SkeletonEditor"); TSharedRef&lt;IEditableSkeleton&gt; EditableSkeleton = SkeletonEditorModule.CreateEditableSkeleton(InSkeleton); socket = EditableSkeleton-&gt;AddSocket(InBoneName); return socket;&#125; 批量删除 Socket &emsp;&emsp;原本以为只要实现添加 Socket ，我的 Python 工具就万无一失了。&emsp;&emsp;但是考虑到如果使用者添加错了，删除 Socket 还要手动删除就很离谱。&emsp;&emsp;于是还得添加一个清空 Socket 的功能才行。 &emsp;&emsp;然后我想直接套用我上面实现的 EditableSkeleton 的方法。&emsp;&emsp;然后才发现，原来上面调用的并不是 FEditableSkeleton 而是 IEditableSkeleton&emsp;&emsp;这两个有啥区别呢？《大象无形》里面没有提到 I 开头的代表啥。&emsp;&emsp;于是网上查了一下 naming convention (还好绑定没有白学~) &emsp;&emsp;然后总算找到了官方文档给出的定义 链接&emsp;&emsp;I 开头属于 abstract interfaces 抽象接口。 &emsp;&emsp;然后相应地去找 IEditableSkeleton 所在的脚本，其实这个时候可以发现这些脚本都在 SkeletonEditor 这个模块下。&emsp;&emsp;而且 FEditableSkeleton 在 Private 目录，而 IEditableSkeleton 在 Public 目录。 &emsp;&emsp;然而另外颇为诧异的是，IEditableSkeleton 没有删除 Socket 的相关函数，但是 FEditableSkeleton 里面有 HandleDeleteSockets 的函数。&emsp;&emsp;但是如果直接调用 FEditableSkeleton 根本无法通过编译。 &emsp;&emsp;最后实在没办法了，查了 UnrealEnginePython 的插件也没有开窍，Unreal 的 C++ 学艺不精，只好找程序来支援一下。&emsp;&emsp;程序一看就说并不是所有的 API 可以暴露出来使用的，有些没有宏暴露的就不可以。&emsp;&emsp;于是我赶紧查了一下 C++ 的 API 文档，结果发现只能查到 IEditableSkeleton 这个类 链接&emsp;&emsp;SkeletonEditor 的 API 文档里面甚至没有提到 FEditableSkeleton(:з」∠) &emsp;&emsp;那现在该怎么办呢？&emsp;&emsp;程序说不慌，实在不行可以将 FEditableSkeleton 的功能代码抄到蓝图里面🤣 &emsp;&emsp;我在仔细看了一下 HandleDeleteSockets 的代码内容，我突然就开窍了。 &emsp;&emsp;这个 Sockets.Remove 是如此的熟悉，这不就和 UnrealEnginePython 的 Python 操作一个样吗？&emsp;&emsp;于是我赶紧试验了一下传 Skeleton 的操作，果然将对应的 Socket Remove 删除掉就可以了~ &emsp;&emsp;不过如果只是Remove操作无法在编辑器面板上更新数据，需要重开面板才能看到 Socket 的确被删除了。&emsp;&emsp;于是我结合上面的 IEditableSkeleton 进行更新就可以实现 Socket 删除的更新~ 1234567891011void UPyToolkitBPLibrary::DeleteSkeletalMeshSocket(USkeleton* InSkeleton, TArray&lt;USkeletalMeshSocket*&gt; SocketList)&#123; InSkeleton-&gt;Modify(); for (USkeletalMeshSocket* Socket : SocketList) &#123; InSkeleton-&gt;Sockets.Remove(Socket); &#125; ISkeletonEditorModule&amp; SkeletonEditorModule = FModuleManager::LoadModuleChecked&lt;ISkeletonEditorModule&gt;("SkeletonEditor"); TSharedRef&lt;IEditableSkeleton&gt; EditableSkeleton = SkeletonEditorModule.CreateEditableSkeleton(InSkeleton); EditableSkeleton-&gt;RefreshBoneTree();&#125; 获取骨骼名称 &emsp;&emsp;官方的 Python 可以获取到 Skeleton 的 bone_tree 信息。&emsp;&emsp;但是 BoneNode 就没有什么有价值的 API 可供调用了。&emsp;&emsp;查了一下 API 文档，原本是可以通过 BoneNode 获取骨骼名称，但是相关方法已经 Deprecated 了 &emsp;&emsp;于是我又参考了 UnrealEnginePython 插件。&emsp;&emsp;可以通过 USkeleton 获取骨骼的数量和骨骼的名称。 123456789int32 UPyToolkitBPLibrary::GetSkeletonBoneNum(USkeleton* InSkeleton)&#123; return InSkeleton-&gt;GetReferenceSkeleton().GetNum();&#125;FName UPyToolkitBPLibrary::GetSkeletonBoneName(USkeleton* InSkeleton,int32 BoneIndex)&#123; return InSkeleton-&gt;GetReferenceSkeleton().GetBoneName(BoneIndex);&#125; &emsp;&emsp;这样 Socket 的增删操作就完场了，改和查的操作可以通过 SkeletalMesh的 API 实现。 Python 结合 CSV 模块编写插件界面 &emsp;&emsp;后续需要开发一个 CSV 编辑界面，这样可以打通 Excel 文档同时又兼有 文件简单的特点。&emsp;&emsp;这次尝试使用 dayu_widgets 来实现效果。&emsp;&emsp;dayu_widgets 封装了一系列 MVC 框架相关的类。&emsp;&emsp;可以直接调用起来，具体可以参考 dayu_widgets 的 example 链接 &emsp;&emsp;相关功能已经集成到了 PyToolkit 仓库里面。 总结 &emsp;&emsp;这次重新整理了一波 C++ 扩展的开发思路，没有深入搞过 Unreal C++ ，总结就一个字 菜(:з」∠)&emsp;&emsp;只能说上面那些套路算是一种野生的解决方案，可以快速应付项目需求，但是真正要摸透还是得用 Unreal 开发几个 C++ 游戏才行~]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# winform 开发]]></title>
    <url>%2Fposts%2F9ef0c0d8.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;没想到吧，说实话自己也没想到，居然回去接触这玩意。&emsp;&emsp;Autohotkey 界面开发它不香吗，为啥还要搞个 winform 折腾自己。&emsp;&emsp;不过用了 C# 的 .net 框架之后，感觉运行库上还是要比 AHK 完善很多，界面开发也可以用 VS 来拉组件。&emsp;&emsp;AHK 虽然也有一些类似 Designer 的工具，显然没有 Layout 布局界面就很难受。 &emsp;&emsp;说实话接触这个一方面是自己有兴趣，另一方面刚好我之前的导师遗留了一个 winform 流程软件。&emsp;&emsp;需要继续开发进行维护，于是我就主动承担了进一步开发的职责，好好熟悉了一遍 C# 的界面开发方案。&emsp;&emsp;看完我导师写的 winform 的软件，感觉图形界面开发都是差不多。&emsp;&emsp;大部分的逻辑处理其实都和 Qt 开发类似，可能这就是所谓的英雄所见略同吧。 &emsp;&emsp;C# 开发还有 WPF ， 我还没有深入接触过，听说是基于 XAML 开发界面的。&emsp;&emsp;听说那个是类似于 Vue 那种 MVVM 的设计模式了，有 DOM 结构的存在处理组件有一定的优势呀~&emsp;&emsp;以后有机会也抽时间研究一下。 winform 开发 &emsp;&emsp;我当时也是在 B站上看了个简单的教程入门，用 4倍速过了一下基础，我大概看到 15、16 集左右就懂了。 链接&emsp;&emsp;其实 winform 也和 QtDesigner 差不多，可以通过工具箱拖拽 windows API 配置的组件。&emsp;&emsp;然后搭建组件也是图形化编程，后面的业务逻辑再单独进行配置即可。 &emsp;&emsp;winform 没有信号槽的概念，双击组件会自动创建触发函数，直接写业务就可以了。&emsp;&emsp;后面 winform 的基本上就是使用 内部的 库可以实现 windows 下的软件开发。&emsp;&emsp;可以制作出一些流程工具。 &emsp;&emsp;我导师写的工具是检测 资源目录的文件是否和引擎目录下的文件匹配&emsp;&emsp;如果不匹配则通过 列表 提示出来，并且可以将美术制作用的资源目录自动合入。&emsp;&emsp;不过现在美术有了新的需求，一方面是有些资源需要在引擎上查看修改结果，反而想要实现反向合入的操作。&emsp;&emsp;另一方面，还想添加一些新的规则文件夹进行自动识别。 &emsp;&emsp;于是我就开始了，相关的研究。&emsp;&emsp;其实修改需求并不难，我让美术给了一个测试的目录给我进行软件测试。&emsp;&emsp;反向合入其实就加一个判断，然后让之前 copy 的路径翻转即可。&emsp;&emsp;新的文件夹规则也可以查查源码可以找到一个 C# 的文件夹列表。&emsp;&emsp;c# 的字符串也有类似 Python 的 r&quot;&quot; 不转义字符串，写法是 @&quot;&quot; &emsp;&emsp;在开发的过程中，我还发现了之前软件匹配文件是否相同的时候的 BUG。&emsp;&emsp;文件是否相同居然用文件大小的 length 进行判断，这样很明显是不准的。&emsp;&emsp;一些贴图经过了修改还是显示相等，因为像素的数量没有变化，只是颜色数据改变了，所以大小是一样的。&emsp;&emsp;于是我又将这个匹配的方式改为 md5 的方式。&emsp;&emsp;最后就是匹配方法有很大的问题，用了双 for 循环。&emsp;&emsp;其实一个 for 循环就可以了，毕竟要转移的路径是可以推断出来的，不需要再获取一遍引擎路径下全部文件进行匹配。 总结 &emsp;&emsp;winform 的最大优点就是直接调用 windows 的 API 所以大小很小，打包的 exe 通常不到 1 M&emsp;&emsp;优势也带来了一部分劣势，那就是无法跨平台，不过工作环境中基本上只会用到 windows 平台，其实这个也不算太大的问题。]]></content>
      <categories>
        <category>CG</category>
        <category>C#</category>
        <category>winform</category>
      </categories>
      <tags>
        <tag>࠴编程/CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt.py 代码补全修复]]></title>
    <url>%2Fposts%2Fdf750dd1.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;之前编写 Qt Designer 使用全攻略的时候，遇到 Qt.py 怎么配置自动提示的方案&emsp;&emsp;关于这个的配置，我去年写的文章，当时还是宣称无解，其实不然，目前已经找到两个解决方案。 TabNine Qt.py-stubs TabNine 全语言补全插件 &emsp;&emsp;这个插件我是在 youtube 上看到他们家的广告认识的。&emsp;&emsp;开启了插件之后虽然没有达到官方宣传的那么好用，但是因为是全语言，而且是人工智能自动补全。&emsp;&emsp;很多时候都可以自动识别到我想要的包，就是有时候我大小写不准确，补全的时候也会自动补全错误的大小写。 Qt.py-stubsQt.py-stubs &emsp;&emsp;这个仓库是我在 github 上找到的。&emsp;&emsp;需要配置一下 VScode python setting 的 autocomplete 路径 123"python.autoComplete.extraPaths": [ "G:\\PythonIntellisense",], &emsp;&emsp;配置好了路径之后，将 仓库的 Qt 文件夹放到配置的路径下。&emsp;&emsp;然后输入等 VScode 的 Python Language Server 预热完毕即可。&emsp;&emsp;基本的提示都很完善了。 总结 &emsp;&emsp;TabNine 我很久就开始用了，自动补全还挺好的。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠆQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt Designer 使用全攻略]]></title>
    <url>%2Fposts%2Fbea01990.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;本来是最近用了一些 Qt Designer 一些之前没用过的特性，觉得特别有用，打算写篇小文章总结一下就算了。&emsp;&emsp;可是想着想着就全面铺开了，之前写 Python Qt 开发系列教程的时候也涉猎到 Qt Designer。&emsp;&emsp;但是 Qt Designer 写得比较基础，总结得不系统😒&emsp;&emsp;这次打算统一将 Qt Designer 黑科技全部挖掘出来😁&emsp;&emsp;这篇文章的前面部分将会介绍 Qt Designer 基础使用方法，搭配 gif 动图配合进行说明&emsp;&emsp;后半部分会介绍一些比较少用的特性，和自己的使用经验汇总，还会介绍以下的独门内容😎 VScode 对接 Qt Designer Qt.py 动态加载 ui 文件 自定义 Property 手动修改 ui 文件 - 实现特殊父类 组件提升 什么是 Qt Designer &emsp;&emsp;没有在网上找到百度百科之类的词条说明这个工具。&emsp;&emsp;不过大概的意思也可以参照我之前写的系列教程的其中一篇 链接 &emsp;&emsp;基本上我自己概括起来就是，开发界面不需要代码了。&emsp;&emsp;实现 View 的自由搭配，通过可视化搭建好图形界面之后，只需要关注业务处理的代码即可。&emsp;&emsp;这就是使用 Qt Designer 的优势，界面代码自动生成，如果使用 Qt.py 流程设置不需要生成 Python 代码。 Qt Designer 基础入门介绍 &emsp;&emsp;Qt Designer 的使用相当简单，基本上就是所见即所得。&emsp;&emsp;基础的玩法网上也有很多不错的文章总结 官网手册 官网说明 PyQT5速成教程-2 Qt Designer介绍与入门 使用Qt Designer来设计界面 &emsp;&emsp;软件默认打开如上图，可以随便选择一个组件启动 Designer&emsp;&emsp;我这里选择 QWidget ，平时一般开发也是用 QWidget 比较多。 &emsp;&emsp;界面分类如上图所示， &emsp;&emsp;Qt Designer 的使用方法其实不难，基本上从左侧的组件库里面拖拽组件，然后放到窗口里面。 &emsp;&emsp;然后可以像控制窗口一样可以用左键拖拽可以缩放组件。&emsp;&emsp;最基础的使用就是如此，懂了这些操作完全就可以自己拖拽组件搭配出想要的界面了。 布局 &emsp;&emsp;当然上面的搭配方法会如果遇到界面的窗口缩放的话，就出问题了。&emsp;&emsp;要让组件自动适应窗口的变化，就需要 Layout 去配合。 &emsp;&emsp;上面就是设置 VBoxLayout 的竖向布局来布局页面。&emsp;&emsp;当然 Qt 提供的布局还有 横向布局、网格布局、表单布局。 &emsp;&emsp;其实用起来都非常好理解，可以通过工具栏将切换上述的布局。 属性编辑器编辑属性 &emsp;&emsp;右侧的属性编辑器可以定义组件很多东西。&emsp;&emsp;包括组件的状态，以及一些组件特有的属性。 &emsp;&emsp;这个具体的组件属性可以参照 Qt 的文档，然后使用上方的搜索查找对应的属性。 设置 stylesheet &emsp;&emsp;Qt 同样提供了类似于 Web 的样式表用来快速定义组件的显示效果。&emsp;&emsp;可以在属性编辑器的 StyleSheet 里面进行自定义。 &emsp;&emsp;关于样式表配置可以参照网上文章以及官网 官网 Qt Style Sheets Reference 官网 Qt Style Sheets Examples Qt常用QSS集合 QSS总结以及最近做的Qt项目 &emsp;&emsp;QSS 背后其实 Qt 的 Paint 事件，通过样式表来简化手动绘制的操作。&emsp;&emsp;如果想要实现一些自定义的图形绘制， 需要代码通过 Qt 的 PaintEvent 实现。 信号槽连接 &emsp;&emsp;Qt Designer 可以设置组件的信号槽连接。 &emsp;&emsp;Qt 的信号槽可以实现一些 Qt 组件的事件回调，比如点击按钮的触发，数据变动触发等等。&emsp;&emsp;通常过去都是用代码连接信号槽。 链接参考 保存 ui 文件 &emsp;&emsp;ui 文件实质上是一个 xml 文件。&emsp;&emsp;定义规范可以参考官方的 XML scheme 文档 链接 &emsp;&emsp;上面的演示文件存储下来如下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ui version="4.0"&gt; &lt;class&gt;Form&lt;/class&gt; &lt;widget class="QWidget" name="Form"&gt; &lt;property name="geometry"&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;329&lt;/width&gt; &lt;height&gt;224&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name="windowTitle"&gt; &lt;string&gt;Form&lt;/string&gt; &lt;/property&gt; &lt;layout class="QVBoxLayout" name="verticalLayout_2"&gt; &lt;item&gt; &lt;layout class="QVBoxLayout" name="verticalLayout"&gt; &lt;item&gt; &lt;widget class="QListView" name="listView"/&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class="QPushButton" name="pushButton_2"&gt; &lt;property name="enabled"&gt; &lt;bool&gt;false&lt;/bool&gt; &lt;/property&gt; &lt;property name="text"&gt; &lt;string&gt;PushButton&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class="QPushButton" name="pushButton"&gt; &lt;property name="styleSheet"&gt; &lt;string notr="true"&gt;background:rgb(170, 0, 0)&lt;/string&gt; &lt;/property&gt; &lt;property name="text"&gt; &lt;string&gt;test BUtton&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class="QRadioButton" name="radioButton"&gt; &lt;property name="text"&gt; &lt;string&gt;RadioButton&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;item&gt; &lt;widget class="QCheckBox" name="checkBox"&gt; &lt;property name="text"&gt; &lt;string&gt;CheckBox&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/item&gt; &lt;/layout&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections&gt; &lt;connection&gt; &lt;sender&gt;pushButton&lt;/sender&gt; &lt;signal&gt;clicked()&lt;/signal&gt; &lt;receiver&gt;checkBox&lt;/receiver&gt; &lt;slot&gt;toggle()&lt;/slot&gt; &lt;hints&gt; &lt;hint type="sourcelabel"&gt; &lt;x&gt;90&lt;/x&gt; &lt;y&gt;214&lt;/y&gt; &lt;/hint&gt; &lt;hint type="destinationlabel"&gt; &lt;x&gt;71&lt;/x&gt; &lt;y&gt;265&lt;/y&gt; &lt;/hint&gt; &lt;/hints&gt; &lt;/connection&gt; &lt;/connections&gt;&lt;/ui&gt; Qt Designer 功能小技巧qrc 资源 &emsp;&emsp;设置资源路径，可以加载外部的图片资源。&emsp;&emsp;在这个过程会通过 Qt Designer 创建了一个 qrc 文件。&emsp;&emsp;这个 qrc 文件也是一个 xml ，用来描述索引的图片资源的位置。&emsp;&emsp;要使用 Qt 的 qrc 资源文件需要将资源编译为 Python 代码。&emsp;&emsp;这个过程会自动将图片资源转换为 Python 的字符信息。 &emsp;&emsp;编译 qrc 文件需要用 pyside2-rcc.exe pyrcc5.exe 执行程序进行转换&emsp;&emsp;maya2019 及以上的版本会总算是集成了 pyside2-rcc.exe 可以直接使用 123456789101112131415C:\Program Files\Autodesk\Maya2019\bin&gt;pyside2-rcc.exe -hPySide2 resource compilerUsage: pyside2-rcc.exe [options] &lt;inputs&gt;Options: -o file Write output to file rather than stdout -py2 Generate code for any Python v2.x version -py3 Generate code for any Python v3.x version (default) -name name Create an external initialization function with name -threshold level Threshold to consider compressing files -compress level Compress input files by level -root path Prefix resource access path with root path -no-compress Disable all compression -version Display version -help Display this information 1pyside2-rcc test.qrc -o test_qrc.py &emsp;&emsp;感觉说明执行命令即可将 qrc 文件转换为 python 代码，调用直接 import 即可。&emsp;&emsp;使用 qrc 的 python 代码可以将资源注册到 QApplication 里面。&emsp;&emsp;不需要再读取资源数据，所有的组件都可以访问这些资源。 Spacer 妙用 &emsp;&emsp;Spacer 组件让 UI 更加紧凑。&emsp;&emsp;在缩放窗口的时候可以让 UI 直接没有间隙，观感好很多。 Layout 转组件 &emsp;&emsp;Layout 布局不属于 Widget 组件，无法设置样式。&emsp;&emsp;这个时候可以将 Layout 转成 QWidet 之类的组件实现进一步的操作。 Ctrl 复制组件 &emsp;&emsp;按住 Ctrl 键可以复制组件，有时候复杂布局也可以一并复制。 select ancestor 方便选择父级 &emsp;&emsp;组件比较复杂的情况，选择会父组件会比较不方便，只能通过组件间的间隙进行选择。&emsp;&emsp;可以在右侧的大纲中选择，或者使用 select ancestor 命令 鼠标中间方便框选 &emsp;&emsp;本来用鼠标左键在空白区域拖拽，可以框选大量组件。&emsp;&emsp;但是组件比较多的话，没有空白区域，则可以用鼠标中键触发框选。 ctrl + R 开启窗口预览 &emsp;&emsp;Ctrl + R 快捷键可以快速打开一个运行状态的预览窗口。&emsp;&emsp;这个操作在上面的信号槽中已经有所演示。 Tab order 编辑 &emsp;&emsp;很少有用到。&emsp;&emsp;使用场景是输入框很多的时候，可以定义 Tab 键跳转到的组件 Edit Buddies 编辑功能 &emsp;&emsp;设置聚焦功能 ，我从来没有用过。&emsp;&emsp;用来通过 QLabel 的快捷键快速触发 QLineEdit 的聚焦。 官方链接 QT Edit Buddies的理解 ui 文件 Python 调用方法pyside2-uic 编译 &emsp;&emsp;关于如何使用 pyside2-uic 编译 ui 文件，我之前的系列文章有保姆级的演示 链接&emsp;&emsp;所以这里就不在赘述，我着重介绍新的方案，目前我开发主要用的是下面的方案了😎 Qt.py 动态加载 ui 文件 &emsp;&emsp;关于 Qt.py 我之前的教程系列里面有所提及👏 链接 1from Qt import QtWidgets,QtGui,QtCore &emsp;&emsp;最大的特点就是将 PyQt4 和 PySide 的代码做了兼容 PyQt5 和 PySide2&emsp;&emsp;全部用 Qt5 来写，自动兼容，缺点就是会丢失编辑器的代码提示。&emsp;&emsp;丢失代码提示也是有解决方案，我后面补上一起文章进行说明 链接 &emsp;&emsp;除了上面的用法之外， Qt.py 还有一些藏得比较深的功能，官方的 readme 文档居然不写出来。🤷‍♂️&emsp;&emsp;我最初是通过 dir 找到这个东西的，貌似不是 Qt 官方的类，于是顺藤摸瓜。&emsp;&emsp;发现 Qt.py 将一些特殊的兼容组件整合到这个类里面去了，其中就包括兼容不同 Qt 模块的动态 loadUi 方法。 1from Qt.QtCompat import loadUi &emsp;&emsp;其实再到 Qt.py 的仓库上摸索一下，会发现有使用案例的 链接&emsp;&emsp;loadUi 的使用非常简单，可以参照官方提供的案例&emsp;&emsp;基本上就是在 类里面 调用 loadUi ， 传入 ui路径 和 self 即可。 1234567891011121314import osfrom Qt import QtWidgets,QtGui,QtCorefrom Qt.QtCompat import loadUiclass TestWidget(QtWidgets.QWidget): def __init__(self): super().__init__() DIR = os.path.dirname(__file__) ui_path = os.path.join(DIR,"test.ui") # NOTE 加载 ui 文件 loadUi(ui_path,self) # NOTE 执行了 loadUi 之后可以通过 ObjectName 获取到 ui 文件里面的定义的组件了 self.Test_BTN.clicked.connect(lambda: sys.stdout.write("click")) &emsp;&emsp;上面就是简单的使用代码场景&emsp;&emsp;这种写法的好处就是不需要手动执行编译命令生成 py 文件&emsp;&emsp;ui文件保存， python 重开一下窗口即可看到 Qt Designer 中的更新，使用更加方便了。 VScode 对接 Qt Designer &emsp;&emsp;VScode 有一个非常好用的插件，可以自己配置 Qt 工具的路径😊 &emsp;&emsp;配置好这些，打开 ui 文件可以直接通过 VScode 打开设置好的 Qt Designer&emsp;&emsp;也可以自动 compile 出代码 &emsp;&emsp;我设置的 pyuic 没有设置代码输出的路径，所以我这里编译显示的代码是在 VScode 里面的。&emsp;&emsp;我一般不用 compile ，但是有时候需要手动配置组件代码的时候，也可以快速通过 ui 文件编译查一下代码怎么写，还挺方便的。&emsp;&emsp;另外 VScode 命令行输入 edit 也可以自动启动 Qt Designer 并打开当前在 VScode 打开的 ui 文件，这个也非常方便。😏 Qt Designer 鲜为人知的黑科技 &emsp;&emsp;最后我们来说讲解最刺激的黑科技部分😀 自定义 property &emsp;&emsp;属性编辑器可以配置自定义属性到组件里面。 &emsp;&emsp;比较常用的就是 字符串 和 布尔类型。&emsp;&emsp;点击其他还能看到更多 C++ 相关的类型，一般情况下也用不上。 挂载配置文件 &emsp;&emsp;基于字符串可以挂载的原理，我可以弄一套 json 配置到组件里面。&emsp;&emsp;然后再 Python 固定读取这个属性解析 json 配置，就甚至可以实现在 Qt Designer 配置组件的基础行为。&emsp;&emsp;组件功能可以更为灵活，不过也不建议配置过于复杂，建议业务逻辑还是写到代码里合适。 &emsp;&emsp;后续 Python 读取这个属性如下 12345&#123; "method" : &#123; "setText":"输出名称" &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637import osimport jsonfrom collections import OrderedDictfrom Qt import QtWidgets,QtGui,QtCorefrom Qt.QtCompat import loadUidef ui_PyInit(widget): """ 递归遍历所有的 Widget 组件 """ if not hasattr(widget,"children"): return # NOTE 初始化 PyInit 中配置的方法 data = widget.property("PyInit") if data: try: data = json.loads(data,object_pairs_hook=OrderedDict) for method,param in data['method'].items(): param = param if isinstance(param,list) else [param] getattr(widget,method)(*param) except: pass for child in widget.children(): ui_PyInit(child)class TestWidget(QtWidgets.QWidget): def __init__(self): super().__init__() DIR = os.path.dirname(__file__) ui_path = os.path.join(DIR,"test.ui") # NOTE 加载 ui 文件 loadUi(ui_path,self) # NOTE 初始化配置方法 ui_PyInit(self) 手动修改 ui 文件 &emsp;&emsp;ui 文件本质上就是 XML&emsp;&emsp;可以通过手动修改 XML 实现一些 Qt Designer 本身无法设置的操作。 将 QWidget 修改为特定组件 &emsp;&emsp;Qt Designer 无法创建一个纯按钮之类的 ui 文件&emsp;&emsp;默认的 ui 文件必须是个容器。 &emsp;&emsp;但是我就是有个需求要弄一个纯 按钮 的 ui 文件，应该要怎么实现。&emsp;&emsp;可以通过修改 xml 类来实现。 &emsp;&emsp;首先默认创建一个 QWidget 的 ui 文件。 &emsp;&emsp;然后将 ui 文件的 QWidget 修改为 QPushButton 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ui version="4.0"&gt; &lt;class&gt;Form&lt;/class&gt; &lt;widget class="QPushButton" name="Form"&gt; &lt;property name="geometry"&gt; &lt;rect&gt; &lt;x&gt;0&lt;/x&gt; &lt;y&gt;0&lt;/y&gt; &lt;width&gt;395&lt;/width&gt; &lt;height&gt;149&lt;/height&gt; &lt;/rect&gt; &lt;/property&gt; &lt;property name="windowTitle"&gt; &lt;string&gt;Form&lt;/string&gt; &lt;/property&gt; &lt;/widget&gt; &lt;resources/&gt; &lt;connections/&gt;&lt;/ui&gt; &emsp;&emsp;重新用 QtDesigner 打开这个文件。&emsp;&emsp;你会发现 Qt Designer 里面呈现的是一个按钮而不是 QWidget 了。 给 QWidget 添加 MenuBar &emsp;&emsp;基于上面的脑洞，也可以实现给 QWidget 添加 QMenuBar 的骚操作。&emsp;&emsp;默认情况下，只有 QMainWindow 可以在 Qt Designer 里面配置 QMenuBar 实现下来菜单。&emsp;&emsp;由于左侧的组件列表没有 QMenuBar 组件，所以根本就无法添加到 QWidget 里面。 &emsp;&emsp;通过编辑 ui 文件，然后用上面的方法将两个 ui 文件拼接到一起，就可以实现这种骚操作。&emsp;&emsp;这样就不需要手动写 QMenuBar 相关的代码了。 组件提升 &emsp;&emsp;默认情况下， Qt Designer 只能拖拽一些基础组件，如果我们想要套用自定义的组件，似乎就无法实现了。&emsp;&emsp;其实不然，通过 promote 提升，可以实现将组件提升为 第三方 类。&emsp;&emsp;当然，组件提升无法在 Qt Designer 直接预览到效果，只能看到基类的 UI。&emsp;&emsp;如果要想实现在 Qt Designer 直接看到效果，也可以用 C++ 开发 Qt Designer 的插件，直接扩展出自定义组件。(这个操作我也不会😂) &emsp;&emsp;基础的提升操作如下 &emsp;&emsp;看起来似乎也是针对 C++ 才有效。&emsp;&emsp;其实不然。 &emsp;&emsp;先添加一个配置头文件的配置&emsp;&emsp;然后再点击 Promote 来提升组件，这个操作的确有点反人类设计😓 &emsp;&emsp;下面编译这个 ui 文件可以看到神奇的 promote 效果 123456789101112131415161718from PySide2 import QtCore, QtGui, QtWidgetsclass Ui_Form(object): def setupUi(self, Form): Form.setObjectName("Form") Form.resize(400, 300) self.pushButton = MPushButton(Form) self.pushButton.setGeometry(QtCore.QRect(60, 60, 75, 23)) self.pushButton.setObjectName("pushButton") self.retranslateUi(Form) QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): Form.setWindowTitle(QtWidgets.QApplication.translate("Form", "Form", None, -1)) self.pushButton.setText(QtWidgets.QApplication.translate("Form", "PushButton", None, -1))from dayu_widgets.push_button import MPushButton &emsp;&emsp;是的，头文件自动转为 Python 的库， 类名就对应库里面的类。&emsp;&emsp;只要自定义的组件类按照默认的 构造函数传参， 就不存在什么问题。 &emsp;&emsp;这个东西其实也可以直接用 ui 文件加载的方式调用起来， 我也是最近看了 tk库 学到的新知识&emsp;&emsp;可以参考 tk_switchboard.py 代码&emsp;&emsp;这里用到了 QUiLoader registerCustomWidget 的使用方法&emsp;&emsp;通过这个方法可以将自定义的组件注册到 QUiLoader 里面，然后 QUiLoader 读取 ui 文件的时候自动映射到第三方组件上。 &emsp;&emsp;这个是 PySide2 的实现方案，其实 Qt.py 早已经在考虑到这个问题。&emsp;&emsp;参考 Qt.py 的 loadUi 源码可以发现它通过 Python 读取 xml 里面的头文件然后通过 importlib.import_module 导入模块 源码链接&emsp;&emsp;所以用 Qt.py 的 loadUi 更加简单，还兼容 PyQt&emsp;&emsp;当然缺点就 Qt.py 没有暴露自定义模块的传参，只能确保导入模块在 sys.path 里面。 例子: dayu_widget &emsp;&emsp;这个 dayu_widget 第三方库通过 Qt Designer 直接嵌入的效果可以参考我的 PyToolkit文章 总结 &emsp;&emsp;花了大半天的功夫，总算是全面地将 Qt Designer 神兵利器介绍完毕了。&emsp;&emsp;基本上已经将 Qt Designer 的各种玩法透彻剖析了，欢迎大家留言交流意见。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠆQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal PyToolkit 插件]]></title>
    <url>%2Fposts%2F513f9ff.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;仓库已经提前搭建好了。 😁github地址😁&emsp;&emsp;最近一直在忙，没有把文章总结整理好。 &emsp;&emsp;这个是基于 C++ 蓝图开发的 Python 插件&emsp;&emsp;有一部分功能通过 C++ API 开发蓝图从而暴露到蓝图里面。&emsp;&emsp;进而可以实现 Python 调用 C++ API 操作 Unreal 底层。 &emsp;&emsp;使用官方 Python 插件扩展蓝图比起第三方 UnrealEnginePython 要更加方便。&emsp;&emsp;虽然现在官方的插件还不是很成熟，但是通过蓝图直接暴露 C++ API 的思路的确更加简单。&emsp;&emsp;UnrealEnginePython 里面写扩展还需要处理 Python 的 C++ 部分，对于纯 Unreal C++ 开发来说的确不太灵活。&emsp;&emsp;也难怪官方居然抛弃了相当成熟的第三方 Python 插件。 C++ 蓝图编写 &emsp;&emsp;其实蓝图编写我也是参照youtube 上的 unreal Python 教程学习的 youtube地址 B站地址 github地址&emsp;&emsp;我之前编写 FBX 动画导入对比面板的时候也有所提到 链接&emsp;&emsp;还有最近写的一篇文章也有比较详细的描述 Unreal Python 结合 C++ 开发蓝图库插件 &emsp;&emsp;看完教程，特别的需求就需要查论坛、查文档和查 Unreal 的 C++ 源码。&emsp;&emsp;在文档方面， Unreal 这的特别不行 😒&emsp;&emsp;不说 C++ 文档各种案例都没有，描述都是参数类型和极其简单的描述。&emsp;&emsp;文档的搜索还经常搜不到 API 信息， Python 的文档都比 C++ 强多了 🤷‍ &emsp;&emsp;一般首选查官方的 问答区 和 论坛&emsp;&emsp;关键字用 C++ 或者 blueprint 开头，然后加上具体需求的英文关键字。&emsp;&emsp;但是不要抱太好的期望，虚幻的社区也是不太活跃，有些问题有人问了，也没人回 🤦‍♂️ &emsp;&emsp;如果上述的方法没有收获，就只能采用比较麻烦的方案了。&emsp;&emsp;用 VScode 查引擎的 C++ 源码 。&emsp;&emsp;VScode 可以直接搜索到文件内容，但是如果匹配很多文件的话就只能一个一个找有用的信息。&emsp;&emsp;通常这种操作都比较麻烦，因为并不是所有的 API 函数都可以暴露到蓝图里面。&emsp;&emsp;有些没有 Unreal 宏设置的内部函数蓝图调用会无法编译通过，后来找来程序帮忙才知道这个原因，我还是太菜了😥&emsp;&emsp;并没有系统的学习 C++ ，Unreal 的 C++ 编程也还没深入看教程学习，最近一直围绕着 Python 开发解决问题😓&emsp;&emsp;倒是有查过 大象无形 工具书，但是很多要实现的需求里头并没有，以后找时间要系统地学习一下 大象无形 工具书。 Python Startup 脚本调用 &emsp;&emsp;虽然我 C++ 开发很一般，但是抄代码的能力总归还是有的。&emsp;&emsp;我想要实现 C++ 插件自动执行 Content 目录下的 initialize.py 脚本的效果。&emsp;&emsp;官方的 Python 插件提供了 Startup 脚本的方案。&emsp;&emsp;但是配置到官方的插件里并不好，配置拆散不是个事情。 &emsp;&emsp;于是我就参照 官方的 Python 插件实现自动加载 initialize.py 的效果。&emsp;&emsp;其实参照了源码真的不复杂。 &emsp;&emsp;就是插件启动的时候调用 Unreal 的 Ticker ，触发一次 Tick 之后就停止函数的执行而已。&emsp;&emsp;这样确保界面启动了之后再去执行相关的 Python 脚本，不容易导致错误。 1234567891011121314151617181920212223242526272829303132333435363738// Copyright Epic Games, Inc. All Rights Reserved.#include "PyToolkit.h"#define LOCTEXT_NAMESPACE "FPyToolkitModule"void FPyToolkitModule::StartupModule()&#123; // This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module // Initialize the tick handler TickHandle = FTicker::GetCoreTicker().AddTicker(FTickerDelegate::CreateLambda([this](float DeltaTime) &#123; Tick(DeltaTime); return true; &#125;));&#125;void FPyToolkitModule::ShutdownModule()&#123; // This function may be called during shutdown to clean up your module. For modules that support dynamic reloading, // we call this function before unloading the module.&#125;void FPyToolkitModule::Tick(const float InDeltaTime) &#123; // 参考 Python 官方插件 | 引擎初始化完成之后 通过 tick 来初始化 initialize.py 脚本 if (!bHasTicked) &#123; bHasTicked = true; FString InitScript = TEXT("py \"") + FPaths::ProjectPluginsDir() / TEXT("PyToolkit/Content/initialize.py") + TEXT("\""); GEngine-&gt;Exec(NULL, InitScript.GetCharArray().GetData()); &#125;&#125;#undef LOCTEXT_NAMESPACEIMPLEMENT_MODULE(FPyToolkitModule, PyToolkit) &emsp;&emsp;如果不用 Tick 来触发而是直接用 GEngine-&gt;Exec 在插件的构造函数执行 Python 代码会直接报错的。 Python 环境配置和初始化 &emsp;&emsp;Content 目录下的 Python 目录默认会添加到 Python sys.path 里面&emsp;&emsp;Python 目录里面添加的依赖库如下: PySide FBX Python SDK dayu_widgets dayu_path singledispatch Qt.py &emsp;&emsp;上面是我在 Python 目录下添加的脚本库 initialize.py 脚本初始化 &emsp;&emsp;这个部分的代码也在 FBX 动画导入对比面板的文章里面有所提及。&emsp;&emsp;不过需要注意的是当时提到的 __QtAppTick__ 回调函数里面，其实不需要不断执行 QtWidgets.QApplication.processEvent&emsp;&emsp;加上表面上也不会对虚幻有什么实质的影响。&emsp;&emsp;不过这边的程序用了第三方的 imgui 来写虚幻的 UI&emsp;&emsp;结果发现如果加上这行 Qt 代码会导致 imgui 的 gui 组件无法聚焦 🤦‍♂️&emsp;&emsp;输入组件的焦点会被抢走。&emsp;&emsp;后面我注释掉那一句也没有对 Qt 的界面产生影响~ json 配置 Unreal 菜单 &emsp;&emsp;Unreal 官方论坛的解决方案&emsp;&emsp;在官方论坛可以查到关于 Python 生成菜单的方案。&emsp;&emsp;大佬贴心的贴出了可运行的代码，我的代码也是在这个基础上优化成 json 配置菜单的效果。 section - 配置分组 menu section - 设置分组 label - 配置显示名称 type - 配置 command 执行的类型 可以填写 python 和 command command - 根据 type 配置执行相应的命令 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "section":&#123; "Model":"建模", "Anim":"动画", "FX":"特效", "Render":"渲染", "Help":"帮助" &#125;, "menu":&#123; "Model_Tool" : &#123; "section": "Model", "label": "演示:模型处理工具(打印到屏幕)", "type": "PYTHON", "command": "unreal.SystemLibrary.print_string(None,'模型处理工具',text_color=[255,255,255,255])" &#125;, "Anim_Tool" : &#123; "section": "Anim", "label": "动画导入比较面板", "type": "COMMAND", "command": "py \"&#123;Content&#125;/Anim/FBXImporter/main.py\"" &#125;, "FX_Tool" : &#123; "section": "FX", "label": "Sequencer 导出选择元素动画为骨骼蒙皮", "type": "COMMAND", "command": "py \"&#123;Content&#125;/FX/sequencer_export_fbx.py\"" &#125;, "SequencerFBX" : &#123; "section": "Render", "label": "批量渲染 Sequencer 工具", "type": "COMMAND", "command": "py \"&#123;Content&#125;/Anim/sequencer_batch_render/render_tool.py\"" &#125;, "Document" : &#123; "section": "Help", "label": "帮助文档", "type": "PYTHON", "command": "import webbrowser;webbrowser.open_new_tab('https://github.com/FXTD-ODYSSEY/Unreal-PyToolkit')" &#125; &#125;&#125; &emsp;&emsp;这个是 json 配置部分，自动生成对应分组脚本的脚本。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556type_map = &#123; "command": unreal.ToolMenuStringCommandType.COMMAND, "python": unreal.ToolMenuStringCommandType.PYTHON&#125;def read_menu_json(path): with open(path, 'r') as f: data = json.load(f, object_pairs_hook=OrderedDict, encoding='utf-8') menu_section_dict = data['section'] menu_entry_dict = data['menu'] for menu, data in menu_entry_dict.items(): data['type'] = type_map[data['type'].lower()] data['command'] = data['command'].format(Content=DIR) return menu_section_dict, menu_entry_dictdef create_menu(): # NOTE 读取 menu json 配置 menu_section_dict, menu_entry_dict = read_menu_json("%s/menu.json" % DIR) # NOTE https://forums.unrealengine.com/development-discussion/python-scripting/1767113-making-menus-in-py menus = unreal.ToolMenus.get() # NOTE 获取主界面的主菜单位置 main_menu = menus.find_menu("LevelEditor.MainMenu") if not main_menu: raise RuntimeError( "Failed to find the 'Main' menu. Something is wrong in the force!") # NOTE 添加一个下拉菜单 script_menu = main_menu.add_sub_menu( main_menu.get_name(), "PythonTools", "Tools", "PyToolkit") # NOTE 初始化下拉菜单的 Section 分组 for section, label in menu_section_dict.items(): script_menu.add_section(section, label) # NOTE 根据 json 来配置菜单显示的 Entry for menu, data in menu_entry_dict.items(): entry = unreal.ToolMenuEntry( name=menu, type=unreal.MultiBlockType.MENU_ENTRY, insert_position=unreal.ToolMenuInsert( "", unreal.ToolMenuInsertType.FIRST) ) entry.set_label(data.get('label', "untitle")) command = data.get('command', '') entry.set_string_command(data.get("type", 0), "", string=command) script_menu.add_menu_entry(data.get('section', ''), entry) # NOTE 刷新组件 menus.refresh_all_widgets() c++ 蓝图实现 RenderTargetCube 渲染出 TextureCube &emsp;&emsp;C++ 蓝图实现的功能在上次的 C++ 开发蓝图插件的总结里面有所提及 链接&emsp;&emsp;这里刚好遇到了一个 Python API 没有的需求，于是就再补充讲一讲。&emsp;&emsp;官方 API 提供了 RenderTarget 输出 Texture2D 的方法 链接 &emsp;&emsp;但是并没有提供 RenderTargetCube 输出 TextureCube 的方法&emsp;&emsp;但是既然后有 RenderTarget 的操作方法，其实就是输出 RenderTargetCube 基本没有太大区别。&emsp;&emsp;我这里的 C++ 代码就是抄引擎的源码然后稍微修改一下出来的。😜 1234567891011121314151617181920212223242526272829303132333435363738UTextureCube* UPyToolkitBPLibrary::RenderTargetCubeCreateStaticTextureCube(UTextureRenderTargetCube* RenderTarget, FString InName)&#123; FString Name; FString PackageName; IAssetTools&amp; AssetTools = FModuleManager::Get().LoadModuleChecked&lt;FAssetToolsModule&gt;("AssetTools").Get(); //Use asset name only if directories are specified, otherwise full path if (!InName.Contains(TEXT("/"))) &#123; FString AssetName = RenderTarget-&gt;GetOutermost()-&gt;GetName(); const FString SanitizedBasePackageName = UPackageTools::SanitizePackageName(AssetName); const FString PackagePath = FPackageName::GetLongPackagePath(SanitizedBasePackageName) + TEXT("/"); AssetTools.CreateUniqueAssetName(PackagePath, InName, PackageName, Name); &#125; else &#123; InName.RemoveFromStart(TEXT("/")); InName.RemoveFromStart(TEXT("Content/")); InName.StartsWith(TEXT("Game/")) == true ? InName.InsertAt(0, TEXT("/")) : InName.InsertAt(0, TEXT("/Game/")); AssetTools.CreateUniqueAssetName(InName, TEXT(""), PackageName, Name); &#125; UTextureCube* NewTex = nullptr; // create a static 2d texture NewTex = RenderTarget-&gt;ConstructTextureCube(CreatePackage(NULL, *PackageName), Name, RenderTarget-&gt;GetMaskedFlags() | RF_Public | RF_Standalone); if (NewTex != nullptr) &#123; // package needs saving NewTex-&gt;MarkPackageDirty(); // Notify the asset registry FAssetRegistryModule::AssetCreated(NewTex); &#125; return NewTex;&#125; &emsp;&emsp;基本上方法调用为 ConstructTextureCube 即可 总结 &emsp;&emsp;作为 TA ，开发 C++ 要牢记，我们只是大自然的搬运工。&emsp;&emsp;不要接引擎压根都没有的功能需求，这种功能开发通常需要交给程序去搞。&emsp;&emsp;我们的工作是将引擎的功能整合自动化。&emsp;&emsp;查源码虽然很麻烦，很绕，但是很多类用法可以参考源代码的 😎]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python Mesh Paint 顶点色绘制工具]]></title>
    <url>%2Fposts%2Fbd6d2a61.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Unreal 内置有顶点色绘制的功能，可以很方便的在引擎里面绘制颜色。&emsp;&emsp;但是这个功能有个小缺点就是依赖模型的顶点色，如果模型的面数很少的情况下，顶点色绘制就非常不方便了。&emsp;&emsp;那么能否在很少面数的情况下一样去驱动绘制呢？&emsp;&emsp;经过我的研究是完全 可以 实现的，而使用 Python 则更可以更进一步将流程自动化，艺术家只要关注绘制即可。 &emsp;&emsp;其实这个顶点色操作和 Unreal 自带的地形实现的贴图混合效果差不多，好处就是可以用任意的自定义模型。&emsp;&emsp;然后通过一个材质绘制 alpha ，然后最后将绘制效果 bake 成一张贴图。&emsp;&emsp;这样就可以实现任意模型贴图混合并且最后输出一张混合到一起完整贴图。 细分模型 &emsp;&emsp;通过上面的描述可以知道，第一步的绘制操作需要在引擎添加面数才能实现细微的控制。&emsp;&emsp;在引擎里面提高模型面数有两种方案。 Editable Mesh &emsp;&emsp;使用 Editable Mesh 需要开启插件 Editable Mesh 插件。 &emsp;&emsp;这个方案有个好处就是功能是基于蓝图实现的，因此可以完全基于 Python 实现调用。&emsp;&emsp;但是网上查了一轮，居然发现这个蓝图怎么用一点文档都没有。（开源就是那么任性）&emsp;&emsp;我经过一轮搜索好不容易搜到一个相关的问题，但是却没有任何人提供相关回答 链接&emsp;&emsp;最新的回答就是我自己了…… &emsp;&emsp;当时这个蓝图操作也是看着 Python 里面的 API 搭建出来的。&emsp;&emsp;各种函数都暴露到了 Python ，比起官方的 蓝图 API 还要清晰。&emsp;&emsp;所以简单摸索搭配一下就成了。 &emsp;&emsp;后来搜索模型细分相关的信息的时候，还是在论坛很深的地方找到了别人关于 Editable mesh 的研究成果 链接，其实也和我搭建的蓝图一样。&emsp;&emsp;新版本需要多加一个 commit 蓝图节点才能在视窗上看到实现的效果。 &emsp;&emsp;上面的蓝图只是我 Extrude 操作的演示， Editable Mesh 提供了 set_subdivision_count 和 tessellate_polygons 的方法。&emsp;&emsp;上面两个都可以实现增加细分的效果。&emsp;&emsp;设置 subdivision 和 Maya 的3键效果一样的，会将模型全部平滑。&emsp;&emsp;如果正方形面片，平滑了之后就变成了 圆形面片 了。&emsp;&emsp;另外这里需要注意，细分之后的结果是直接存储到 asset 里面的。&emsp;&emsp;如果直接拖基础方块到场景的话，引擎官方的方块 asset 会被细分，如果不甚保存了结果。&emsp;&emsp;那么恭喜你，你的基础方块永远都是细分过的高面数方块了(:з」∠) &emsp;&emsp;因为直接设置细分有平滑的问题，所以用 tessellate_polygons 加面的方案比较好，因为这里只想保持模型外轮廓不变的情况下加面数。 &emsp;&emsp;不过最后折腾了一圈之后，并没有采用 Editable Mesh 的方案。&emsp;&emsp;因为在我们项目的魔改引擎里测试很容易导致崩溃，非常不稳定。&emsp;&emsp;貌似官方版本的引擎会好好很多。&emsp;&emsp;鉴于这些问题，即便 Python 可以调用这些蓝图，也不得不放弃了这个方案。 Mesh Tool Remesh &emsp;&emsp;在引擎里面除了刚才提到的没什么人用的 Editable Mesh 之外。&emsp;&emsp;还有 Mesh Tool 这个官方力推的建模工具箱，里面提供了 Remesh 功能，同样可以实现细分效果。&emsp;&emsp;Remesh 也完美保证外轮廓不变，和 Houdini 的 Remesh 效果差不多，会重新拓扑成不规则的三角面。 &emsp;&emsp;使用 Mesh Tool 需要开启插件。 &emsp;&emsp;开启之后可以在 Mode 下面找到 Mesh Tool 工具集。&emsp;&emsp;选择 Deform 然后点击 Remesh 就可以细分模型了。 &emsp;&emsp;当然这里需要注意 Editable Mesh 同样的问题，这个修改会直接应用到当前 asset 里面。&emsp;&emsp;然而这个细分的资源只是用来临时通过顶点色绘制贴图的，因此我们这里复制一个新的模型并手动细分处理。&emsp;&emsp;通过 Mesh Tool 也可以让艺术家自己调节细分的程度，比起 Editable Mesh 的一步到位,没有多少可以调节的参数要好很多。 材质 Bake &emsp;&emsp;正如上面提到，这里绘制是需要一个 贴图 混合的材质。&emsp;&emsp;这个材质可以简单通过 lerp 节点实现。&emsp;&emsp;当然也可以搭建更为复杂的效果，比如说通过高度图实现更细微的贴图混合。 &emsp;&emsp;那么绘制完成之后，要怎么输出绘制的贴图呢？&emsp;&emsp;首先需要将材质 bake 成一个新的材质。&emsp;&emsp;这样可以将材质混合的贴图类似 PS 的图层合并一样 合并成一张贴图。 &emsp;&emsp;Bake 输出完成之后，会输出一个特殊的材质以及配到一张合并好的贴图。这个 材质 和 贴图 都在 Transient 临时目录里面&emsp;&emsp;如果是 Python 驱动的话，甚至连临时的文件都没有了，是一个动态 Texture2d 贴图。&emsp;&emsp;这个操作就类似你用 蓝图节点 import File as Texture2D 获取到 Texture2D 。 &emsp;&emsp;这个 Texture2D 完全没有 Asset 路径，也无法直接存储到 Unreal 的 Content Browser 里面。&emsp;&emsp;最后我的处理方法是将这张贴图导出通过 export to disk 方法将图片导出到本地。&emsp;&emsp;然后再通过 import asset tasks 将图片重新导入到 Content Browser 里面。 &emsp;&emsp;当然除了这种曲线救国的导出引擎在导入的方法之外，也可以用 RenderTarget 的方式将图片存储到 Content Browser。&emsp;&emsp;只是 Render Target 的处理要麻烦很多，需要通过 Python 搭建材质然后调用 Draw Material to Render Target 节点实现材质转纹理&emsp;&emsp;所以最后还不如做一次导出导入的操作流程。 &emsp;&emsp;完成贴图导出导入的流程基本就大功告成，后续就是清理掉之前生成的高模即可。 &emsp;&emsp;这里的操作和我们这边的材质属性直接挂钩，就不直接 post 程序代码，下面放出一些过程代码给大家参考。&emsp;&emsp;由于这里需要输出的是一张黑白的单通道纹理，所以 bake 的时候实际上是生成了一个 顶点色 连接的材质&emsp;&emsp;然后将顶点色的贴图 bake 出来，导出 TGA 贴图然后再导入会引擎。 （TGA 贴图在下个章节解释） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# NOTE 生成临时材质material = unreal.Material()unlit = unreal.MaterialShadingModel.MSM_UNLIT# NOTE 设置为 unlit 模式material.set_editor_property("shading_model", unlit)# NOTE 生成顶点色节点 位置为 0,0 vertex_color = unreal.MaterialEditingLibrary.create_material_expression( material,unreal.MaterialExpressionVertexColor)# NOTE 将顶点色节点的 R 通道和 emissive 属性相连emissive = unreal.MaterialProperty.MP_EMISSIVE_COLORunreal.MaterialEditingLibrary.connect_material_property(vertex_color, "R", emissive)# NOTE 编译材质unreal.MaterialEditingLibrary.recompile_material(material)# NOTE 将临时材质赋予到选择模型的 StatiMeshComponent 上static_comp.set_editor_property("override_materials",[material])# NOTE 设置 Bake 属性option = unreal.MaterialOptions()option.set_editor_property("use_mesh_data", True)properties = unreal.PropertyEntry()MP_EMISSIVE_COLOR = unreal.MaterialProperty.MP_EMISSIVE_COLORproperties.set_editor_property("property_", MP_EMISSIVE_COLOR)option.set_editor_property("properties", [properties])# NOTE 获取 Gui 上的输入的贴图大小x = self.Tex_Size_X_SP.value()y = self.Tex_Size_Y_SP.value()size = unreal.IntPoint(x, y)option.set_editor_property("texture_size", size)# NOTE 通过 Editor Tests 插件提供的蓝图 bake 出材质和贴图 unreal.EditorTestsUtilityLibrary.bake_materials_for_component( static_comp, option, unreal.MaterialMergeOptions())# NOTE 获取Bake出来的 材质 | 从材质上获取生成的目标贴图material = static_comp.get_editor_property("override_materials")[0]texture = material.get_texture_parameter_value("EmissiveColorTexture")# NOTE 导出 TGA 图片 | 方便 顶点色 导入asset_tool = unreal.AssetToolsHelpers.get_asset_tools()# NOTE 输出到临时路径上texture_path = os.path.join(tempfile.gettempdir(),"Unreal_temp",name+"_BakeTexture.tga")task = unreal.AssetExportTask()task.set_editor_property('automated', True)task.set_editor_property('filename', texture_path)task.set_editor_property('object', texture)task.set_editor_property('prompt', False)task.set_editor_property('exporter', unreal.TextureExporterTGA())check = unreal.Exporter.run_asset_export_task(task)if not check: alert(u"tga 图片生成失败") return# NOTE 等待贴图生成time.sleep(1)# NOTE https://forums.unrealengine.com/development-discussion/python-scripting/1608720-python-scripting-for-importing-custom-assets# NOTE 导入贴图task = unreal.AssetImportTask()task.set_editor_property('automated', True)task.set_editor_property('destination_name', name + '_BakeTexture')task.set_editor_property('destination_path', path)task.set_editor_property('filename', texture_path)task.set_editor_property('replace_existing', True)task.set_editor_property('save', True)asset_tool.import_asset_tasks([task])bake_path = path + "/" + name + '_BakeTexture'texture = unreal.EditorAssetLibrary.load_asset(bake_path) 顶点色绘制还原 &emsp;&emsp;本来是觉得这个纹理处理流程已经完美了，没想到在美术使用之后遇到了一个非常致命的问题。&emsp;&emsp;那就是贴图画得不好想要重新画该怎么办？ &emsp;&emsp;好在虚幻的顶点色绘制提供了重新导入顶点色纹理的方法。&emsp;&emsp;只不过模型在处理过程中已经将细分删除了，需要重新复制一个模型，然后细分，再然后导入之前导出的 黑白 纹理为顶点色即可。&emsp;&emsp;由于引擎只支持导入 TGA 纹理，所以上面导出的时候也将格式改为 TGA。 总结 &emsp;&emsp;这次贴图处理流程有些许模糊不清，主要原因是 Material 节点的连接上不是我做的。&emsp;&emsp;我负责写工具将流程自动化，并且对接这个特殊 Meterial 上的一些参数。&emsp;&emsp;以后有时间也得再好好研究一下 Unreal 的 Material 节点连接。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt PySide 内置图标]]></title>
    <url>%2Fposts%2F3b9c0ad6.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;关于 Qt 内置的 图标 ，之前开发 Unreal FBX 导入导出面板的时候就已经研究过了。 链接&emsp;&emsp;但是当时没有系统整理这个图标的获取方法，最近又遇到类似的问题，就特别扩展延伸了一下。 内置图标查找 &emsp;&emsp;遇到问题，首先在网络上查找，可以在 Stack Overflow 上找到不错的回答 链接 &emsp;&emsp;链接里面提到的第一个回答是使用 theme 可以获取 gtk 的默认图标。&emsp;&emsp;但是这个操作在 windows 平台不起作用，我也不知道怎么在 windows 上实现。&emsp;&emsp;于是我参考了第二个回答，还是有所收获的， Qt 内置了72个图标（后面研究有些图标是不可用的）。&emsp;&emsp;基本可以满足大部分的需要了。 QStyle 获取内置图标 &emsp;&emsp;Qt 的内置图标可以在 PySide 的文档里面找到 链接 &emsp;&emsp;当初我开发 FBX 导入导出面板的时候还没有整理，所以要用什么图标只能看描述，然后一个一个图标测试。&emsp;&emsp;现在想着不如直接做个 Widget 将所有的图标罗列出来吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# -*- coding: utf-8 -*-"""罗列 Qt 内置的图标"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-07-18 23:29:36'import osfrom functools import partialfrom PySide2 import QtCore, QtWidgets, QtGuiclass IconWidget(QtWidgets.QWidget): def __init__(self,parent=None): super(IconWidget, self).__init__(parent) DIR = os.path.dirname(__file__) layout = QtWidgets.QHBoxLayout() self.setLayout(layout) style = QtWidgets.QApplication.style() container = QtWidgets.QWidget() container.setLayout(QtWidgets.QVBoxLayout()) layout.addWidget(container) index = 0 for attr in dir(QtWidgets.QStyle): if not attr.startswith("SP_"): continue index += 1 ref = getattr(QtWidgets.QStyle,attr) # # NOTE 保存图片到本地 # pixmap = style.standardIcon(ref).pixmap(32,32) if attr == "SP_LineEditClearButton" else style.standardPixmap(ref) # icon_folder = os.path.join(DIR,"icon") # if not os.path.exists(icon_folder): # os.makedirs(icon_folder) # path = os.path.join(icon_folder,"%s.png" % attr) # pixmap.save(path,"png") icon = style.standardIcon(ref) button = QtWidgets.QPushButton() button.setIcon(icon) button.setText(attr) button.clicked.connect(partial(self.copy_text,"QtWidgets.QStyle.%s" % attr)) container.layout().addWidget(button) if index % 18 == 0: container = QtWidgets.QWidget() container.setLayout(QtWidgets.QVBoxLayout()) layout.addWidget(container) def copy_text(self,text): cb = QtWidgets.QApplication.clipboard() cb.clear(mode=cb.Clipboard ) cb.setText(text, mode=cb.Clipboard)def main(): app = QtWidgets.QApplication([]) widget = IconWidget() widget.show() app.exec_()if __name__ == "__main__": main() &emsp;&emsp;加了个贴心的小功能，点击图标自动复制图标的类名到剪切板里面。&emsp;&emsp;方便将中意的图标拿出来用。&emsp;&emsp;另外整理一份 md 文档列表，图标文件也已经上传到 github 上了。 github地址 总结 &emsp;&emsp;Qt 框架真的非常庞大，而且跨平台，功能强大。&emsp;&emsp;只可惜这个内置图标提供的数量比较少，当然如果不嫌麻烦，Qt也提供了和多方便的 API 来外部调用图标，满足各种需求。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python Sequencer 批量渲染总结]]></title>
    <url>%2Fposts%2F2f3a9b95.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近我的学弟找我咨询关于 Unreal Sequencer 渲染输出的问题。&emsp;&emsp;之前没有折腾过这个一块，于是就跟进了一下，顺便学习 Sequencer 的序列输出。 &emsp;&emsp;另外最近另一个师弟也研究了差不多的问题，发了一篇 B站专栏 ， 在这里推荐一下 链接 手动操作 &emsp;&emsp;在自动化操作渲染之前，需要先搞清楚怎么手动操作 Sequencer 进行渲染。 &emsp;&emsp;其实操作起来不难，打开 Unreal 的定序器，点击上面的 Render 图标打开 Render Movie Setting&emsp;&emsp;然后配置好渲染设置就可以点击渲染，就可以将影片批量渲染出来。 自动化操作 &emsp;&emsp;下面就是将手动操作转为 Python 的自动操作。&emsp;&emsp;具体的操作脚本其实可以参考官方的脚本，在官方 SequencerScripting 插件里面有渲染相关的 Python 脚本。&emsp;&emsp;安装了 Unreal 引擎之后可以根据地址查找 \Engine\Plugins\MovieScene\SequencerScripting\Content\Python&emsp;&emsp;sequencer_examples 就有输出的 Python 代码，不需要自己查文档研究怎么搭建代码。&emsp;&emsp;参照 render_sequence_to_movie 的代码即可输出。 &emsp;&emsp;其中比较坑的点在于 OnRenderMovieStopped 的 delegate&emsp;&emsp;接入 Python 回调需要一个 global 函数才可以，否则执行完成的回调函数不会触发。&emsp;&emsp;官方的案例是放到最外层执行的，如果不凑巧回调函数写在函数里面，就需要利用 global 关键字解决这个问题。 &emsp;&emsp;官方案例还没能实现一个需求，就是批量将不同 Sequence 同时渲染出来。&emsp;&emsp;然而 render_movie 这个函数是不阻塞的，如果使用 for 循环会一直把所有的 render_movie 持续执行。&emsp;&emsp;所以这里进行渲染需要通过回调来实现逐个渲染的调用。 Python 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# -*- coding: utf-8 -*-"""渲染 sequencer 的画面选择 LevelSequence 批量进行渲染"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_import__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-07-14 21:57:32'import unrealimport osimport subprocessfrom functools import partialdef alert(msg): unreal.SystemLibrary.print_string(None,msg,text_color=[255,255,255,255])def render(sequence_list,i,output_directory="C:/render",output_format="&#123;sequence&#125;"): # NOTE 如果超出数组则退出执行 if i &gt;= len(sequence_list): # NOTE 输出完成 打开输出文件夹的路径 subprocess.call(["start","",output_directory], creationflags=0x08000000,shell=True) return # NOTE 获取当前渲染序号下的 LevelSequence sequence = sequence_list[i] # NOTE 配置渲染参数 settings = unreal.MovieSceneCaptureSettings() path = unreal.DirectoryPath(output_directory) settings.set_editor_property("output_directory",path) settings.set_editor_property("output_format",output_format) settings.set_editor_property("overwrite_existing",True) settings.set_editor_property("game_mode_override",None) settings.set_editor_property("use_relative_frame_numbers",False) settings.set_editor_property("handle_frames",0) settings.set_editor_property("zero_pad_frame_numbers",4) settings.set_editor_property("use_custom_frame_rate",True) settings.set_editor_property("custom_frame_rate",unreal.FrameRate(24, 1)) # NOTE 渲染大小 w,h = 1280,720 settings.set_editor_property("resolution",unreal.CaptureResolution(w,h)) settings.set_editor_property("enable_texture_streaming",False) settings.set_editor_property("cinematic_engine_scalability",True) settings.set_editor_property("cinematic_mode",True) settings.set_editor_property("allow_movement",False) settings.set_editor_property("allow_turning",False) settings.set_editor_property("show_player",False) settings.set_editor_property("show_hud",False) # NOTE 设置默认的自动渲染参数 option = unreal.AutomatedLevelSequenceCapture() option.set_editor_property("use_separate_process",False) option.set_editor_property("close_editor_when_capture_starts",False) option.set_editor_property("additional_command_line_arguments","-NOSCREENMESSAGES") option.set_editor_property("inherited_command_line_arguments","") option.set_editor_property("use_custom_start_frame",False) option.set_editor_property("use_custom_end_frame",False) option.set_editor_property("warm_up_frame_count",0.0) option.set_editor_property("delay_before_warm_up",0) option.set_editor_property("delay_before_shot_warm_up",0.0) option.set_editor_property("write_edit_decision_list",True) # option.set_editor_property("custom_start_frame",unreal.FrameNumber(0)) # option.set_editor_property("custom_end_frame",unreal.FrameNumber(0)) option.set_editor_property("settings",settings) option.set_editor_property("level_sequence_asset",unreal.SoftObjectPath(sequence.get_path_name())) # NOTE 设置自定义渲染参数 option.set_image_capture_protocol_type(unreal.CompositionGraphCaptureProtocol) protocol = option.get_image_capture_protocol() # NOTE 这里设置 Base Color 渲染 Base Color 通道，可以根据输出的 UI 设置数组名称 passes = unreal.CompositionGraphCapturePasses(["Base Color"]) protocol.set_editor_property("include_render_passes",passes) # protocol.set_editor_property("compression_quality",100) # NOTE 设置全局变量才起作用！ global on_finished_callback on_finished_callback = unreal.OnRenderMovieStopped( lambda s:render(sequence_list,i+1,output_directory,output_format)) unreal.SequencerTools.render_movie(option,on_finished_callback) def main(output_directory="C:/render",output_format="&#123;sequence&#125;"): # NOTE 获取当前选择的 LevelSequence sequence_list = [asset for asset in unreal.EditorUtilityLibrary.get_selected_assets() if isinstance(asset,unreal.LevelSequence)] if not sequence_list: alert(u"请选择一个 LevelSequence") return if not os.access(output_directory, os.W_OK): alert(u"当前输出路径非法") return elif not os.path.exists(output_directory): # NOTE 路径不存在则创建文件夹 os.makedirs(output_directory) elif os.path.isfile(output_directory): # NOTE 如果传入文件路径则获取目录 output_directory = os.path.dirname(output_directory) render(sequence_list,0,output_directory,output_format)if __name__ == "__main__": main() &emsp;&emsp;选择 Sequencer 执行上面的脚本，就可以自动批量输出 Sequencer 了。 总结 &emsp;&emsp;理论上 Python 调用蓝图方法做到的功能， 蓝图应该也可以做到的。&emsp;&emsp;但是经过我的测试，我发现 蓝图 的 get_image_capture_protocol 返回值是 基类。&emsp;&emsp;导致无法获取 CompositionGraphCaptureProtocol 这个类&emsp;&emsp;也就无法设置 include_render_passes 的值了，这样导致蓝图输出会将所有通道输出，而不能实现单一通道的输出。 &emsp;&emsp;另外这一次没有制作 GUI ，我还在纠结使用 Qt 还是 Unreal 原生的界面。&emsp;&emsp;Unreal使用 Editor Utility 创建的 UI 是二进制 uasset ，无法向前兼容 Unreal 版本。&emsp;&emsp;UI的功能响应上也没有 Qt 成熟。&emsp;&emsp;但是无论如何，Unreal 的 UMG 是原生体验，嵌入样式各方面都比较舒服的。&emsp;&emsp;虽然 Qt 可以写一套 Qss 来解决样式问题，但是在 Unreal 中实现 Dock 目前还是无解。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal/Sequencer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（十一） - 主题迁移]]></title>
    <url>%2Fposts%2F260a6911.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;随着博客的文章数量不断增加，我觉得自己挂在网上的网站越来越臃肿了。&emsp;&emsp;特别是文章数量很多之后，使用本地搜索会非常卡顿，交互体验很不友好。&emsp;&emsp;于是我痛定思痛，决定废弃 Hexo 了， Hexo 不使用 Vue 和 React 这种前端技术栈。&emsp;&emsp;搜索用的文件大小降低不下来。&emsp;&emsp;为此我还特意去尝试了 VuePress 和 Hugo ，东西都准备好，也简单测试过了。&emsp;&emsp;最后我觉得还是可以抢救一下，于是专门搜索了关于 Hexo search.xml 的处理。&emsp;&emsp;没想到就因为自己一时激动 打开了新世界的大门。 链接 &emsp;&emsp;打开文章链接的作者博客， 好清爽，好喜欢。&emsp;&emsp;然后在仔细看看作者的文章，最近的文章也是关于 Hexo 的，没想到 Hexo 4.0 之后居然有这么好看的主题。&emsp;&emsp;于是我的折腾就开始了，真就这最后一下的抢救让我有留在了 Hexo 阵营。 &emsp;&emsp;另外关于如何解决 search.xml 过大的问题， 免费 jsdelivr cdn 服务简直就是正道的光。&emsp;&emsp;这个 cdn 服务覆盖 github 的资源，只要资源上传到 github 就可以享受 cdn 加速服务。&emsp;&emsp;而且国内网络加速良好，1、2 M 大小根本不在话下。&emsp;&emsp;图片加速也完全 OK ，我也不需要花钱使用 COS 腾讯云的资源共享了~ 配置 Butterfly 主题 &amp; 踩坑 &emsp;&emsp;一起 Hexo 的主题还没有那么全面的功能。&emsp;&emsp;当时使用的 SPFK 主题是很不容易找到兼容移动端并且浏览带目录的了。&emsp;&emsp;但是即便如此，主题中仍然有很多问题，需要我手动去修改，花费了大量的时间。&emsp;&emsp;现在我看到比如打赏 gittalk 集成等等之类的功能，主题都已经做好了，根本就不需要自己操心。&emsp;&emsp;特别是当时要自己动手将 Next 主题的搜索集成到现有的主题里面，真的是折腾了好久，印象深刻。 链接&emsp;&emsp;还有代码块加个复制功能也是贼麻烦，当时为了省事，还用了 setInterval 定时执行对齐命令，导致博客的无用运算很多(:з」∠) 链接 butterfly github地址butterfly 官方文档 &emsp;&emsp;Butterfly 配置其实不难，不过我这个老用户的确遇到了不少坑。&emsp;&emsp;首先就是我安装的 Hexo 是老版本了， 需要安装新版本 4.0 才能运行主题，否则会出错。&emsp;&emsp;不过还好，出错之后可以去 github 仓库上搜索 issue ，可以找到解决方案。 &emsp;&emsp;由于 Butterfly 主题的 分类 模式和我之前的主题不一样。&emsp;&emsp;我之前的主题的分类没有层级结构，每一个关键词都是一个单独的分类。&emsp;&emsp;Butterfly 的分类是从上到下的层级排布，我认为是更加好的，但是得修改我之前所有的文章。 &emsp;&emsp;考虑到 jsdelivr 这么优秀的 cdn 服务，我还要将所有文章的截图全部转到 Github 上，通过 jsdelivr 来读取。 &emsp;&emsp;描述上，我之前的主题是通过 &lt;!-- more --&gt; 实现的。&emsp;&emsp;现在文章描述需要单独配置到 md 的 fontmatter 里&emsp;&emsp;因此还是需要修改每一篇文章。 &emsp;&emsp;Butterfly 主题多了文章封面的操作，为此我写了 Python 脚本批量读取我之前的文章。&emsp;&emsp;然后将之前文章的第一张截图放到封面上，上面的描述和图片地址处理也是这么解决的。&emsp;&emsp;分类需要重新调整，所以是手动处理。 &emsp;&emsp;这里面踩了比较大的坑，官方提到可以在 Source 目录下配置 _data/butterfly.yml 进行主题配置&emsp;&emsp;方便随时进行主题的更新。&emsp;&emsp;当时文档的 Butterfly 是首字母大小的，所以 yml 命名上也大写了，导致根本没有读取到我的配置。 &emsp;&emsp;最后我也尝试将 Vex 和 Maxscirpt 的高亮接入到 博客里面。&emsp;&emsp;以前就有魔改 node_module 里面的模块的经验，但是以前的修改方案在一次处理中完全不起作用。&emsp;&emsp;目前原因还不是很清楚，我暂时放弃了这两门语言的高亮了。 补充 - hexo 文章加密 &emsp;&emsp;之前写了一些不想外传的文章，通过 hexo 的一个插件可以轻松实现文章的加密。&emsp;&emsp;名字叫做 hexo-blog-encrypt 插件&emsp;&emsp;加密解密 的 样式模块，算法全部都弄好了&emsp;&emsp;只有知道文章的密码才能观看，我还挺喜欢的。 总结 &emsp;&emsp;本来是觉得 Hexo 太臃肿了，想要换个更好用的。&emsp;&emsp;没想到改到最后变成了真香党，配置新的主题花了好几天的时间（毕竟还有工作）&emsp;&emsp;导致原定计划要更新的 Unreal Python 记录延后了，后续会继续更新相关的文章。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal Python 结合 C++ 开发蓝图库插件]]></title>
    <url>%2Fposts%2Fc6f4bf5b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上个月的这个时候我写了一篇文章关于如何嵌入 PySide 调用 Qt 的 GUI 开发。 链接&emsp;&emsp;Python 虽然很好，但是有些功能，并没有从 C++ 里面暴露出来。&emsp;&emsp;这种情况就需要通过 C++ 的蓝图开发来将这部分的功能进行暴露。&emsp;&emsp;这样 Python 基本上可以做任何 Unreal 的事情。 &emsp;&emsp;如何开发蓝图库也基本可以参照上篇文章提到的 Unreal Python 教程。 链接 为什么需要开发 C++ 蓝图 &emsp;&emsp;上面的视频链接有很详细如何通过 Unreal C++ API 开发一个 Unreal 的蓝图，暴露给 Python 调用。&emsp;&emsp;Unreal 的 Python 插件其实已经将 Unreal 内置的所有蓝图暴露给了 Python。&emsp;&emsp;因此 蓝图 能够做到的事情， Python 是绝对可以做到的。&emsp;&emsp;而且经过一个多月的使用来看， Python 的 API 文档做得比 蓝图 的 文档要好很多。&emsp;&emsp;有时候直接查 Python 的 API 反而更有效率，甚至会发现一些其他插件所引入的蓝图。 &emsp;&emsp;那么 Python 相较于 蓝图 的有什么异同？&emsp;&emsp;我目前的使用感受来看，除了失去图形节点编程的可视化之外，基本上碾压蓝图，当然运行效率上没有测试过。&emsp;&emsp;蓝图 和 Python 的定位有很大的不一样。&emsp;&emsp;蓝图可以作为游戏运行逻辑的一部分， Python 只能当做编辑器的自动化工具。（Python 效率太低了，运行脚本宁愿用 lua 调 C++） &emsp;&emsp;蓝图自身有它的优缺点，效率比不过 C++ 链接&emsp;&emsp;但是图形化编程，对于非 coding 人员很友好，而且一些简单的逻辑也比较直观。&emsp;&emsp;但是复杂蓝图的连线还是太让人劝退了。 &emsp;&emsp;Python 对于像我这种工具向开发的 TA 来说太友好了，毕竟很多 DCC 都使用 Python 。&emsp;&emsp;Unreal 的 Python 插件大部分是对 蓝图 的分装，基本上蓝图有的功能都可以通过 Python 来调。&emsp;&emsp;同时 Python 还可以实现一些神奇的功能，比如说通过 Python 开发一个蓝图节点 ，调用 Python 的第三方库诸如 PySide 包，或者调用系统的 cmd 或者 shell 命令。&emsp;&emsp;因此从引擎的提升来说， Python 的确在这方面更胜一筹，复杂逻辑通过代码看也比较直观。 &emsp;&emsp;当然很明显， 蓝图不能实现的引擎操作，基本上也不用指望 Python 能够调用什么 API 来实现了。&emsp;&emsp;这种情况下就需要 C++ 来扩展蓝图，实现 Python 调用。 C++ 开发蓝图库插件 &emsp;&emsp;我们目前的需求并不是开发游戏调用的蓝图，因此我们可以开发一个蓝图库插件。&emsp;&emsp;这样可以轻易将这些蓝图迁移到不同的项目里面去。 &emsp;&emsp;Unreal 搭建蓝图库开发其实并不难，按照官方的指引去做即可。&emsp;&emsp;首先需要创建一个 C++ 工程，如果是蓝图工程是无法写 C++ 代码的。&emsp;&emsp;然后打开插件面板，选择 New Plugin &emsp;&emsp;然后引擎就会自动创建一个基础插件的模板出来。&emsp;&emsp;后续就是在这个基础模板上调用 C++ 的 API 实现一些特殊的功能。 unreal C++ 插件注意事项 &emsp;&emsp;插件的默认结构是 .uplugin 文件加 Resource 和 Source 文件夹。&emsp;&emsp;uplugin 就是一个 Json 配置，配置了插件在引擎的插件列表的显示，以及加载方式。&emsp;&emsp;Resource 存放插件显示的图标。&emsp;&emsp;Source 存放的是 C++ 源码了。 &emsp;&emsp;前面两个不需要太过关注，重点的 Source 文件夹的东西。&emsp;&emsp;里面会有 .Build.cs 文件以及 Public 和 Private 文件夹。&emsp;&emsp;`.Build.cs`是 C# 代码，通过虚幻的 Reflect 机制生成 Intermediate 的中间代码用来编译生成 dll。&emsp;&emsp;Public 默认存放头文件&emsp;&emsp;Private 默认存放cpp源码 &emsp;&emsp;引用了引擎内部的一些库，需要在 build.cs 文件里面添加上。&emsp;&emsp;否则编译的时候回报某些类型无法识别的错误。&emsp;&emsp;试过排查这种小错误花了我大半天。 &emsp;&emsp;前面两个部分是添加路径的，用来缩短头文件索引的路径长度。&emsp;&emsp;后面的 Private 和 Public Module 则是最重要的索引头文件的，必须要在这里配置才能在 c++ 里面调用。&emsp;&emsp;这里怎么填写可以参考引擎 Source 源码下的文件夹名称。 &emsp;&emsp;cs 里面配置就可以找 Source 源码的一些头文件进行引用了。&emsp;&emsp;因为虚幻开源了，所以内部 Private 和 Public 没有什么区别，也可能是我的 C++ 造诣还不够。 &emsp;&emsp;配置头文件就可以愉快地使用官方提供的一些 C++ 了。 C++ 实现 Add Component 蓝图功能 &emsp;&emsp;这个功能看似非常简单，奈何 Python 就是实现不了。 &emsp;&emsp;就是给现有 Actor 添加新的 Component 组件而已。&emsp;&emsp;但是查了 API 文档，即便使用 Attach 相关的方法，也无法新的 Component 添加到 Actor 上。&emsp;&emsp;应该说 Python 的操作没有问题， Component 也加上了，可以通过 Python 获取到，但是 Component 没有注册，无法在 UI 上显示出来。 &emsp;&emsp;经过我查阅大量网上的资料之后，只在论坛上找到了一个通过 C++ 实现的方案。 链接&emsp;&emsp;这段代码里面有很关键的 RegisterComponent 的操作。&emsp;&emsp;而这些操作并没有暴露到 Python 或者说 蓝图 里面。&emsp;&emsp;当然这个添加 Component 的方法估计也和 Unreal 的机制有关，我对 Unreal 引擎还不是很熟，就不做无关的揣测了。 &emsp;&emsp;Python 的文档在 Actor 的部分有所涉及。&emsp;&emsp;不过这个问题就非常蛋疼，&emsp;&emsp;unreal.EditorLevelLibrary.get_all_level_actors_components 可以获取所有注册的 Component&emsp;&emsp;Actor 也可以删除现有的 Component ，偏偏无法添加新的 Component &emsp;&emsp;C++ 的部分我简化了上面回答的代码。&emsp;&emsp;如果没有传入具体的 Component 类型就返回 None 给 Python 就好了。 1234567891011121314151617181920212223242526272829UActorComponent* URedArtToolkitBPLibrary::AddComponent(AActor* a, USceneComponent *future_parent, FName name, UClass* NewComponentClass)&#123; UActorComponent* retComponent = nullptr; if (NewComponentClass) &#123; UActorComponent* NewComponent = NewObject&lt;UActorComponent&gt;(a, NewComponentClass, name); FTransform CmpTransform;// = dup_source-&gt;GetComponentToWorld(); //NewComponent-&gt;AttachToComponent(sc, FAttachmentTransformRules::KeepWorldTransform); // Do Scene Attachment if this new Comnponent is a USceneComponent if (USceneComponent* NewSceneComponent = Cast&lt;USceneComponent&gt;(NewComponent)) &#123; if (future_parent != 0) NewSceneComponent-&gt;AttachToComponent(future_parent, FAttachmentTransformRules::KeepWorldTransform); else NewSceneComponent-&gt;AttachToComponent(a-&gt;GetRootComponent(), FAttachmentTransformRules::KeepWorldTransform); NewSceneComponent-&gt;SetComponentToWorld(CmpTransform); &#125; a-&gt;AddInstanceComponent(NewComponent); NewComponent-&gt;OnComponentCreated(); NewComponent-&gt;RegisterComponent(); a-&gt;RerunConstructionScripts(); retComponent = NewComponent; &#125; return retComponent;&#125; &emsp;&emsp;头文件怎么去 #include ，我基本就是用 VScode 搜索引擎源码，查找头文件的位置，然后逐个添加。 &emsp;&emsp;C++有点麻烦的地方就是 cpp 代码写完之后还要将函数注册到 头文件 里面&emsp;&emsp;不过基本上复制 cpp 的函数第一行就可以了，只需要把 :: 前面的类名删除掉而已。 &emsp;&emsp;下面就是点击 VS 上面的 本地 windows 调试，编译插件并启动项目。 &emsp;&emsp;我用 VS2017 编译经常遇到 clxx.dll 命令行过长 的错误。&emsp;&emsp;网上了查了要将项目的编译改为 Release 版本，或者升级到 VS2019 才可以解决。（网上查到这个是 VS 的 BUG） &emsp;&emsp;后来我是随便将一些 Intermediate 文件夹删除，然后重新调用 UnrealHeaderTool 生成反射代码就不会有这个编译报错了。&emsp;&emsp;完成到这里基本可以参照老外的教程，使用 Python 可以在 unreal 库下找到刚才蓝图扩展的类的，类下面就由刚才扩展的 函数 了。&emsp;&emsp;行数名称自动将 C++ 的驼峰转为 Python pep8 规范的 sneak 写法。 C++ 蓝图获取当前 Sequencer 选择的元素 &emsp;&emsp;上面介绍了 C++ 的编写的流程，就不再追溯，这里着重看蓝图的实现。&emsp;&emsp;我最近有一个需求是要获取当前打开的 Sequencer 里面的元素，然后进行 FBX 导出。&emsp;&emsp;但是查遍了 Unreal 的 Python 文档也没有找到这个方法。&emsp;&emsp;对了这里记录一个天坑，之前被坑惨了的。&emsp;&emsp;Unreal Python 的老外教程里面也记录一些使用 Sequencer 处理的 Python 方案。&emsp;&emsp;但是我发现到我调用这些 API 的时候， Unreal 居然报错找不到这些 API。&emsp;&emsp;然后我就以为是我当前 Unreal 版本出 BUG 了，或者是官方删除了这个功能。&emsp;&emsp;后来折腾了好久之后才发现，我没有开启 Sequencer Scripting 插件，所以那些调用蓝图没有加载(:з」∠)&emsp;&emsp;我当时还不知道 Python 调用的就是蓝图， 踩了这个坑才有了深刻的认识。 &emsp;&emsp;回到这里要实现的功能，我查了 C++ 相关的问题，总算是找到了一个比较可靠的回复。 链接&emsp;&emsp;于是我就抄了这里的代码。 &emsp;&emsp;不过上面的代码有点旧，其中 IAssetEditorInstance AssetEditor = UAssetEditorSubsystem().FindEditorForAsset(LevelSeq, true); 编译会报错&emsp;&emsp;修改为 IAssetEditorInstance AssetEditor = GEditor-&gt;GetEditorSubsystem()-&gt;FindEditorForAsset(LevelSeq, true); 解决问题。 &emsp;&emsp;经过修改之后上面的代码可以获取到当前 Sequencer 打开的 LevelSequence&emsp;&emsp;原理也不复杂，就是遍历项目所有的 LevelSequence 然后找到那个开启了 Editor 的 LevelSequence&emsp;&emsp;然后在从这个 LevelSequence 里获取 Editor 再从 Editor 获取 Sequencer。 &emsp;&emsp;虽然这个遍历有点不太合理，但是我在测试的项目上还是很奏效的。&emsp;&emsp;但是当我将代码编译放到我们正在开发的项目上之后，出现了大问题。&emsp;&emsp;项目有大量的 LevelSequence ，遍历需要很长的时间，并且遍历之后大量的材质启动了编译，导致电脑很卡。 &emsp;&emsp;于是我又查了一下 C++ API 文档，发现有个很有用的函数 GetAllEditedAssets。&emsp;&emsp;这个函数可以获取当前打开在编辑器里面的 Assets ，能打开的 Asset 肯定就那么几个。&emsp;&emsp;这样找 Editor 的速度可就快多了。 123456789101112131415161718ULevelSequence* URedArtToolkitBPLibrary::GetFocusSequence()&#123; UAssetEditorSubsystem* sub = GEditor-&gt;GetEditorSubsystem&lt;UAssetEditorSubsystem&gt;(); TArray &lt;UObject*&gt; assets = sub-&gt;GetAllEditedAssets(); for (UObject* asset : assets) &#123; IAssetEditorInstance* AssetEditor = sub-&gt;FindEditorForAsset(asset, false); FLevelSequenceEditorToolkit* LevelSequenceEditor = (FLevelSequenceEditorToolkit*)AssetEditor; if (LevelSequenceEditor != nullptr) &#123; ULevelSequence* LevelSeq = Cast&lt;ULevelSequence&gt;(asset); return LevelSeq; &#125; &#125; return nullptr;&#125; &emsp;&emsp;上面只是找 LevelSequence ，还需要找当前 LevelSequence 里面选择的元素。&emsp;&emsp;好在 Sequencer 提供了 GetSelectedObjects 的方法&emsp;&emsp;通过 LevelSequence 可以获取到 Sequencer 1234567891011121314TArray&lt;FGuid&gt; URedArtToolkitBPLibrary::GetFocusBindings(ULevelSequence* LevelSeq)&#123; IAssetEditorInstance* AssetEditor = GEditor-&gt;GetEditorSubsystem&lt;UAssetEditorSubsystem&gt;()-&gt;FindEditorForAsset(LevelSeq, false); FLevelSequenceEditorToolkit* LevelSequenceEditor = (FLevelSequenceEditorToolkit*)AssetEditor; TArray&lt;FGuid&gt; SelectedGuid; if (LevelSequenceEditor != nullptr) &#123; ISequencer* Sequencer = LevelSequenceEditor-&gt;GetSequencer().Get(); Sequencer-&gt;GetSelectedObjects(SelectedGuid); return SelectedGuid; &#125; return SelectedGuid;&#125; &emsp;&emsp;这样获取返回的是 Guid ， Python 有 Guid 类。&emsp;&emsp;可以通过 LevelSequence 的 get_bindings 方法获取 sequence 相关的 binding&emsp;&emsp;再调用 get_id 方法获取 guid ，然后通过 C++ 的蓝图将获取到的 id 筛选一遍。 12345# NOTE 获取当前 Sequencer 中的 LevelSequencesequence = unreal.RedArtToolkitBPLibrary.get_focus_sequence()# NOTE 获取当前 Sequencer 中选中的 Bindingsid_list = unreal.RedArtToolkitBPLibrary.get_focus_bindings(sequence)bindings_list = [binding for binding in sequence.get_bindings() if binding.get_id() in id_list] &emsp;&emsp;这样就获取到了当前选择的 SequencerBindingProxy 类。&emsp;&emsp;通过 unreal.SequencerTools.export_fbx 就可以将选择的元素导出 FBX 了。 123456789101112131415161718192021222324252627282930313233import unrealfrom Qt import QtCore, QtWidgets, QtGuidef alert(msg=u"msg", title=u"警告", button_text=u"确定"): # NOTE 生成 Qt 警告窗口 msg_box = QtWidgets.QMessageBox() msg_box.setIcon(QtWidgets.QMessageBox.Warning) msg_box.setWindowTitle(title) msg_box.setText(msg) msg_box.addButton(button_text, QtWidgets.QMessageBox.AcceptRole) unreal.parent_external_window_to_slate(msg_box.winId()) msg_box.exec_()def unreal_export_fbx(fbx_file): # NOTE 获取当前 Sequencer 中的 LevelSequence sequence = unreal.RedArtToolkitBPLibrary.get_focus_sequence() if not sequence: alert(u"请打开定序器") return # NOTE 获取当前 Sequencer 中选中的 Bindings id_list = unreal.RedArtToolkitBPLibrary.get_focus_bindings(sequence) bindings_list = [binding for binding in sequence.get_bindings() if binding.get_id() in id_list] if bindings_list: # NOTE 导出 FBX 文件 option = unreal.FbxExportOption() option.set_editor_property("collision",False) world = unreal.EditorLevelLibrary.get_editor_world() unreal.SequencerTools.export_fbx(world,sequence,bindings_list,option,fbx_file) else: alert(u"请选择定序器的元素进行 FBX 导出") return &emsp;&emsp;上面就是完整的示例代码。&emsp;&emsp;当然导出的 FBX 是带动画的，还需要将动画处理成带 蒙皮骨骼 的 FBX 。&emsp;&emsp;这个操作我是通过 FBX Python SDK 实现的。&emsp;&emsp;官方的 ExportScene01 包含了蒙皮创建，关键帧处理等等的操作，绝大部分的代码可以照抄。&emsp;&emsp;这里蒙皮转换的需求很简单，因此稍微修改一下就可以用了。&emsp;&emsp;处理完成之后将 FBX 输出到临时目录，然后用 Python 调 windows 命令打开路径。 总结 &emsp;&emsp;其实调用 C++ API 并不难，这种程度的操作还没有修改到 Unreal 的底层，很多机制也没有用到，我作为个外行还是可以应付的。&emsp;&emsp;而且 Unreal C++ 本身做了很多工作，比如实现了 垃圾回收，含有智能指针，都降低了开发难度（同时增加了学习的难度） &emsp;&emsp;Unreal 开发比较难受的地方时教程文档各方面都不全， Unity 文档还有代码示例，Unreal 因为开源，基本上就是让你直接看源码(:з」∠)&emsp;&emsp;有时候遇到的一些奇奇怪怪的问题还找不到任何网上的提问，就很难受了。 &emsp;&emsp;最后引擎编译非常耗时，如果要搞这一块的研究，一定一定要配台好电脑。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠇCpp</tag>
        <tag>ࠃUnreal/blueprint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MG-PickerStudio 使用推荐]]></title>
    <url>%2Fposts%2F115d5490.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. f270f815678216eb0f04e9564751428359a4aeb9008030956838fed9e7a131e24e1455a1cf02216dd8efde98cb455f671216bb221191cd73a7f604154e668793018fb3c9088dceb37f72f23287d3964a364775a486f8528fa6cb137d153ecc56ae1ecd25b6898840440c9a4e228e67d14fffa9afd9122bd37dd949d63a7fcf0265bc73d9c1fbe3929e4917b87fdc456bf3eaa123b96e7a9375a7ed0e4a30e77adae396ada1c1a05b995c3a67b8e2570878f9dd3aa62e3b6695c877ffaaa6bc4f6fd78125e004bc5f97c73e1a4f0da19d0caf8e81b45821de89f1bb2623f2aad12fb8dbfe6f3031d9340756b8bcb503625c1860784102521850310f53262422a5174b455452203a6d7d09f4898fd765adc0c4f7417e3c0471083ea22954af6e6dbf325728c99c3363af66795742a20b2946c96baf7c9d8487afe4b4b880fc1e73bd5961b157b673440600d3eaeefad65cba3c669d65cb1c9c227d075f85c3c23c909ce7fb1b45fb2edebece3c8618f23740fb9a1bed8bb068c8376c384daa17d741060c4f0da54b43e9087936a77e32aeeeea24fcbaf5bcddbfde944d276da4864c71458b847acadcd048bbe30ed43ba4b83346b713a15e1eef0b6296e9766d42a97dffb17b802f4a44d52ed19428f5c87c0731c87450dd3005a86ae7d31d1808b2a3f7a42135ad96ce112b382cff046674fc867f5306fdc61de427fb06958c15544dec31ba71f307bafbd64027fb97fe672b42ea2ef91f6396efcbcd001a7164730fe143fb30da018a455e069583912b566fadcb6f4fd72a1f7e1105df6ce1df1f059ad772b5cdf60b2173b06abb9b63b84b07358343753cf7dea435484a2eb410f9f4c0bfa717a27026600232a016820d56120c6abfa1f3592e50d5e1bd77e76df5ea554bcf96552f5e1307436ceb623f3dc9c775bc5b0890eb4638f0f1d9b575c24ea93fb53934f41f7f06ea76c3dd245b96d6dcd522453e0bb226d2e0be4d0df216000608f3b0462b6df3f1a5fef3a485e152a6ea95f2776d82b4ec4f677b2106c4a675ba3cabc916b345197a38d2efab128cdf7220bcedfd4f893c85aa96ce62fc0680089f4776191192c690a236db01c3351567009a25e4f6b0dec6d0bb53d0024d9f1f5d225671f331a7e3a53c9bc8604f65422b41f9083cfa8d4c91b2b223ceb70013b56928befe34fd481e7dc56f1c3c773339b856da8dacec27df2bc8ad943355436f2fa3991213e7524ee502366817724e40c35f36962f6186bfce302e96750d4c3c453ba33a0de0c70aab812cdc012c7daf9d10f1d8327daca8159b757ad65b6e356a63fa3e914614b4780936066f709fe83dc6ac0423c8a5c964b0034849cbe877d17717b8e9229008f530b98e6e5d6336deb7a82e70d70cb1fc949f94eac4de5f82a47098fdd31ffe4fb2624604d937cc722d20ddea365bcd897a815f34bfed2684cc14315ea47bd7c8982c70e56d5de443da688033240f88c2cf705a37c68d61bde0da2f40a92d105180c27dc9f4e8206d05a537c0c2ae452a51bdf9713b19f70d3c428fb56e514aecb38f82ac57f5b4997567a8dbf8d8549696d8da38152c6d9ba97ee573e5bcfba3c29b0902479ee2d7248f381bc4745d46481b0b4ff536ac946d29be42eafeab84fbc82883c07220243cc82f3add095f32aff5df7a01952c5597dd457a174db9fe924f4100a70d2c3769b6c3b5bd73500266ae18c7df74da5fd523cb26789119e3ea72116b4c3b22282a08fb753d189cda92445c84fee7d2e3e3626515d609afbb9d29f9d1229e05aeff991c59e097fc80c87dcd1730c05103dd8ac294249a2439cecb274a2aaa3eea53023c9568b2ac9420542d738329618d43a3fa12763da1a7e4572364a722788446d3253ac2869ba94c82a067bb66e656ccc0383535f61724be20d1986f74ee0d5fba2847f1c65eab5dc799e0b4b9e13b75f1a4927f4d52bcbe9b747899884aa089f21e2efc5925ab086719d97c16aaf7d7648a3b1196224399dc1672d9b19a09cc2e258bf56e69376d24295ac60e96af866939adfeb66c5fb466cde85b5cf0bdcca7ce80dc1801d37684ca0e52a925e26ce85910ca5866d4e105c77723aff76a813cc99139ffc44893344dfc06bef8efcfd25ff78c2af13d8cb3279c52a03875067620d0a7f8fa9028993986acc652569620de1d312f095356c60c9d109883cc039ff85413e7566ced60af7e4761afbf163ffb1b3063fef85ce46a0c9e9674af5f1c5744eb9243f903340ed0430d610a2f24f30535d2dee4a5406103ff840acf7a00fa01fbdd337cbe332fd916319727e8e3c7a0c46a07b2da1e959e2acc65587b1709581ee7634dcdd571cc0f55ed50a05c8bb787a718720c72e097ddfdcb2e7bc49bcda760c0f5e46ad66124d57f45c6b899ac026fefbb70e5f89e73f8f03ff920953b319fb552a2114816fc5d3bdfaa1c1a7acbe7228d6ea88f823093610b07655be6385f03c085247aa9e3f6dad202dd4f4c4b54ad1b49a5188f0a8dba3ade450fab338ced21228b35acf5c6f0f3c0d2dbc04f783201345536b9fb07dbc274e3323a3f943c307fd938f98f83ce175706965e68418884ad6c9d506e6afe0afd4b3a145edf233303ff1a9e3dfa3040acc81a76e96a78d14f1b0c52bf537bb036ed2546a4e8827276e4540784f23c945d1f5263ad92f160d9a114bf28000a60dc0d77f39d468b09dc2b1e42231debbb2bc80b0c316cebfde1a8da16ae9e6bcfef73b3f24d6c45683a0e5252c6144bf0a09173a9d6e18b4a7a4ca83613baa055cf111c8a8d6ac6ca6154ea9f791694dafe232431e649a7ae17246e62e7251589e5fc56907e441efd4ceb13e9102b3e96a5e1d70420a84239d744d3c10b6fa48d927ff156cf3e58a936ddf801d97e11df2a3cb46146b12d680dbd867be0e22e515cb9a001c036ec08ff66576bd4aee7ad3f597939d8250598770c40d55fced3200b263b398b05c48f950aa3df64b34d43988cbe35e2a69c5a457b0766142912e970e948bef91e682462b47fa8257750f4eca1af0483329eddf4443b0c385d2718905aa65b47df11bffaad44b1a82dd93e20beb96fb91173fbb789f79567996c239cc2941bdad9daac3cb3a2ba18ecca2e64bcd8041150ff1daf2fa495523bc99c28420544ce345d24af041a724a393ad29e05ef4192158e0b6c62db9191f214f52788d846901988eb9dcb22b0a30c76477294faa9fe38e1280f1364535b0bb2e515c78067050696b6773e732a096ef23a4dc8b9f89adb7c38e7e6878517f0c165c1304410daa74dad6b9c4585059a364c56c4e94d9d97df8593cabef8b97029002a6eb2ea946edb308fac49b645bce024ac5b55a42080e50d22adeea7ff8baa331f05fdc4367a64fbeb798e75c5a0f60975d46a289359457d40077731335b630e91e973c2428265a458131244e1c4ae189c70ee1f08e179cff1c6db793b6dcce620b80649aadfccf812837d9b1a3dbba42552ce8587a463de352a2027199c3fb4534aac541f8db01faeb0200f1020a6b02e991199cd28c48f68586f356bf86150e1f5b241555ea9a4b7d24e28077bc1106a65c9f5e14a8c715c40e6995112348475becaf40381fc7272e883ac6f6633b82f4957a86b7ef5025bf53829be6af7753dd6e0d069fa71b5f2452f986d9a1929f74eca173b684a3a9197f30aa5a2009391981b915e058e9882fb70eeceb3cbea66f3633ae942ab76ec6a3b4f20a38948ee50c17eb031458064a013d3be3ed84096f952d87b5a09228fbe3600eee0e290f4a2c1fe2bb26d1de20810336f343ac2199ecaba2360f387aaff5671f0d010725d5b4a4366c2f4d6d14af22d77d0330c792e2024e7cf4b7bdbd9d0ecb7f7511d40e154c9d57f91b348e962012b203b94b233c3a8ad4d65f4e6add51daf1dcc424b5817608801c3b88bc4e76d4abbb7705427c693cf35ef73cea76c5a46fab772cc2e1a681d057488560466f776b5937ad5f778cc15621db7452f7643c1381d0ac200713a59262407a8112cb045f16d644fc665eb3b92b139d4e5968a9de7148d5e0dc32b185c926ffb56ea29e06551cb5ba5554ed5a0917435af41a33697bc82c03eb14868a7d6ad28c50d21c0c44c2e764b299c81350a523aa9a9e6ddda07f45a698d8d2be511206b129df60d9ed28c79b3b7fe545a86cfbed8300b78d159bb55c403b31dc920f36bd6fa1eb47b98e810391fdaa93aefca5bf2e11d91bebb65981222b0469bb275ae628ac6a51b35307dbb1e6d19dca74e71a84d22d74774499f9e9b9ddbe9e2d8f0ae9168b0a922af7faaaa44adb244f8127f4dbf3e13ac569529bb6b8c98eabf8877d2b4e078df0096fad53588db1a6570693c6076a5abb882501eb93f288018a53fa4295ad3fa9d6b4aa3a9801004525b821fe0ba4b2bf654d9c4da7867239c2ed651bf2cec54acc69c4c61d45dc1b5e2a301887bd77fe58dab89e8bfde36e8a13e12081964208e31f1369fc04ec97f6c19bf6031c0dfae7aefa09fb6d6662cfb72f60434d3e73dbf3596357d212f2cf01e69ee2bc462e9bc2d4546742bb6efa125bb0faf7ae212afe7c291715ea5c9e942e88b803424f8f3517987ed34be001aafd2d0bf8742f1e64dd871c2661429183457f33aac4541907af8931daeb8bd3b956fa6d055c1a808b6c79eff68fbfaba5944e0798cee6a48ad6e4be28f9907d2b5afdc826442f78783e4c06611755af92e0929ae9a8354921b0c31c844b9712130cbd45d719faf7c1c128f98083c1fb2dc47c06976f27df58674c03b2724773c2c6a6ee33bd323601f4fb471010c412e7b096f6ba9db200b740594364840bd5822c6cb541a31b7ce8f35046ab2b8779aa125a47bcade4942d082f628ed6f6ffbce25b8bfdb0b8db582aa6ca86a77cc01d87ebf815c113badfffcfffafd4ebd111040232a20b5137e8ecf13a3a912158bd4132f932a9a9e4993112fc215832f96f989f1d8d669e84cb947001cc3eac65adccb10e3796f55d836a1c0517fe81f3ef2dd456904b4e234778a0866eefd03c317ce5ef2eb7f7e76ab5dfe4412b703021d2d17026466379df793e4ea91fdbd9decd218f666c01b2b6b6986f9ba1bf688592da78fdfd0401f0afb575e534275b70c1a1f4c92dfa973037620b4736779f674bc89dcc06d1460d8427f0428362576cbfd31f69383847357a11316857996e464b6eb15c5ee3f6f09fac1960c3b482cf87e5379e0567d7b62c7ed3652bf49d128050c07627bdb44a504c127eb2d91772a12718b2e037da3886304a4c8f5ab1a48b5cfd7be51d4d1921a84faa01d56c7e49856e1b6619adb789297384d50059ea9b29a60b4b128f972658c7f8f9be2b053eca71feb405d1cc1345ac0be4f8d06a658468f2d2d7da44ba35788478b74227da62c2040072dda423d2f4e2c75eecea01531bcfa501199a8638b3fce5aeaceb324849eab0160f4db40f3e3223b6327b44869f02a3605edc7ee625f2187406c9229cdab99aa861f60d96f2e329d3dd639d71be51a6663f896f709ad3e70d617c10abcb59cf10dd1ad42c8cb17844eedaabe0085d286349a84c8c81e0d442c755837905f44c3ea96f379947b7e7e5deb821b2cc9c4613ebffa0dea74aa0d25a41164a66284808eabef62f0e4cd246cf34fd9cdada10336fcb3118ef6d18c0bb991d0e95ab68dd1478482c020bfe1f620db8ea57576c0a2825d468692813332ce14276b3ae935e4fe4f9c655d65fbd0e3ef88829af026e92f846ff660a92cc6377f4efeceb0b80c07b31880e50fe6df4bb2b56061e083545e43addb0872a389cef3f706cb90e7c285acf274a244ccf08d8b259666a1f0047d0baa53883cfbbf5330aed4471b034d064fdd93687a914df9cbc66c6ddb385763a8938a5e7bb34647b61c13a109e625ca9eb1740614c60a04ac83794d7efc960fbbdd2dba81c715f6f21e9393e7eb25fdbabd7b00770c5ab889ba32310640c9fdf84fa05e0f63502cfe479b4409e8818b5126510024b3e02ae1da22802cbcbb5df4c3d4d8ecee54792ba0945a75541648070530ef62fe6dce1e7762cbefabebc1ccf6bcd32541151382aa661163bb32e01baacbd56a28b52e400c8c54766bc11bcfa74c640eb8dac96d8061d22ceb99054a8ce58919ef1559ba3d979b1aa1d93ee88296c1fb733de972c7e9107c833644a9dd5c9203c02a5bb56686e0f5508cde13a32b93b415b36e4ebec72c8bcf7cdea83d05bbd32c6930fd9d044ef5e6a68ba74987c7f00f914188c2437247691c081748b50941383b727963a18dd41063dbb49a6a79c4267f4f2a6ff57f4daeeebc7d523d731719a069737bea3f868fabf39e4566ae3a1708cd7260841c45e052a40c123dbaae2757866c438a4a51bc81d0c0055dd4949126436355ebaf1b9882b26ee66035e1cc5544d056770aae8a667aed5ff245fb917e2dab85da91c584c20931ea44f6175aeee7f5c061aadc00374a2096128d70683b8e54fb7e9db4be8b9f6755cfab0949e731d89994f7e2136afa9b9ee89eec7a1047b137704c1ebf35cb77405acfd1913d2046d4fb189725c71c705f829ccff3396682bf111ec5904e63ae169d5cdf0ce6b4f107b7c61e8e46fba7355c40bcef351d90e6572567a0b08301bec5161c4539bcc89bc0c4853b18f7348781db0610e01462bd3d5d9a40b51ac4ec921cf6fd8fa494f59bf5b0c8cc80cce4bc541ae9c18ce544f2f635ed5574c0893b39ccd7b4e77242f3670c9a3952f3fd8ae3b494511e8b5bbd8c706b5f388bea467bf8393e74271e0f8b5f82d9e025cea9cf573d8ce42478e7faff1218df3aa695ce96585949434acd930e72a0255f70beebd384c24529bedbf739ed991d001fd40cb032c21c423904ba892a1815c3f75d6d6b8b54c622bd27866c0854472148be378ee1fdac92b8244ccd3e150cdf8d9e9077face1450420693319361494d4c9bde79f892dcc7632bddb95b50f1475f244a3ff8117becfcdaeb5bc89c1839752828921a382612d109e2b4d9febe0dbe773b3739628a20db64df4614375c673d96121977b3c3b4a29587acf18317dc7e9a7bed09e9e76f703cac0081c5867d8b8582aa68d99150c0a43be35e6f3507c12ebfa3ea933688c4e1ef09f20ba22b69302bf87624ea27ae0f1025c08846745fdbf5cea28a14ff38b25989d4d5309b5c3adbb170ddf153add6294a62cd4fb54097220bb7ac0eca3c3844a9bd7d1e16ff3e4f70c83ee6a8e0802accb35d01bc170d953ad811eeaaed5de96229f9ddbca718c3f3dd36cf553601d1359f5ab66d89cbc59c1e3226430eaddc65f511583d0d8973c661520c38f6c6e6aaf2292979db23c0ad99dd0c70526b64c52d6676974eb9d45653a3e903e21bbf497e97a35f82c688631af04f9527889f4bab99c7792cf1ec49a4e19f14a12e59363faad37d5d0a283bae57d21c052bb790fdad05994e7407ea955946238084b782c2d349214451550b839e342bc8e3299fb18c2eba262c9d254d1fe13f9c48720448da6f9707cadb86af64e3d83b643f189c89192ecc81c8f1d91c02da092ca800cbe81672f19f51416c15d47e9e41047de595bed4c35f9b6523b328609faf74c7a925d6d42d32eddfbbeaf5c95ef9c4e8731aa45747f6a9916723deb59702f97006f6832c4181956993d9c54d6f6bdfcec3a001e77eae13e9d46a920f7723ee32d4aa02425902612c404eab0983cff97cb32a26406ac3f2ef40e1a1a9c7b0da23cf296e38722a1f8374c7617d967c4d835e55a6a86d5656bd83cfa4656afab2de605d0600967513b525537ad0f04e72d456b49966842face4fc7dc2f3e3114144eb5e056a4a5f385766c4c10f6e07b08395824b4379e00b829939934e287ecb776be00e0350043c48eda0a75375f46f93ec9a30e5d256988f00ee01016c8a4e25d1aacfe5281b99a17ddaf6743d01b5bca12837b10a689b8db1a75ec64c14adf8797ff924242cdc108574372f44d05803bb39945c794213dc661b79fee593063ea1c4f6084ea437d21b82eacc664994a32e6181a361d91343f3544a2f39852e17aa00d284a230ad161ba206493d08d035f57f83e3ce2f86e4a8be862f76f08e28d5f75e6d45878e1d9a371f28a439fa4f8b56fb84a4241cc063f2e9b84634e511fcc4537f35ab87191a49f31f83c8f9efb8cff4b9e89f786c9fae2d953612d78356affe09b32b09b2f0f2e6e3a17d712e659bb41e45dde3ee2646c0f7e29720c143265a1a8f1fd8e9d16bda743e2d752ae9b503f3270ac2738f31345a625d7b1fd4698215edf638e5ef3c4d30284af91003ebe98f88d5889fdeb5fd0905ab0ac8061b4c7d84ec36659d1f72828b1ac5743409bfc119f9a47bcded2af5d8f25cf5a9754c83f3ae6d8bf499381643b85b57558b794cdfdb27f20f568802c00c344c9e32b7e03c053b31479f0e346c4bfd14cab5e5d406d22f22d59318a760bac928924b08ca21edce7b8904beadb97875ca8901cf7b6a3af8e6d947326b40cf7454977f82ffb231878f649ea06061c5a528aa8b188d50e8a3ffd759c60bdfb37e34eefa544d8cd5d9570f73dbe8c830bda3c1a12b48a08b3b445abd6fcd26639e61291db505f70b137c6f9c03d7ff22ad120914f08d805e05725c45305c58a080845c3db738fd05df30fbbeea19149928e12969247c9e6f8e0df86bccc2a387f6a1c9361f2e0cfa2a3f10304dd8372b4007c6f08436d5ec68b205d60baa593e7c2e56b0b0290248fa7eac5c7d4edc77df2baa417616b3535ed5c492f6cb5d96beba0d74ca7f40270b283c241bb48f4b86a2a9ba85e83c8a5d1e962eb5e70044881323c0d28cd8d83913121f9e2091966a74f686c6d02d3e41eb18028ba5f244ee5790bb62298dcc8f9ee840f8c9e8b266787cdac097a07b49d46c1f0a41b2e5d14d9fb6f889f6acca62c1173a2840069ce51a9690bd7095087f61af0fad4066ff5c43106d9fc931a3387204d40f75f6ba2bf0cec46222d694fcdc939a0d0f100bb6779b0d752b705ee3feff3d40855c79376885fefe711775c5b8f3fd86116572fc438b7446960975792ec62cb941d162b5a34b2523007ab0384e98e7c98024783b9a461e27b878c1502ad0da99825aab5028ddaef0c8276084e43e5ad913f4a525f59663e338c8817a19d3e12c32f92dacb19f5339751ff0e4954b1886163d2355732e5bbe19f1a7dcd7bcf675d00517b11b1093e640711ccfbeac54419aee47c0fec9b1ec31f966a25351ec8b6828b307ee6d4d508e9e0e4967ee52e2f1ca3b5f61cba6ed6e2aa89f9b37deba8dc492547591ebe6d83319d41bde3e81b1c91b5965d2448e9ac466447a3a8136d9614e617354756a5da6c9288de01ab5238ea0fa1bf2108776dd957e3cfab33c0323e7948e2b8e5aa6fe41b8910e3975d5ca85c2608165cee793e5fc2a3bef08cd89f9686e59d29c17f5146f87d308c9cf3613306cd3315f1159b6c41fb4128b7578320c074bc880be113b73003c8cbb72642c0848c7848905752e28379202c2403a6ae700c6ab85533a663bca1c12fa09412b6977164dd1eb0e6dcd4e8f4c89cc47683a3b33952e0c7f106c61188b2af760dcb24b924109d71b33cc0842d6616f87aed58211a09d47fa0e8deaa28ec112bac4c1c501e1d4198e9606477ed50048d70dd22d7785ae253ac959bf6c1bbfe417559cff076b6e32e31e3c270dc25fc535ef8c7f1665115fc5077fcf0f5729e7de2cd799a7bbf0a8b3474dffe8ddafc79429198aaa039e1c180ac7f54e10c4c60dc3c1aae158a4762123df9f473a5a4e40b49125ad59591b3b27532f2e5d4c565f78657b1f513f34ecdc473cfbdb98868c8ee42db0463ede2347b9826009bdad7acf3470b7ac26279694df099aace151c440f7a3d9871ae0d2dfa52328aa76ac5df544841f7cfb01d456fd44c8d8a4a4fe26524f7ced4e95a858bad6fb48cb7e7f56ba730f6484566393b565b07f1088d9d251dd32791244d16439419c5b2324da8a799bc2b38a9a484cd4750eb80a72134db7f275c64d30e4f62a5373781be54733e7b85ed48f53854a1389dfc3c3930de8c2ba8085c9dc12b5cc11f005ce60dccd142d7e22c523131ebcfa1907c11e12611c76c576c3cc8574d4aa4b2d61dd742e4a27bcbb032ea2c6468f626e1c8aa58ed176cc4d55e692fe009a77705c1a9147ce1a4999a2c2691eefa58de09d845fff8eb940210c1ff14232a42730f3ee78b3a1cca834e20d4d200fe234b46b4067bf887f63286d7849e31a39b2ad223253a4c26f5e144c3a323adc2ce0f5ecb50d6a719cdf1b2f55cd221248908ff3a70cd9d20063715c47845637151adac85d69cdde36e23cf909cb4545f8290ce8fd36d3a919b5bf601930c54ca5961ff70a86a2f297c414e24719dc994075da9b180d768e7996cb4fcea1a0ddbfe9d3ff420603927e380a9395b78708768e5ef16b207e3f5762504339b9675779fcb5f283d8b4d8837c356c28ae3f7e45a1c922132b3cfc5e60acf5d936e02ba8df4a8780cbddac11deea8313d680d355950c5e5dad6a76b428e70f6d9a81c17f32c50f4f3d7093d77d16fa56edba69c8b3bbb22a9dcc1c0b9f3d122b1af9c58b5b2fe527ecabdf0be6b6443f2238267a558d4b11928a3ca05ac6e6fe181a2ebc0c4aba3de117742384398eae4dfdbb053c74cddb70b359147ba42ded66097f6ed0bb551f127ef474a6f605b712d0073473b75856329c4bf8b118cf965d32e1f9de46621b93fb8ba5660d937e67f8101f28adfc002cb51a611b507c60a2fc56c608cde03d6b8a4b6e8a192de2ba14289e3e7eac74a9d32bd1008e569bd194292723f94ab82cfa59cdb5a5a9546bfd76f0aaca02c3b28ec9a761d17bba7f543c959b1439af51f9ace546d6cb55f81a04bd9a89be491938e5d8179f216abd70d4c0033a4b07dc9797a302eb3abb141f0164a49c989a6aa8c274d6907e659759cebcde4117e1ca071628f85f7cf855b16d88ea64caad1e7a17cb1a18f238c21295f81dfc8d08f4d5fc2601cd03954e7c4bf8c1aeb9ac46b127bbdf3bbf017b402fda9d53907f08c7d0b9641a349fe788afb5cb26967b8601d9c6f25131530afd3e1f00a3c7c62f12b78418f5242a22a54379d8305d9a323b678e43ee0b6c1362fa0c11b4ce0accc05f31f14ecba05e824464478055914ef0a76808f04f80700e9ff2870b855f270942f43759e597d33203997717e9c3cf383a19f33f4311fc938db89cb16a83b271a84b79ceecac56e3ff98a0bc61c0b37ae030d89b9813698a72fc93431f04aeb1401e3c11fd9041e7f1079e77158ed7358a51b054766a04c2c4e66721a94b7503d0a0c39ffa5bd62a28ea90518efe0a4c5bdd6d0cd4d37543098be8e6bd8e815a7949f3668972937590b37a0c182a9618703524999484d9137b313f306d40f90a31588dda6c390763d03132a8290aa9181185f09a45758114b7b62d8c1565393530e472116c1e69dc79d4df1555335ce8e261b8b7dbe21c26714cf3f6b56aa1237862edf3e1b5ec650393f0c05728a358e660ff5a5c777c5cfe02e1e8b4b6917ab96cc71bff82f635d90183f22bdb19bbb01e033aa54034d068c9ff6a22954c617b3296c63c4c413353400fbe123526433945f59524a8087d3b2bd81599a852405399a567109737fa772c858c20205e4658a672dbca514714210a9749657a73accae1fc2dc4f6d76bc84e2977591ff569c37e598613df180788a4289d28395beaceaa8cf787c28aa28f8548205bf76e5cfee9f67ec08d4433cc4b8d95bf446d5dc9e9746840db45d9e1c9cffd1d32be302f119bac4d9143ee999692b015c2def30ac2ad52f73f2fee9b5b3bb577ce3a5eb8ec2957fd88c012ebc6ecd93edd475c5c91f753adb8bed917f43c918a3167b58308609cf09564c4c839acf051a59cfec5ab8f3a5939458781b4df525b0c845f282273435e4672fd71c110da416fbe0265f81a106829fb9f6c814d59273d25dc8a4ff2e0fb62c70920d589ba46b13373dfa18cc21c1f205838591279de8c88b68a55fa8cb84679cbab6cf847f5c7074bb0a9d0fce692f705b82e267b0e480a696eb2646d55ad90e030ead8821eae569fef7c8987de38029c92c9ec1306fd993a48f23a32814e05dd7e11531103e9addebfd66096b8a2654973165175e0819f8f02fc0a6bd63299e7839b5ae0d311be1de5391ba37891260d172db3d83f171a2e0342cae8b0ad20aff11c2d2f3c0c54a7eb3c0cb3aa86c3f0b2eeef66d606b9fbcc0bb6ea009208a854ee70c1c9ec9a7fa816809e2cbfd6546162b8299cef1301ceb32ea7e748ae114241ae4ad8739c0cc551e272dbb535291604d2c16f98648f9f28660e631c10aa9ae7713a9ef67a5f4dfd4cb5a6222e271703274aebb887b5fecd8d4985185d86844177a927112619042291fe5808dc754d4e0b1c310530396778eb0513b9c43dd012bb88bc917f4e2009bd3da5f69f7e8ac5ecea5520c5f04ef943dc024df70fb08c17f0480ed939b59795d83dcfd916500db34e321c2c0abc4a9c9b3de0526053ef411cdb42936ecd91222d51be0e9a76be6e35885f8121517b2e360c060da4aebea1d2f829dd05dbd8db1902bb4b1057a9726a3ce1c6741a77c4117482b257555b854f0e1d1533bedb686b64d3563b8a743a5420095777e6375ea8e72a05d1a63fc13c71a3df9167a38d0de85faa8ba6cc24a68d71e760c64c0fadab9ad60d63b6cbf1913939431e013f79408a1f6b5c67f5a2f3048e17a5f28fb160d7b9b1c86880c5a468ed76429fdcf851d7e2f45be4aa2be342d0b0c112123d695002a7bb22976458b4bdf600a8e8c9155155a97aaf3c073ca225e620ce07f7b8dfbad3e7f843b466881f981a37eecf5d80f0ef5fffcabbccee87bc3767df15cc6d7d66fb12d256963549bd83e7ce2afd797aa1214d6e09d33176d9c1a61c94982fb04af058eccbc75c1fe59b20fb55264398408d8ec15a41b53dc873a3ea51a68c6d0f128289f5d4dabac90498d9809949c0eb7a6a84b7b3b04d98abd244b3b60433ebcc1f6f1f12bb3d6dc13a134a6e53f69de71eb12445fdd261ceaf320c5e38dc3c9b9edc4e7b1326f42da757e7b0509b892c48ab2f225a1926ce88befe00edb1e702efaa478a3c9520c3ad2156263facd44c8b5b82dfecc0019629b376e6074c63549f8d500170e164825f49f056a3cc0f4f0c56634db261bfc76ea4ceecf0e47b013d49477cfadad6426c71570e05996526c1f1d62f3135d773cb243e24ccef3f99932c1a393d8d0c32fd211b2b2055dea62c62ded13e8bbc263c7b30539cb1e934266ab3807838ecc85b0136e50ac404a3be989f06e9ecdd53b68bbeda76a6326e986262392021f90babec5067380edbe236d62d917d85f2f1b6f74494a07c3691648fdfd67ecc3305b209a2092d55b00ee0375314d9bc9376cd450719671f6ea85672472094105afd5a026c59ce02c1fce0cfd7b5def85c4a0feb6fae1ab9f3ce699cbf959b87e293843208ec8edb70e3c87a7bbe1e11673d51c9737ab06db2039e058bbec667a89d03a0c6c707d6c32dd19dc679f0022b7ccf36bfc3c0bb9ae7e8db5db9c30c75573e37f82d9f4b31d8d649e97f10e754444a54b45004ad4a1c26b7d78174e78d0989476b64f5798f15d604f2eab43243e31a331a49a66387f5e538e82da009eabaa18d9cbea294c92ed7aa8e7645a0472b9c5f1c53bd375cb6eb48cd32d2a93afb9cfdcf68ea3b1d186f188f69181127037ad4a657a5d8e1a434c686836ad616e25fc6ba170b249e634b7fd48fa4df1a58513ab7369d1b8af1225e4196231a0d7b6466e5dd9910a561f8e307f5ae79bb0e61d07876cd3b5bcb8982ca21a58ce476475decd1249c96ce3b5eb304740a7d4e34fbab93661c472330f7ede1c0537ebe6c2e6afcd1c0dd891c36e67f2ae34e04d45e0eb3f99a8838e651020a5e85347afc361201c02ec8d30d94081d4fa74626bf381a57e2e358527990deeb63dedd09bdd3d1216c79490328ea6f73f2ea7297e1602795390d2855a0a5caab4fb81ea21920f4f11a7c4672bb15d50d8e37e7b97e2b4e836d32ce2aac99e874fbe6557ab30a42f9212515c1d7a0852fa4483f2bf0429e353eca79e37173400aeffa7e1136e64873b29223bc92a5c572d3aae6fc315971d14ceace0df3e3a90e682055e4c2311e063f660ab9e88384660b758b9fc0a537ddd30111d21108fcd203e208c40bc544bed0924414b35aa9afd2c3cefd4b3e9fbc299bc2a76f958f1a439a6e25ac496893fdcbe2ecd1a41b00f69cc58f7ec98167bca79e587c0d141faea63a11b1c9a159d8bd025a089e700c55346f519044c5068230fb1f94e807e676c1ae2fb7467cb9139d404ade0fb9f41f009d73a47947cc89eadff7d1c09cb8ff30258bbb315435247fb2e6683bcb97673eb25956ba4c009cbdf22b5471c7b34a80eaeb1ce968311d32b8148ff9eceea7d9cb5eb505619eb48ed5e7eecfa2e59051c30aa606dc6fcfb9ef689cd34eee5ea405e54ab18d5b34e6f7a602fe5cd86020963605c63a8bd0dcdd38ae3d916fb22c5728e84c27509ca27ecc939aed9dc49b78d78a87d91cb6630757b45a4356d5339787d9e803f1be5561599f8d23bd5fcfa3a61c8d113675759a06434cf530e881389e25fd8d345ffb97f5e6a2637d39ab0a276c8f9f428b7dddd1f74a7f65987f457ec8a1a01938103084dfa62adab4e19768e7245259202875c7c384007ce95820ccdf9fbc38ebcd52c779c78ac55305113dac841f957a072ca58443]]></content>
      <categories>
        <category>神秘研究</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠀMaya/Rigging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 高效使用指南]]></title>
    <url>%2Fposts%2F1c2d932.html</url>
    <content type="text"><![CDATA[通用 File Path Editor 可以解决 Maya 各种贴图路径找不到的问题 ctrl+m &amp; ctrl+shift+m &amp; shift+m 隐藏菜单栏 alt+z alt+y 摄像机位置撤销 Maya 递增保存，备份保存 optimize scene size ctrl+shift 左键 添加菜单到工具架上 标记菜单 shift+右键 对象标记菜单 ctrl+右键 对象转换标记菜单 Q W E R+左键 选择标记菜单 alt+Q+左键 选择对象标记菜单 shift+Q+左键 选择对象标记菜单 A+左键 选择全部菜单删除历史 O+左键 选择标记菜单 U+左键 绘制标记菜单 右键图标菜单 文件打开图标 打开最近打开的文件 摄像机图标 切换摄像机 网格图标 右键菜单可以快速设置网格属性 隔离显示图标 右键菜单可以快速添加隔离显示的物体 首选项 文件选择窗口使用 os native 可以配合 listary 发挥打开文件的最大效率 Viewport 2.0 选择 DirectX11 渲染 ， 否则 DX11 材质不起作用 Remember Size And Position 勾选 undo infinity autosave 选择 按住 Tab 键可以进行拖拽选择 + - 可以调整操纵杆大小 Q 键选择模式不会受到控制杆的干扰 通道盒中键拖拽 ctrl 和 shift 以及 ctrl+shift 键可以调节数值精度 tweaker 可以不借助操纵杆 操作模型 开启摄像机模式选择 camera base selection 动画 曲线编辑器 按住 K 键 可以自由拖拽时间轴 , . 按键可以跳转前后关键帧 加上 alt 可以前后帧 alt+v 播放 alt+shift+v 可以跳转到开头 快捷键网站 取消顶点色显示顶点色配置在模型上，部分窗口也可以进行配置 批量删除显示层层的菜单里面有]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>🚀效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 效率提升指南 （二）]]></title>
    <url>%2Fposts%2Fccde0edd.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近在 B站上找到了一个专注于提升电脑效率的网站，里面介绍很多东西也非常受用 B站 网站 &emsp;&emsp;上一句话是我半年前写下的，给自己挖了一个天坑。&emsp;&emsp;终于过了大半年，我开始回来填坑了，而且上一期总结的效率指南 文章链接 的使用基本已经融会贯通，&emsp;&emsp;好用的工具都是先发掘出来的，后续找到的工具都是一些细枝末节的优化。&emsp;&emsp;不过也可以提升不少的日常使用体验。 Seer &amp; QuickLookSeer 官网地址 QuickLook 官网地址 &emsp;&emsp;副标题提到的是两款定位相同的软件。&emsp;&emsp;都是将 MacOS 里按空格可以直接预览文件的功能移植到了 windows 上。&emsp;&emsp;其中 QuickLook 是开源免费的，我比较推荐，后来就将 Seer 卸载了。 &emsp;&emsp;原本 QtTabbar 也提供了文件预览的功能。&emsp;&emsp;不过这个功能非常不全面，比如文本预览以及一些 Office 办公文件的预览都是不支持的。&emsp;&emsp;这里 QuickLook 装上插件之后甚至可以预览 Obj 文件，也支持 PSD 等等文件的预览 &emsp;&emsp;使用体验也非常简单，无非就是选择文件然后按空格键就可以进行预览了。&emsp;&emsp;不需要预览可以再次敲空格。 TeraCopyTeraCopy 官网地址 &emsp;&emsp;比 windows 自带的复制更好用的复制软件。&emsp;&emsp;我自己也没有做过仔细的比较，网上大部分提到这个软件使用逐个文件复制的方案，面对零碎文件的复制速度更快。&emsp;&emsp;不过复制速度本质取决于硬盘，个人使用时间不长，感觉还行。 Mem ReductMem Reduct github地址 &emsp;&emsp;这个软件可以自动清理内存。&emsp;&emsp;个人觉得小巧可用，平时感受不到它的存在。&emsp;&emsp;我设了定时帮我清理内存，还挺好的。 PowerToysPowerToys github地址 &emsp;&emsp;微软官方出品&emsp;&emsp;使用 win + ~ 可以自定义 win10 窗口排列的区域&emsp;&emsp;按住shift键拖拽就可以显示定义好的窗口区域&emsp;&emsp;配合 win10 的虚拟桌面可以玩出很多花样。 &emsp;&emsp;另外提供带撤销的批量重命名文件工具&emsp;&emsp;只是功能比较普通。&emsp;&emsp;其他的一些功能因为我 win10 的版本不够新，就无法体验了。 Aquasnap &amp; TidyTabsAquasnap 官网地址 TidyTabs 官网地址 &emsp;&emsp;上面两个工具都是 nurgo-software 公司出品的软件，我觉得做得非常好。&emsp;&emsp;针对 windows 的窗口玩法，又玩出了新的高度。&emsp;&emsp;只不过这两个软件都要付费（有带限制的免费版），而且功能有点花里胡哨，不是刚需，我就不怎么用了。 f.luxf.lux 官网 &emsp;&emsp;很不错的自动调节屏幕亮度的软件，可以很好的保护眼睛。 Dism++Dism++ 官网地址 &emsp;&emsp;非常小巧且使用的 windows 工具，比起一些全家桶的清理还要厉害。&emsp;&emsp;集成了很多 windows 的黑科技功能，比如系统备份。 Sao UtilsSao Utils 官网地址 &emsp;&emsp;实现华丽高端大气上档次的 3D 菜单，默认通过 左右键同时下拉 启动。&emsp;&emsp;提供雨滴桌面类似的桌面挂件。&emsp;&emsp;体验感觉过于花里胡哨，菜单有冗余的动画效果，不过的确是装逼神器。&emsp;&emsp;我日常还是不怎么使用， Listary 之类的实用性工具更深得我心。 RocketDock &amp; 软媒桌面RocketDock 官网地址 软媒 官网地址 &emsp;&emsp;两个都实现了类似 Mac 的任务栏效果，但是无法和 win10 的任务栏深度结合，只能当个启动器。&emsp;&emsp;软媒是国产软件，有点流氓，要使用必须的装他们的全家桶套装，不过网上也有一些提取出来的独立程序。&emsp;&emsp;个人觉得和 Sao Utils 一样可以用来装逼，但是实际使用还不如 Listary 启动来得方便。&emsp;&emsp;曾经有用过一段时间，最后还是觉得后台程序太多了，我就放弃了。 SpaceSnifferSpaceSniffer 官网地址 &emsp;&emsp;超级小巧，功能又非常直观的文件大小查看器。&emsp;&emsp;通常清理 C 盘我都用它。 DeskPins &amp; pinwinDeskPins 官网地址 pinwin github地址 &emsp;&emsp;两个相似的窗口置顶神器。&emsp;&emsp;其实窗口置顶很多软件都可以实现， WGesture 或者 Capslock+ 都有相关的功能。&emsp;&emsp;缺点就是置顶功能无法可视化，而这两个工具可以给置顶的窗口添加个提示图标。&emsp;&emsp;DeskPins 是很老牌的置顶工具了。&emsp;&emsp;而 pinwin 是参考 DeskPins 做的，更加简洁，针对性很强，很好用。 7+ TaskBar tweaker &amp; TrayS7+ TaskBar tweaker github地址7+ TaskBar tweaker 官网地址 TrayS gitee地址 &emsp;&emsp;这个工具拓展了 windows 任务栏，而 TrayS 可以美化任务栏，让我的任务栏锦上添花。 &emsp;&emsp;上面是 7+ TaskBar tweaker 我自己的配置。&emsp;&emsp;在任务栏 滚动可以切换没有最小化的窗口。&emsp;&emsp;任务栏中键 可以快速静音&emsp;&emsp;任务栏双击 可以轻松切换任务栏的隐藏&emsp;&emsp;任务栏通知 可以通过滚动调节音量 | 和 quicker 的功能又重叠 &emsp;&emsp;TrayS 可以实现图标居中以及一些系统信息的显示，还能让任务栏透明，关键是还非常小巧，占用极小。 总结 &emsp;&emsp;以上就是我收集的一部分非常好用的小工具合集。&emsp;&emsp;大家可以各取所需。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 效率提升总结]]></title>
    <url>%2Fposts%2F82cd243a.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;经过了几个月的使用洗礼，总算是可以总结一些非常好用的效率软件使用经验了。 效率软件经验总结 Listary 收藏常用的路径 Listary Ctrl+G 切换路径 Listary Ctrl+Shift+c 复制路径 Listary Maya 打开窗口改用 os native QtTabbar 批量重命名文件 Quicker 快速关闭程序 Quicker 打开映射盘符的真实路径 Quicker 朗诵日语 Ditto 记录不同的路径进行切换 WGesture 常用手势 Capslock+ 个人魔改 中文标点输入 Windows快捷操作 操作参考 Ctrl+Shift+Esc 开启任务管理器 Win+e 打开 文件资源管理器 Win+d 显示桌面 Win+x 快捷菜单 Win+v Win10 自带的粘贴历史 Win+s Win10 自带的全局搜索 Win+Shift+S Win10 自带的截屏软件 Win++ &amp; Win+- 放大镜 Win+; Win10 自带颜文字菜单 alt+d 文件资源管理器定位到地址栏 路径上输入 cmd 打开命令行并定位到当前路径 .gitignore 这种文件在 Windows 平台的命名方法 鼠标中键 或 Shift左键 开启更多程序 Win+r 运行 固定 Windows 程序 shell 命令打开系统内置路径 %env% 打开环境变量路径 命令行操作 cd dir rename copy start ping ipconfig where 命令查找程序位置 sbust 映射网络地址 net 连接网络路径 taskkill 杀死进程 &emsp;&emsp;上面就是总结归纳的常用操作。 效率软件经验总结Listary 收藏常用的路径 &emsp;&emsp;Listary 在文件浏览器中键可以打开它的菜单。&emsp;&emsp;菜单里面可以添加一些文件夹的收藏，下次可以快速定位到我们需要文件路径去。 &emsp;&emsp;点击菜单的右上角添加按钮即可快速添加当前打开的路径。&emsp;&emsp;添加的菜单可以在 Listary 的设置里面进行修改，可以加入分割线和子菜单。 Listary Ctrl+G 切换路径 &emsp;&emsp;Listary 的打开窗口有非常便捷的操作，通过快捷键 Ctrl+G 可以快速切换到当前 文件浏览器 打开的路径上。 Listary Ctrl+Shift+c 复制路径 &emsp;&emsp;Listary 和 QtTabbar 都提供了 Ctrl+Shift+c 复制选中文件路径的功能。&emsp;&emsp;这样就可以通过 Maya 快速打开文件，而不需要复制文件的父目录，然后双击目录下的 maya 文件了。 Listary Maya 打开窗口改用 os native &emsp;&emsp;默认的 Maya 打开窗口是 Maya 自己写的提要统一 UI 文件浏览器。&emsp;&emsp;好处就是跨平台 UI 统一了，导出 FBX 之类的文件的时候，右侧还可以直接控制导出的属性。&emsp;&emsp;OS native 其实没啥缺点的，反而没有 Listary 加持，找文件会变得很辛苦。 &emsp;&emsp;考虑到导入导出基本都是用工具定好规范进行处理的，因此这点牺牲不算什么，但是接入 Listary 可以让 Maya 打开文件的效率提升很多。&emsp;&emsp;而且某位大大说过， Maya 这个打开窗口有时候会导致 Maya 读取文件卡死，还是系统打开窗口比较靠谱。 &emsp;&emsp;如图所示，进入首选项，将窗口风格选择为 OS native 就可以调用系统内置的打开窗口了。&emsp;&emsp;调用系统内置的打开窗口可以调用了 Listary 来快速定位要打开的文件。 &emsp;&emsp;也可以利用 Listary 的收藏夹来进行文件跳转。&emsp;&emsp;只不过 Maya 里面会有 BUG ，别的窗口会自动盖住当前的窗口，这个时候需要 alt+Tab 切换一下就好了。&emsp;&emsp;这里面也可以利用 Ctrl+G 跳转到当前打开的文件夹路径，打开文件会更方便。 QtTabbar 批量重命名文件 &emsp;&emsp;QtTabbar 内置批量重命名文件的功能，虽然功能比较简单，但是足够应付大多数批量重命名的情况。 Quicker 快速关闭程序 &emsp;&emsp;Quicker 可以获取到程序的 pid ，通过 pid 可以通过 windows 命令 taskkill 来强行关闭进程。 &emsp;&emsp;这样关闭 Maya 速度最快，虽然这样所有的首选项都不会保存下来。&emsp;&emsp;在应对卡死的 Maya 的时候，就不需要在 任务管理器 里面找无响应的进程了。&emsp;&emsp;有时候开了好几个Maya，任务管理器也无法分辨哪个是哪个，这种方法就可以直接结束掉我们想要的进程。&emsp;&emsp;杀进程的动作可以参考 quicker 官网的。 &emsp;&emsp;我的动作是我自己稍微修改过的， {context} 是 pid 进程的变量 1taskkill /pid &#123;context&#125; -f -t &emsp;&emsp;-f 指定强制终止进程&emsp;&emsp;-t 终止指定的进程和由它启动的子进程 打开映射盘符的真实路径 &emsp;&emsp;这边利用 windows subst 的命令来映射虚拟盘符。&emsp;&emsp;这样可以实现本地的不同路径通过 虚拟盘符 实现路径统一。 &emsp;&emsp;关于盘符映射工具，我之前通过 Tkinter Gui 打包了一个 windows 平台的映射工具 文章 &emsp;&emsp;但是这种路径会导致 SVN 无法正确索引导致右键菜单的更新按钮不在。&emsp;&emsp;之前的处理方案是需要在映射的路径上重新 checkout SVN的对应目录，从而生成一个 .svn 目录，这样右键更新就恢复了。&emsp;&emsp;如果 SVN 目录过于庞杂，这种操作就会比较麻烦，所以我想退而求其次，直接打开原始的路径。&emsp;&emsp;于是我通过 Quicker 做了一个自动跳转到真实路径的操作。 &emsp;&emsp;这个动作已经上传到 Quicker 官网。&emsp;&emsp;实现原理基本是超 Stack Overflow 回答的 https://stackoverflow.com/questions/1299814&emsp;&emsp;只是将路径修改为 Quicker 获取到的当前目录的路径 Quicker 朗诵日语 &emsp;&emsp;有时候看日语文章的时候，这个功能对我来说还是非常有用的。&emsp;&emsp;虽然我也自学了 50音图，但是看文字的速度还是太慢了，看文字也是读出来才能理解意思。如果可以直接朗读出日语的文章，我大部分的内容都可以听得懂，而且比起机翻更加亲切一点。 &emsp;&emsp;朗读文字的方法也可以参考 Quicker 官网上的一些动作。&emsp;&emsp;基本原理其实不难，通过 vbs 向百度翻译发送朗读语言的请求，然后通过 vbs 的 Stream 将生成的语音文件下载下来并进行播放。&emsp;&emsp;这个过程完全后台执行，我感觉非常好。 Ditto 记录不同的路径进行切换 &emsp;&emsp;有时候 Maya 需要打开的文件路径在好几个不同的文件夹里面。&emsp;&emsp;这个时候每次打开文件都要人工选择一大堆路径才可以找到正确的文件。&emsp;&emsp;通过 Ditto 的快捷键历史就可以省去重复找文件的麻烦。 &emsp;&emsp;如果比较常用的路径也可以通过 Ditto 将路径收藏起来&emsp;&emsp;通过 Ctrl+G 可以打开 Ditto 的收藏夹 WGesture 常用手势 ←↑ Home ←↓ End ← 后退 → 前进 ↓→ 关闭 ↓← 退出 &emsp;&emsp;最常用的手势有上面几个&emsp;&emsp;Home 和 End 浏览网页的时候可以快速去到顶部，特别是搜索引擎的搜索栏总是在顶部，可以快速回到网页上面进行搜索。&emsp;&emsp;后退 前进 通常在浏览文件的时候使用，&emsp;&emsp;关闭和退出通常在删除网页标签，文件标签的时候很常用。 Capslock+ 个人魔改 中文标点输入Capslock+ 个人魔改 github 仓库 &emsp;&emsp;这个操作是当时看网上一篇关于 AHK 解决中文标点输入的文章学到的，于是我将它的功能融合到 魔改的 Capslock+ 工具里面了。&emsp;&emsp;简单的意思就是将 打字法 的中文标点输入取消，然后通过 AHK 实现 HotString ，两个英文标点自动替换为中文标点。&emsp;&emsp;我觉得这个操作用起来真的很舒服，敲代码的时候再也不会因为敲错中文标点报错了。 Windows快捷操作 &emsp;&emsp;windows10 现在内置了很多功能，可以通过各种 win 加快捷键来触发。&emsp;&emsp;尽管 win10 内置的和第三方软件还是有很大差距，但是如果在一台全新的 win10 电脑上。&emsp;&emsp;无论是截图、粘贴历史还是快速搜索，win10内置的功能都有不错的暂用方案。 &emsp;&emsp;并且 windows 的放大镜还是很不错的，演讲屏幕太小的时候可以通过 放大镜 来辅助。 路径上输入 cmd 打开命令行并定位到当前路径 &emsp;&emsp;在当前路径打开命令行有两个方法。&emsp;&emsp;一种是在路径输入上输入 cmd 。 &emsp;&emsp;还有一种方法是按住 shift 右键。&emsp;&emsp;菜单上会多出在 命令行打开 ，不过这个功能在 win10 被修改为用 PowerShell 打开了。&emsp;&emsp;要修改回来需要修改注册表 ， 参考文章 .gitignore 这种文件在 Windows 平台的命名方法 &emsp;&emsp;这种文件在 VScode 可以直接命名&emsp;&emsp;但是在 windows 下的资源浏览器，你是无法命名一个只有后缀无名称的文件的&emsp;&emsp;这个时候需要命名为 .gitignore. 就可以命名了。 鼠标中键 或 Shift左键 开启更多程序 &emsp;&emsp;有时候运行了一个 Maya ，还想运行更多的 Maya 。&emsp;&emsp;过去的操作需要右键 Maya 的任务栏图标，然后选择 Maya 进行运行。&emsp;&emsp;其实可以直接对任务栏图标进行鼠标中间或者 shift+鼠标左键 就可以运行一个程序的副本了。 Win+r 运行 &emsp;&emsp;win+r 开启 windows 的启动窗口。&emsp;&emsp;这个窗口执行的命令类似于 cmd 窗口中执行 start&emsp;&emsp;通常支持启动添加到环境变量路径的程序，比如输入 cmd regedit 之类的可以启动相关的 exe 程序&emsp;&emsp;可以启动程序可以参考 链接 &emsp;&emsp;不过除了这些方法之外，还可以根据注册表里面的记录特殊打开一些内置的路径。&emsp;&emsp;比如通过 shell:startup 可以打开开机启动目录， shell:recycleBinFolder 可以打开回收站 链接参考&emsp;&emsp;另外 windows 的系统设置也有一套快捷打开路径 链接参考&emsp;&emsp;包括一些系统级的应用也可以通过特殊 ms- 前缀来启动 ， 比如 ms-actioncenter: &emsp;&emsp;经过我后面查找我发现有些启动可以在注册表里面找到对应记录的关系。shell: HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\FolderDescriptionsms- : HKEY_CLASSES_ROOT\Local Settings\Software\Microsoft\Windows\CurrentVersion\AppModel\PackageRepository\Extensions\Windows.protocol &emsp;&emsp;最后运行窗口还支持 环境变量 存储的路径，比如可以通过 %SYSTEMDRIVE% 打开系统安装磁盘，也支持通过环境变量的路径拼接 链接参考 命令行操作 &emsp;&emsp;命令行操作其实没有什么好说的，属于 bat 批处理的范畴。命令文档可以参考 ss64.com &emsp;&emsp;比较重要的命令就是 where ，类似 mel 语言的 whatIs 命令（应该说 mel 语言就是参考它的），可以查询到命令的路径。&emsp;&emsp;有些很多命令的背后其实是运行 exe 实现的。&emsp;&emsp;另外 /? 非常重要，大部分的命令不懂都可以加这个后缀来查看帮助。 总结 &emsp;&emsp;以上就是 windows 这几个月使用总结的一些效率提升的操作。&emsp;&emsp;最近疯狂折腾，还要出一期 效率工具总结， 希望对大家有用。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AHK - 实现软件自动安装]]></title>
    <url>%2Fposts%2Ff6bbf3ad.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;数个月前我整理一套 windows 平台的效率工具，文章链接&emsp;&emsp;里面总结的软件操作，再经过了我几个月的运用，已经熟练地应用到我的日常工作当中了。&emsp;&emsp;只是软件的数量有点多，手动安装起来还是挺麻烦的。&emsp;&emsp;这个月初就开始筹备实现这些软件的自动化安装了，花了不少时间，也踩了一些坑。 &emsp;&emsp;github 仓库地址 踩坑前奏 &emsp;&emsp;最初的时候，我打算是用 bat 批处理来实现软件的自动化安装。&emsp;&emsp;因为经过我简单的网上搜索，我了解到，很多软件的安装包都有提供静默安装的选项，那么这些流程完全可以通过一个简单的 bat 批处理脚本实现自动化安装。&emsp;&emsp;但是，我发现有些软件并没有那么好弄，比如 PotPlayer 是需要解压再进行安装的，因此没有提供静默安装的功能。&emsp;&emsp;QtTabbar 1038 版本可以静默安装，但是升级包 1040 版本无法静默安装。 &emsp;&emsp;考虑到上述的诸多情况，我必须要实现 自动化 操作点击才可以。&emsp;&emsp;于是乎，我打算利用 Python 来实现自动化流程。&emsp;&emsp;一开始没有想到 autohotkey 这个自动化编程工具，因为一直想着 python 的 subprocess 可以调用命令行，通过 tkinter 开发界面。&emsp;&emsp;考虑到python 自动化操作 windows ，可以用的库也有不少。&emsp;&emsp;比较知名的库是 pywinauto 和 pyautogui &emsp;&emsp;pyautogui 是跨平台的自动化包，但是大部分通过截图识别来定位鼠标位置实现自动化，因此运行效率比较低。&emsp;&emsp;具体可以参考 Stack Overflow 里面 pywinatuo 作者提供的回复 链接&emsp;&emsp;pywinatuo 的优点是调用了 windows 的 API 获取窗口的信息，在这些信息基础上实现窗体匹配。&emsp;&emsp;因此后面我就采用了 pywinatuo 来实现我的自动化安装流程。 pywinatuo 开发 &emsp;&emsp;于是我开始踩坑 pywinauto 实现界面的自动化触发。&emsp;&emsp;开发的过程感受到诸多和 ahk 相同的地方。 &emsp;&emsp;我首先从 QTTabBar 安装入手，QTTabBar 的启动比较坑，完成安装之后，还需要点到下拉菜单来启动。 &emsp;&emsp;通过敲击 alt 可以让 win10 显示出快捷键，通过快捷键的方式可以实现自动化的操作。 1234567891011121314151617181920212223242526272829303132333435import timefrom pywinauto.application import Applicationfrom pywinauto import Desktop, keyboarddef main(): new_win = False for win in Desktop(backend="uia").windows(): if win.class_name() == "CabinetWClass": break else: new_win = True app = Application(backend="uia").start('explorer.exe') win = Desktop(backend="uia").window(class_name="CabinetWClass") win.set_focus() # NOTE 开启 QTTabBar keyboard.send_keys("&#123;VK_MENU&#125;") keyboard.send_keys("&#123;V&#125;") time.sleep(0.5) keyboard.send_keys("&#123;Y&#125;") keyboard.send_keys("&#123;DOWN&#125;") keyboard.send_keys("&#123;DOWN&#125;") keyboard.send_keys("&#123;DOWN&#125;") keyboard.send_keys("&#123;ENTER&#125;") if new_win: win.close()if __name__ == "__main__": main() &emsp;&emsp;通过看文档和网上查资料，总算是知道怎么在 pywinauto 里面获取到打开的 explorer 窗口。 &emsp;&emsp;CabinetWClass 这个参数是通过 pywinauto 的 print_control_identifiers 获取 - 文档&emsp;&emsp;print_control_identifiers 会打印出当前窗口下所有的组件信息。&emsp;&emsp;从中我发现 explorer 这个大窗口类就是 CabinetWClass&emsp;&emsp;通过这个方法可以直接获取到 explorer 打开的窗口。 &emsp;&emsp;然后通过 send_keys 发送键盘的命令实现自动化操作。 &emsp;&emsp;好不容易实现 python 的自动化， Tkinter 界面也尝试弄了些 checkbox 来进行软件安装的选择。&emsp;&emsp;后续测试了一下 pyinstaller 打包程序，这一打包就直接原地炸了。&emsp;&emsp;pywinauto 打包出来的 exe 居然有 200+ M&emsp;&emsp;这个大小和 numpy 打包有得一拼了(:з」∠) &emsp;&emsp;所以我果断放弃了这个方案了，网上稍微又查了查，才发现原来还有 autohotkey 的方案。 autohotkey 开发界面 &emsp;&emsp;以前用 tkinter 开发界面的时候，就有提过 tkinter 打包的界面稍微还是有点大，如果用 ahk 可以压缩得更小。Python - Tkinter Windows 磁盘映射工具&emsp;&emsp;关于 ahk 的认识，我基本上是从 capslock+ 魔改的时候认识的 github仓库&emsp;&emsp;所以我并没有真正开发过 ahk 界面。&emsp;&emsp;不过我这一次的界面开发需求其实很简单，只需要开发几个 checkbox 界面即可。 &emsp;&emsp;不过开发 ahk 界面果然还是非常不习惯。&emsp;&emsp;这个东西和 tkinter 一样也有同样的问题，没有 Qt 的 Layout 的概念。&emsp;&emsp;所以界面的长宽位置大小都是固定的，窗口也无法进行缩放。 &emsp;&emsp;不过，考虑到 ahk 超级小的大小，还是太香了，委曲求全可还行。 注 : 也有可能我对 ahk 还了解不深(:з」∠) &emsp;&emsp;后面在 ahk 中文网 上了解到了 中文最强 IDE ， 河许人出品。 链接&emsp;&emsp;这个工具可以实现类似 QtDesigner 的界面拖拽的效果。&emsp;&emsp;不过界面修改起来很麻烦，人工修改代码需要断开界面的链接 ε=(´ο｀*)))&emsp;&emsp;用起来有诸多不爽的地方。 &emsp;&emsp;界面开发其实倒还好说，官方文档也非常全面，和 mel 文档有得一拼，每个命令都有个小案例，学习起来非常便利。&emsp;&emsp;最大的难点就是如何获取 checkbox 的状态。&emsp;&emsp;在组件的长宽后面加上 v 开发的变量名，可以绑定一个状态变量进去。&emsp;&emsp;后续触发 Gui, Submit ,NoHide 之后就可以让这些变量获取到 checkbox 的状态。 123456789101112131415161718192021222324252627282930Gui Add, GroupBox, x10 y6 w120 h205, 效率软件Gui Add, CheckBox, x20 y23 w100 h25 +Checked vListary, ListaryGui Add, CheckBox, y+5 w100 h25 +Checked vQTTabBar, QTTabBarGui Add, CheckBox, y+5 w100 h25 +Checked vDitto, DittoGui Add, CheckBox, y+5 w100 h25 vWGesture, WGestureGui Add, CheckBox, y+5 w100 h25 vQuicker, QuickerGui Add, CheckBox, y+5 w100 h25 vTencentDesktop, 腾讯桌面管理Gui Add, GroupBox, x135 y6 w120 h49, 代码编辑器Gui Add, CheckBox, x143 y24 w102 h23 +Checked vVScode, VScodeGui Add, GroupBox, x135 y66 w120 h80, 截取软件Gui Add, CheckBox, x143 y86 w107 h23 +Checked vSnipaste, SnipasteGui Add, CheckBox, x143 y115 w107 h23 +Checked vScreenToGif, ScreenToGifGui Add, GroupBox, x135 y153 w120 h58, 播放器Gui Add, CheckBox, x143 y176 w102 h23 +Checked vPotPlayer, Pot PlayerGui Add, Button, x8 y222 w248 h23, 自动安装Gui +AlwaysOnTopGui Show , w260 h252 , 自动安装 - 界面ReturnGuiEscape:GuiClose: ExitAppButton自动安装: Gui, Submit ,NoHide SetTitleMatchMode, 1 ; 软件安装流程 ... ExitApp &emsp;&emsp;+Checked 添加标记可以让 checkbox 保持勾选的状态。 autohotkey 自动化安装流程 &emsp;&emsp;大部分的安装的可以静默安装来完成。&emsp;&emsp;需要特殊处理有的 QtTabbar 和 PotPlayer ， 还有 msi 同时安装会导致冲突。 QtTabbar 自动化安装 &emsp;&emsp;这个工具安装可谓是花费了我好多时间。&emsp;&emsp;因为插件安装完成之后并没有进行启动，而这个插件启动的方式又比较隐秘，参考上面的截图。&emsp;&emsp;启动需要点击下拉菜单实现。&emsp;&emsp;如果不将启动流程自动化，反而会比较让人困惑。 &emsp;&emsp;后面又在网上找到了中文语言的配置文件，于是又想实现自动加载语言配置的功能。&emsp;&emsp;通过查 QtTabbar 的官方网站提供的文档&emsp;&emsp;我发现 QtTabbar 的架构还是非常灵活的。&emsp;&emsp;最重要的是还支持 Scripting ，可以通过 windows 的 Active Scripting 来调用 QtTabbar 的 API。 文档&emsp;&emsp;支持 windows 平台的 VBScript 和 JScript。&emsp;&emsp;官方提供的的案例都是 JScript 写的。&emsp;&emsp;我查了一下微软官方关于 JScript 的描述，直接惊呆了。&emsp;&emsp;JScript 是根据 ECAMscript 3.0 的标准做的脚本语言（其实就是 JavaScript ， 只不过版本过于过时）&emsp;&emsp;感觉回到10多年前的 IE 时代，那个时候 JScript 可以通过调用 ActiveXObject 实现对 windows API 的调用。 &emsp;&emsp;至于如何通过 JScript 来操作 QtTabbar ，官网提供了很详细的文档 API文档&emsp;&emsp;还包括一些简单的调用案例&emsp;&emsp;可以通过脚本来制作一些 QtTabbar 的命令按钮，实现文件操作的自动化。 &emsp;&emsp;通过这个脚本操作可以实现很多细微操作，因为命令行调用 explorer 只能开启一个新的窗口，如果要新建一个 Tab 还是得用脚本实现。&emsp;&emsp;JScript 的执行可以调用 windows 自带的 cscript 来执行 百度百科 1234567891011121314151617181920212223C:\Users\timmyliang&gt;where cscriptC:\Windows\System32\cscript.exeC:\Users\timmyliang&gt;cscriptMicrosoft (R) Windows Script Host Version 5.812版权所有(C) Microsoft Corporation。保留所有权利。用法：CScript scriptname.extension [option...] [arguments...]选项： //B 批模式：不显示脚本错误及提示信息 //D 启用 Active Debugging //E:engine 使用执行脚本的引擎 //H:CScript 将默认的脚本宿主改为 CScript.exe //H:WScript 将默认的脚本宿主改为 WScript.exe （默认） //I 交互模式（默认，与 //B 相对) //Job:xxxx 执行一个 WSF 工作 //Logo 显示徽标（默认） //Nologo 不显示徽标：执行时不显示标志 //S 为该用户保存当前命令行选项 //T:nn 超时设定秒：允许脚本运行的最长时间 //X 在调试器中执行脚本 //U 用 Unicode 表示来自控制台的重定向 I/O &emsp;&emsp;cscript 是 System32 目录下的一个 exe ，可以用来执行 JScript 和 VBScript&emsp;&emsp;我还是比较喜欢使用 JScript ， js 毕竟也写过一段时间了。&emsp;&emsp;只可惜基于 ES3 标准，很多 ES6 的写法都不支持。 &emsp;&emsp;原本打算通过脚本后台来实现 QtTabbar 的自启动的。&emsp;&emsp;为此还专门用 procmon 来监听查看 QtTabbar 的文件输入输出流。&emsp;&emsp;尽管发现了 QtTabbar 进行了很多 注册表的 写入写出 操作。&emsp;&emsp;但是单纯修改注册表并不能实现 QtTabbar 多标签的自启动。&emsp;&emsp;后来还是看了 QtTabbar 的官方文档，找到了 ShowToolbar 的命令可以实现这个效果。&emsp;&emsp;我在自己的电脑上测试得很完美。&emsp;&emsp;然而当我走安装流程的时候，发现脚本并不起作用。&emsp;&emsp;ShowToolbar 命令需要有 Tab 窗口开启才可以实现调用。&emsp;&emsp;但是如果还没有开启多标签页面的话，无法获取到打开的标签的实例，根本就无法调用这个方法。 &emsp;&emsp;最后无奈，只能还是采用之前 python 自动化弄过的 快捷键操作实现 开启。&emsp;&emsp;自动化开启有可能因为用户操作等问题，导致开启不成功。这个自动操作的体验也不是太友好，但是没有更好的方法了。 &emsp;&emsp;后来找到汉化语言 xml 配置，于是想将 汉化 添加上。&emsp;&emsp;只要通过快捷键开启 QTTabBar 之后，就可以愉快地使用 JScript API 了。&emsp;&emsp;于是我又查了文档，并没有直接加载 语言设置 的功能，但是可以通过加载 全局设置 功能间接加载 语言设置。&emsp;&emsp;全局设置可以通过 QTTabBar 的设置界面进行导出。 &emsp;&emsp;API 文档 通过 Import 命令可以加载 xml 配置。&emsp;&emsp;但是 xml 的配置只能是个绝对路径。&emsp;&emsp;因此我需要实现 JScript 的文件拷贝和读写功能，实现对路径的替换。 123456789101112131415161718192021222324252627282930313233343536var shell = new ActiveXObject("wscript.shell");var qs = new ActiveXObject("QTTabBarLib.Scripting");var fso = new ActiveXObject("Scripting.FileSystemObject");var DIR = fso.GetAbsolutePathName(".")var APPDATA = shell.ExpandEnvironmentStrings("%APPDATA%")var xml = fso.BuildPath(DIR, "*.xml")fso.CopyFile(xml, APPDATA)var config = fso.BuildPath(DIR, "config.xml")// NOTE https://language-and-engineering.hatenablog.jp/entry/20090203/p1var stream = new ActiveXObject("ADODB.Stream");stream.CharSet = "utf-8";stream.Type = 2;stream.Open();stream.LoadFromFile(config)var config_xml = stream.ReadText(-1)stream.Close()var target_config = fso.BuildPath(APPDATA, "config.xml")var stream = new ActiveXObject("ADODB.Stream");stream.Type = 2;stream.charset = "utf-8";stream.Open();stream.WriteText(config_xml.replace("&#123;&#123;QTTabBar&#125;&#125;",APPDATA),1);stream.SaveToFile( target_config, 2 );stream.Close();qs.CloseAllWindows()var SYSTEMDRIVE = shell.ExpandEnvironmentStrings("%SYSTEMDRIVE%")wnd = qs.open(SYSTEMDRIVE)// NOTE 导入中文设定wnd.InvokeCommand("Import",target_config) &emsp;&emsp;通过 FileSystemObject 无法处理 utf-8 的文件。&emsp;&emsp;因此需要用 ADODB.Stream 来读写 utf-8 的 xml 配置&emsp;&emsp;这里通过 JScript 直接将文件拷贝到 APPDATA 的目录下，这个目录一般不需要管理员权限。 &emsp;&emsp;安装流程见上图，缺点就是敲快捷键的时候，如果遇到用户操作或者过于卡顿会导致启动失败。 PotPlayer 安装 &emsp;&emsp;QTTabbar 是最为艰难的了，后续这些问题都不算太大的问题。&emsp;&emsp;PotPlayer 的安装包没有提供静默安装的方案，安装包需要经过解压才可以执行安装。&emsp;&emsp;这个基本上利用 AHK 的按键自动化点击即可。 &emsp;&emsp;其中的难点就是要实现窗口等待。 12345678910111213141516171819202122232425262728293031323334353637; PotPlayer 安装操作install_PotPlayer()&#123; install_path := A_ScriptDir "\software\PotPlayerSetup64-200512-ads.exe" ; 判断安装包是否存在 if !FileExist(install_path)&#123; MsgBox, "PotPlayerSetup64-200512-ads.exe not exists" return &#125; ToolTip, 解压 PotPlayer 安装包 install_cmd := install_path Run, %install_cmd% WinWait, Installer Language, , 3 SendInput,&#123;Enter&#125; ; ControlClick, OK , Installer Language Sleep, 2000 WinWait, PotPlayer-64 bit 安装 SendInput,&#123;Enter&#125; SendInput,&#123;Enter&#125; SendInput,&#123;Enter&#125; Loop, 10 &#123; Sleep, 200 ControlClick, 安装 , PotPlayer-64 bit 安装 &#125; ; ; 等待 关闭 按钮激活 ; Sleep, 2000 while (WinExist(PotPlayer-64 bit 安装)) &#123; ToolTip, 等待 PotPlayer 安装 Sleep, 500 ; ControlGet, button_enable, Visible ,, ClassNN Button2 ControlClick, 关闭 , PotPlayer-64 bit 安装 &#125;&#125; &emsp;&emsp;点击安装按钮有时候会卡主，所以弄了个循环10次进行点击。&emsp;&emsp;后续进入安装流程，定期点击 关闭 按钮直到窗口关闭为止。 Snipaste 安装 &emsp;&emsp;Snipaste 只提供了压缩包的便捷安装版本。&emsp;&emsp;因此自动安装需要用过 ahk 实现压缩包的解压&emsp;&emsp;还好 ahk官方论坛上有提供解决方案。&emsp;&emsp;也是通过调用 windows 的 API 实现的。 1234567891011121314151617Unz(sZip, sUnz)&#123; fso := ComObjCreate("Scripting.FileSystemObject") If Not fso.FolderExists(sUnz) ;http://www.autohotkey.com/forum/viewtopic.php?p=402574 fso.CreateFolder(sUnz) psh := ComObjCreate("Shell.Application") zippedItems := psh.Namespace( sZip ).items().count psh.Namespace( sUnz ).CopyHere( psh.Namespace( sZip ).items, 4|16 ) Loop &#123; sleep 50 unzippedItems := psh.Namespace( sUnz ).items().count ToolTip Unzipping in progress.. IfEqual,zippedItems,%unzippedItems% break &#125; ToolTip&#125; &emsp;&emsp;解压之后再执行 Snipaste.exe 启动 msi 处理 &emsp;&emsp;msi安装如果同时启动 /passive 安装会跳过只保留一个。&emsp;&emsp;因此加入死循环来检测是否 msiexec.exe 在运行 1234567891011121314151617181920install_Quicker()&#123; install_path := A_ScriptDir "\software\Quicker.x64.1.8.0.0.msi" ; 判断安装包是否存在 if !FileExist(install_path)&#123; MsgBox, "Quicker.x64.1.8.0.0.msi not exists" return &#125; install_cmd := install_path " /passive" Run, %install_cmd% Loop &#123; ToolTip, 安装 Quicker sleep 500 result := WinExist("ahk_exe msiexec.exe") if (!result)&#123; break &#125; &#125;&#125; 总结 &emsp;&emsp;这次尝试了 ahk 的图形化编程，打包之后的程序大小只有 1M+ ，真的非常小巧。&emsp;&emsp;自动化安装流程有一定的安装失败几率，这个可能因电脑而异。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 命令 自定义触发 & Mel 源码获取]]></title>
    <url>%2Fposts%2Fdfd7b1ea.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;其实这部分的内容，很早之前我就通过看 DT 的教程掌握了，毕竟操作很基础，之前甚至都没有想到要写文章进行总结说明。&emsp;&emsp;最近美术制作人员又出现了自定义触发命令的需求问题，于是就有了写这篇文章的动力。&emsp;&emsp;这个技巧对于美术制作人员来说非常有用，懂了这个，就可以将 Maya 大部分的功能提取出来，按照自己的喜好进行触发。 类似的教程可以参考我很早之前上传的教程 【Maya成神】maya100招+【中文字幕】10种可以提升你们Maya制作效率的方法还有 DT 的 Maya 入门教程有提到命令提取的操作 获取操作命令 &emsp;&emsp;Maya 的代码编辑器上有一个非常优秀的设计，对于学习 Maya 编程来说可谓极度有用的功能，那就是代码编辑器的命令回显。&emsp;&emsp;通过命令回显，如果是搞程序的可以进一步深挖 Mel 命令源码，分析 Maya 命令背后的操作，如果不懂程序的美术制作人员也可以直接复制命令进行使用。&emsp;&emsp;大部分回显是 mel 命令的，只有极个别的情况返回的是 python 代码，因此美术人员基本可以默认所有的回显代码都是 mel 操作。 &emsp;&emsp;默认打开的 Maya 右下角可以打开代码编辑器。&emsp;&emsp;关于代码编辑器各个按钮的含义，可以参照官方中文文档 &emsp;&emsp;在 Maya 里面进行的大部分操作，比如上图的新建一个球体，都是可以看到 代码编辑器 返回执行的 Mel 命令代码。&emsp;&emsp;你可以复制上面的 mel 命令到代码编辑器下面执行，从而生成一个球。 &emsp;&emsp;你可以复制上面的 mel 命令到代码编辑器下面执行，从而生成一个球。 生成工具架 &emsp;&emsp;完成上面一步，恭喜你，你已经完成了最基本的功能提取了。&emsp;&emsp;要实现将代码放到 Maya 工具架其实非常简单，只需要选中代码，然后用鼠标中间拖拽代码到工具架上。 &emsp;&emsp;这样就可以生成一个 Maya Mel 命令的图标，点击图标就可以生成一个球。 添加快捷键 &emsp;&emsp;快捷键操作可以通过上面的菜单，打开热键编辑器。&emsp;&emsp;然后新建一个命令，选择 Mel 命令，然后将 Mel 命令拷贝进去。&emsp;&emsp;可以生成一个 runTimeCommand ， 这样就可以搜索 runTimeCommand 找到刚才输入名称的命令来输入自定义的快捷键了。 &emsp;&emsp;后续就和正常添加快捷键的操作一样。 制作标记菜单快速调用 &emsp;&emsp;请参考教程 10种可以提升你们Maya制作效率的方法 第8集 获取技巧补充 &emsp;&emsp;有时候有些操作没有命令回显。&emsp;&emsp;这个时候可以通过 撤销 命令获取到隐藏的 mel 代码。 &emsp;&emsp;当然撤销的方法也并不是百试百灵的，因此终极的解决方式开启 Echo All Commands 的功能。 &emsp;&emsp;这个功能开启之后可以显示所有 Maya 调用的命令，基本任何的底层 mel 命令操作都显示出来了。&emsp;&emsp;缺点就是大量的命令显示会将有用的信息淹没，这个需要将信息拿出来然后进行过滤处理。 如何获取操作命令源码 &emsp;&emsp;这个部分和编程开发相关，如果是美术制作人员可以跳过 &emsp;&emsp;通过命令回显可以获取到 Maya 内部执行的命令名称。&emsp;&emsp;Maya 虽然是 闭源 的，我们看不到底层的 Qt 框架的 C++ 代码。&emsp;&emsp;但是 Maya 自身开发的 Mel 语言代码层几乎可算是开源了。&emsp;&emsp;具体的代码可以 Maya 安装目录的 scripts 文件夹下找到。 文档说明&emsp;&emsp;基本上大部分的 UI 界面，以及 UI 别后的按钮操作都是用 Mel 命令写的， Mel 界面的底层其实调用的还是 Qt 框架。&emsp;&emsp;只是为了兼容老版本的 Maya 的一些 Mel 代码界面，整个 Maya 底层有魔改过。（Maya 的上古版本貌似还不是使用 Qt） &emsp;&emsp;虽然只是 mel 命令开源，并没有开放 C++ 底层。&emsp;&emsp;但是我觉得 Maya 的开放程度是相当之高的，基本上 whatIs 命令详解 &emsp;&emsp;whatIs 命令只可以在 Mel 中使用，如果要在 Python 使用 whatIs 命令，可以加载官方提供的 Python API 编写的脚本。&emsp;&emsp;文档里面是没有 whatIs 的 cmds 命令的，还有一种在 Python 运行的方法就是使用 mel.eval 的方式来运行。&emsp;&emsp;通过 whatIs 这个内置的 Mel 命令查询回显命令的类型。 whatIs 文档&emsp;&emsp;文档里面的案例其实有命令显示的几种类型，我再补充了两种。 12345678910111213141516171819202122232425262728whatIs "sphere";// Result: Command //whatIs "initToolBox";// Result: Mel procedure found in: /u/mayauser/maya/scripts/initToolBox.mel //whatIs "kaosFieldTest";// Result: Script found in: /u/mayauser/maya/scripts/kaosFieldTest.mel //whatIs "fdsafda";// Result: Unknown //int $abc[42];whatIs "$abc";// Result: int[] variable //$s=`pwd`;whatIs "$s";// Result: string variable //global proc MelProce()&#123;&#125;;whatIs MelProce;// Result: Mel procedure entered interactively. // whatIs CenterPivot;// Result: Run Time Command // runTimeCommand -q -c CenterPivot// Result: xform -cpc // &emsp;&emsp;返回 Command 类型表示是 Mel 命令，绝大多数的 Command 都可以查 Mel 命令文档可以得到详细的说明。&emsp;&emsp;但是有些插件引入的 Mel 命令就需要通过名称查出它是什么插件引入的 Mel 命令，具体也可以在插件编辑器上查看插件引入了什么样的 Mel 命令和 节点。 &emsp;&emsp;Mel procedure found in: /u/mayauser/maya/scripts/initToolBox.mel&emsp;&emsp;返回 Mel procedure 会返回 mel 代码文件的路径，可以通过路径找到 mel 源码。&emsp;&emsp;如果是动态的 mel 就看不到源码了。 &emsp;&emsp;返回 Run Time Command 类型可以通过 mel 命令 runTimeCommand 来获取嵌入的代码。 总结 &emsp;&emsp;Maya 是相当开放的软件了，当我使用 Unreal Houdini 等等软件的时候，没有命令的回显，让我去做一些功能的自动化处理就非常麻烦。&emsp;&emsp;而且 Maya 相对简单，对 美术制作人员 的交互体验非常友好。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal FBX 动画导入比对面板]]></title>
    <url>%2Fposts%2Fa999f0c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间协助动画组制作将动画 FBX 文件导入 Unreal 引擎里面，遇到很麻烦的问题。&emsp;&emsp;由于一些流程规范的问题，我们的动画需要添加修型，这个修型 K 帧的过程中有修改了时间滑块范围的情况。&emsp;&emsp;结果导致后续导出文件的数据和引擎里面的源动画数据匹配不上。&emsp;&emsp;这种问题检查起来就很麻烦了。&emsp;&emsp;当时由于赶时间，我们只好人工校对了，后来吸取教训，我觉得也可以在 Unreal 上开发工具， 借助 Unreal 的 Python API 来解决这些琐事。 Unreal Python 插件选择 &emsp;&emsp;其实关于 Unreal 接入 Python 的插件是有两个选择的。&emsp;&emsp;一个是 Github 上已经有 1.6K 星星，已经经历常年开发，非常很成熟的插件 UnrealEnginePython github地址&emsp;&emsp;然后 Epic 官方在 2018 年推出了 Unreal 内置的 Python 插件&emsp;&emsp;然后第三方插件的 readme 里面提到了关于和官方之间的纠葛，最后很可惜还是得不到官方的承认。&emsp;&emsp;所以我这里还是使用 官方的 Python 插件。 &emsp;&emsp;关于 Unreal 官方 Python 插件要如何使用，可以参照外国人做的一个教程 B站地址 Youtube地址 B站国人重制版 github地址&emsp;&emsp;这套教程里面有很详细的 Python 操作教程，甚至还包括如何通过 C++ 开发蓝图节点，然后通过官方插件转换为 Python 调用。 &emsp;&emsp;由于目前项目用的 版本 为 4.22 ，所以有些功能和最新的不太一样，比如我最近开发遇到了 Python API 无法操作 Sequencer 导出 FBX&emsp;&emsp;这个命令在 SequencerTools 模块下面。&emsp;&emsp;但是我的 4.22 版本的插件下是无法调用，只能通过 C++ API 开发蓝图来调用。 Unreal Editor Utility 开发 &emsp;&emsp;Editor Utility 是 Unreal 4.22 引入的新机制。&emsp;&emsp;通过这个可以借助 UMG 界面来开发引擎的工具界面，集成 Designer 组件拖拽开发，比较完善了。&emsp;&emsp;事件触发也支持蓝图，可以通过蓝图实现 Unreal 的自动化工具。&emsp;&emsp;具体的使用方法可以参照 官方live ， 视频内容干货很多，很有参考价值。 youtube地址 B站地址 github地址&emsp;&emsp;这个视频里面也有提到如何在 4.22 中通过 蓝图 调用 Python。 &emsp;&emsp;下面就是我按钮点击触发 调用 Pyhton 方法。 &emsp;&emsp;4.22 还没有直接执行 Python 脚本的蓝图，只能通过 Execute Console Command 调用 py 来变相执行 Python 脚本。&emsp;&emsp;这里我直接脚本前缀默认路径指向了蓝图的路径，然后只要输入相对蓝图路径的地址就可以执行相应的 Python 文件了。 Unreal 对接 PySide &emsp;&emsp;Unreal 官方内置了 Python2 ， 简直就是为了影视工业的各个 DCC 软件所做的妥协。(当然不爽的话可以自己搭建一个 Python3 ，或者用 UnrealEnginePython 第三方插件也可以)&emsp;&emsp;目前 Python2 已经不再维护，还是希望整个行业的 Python 能够集体升级。 &emsp;&emsp;由于官方使用的是 Python2 所以只好接入比较过时的 PySide 包。&emsp;&emsp;安装方法很简单，因为 Unreal 的 Python 没有类似 Maya 的魔改，还是兼容传统的 Python2 编译器的。&emsp;&emsp;所以直接去网上安装一个 Python2 ，然后用 pip install PySide 即可，最后将包的路径添加到 Unreal python 的 sys.path 里面就可以用实现在 Unreal 里面调用 Qt 了。&emsp;&emsp;不过这里也有一些麻烦。&emsp;&emsp;图形化编程要保持窗口响应，进程需要挂起。 &emsp;&emsp;那么 Unreal 和 PySide 这两个会产生冲突。&emsp;&emsp;PySide 的 exec_ 函数不好使，我之前有测试过，如果执行 QApplication 的 exec_ 会导致 Unreal 卡死。&emsp;&emsp;好在油管那套 Unreal Python 教程有指点迷津， Unreal 自身有可以使用 register_slate_post_tick_callback 来提供无限回调的 tick 。&emsp;&emsp;教程通过 无限回调 来确保 Gui 窗口的持续相应的。&emsp;&emsp;不过经过我使用 PySide 的经验， 特别是年前开发 mpdb 模块的时候接触到的一些让 Qt GUI 持续响应的方法。&emsp;&emsp;其实不需要教程里那么麻烦，要记录存在的所有窗口并且还要不停触发 eventTick 函数来刷新 GUI 从而实现窗口响应。&emsp;&emsp;其实 QApplication 提供了 processEvents 来触发事件队列，所有的响应事件都是先插入到事件队列里面，然后通过 processEvents 来异步触发。&emsp;&emsp;这样的好处是 UI 刷新频率没有那么高，没有事件的话就不需要不断刷新重绘了。&emsp;&emsp;maya 的 evalDeferred 也是类似的事件队列机制。 &emsp;&emsp;下面就是我在 Unreal 里面初始化 PySide 的脚本，用了 Qt.py 来以防万一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import osimport sysDIR = os.path.dirname(__file__)vendor = os.path.join(DIR, "vendor")sys.path.insert(0, vendor) if vendor not in sys.path else None# NOTE 添加 FBXImporter 路径FBX = os.path.join(DIR, "FBXImporter")sys.path.insert(0, FBX) if FBX not in sys.path else Noneimport unrealfrom Qt import QtWidgetsfrom Qt import QtCorefrom Qt import QtGuidef slate_deco(func): def wrapper(self, single=True, *args, **kwargs): # NOTE 只保留一个当前类窗口 if single: for win in QtWidgets.QApplication.topLevelWidgets(): if win is self: continue elif self.__class__.__name__ in str(type(win)): win.deleteLater() win.close() # NOTE https://forums.unrealengine.com/unreal-engine/unreal-studio/1526501 # NOTE 让窗口嵌入到 unreal 内部 unreal.parent_external_window_to_slate(self.winId()) return func(self, *args, **kwargs) return wrapper# This function will receive the tick from Unrealdef __QtAppTick__(delta_seconds): QtWidgets.QApplication.processEvents() # NOTE 处理 deleteDeferred 事件 QtWidgets.QApplication.sendPostedEvents()# This function will be called when the application is closing.def __QtAppQuit__(): unreal.unregister_slate_post_tick_callback(tick_handle)# This part is for the initial setup. Need to run once to spawn the application.unreal_app = QtWidgets.QApplication.instance()if not unreal_app: unreal_app = QtWidgets.QApplication([]) tick_handle = unreal.register_slate_post_tick_callback(__QtAppTick__) unreal_app.aboutToQuit.connect(__QtAppQuit__) # NOTE 重载 show 方法 QtWidgets.QWidget.show = slate_deco(QtWidgets.QWidget.show) &emsp;&emsp;__QtAppTick__原本只需要添加 processEvents 就可以了，但是根据官方文档，这个操作无法执行组件删除事件。&emsp;&emsp;这会导致我的 Qt 窗口越来越多，而不会触发回收删除。&emsp;&emsp;进一步查了文档可以知道 deleteDeferred 事件可以通过 sendPostedEvents 函数触发。 &emsp;&emsp;另外借助 Python 动态特性 用装饰器 重写了 QWidget 的 show 函数。&emsp;&emsp;这样我的窗口组件执行 show 确保只有一个窗口。&emsp;&emsp;parent_external_window_to_slate 这个操作是在官方论坛里面学到的 链接，加入这个之后 PySide 生成的窗口就是依附到 Unreal 里面了。&emsp;&emsp;窗口不会和 Unreal 分开，不会导致 Unreal 的界面将窗口盖住的问题。&emsp;&emsp;由于几乎所有的 Qt 组件都是继承自 QWidget 的，所以几乎所有的 show 方法都会重载到这个装饰器上，一劳永逸，方便快捷。 &emsp;&emsp;最后就是通过蓝图连接到 Editor Utility 上，确保启动插件的窗口自动执行上面的初始化脚本。 &emsp;&emsp;有了这一步初始化之后，就可以像 Maya 一样来写 Qt 界面了。 Qt 界面编写 &emsp;&emsp;这一次 Qt 编写的要求还是有点高的，毕竟需要实现对比效果。&emsp;&emsp;而且最好是直观的，一目了然的。&emsp;&emsp;下面是界面写好的效果，通过点击我的 Editor Utility 的界面启动。 &emsp;&emsp;基本的界面交互如上图所示，基本就是两个列表同步滚动和选择。&emsp;&emsp;导入的话可以利用按钮打开选择窗口进行导入，也可以通过拖拽直接将 FBX 文件拖拽到 ListWidget 上。 &emsp;&emsp;导入 FBX 会使用 Autodesk 提供的 FBX Python SDK 读取 FBX 文件中的时间数据，经过换算获取帧数，然后比对是否和隔壁列表的 AnimSequence 有同名对象。&emsp;&emsp;如果名称匹配则比较帧数是否统一，如果帧数统一就打勾，帧数不统一打叉。 &emsp;&emsp;如果没有匹配额的则放到列表最下面提示感叹号。 &emsp;&emsp;右键菜单可以将选择的 item 进行删除和批量导入 FBX 动画。 ListWidget 同步 &emsp;&emsp;这次界面开发比较大难点就是两个 ListWidget 的 同步问题。 &emsp;&emsp;滚动同步其实参考 Stack Overflow 的回答 链接地址&emsp;&emsp;选择同步也可以利用类似的方法去做，但是选择前首先需要清空当前的选择项。&emsp;&emsp;清空操作也会触发 signal，直接导致 signal 重复调用变成永动机(:з」∠)&emsp;&emsp;后面写了个同步类，通过 protected 保护变量来防止死循环调用。 &emsp;&emsp;代码整合到了 QtLib 里面 链接地址 Splitter 组件 &emsp;&emsp;我发现 PySide 的 Splitter 没有明显的 Gui 表示进行区分。&emsp;&emsp;这让我很不爽，于是网上搜了一下，发现有方法可以将 Splitter 做成类似 Houdini 带按钮的 Splitter 效果。 Stack Overflow链接&emsp;&emsp;于是就学着自己改良了一个 Splitter 组件。 github链接 &emsp;&emsp;支持轴向和横向，双击 splitter 可以自动平均分配。 Unreal Python API 调用 &emsp;&emsp;Unreal Python API 网上的材料极少，出了寥寥无几的论坛文章之外，就只有 Youtube 的那套教程是比较好的了。&emsp;&emsp;剩下就是在 Python API 文档里面查方法的说明了，好在大部分常用的操作视频教程都涵盖了。 &emsp;&emsp;另外使用 Python API 之前，相关的 Scripting 插件都要统统开启， Unreal 的官方 Python 插件本质上是调用 Unreal 的蓝图节点功能。&emsp;&emsp;我之前就是没有开启 Sequencer Scripting 插件，结果 Sequencer 相关的命令都是空的，我一度怀疑是官方插件出 Bug 了，后来试着试着才知道是我没加载(:з」∠) Unreal 获取选中的资源目录 &emsp;&emsp;Python API 目前依然是各种不完善，比如无法直接获取到 Content Browser 的文件夹，只能获取到选中的资源。&emsp;&emsp;所以我只好通过选中的资源获取目录，然后通过目录获取目录下所有的资源. 12345678import unrealselected_assets = unreal.EditorUtilityLibrary.get_selected_assets()if len(selected_assets) == 0: returnasset = selected_assets[0]directory = unreal.Paths.get_path(asset.get_path_name())# NOTE 获取目录下的资源assets = unreal.EditorAssetLibrary.list_assets(directory) Unreal Cotent Browser 跳转到选中资源 &emsp;&emsp;一开始以为这个功能挺难实现的，没想到 Unreal 已经封装好了。&emsp;&emsp;直接传入 unreal 引用路径就可以自动同步。 1234# NOTE listWidget 里面的选择函数操作def sync_assets(self): path_list = [item.text() for item in self.selectedItems()] unreal.EditorAssetLibrary.sync_browser_to_objects(path_list) 导入 FBX 动画 &emsp;&emsp;这个操作就遇到了大坑了，&emsp;&emsp;因为 上面的教程只提供了 骨骼动画蒙皮全部一起导入的方案。&emsp;&emsp;但是没有提供只导入动画这种方案。&emsp;&emsp;后来我踩了很多坑之后，在论坛上上找到了解决方案。&emsp;&emsp;就是导入 task 的 FbxImportUI options 需要设置 automated_import_should_detect_type 为 False 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253def buildImportTask(self, filename='', destination_path='', skeleton=None): options = unreal.FbxImportUI() options.set_editor_property("skeleton", skeleton) # NOTE 只导入 动画 数据 options.set_editor_property("import_animations", True) options.set_editor_property("import_as_skeletal", False) options.set_editor_property("import_materials", False) options.set_editor_property("import_textures", False) options.set_editor_property("import_rigid_mesh", False) options.set_editor_property("create_physics_asset", False) options.set_editor_property( "mesh_type_to_import", unreal.FBXImportType.FBXIT_ANIMATION) # NOTE https://forums.unrealengine.com/development-discussion/python-scripting/1576474-importing-skeletal-meshes-4-21 options.set_editor_property( "automated_import_should_detect_type", False) task = unreal.AssetImportTask() task.set_editor_property("factory", unreal.FbxFactory()) # NOTE 设置 automated 为 True 不会弹窗 task.set_editor_property("automated", True) task.set_editor_property("destination_name", '') task.set_editor_property("destination_path", destination_path) task.set_editor_property("filename", filename) task.set_editor_property("replace_existing", True) task.set_editor_property("save", False) task.options = options return taskdef import_items(self): # Note unreal 导入 FBX tasks = [] for fbx_item in self.selectedItems(): fbx_path = fbx_item.toolTip() if not fbx_path: continue # NOTE toolTip 第一行为路径 | 第二行为帧数 fbx_path = fbx_path.split("\n")[0] row = self.row(fbx_item) asset_item = self.asset_list.item(row) asset_path = os.path.dirname(asset_item.text()) skeleton = asset_item.asset.get_editor_property('skeleton') task = self.buildImportTask(fbx_path, asset_path, skeleton) tasks.append(task) # NOTE 配置导入的颜色 fbx_item.setBackground(QtGui.QBrush(QtGui.QColor(0, 255, 0))) asset_item.setBackground(QtGui.QBrush(QtGui.QColor(0, 255, 0))) # NOTE 批量导入 FBX unreal.AssetToolsHelpers.get_asset_tools().import_asset_tasks(tasks) FBX Python SDK &emsp;&emsp;我们插件面板获取到了 FBX 的文件路径，但是还需要通过 Python 来读取 FBX 的数据。&emsp;&emsp;这要如何实现呢？&emsp;&emsp;其实方法不止有一种，比如存储 FBX 的 ASCII 模式，那就是纯文本编辑，甚至可以用正则表达式匹配数据。&emsp;&emsp;但是如果凑巧导出的是 Binary 格式，那就操作不了了。&emsp;&emsp;所以我网上查了一下，比较靠谱的方法就是使用 Autodesk 官方提供的 FBX Python SDK &emsp;&emsp;FBX 是 Autodesk 公司开发的一种通用三维数据存储格式，极大解决了不同软件的数据互通问题。(现在有 USD 这种更好的解决方案了，我还没有时间研究这个(:з」∠))&emsp;&emsp;我感觉这个东西推出来主要原因是 Autodesk 收购了太多三维软件了，每个软件用的标准都不统一。&emsp;&emsp;推出这个格式，可以解决动捕软件对接主流三维软件的问题，所以它并不是一种工业标准的格式。&emsp;&emsp;FBX 格式算是比较早期支持相对完整的通用格式了，至今依然是游戏行业的通用标准。影视的流程比较复杂，目前大都用 Alembic 或者 ass 等各种缓存。&emsp;&emsp;USD没用过，传闻听了很多，希望生态能够成熟起来，实现数据格式的大一统。 &emsp;&emsp;回到这里讨论的主题， FBX 的 Python SDK 如何使用。具体可以从官网了解 链接&emsp;&emsp;Autodesk 提供了 C++ 的 SDK ， 类似 Unreal Unity 这些游戏引擎大概率也是引入了这个模块实现 FBX 的解析。&emsp;&emsp;我们要用 Python 操作 FBX ，首先需要安装 Python SDK ，可以去官网下载并安装 链接 &emsp;&emsp;下载运行 exe 安装完成，可以去到安装目录找到 FBX 的 python 包。 &emsp;&emsp;lib 文件夹有对应不同 Python 平台的 fbx 库，已经编译好，是可以直接 Python 调用的 pyd 文件，还有一个为了简化操作而写的 FbxCommon.py&emsp;&emsp;而 samples 目录下则有一些 Python 操作的案例，可以参考学习。&emsp;&emsp;这个 SDK 操作网上也找不到多少使用资料，基本看官方的材料足矣。 &emsp;&emsp;这里主要参考了 ImportScene 里面 DisplayAnimation 的一些数据。&emsp;&emsp;通过 ImportScene.py 的操作可以知道， FBX SDK 需要 FbxCommon.InitializeSdkObjects 初始化 manager 和 scene 对象。&emsp;&emsp;然后通过 FbxCommon.LoadScene 来加载 FBX 场景。&emsp;&emsp;最初我们的动画是带修型的，所以记载模型的数据就特别特别慢，我在想 难道 FBX SDK 不可以只读取部分数据来加速吗？&emsp;&emsp;于是又去翻阅 FBX 的官方文档以及 FBX C++ API 文档，没错这个 API 和 OpenMaya 1.0 一样只有 C++ 文档，不过用起来差不多。 官方文档地址 C++文档地址&emsp;&emsp;文档也是用同一个生成器生成的。 123456789101112131415161718192021222324252627282930def read_fbx_frame(self, fbx_file): # NOTE read FBX frame count manager, scene = FbxCommon.InitializeSdkObjects() # NOTE 只导入 Global_Settings 读取帧数 s = manager.GetIOSettings() s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Material", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Texture", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Audio", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Audio", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Shape", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Link", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Gobo", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Animation", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Character", False) s.SetBoolProp("Import|AdvOptGrp|FileFormat|Fbx|Global_Settings", True) manager.SetIOSettings(s) result = FbxCommon.LoadScene(manager, scene, fbx_file) if not result: raise RuntimeError("%s load Fail" % fbx_file) setting = scene.GetGlobalSettings() time_span = setting.GetTimelineDefaultTimeSpan() time_mode = setting.GetTimeMode() frame_rate = fbx.FbxTime.GetFrameRate(time_mode) duration = time_span.GetDuration() second = duration.GetMilliSeconds() # NOTE unreal 计算第0帧 所以要 + 1 才和 unreal 的实际长度匹配 frame_count = round(second/1000*frame_rate) + 1 return frame_count &emsp;&emsp;读取 FBX 遇到最大的坑就是 设置 IOsettings 属性&emsp;&emsp;在 C++ 官方文档的说明里面明明是有 IMP_FBX_MATERIAL IMP_FBX_TEXTURE 这些可以通过 SetBoolProp 来设置的 链接&emsp;&emsp;但是 fbx 模块并没有直接提供这些属性，只有 EXP 相关的属性。&emsp;&emsp;结果我就不知道怎样才可以设置导入场景的设置。&emsp;&emsp;后来想到可以打印一些 已有 的 EXP 相关属性的类型，结果发现这些原来都是字符串。&emsp;&emsp;于是又深入查了 C++ 文档，但是 C++ 文档各种变量串在一起，查询起来非常非常混乱。&emsp;&emsp;后来我研究了一下怎么讲 IOSettings 里面相关的字符串全部打印出来，通过 C++ 文档的方法和自己的测试，总算实现了这个效果。 FBX Python SDK 打印 IOSettings 包含的 Property 属性输出的属性整理出的 md 文件 &emsp;&emsp;通过上面输出打印的 IOSettings 可以看到 SetBoolRrop 可以填写控制导入的物体的字符串。&emsp;&emsp;通过这个导入限定，FBX 的读取速度就非常快了。 总结 &emsp;&emsp;这次 Unreal 的工具开发，深度结合了 Python Qt 界面开发和 Unreal 内置的 API ，还额外研究 FBX Python SDK 的 API 使用。&emsp;&emsp;学习到了很多新的东西，不过感觉这些东西没有太多深度，就是资料太少，需要有查文档踩坑的过程。&emsp;&emsp;近期特效给我安排了一个任务，需要将 Unreal 的 Sequencer 里的东西自动导出进行处理。&emsp;&emsp;但是最近查了 Sequencer 的 API ，貌似支持非常不友好，比如无法直接获取到当前 Sequencer 界面所使用的 LevelSequence&emsp;&emsp;所以后续需要研究一下 Unreal 插件开发，通过 C++ 蓝图插件开发来解决这些问题。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
        <tag>🇨🇬CG/FBX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Standalone 后台模式]]></title>
    <url>%2Fposts%2F906141af.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间去有了个小需求，需要批量统计之前做好的动画文件的文件帧数和相应的骨骼数。&emsp;&emsp;之前大部分的批处理都是在前台做的，也没有什么大问题，就是 Maya 一直在加载文件， UI 各种更新确实影响到了执行效率。&emsp;&emsp;最近总算是闲了一点，于是打算好好研究一下通过 standalone 批处理的方法。 &emsp;&emsp;其实早在去年，我就用过 standalone 模式，一直没有写文章进行深刻的总结，不过这个模式也不复杂。&emsp;&emsp;其实就是实现无 UI 界面使用 Maya，通过 Python 命令可以实现大部分的 Maya 操作，这样的好处上面也提到了， Maya 不需要更新 UI ，文件加载效率更高。&emsp;&emsp;关于 standlone 模式， DT 有一套老教程有提到，可惜教程之前被爆破了，我最近上传了补档教程，希望对大家有帮助。 链接&emsp;&emsp;由于教程很少，我之前是通过官方文档研究的。 链接&emsp;&emsp;Stack Overflow 也有不少有用的参考回答 链接 &emsp;&emsp;我之前就一直很好奇， Maya 是如何执行 userSetup 的&emsp;&emsp;为什么使用 standalone 模式也会自动加载到 userSetup 导致开启速度大降&emsp;&emsp;结合着上述的问题，我开始了研究。 Maya 初始化探索 &emsp;&emsp;我之前写了一篇文章，关于如何提取出 mayapy.exe 并且可以正常输出 Maya 文件的文章 链接&emsp;&emsp;mayapy.exe 其实就是重新编译的 python.exe&emsp;&emsp;完全兼容 python2 并且对 maya 内置 dll 进行了底层对接。&emsp;&emsp;我之前的研究发现 maya 的 bin 目录下有 commandList 文件，里面记录了所有的 mel 命令对应读取的 dll 文件。&emsp;&emsp;这些发现其实都和 Maya 启动初始化的读取相关的。 &emsp;&emsp;我们可以直接双击启动 mayapy.exe ， 打开之后的操作和双击启动的 python.exe 没有任何区别&emsp;&emsp;最大的特点是这里定位的 python 包里面已经自带了 maya 包&emsp;&emsp;可以通过 from maya import cmds 来导入 cmds 库&emsp;&emsp;但是当你 print dir(cmds) 你会发现 cmds 库里面的 mel 命令是空空如也的。&emsp;&emsp;根据官方的说法，你需要使用 maya 的 standalone 模式初始化，才可以正常使用 cmds 库。&emsp;&emsp;pymel文档也有提到 链接 &emsp;&emsp;今天就针对上面所列的代码，探讨 initialize 函数执行的背后到底发生了什么。&emsp;&emsp;直觉告诉我，这个东西绝对和 python 的环境相关。&emsp;&emsp;于是我简单粗暴的将 os.environ 的环境赋值为空。&emsp;&emsp;就是想看看 mayapy 会怎么花式报错。 12345import osos.environ = &#123;&#125;from maya import standalonestandalone.initialize() &emsp;&emsp;执行上面的代码，会有如下的代码报错提示 (测试使用的是 Maya2017 的 mayapy.exe) 12345678910111213141516Python 2.7.11 (default, Dec 21 2015, 22:48:54) [MSC v.1700 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import os&gt;&gt;&gt; os.environ &#x3D; &#123;&#125;&gt;&gt;&gt;&gt;&gt;&gt; from maya import standalone&gt;&gt;&gt; standalone.initialize()Error: local variable &#39;commandListPath&#39; referenced before assignment# Traceback (most recent call last):# File &quot;C:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\maya\app\startup\batch.py&quot;, line 5, in &lt;module&gt;# import maya.app.startup.basic# File &quot;C:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\maya\app\startup\basic.py&quot;, line 76, in &lt;module&gt;# maya.app.commands.processCommandList()# File &quot;C:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\maya\app\commands.py&quot;, line 43, in processCommandList# sys.stderr.write(&quot;Unable to process commandList %s&quot; % commandListPath)# UnboundLocalError: local variable &#39;commandListPath&#39; referenced before assignment &emsp;&emsp;这个脚本路径，一看就知道大概是怎么回事了，原来 maya.app 里面还有 startup 的库。&emsp;&emsp;可以断定 startup 肯定和启动初始化有着千丝万缕的关系了。&emsp;&emsp;于是我又将 startup 这个名字稍稍改掉&emsp;&emsp;然后再执行一遍。 12345678Python 2.7.11 (default, Dec 21 2015, 22:48:54) [MSC v.1700 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from maya import standalone&gt;&gt;&gt; standalone.initialize()Error: No module named startup.batch# ImportError: No module named startup.batch&gt;&gt;&gt; &emsp;&emsp;盲生发现了华点了，可以断定 initialize 函数导入了 startup.batch 脚本。&emsp;&emsp;于是追踪 startup.batch 的脚本可以找到下面的代码 12345678"""This module is imported during the startup of Maya in batch mode."""import maya.app.startup.basic# Run the user's userSetup.py if it existsmaya.app.startup.basic.executeUserSetup() &emsp;&emsp;这里导入了 basic 库，然后进行初始化。&emsp;&emsp;于是又可以去追踪 basic 的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283"""This module is always imported during Maya's startup. It is imported fromboth the maya.app.startup.batch and maya.app.startup.gui scripts"""import atexitimport os.pathimport sysimport tracebackimport mayaimport maya.appimport maya.app.commandsfrom maya import cmds, utilsdef setupScriptPaths(): """ Add Maya-specific directories to sys.path """ # Extra libraries # try: # Tkinter libraries are included in the zip, add that subfolder p = [p for p in sys.path if p.endswith('.zip')][0] sys.path.append( os.path.join(p,'lib-tk') ) except: pass # Per-version prefs scripts dir (eg .../maya8.5/prefs/scripts) # prefsDir = cmds.internalVar( userPrefDir=True ) sys.path.append( os.path.join( prefsDir, 'scripts' ) ) # Per-version scripts dir (eg .../maya8.5/scripts) # scriptDir = cmds.internalVar( userScriptDir=True ) sys.path.append( os.path.dirname(scriptDir) ) # User application dir (eg .../maya/scripts) # appDir = cmds.internalVar( userAppDir=True ) sys.path.append( os.path.join( appDir, 'scripts' ) ) def executeUserSetup(): """ Look for userSetup.py in the search path and execute it in the "__main__" namespace """ if not os.environ.has_key('MAYA_SKIP_USERSETUP_PY'): try: for path in sys.path[:]: scriptPath = os.path.join( path, 'userSetup.py' ) if os.path.isfile( scriptPath ): import __main__ execfile( scriptPath, __main__.__dict__ ) except Exception, err: # err contains the stack of everything leading to execfile, # while sys.exc_info returns the stack of everything after execfile try: # extract the stack trace for the current exception etype, value, tb = sys.exc_info() tbStack = traceback.extract_tb(tb) finally: del tb # see warning in sys.exc_type docs for why this is deleted here sys.stderr.write("Failed to execute userSetup.py\n") sys.stderr.write("Traceback (most recent call last):\n") # format the traceback, excluding our current level result = traceback.format_list( tbStack[1:] ) + traceback.format_exception_only(etype, value) sys.stderr.write(''.join(result))# Set up sys.path to include Maya-specific user script directories.setupScriptPaths()# Set up string table instance for applicationmaya.stringTable = utils.StringTable()# Set up auto-load stubs for Maya commands implemented in libraries which are not yet loadedmaya.app.commands.processCommandList()# Set up the maya logger before userSetup.py runs, so that any custom scripts that# use the logger will have it availableutils.shellLogHandler()# Register code to be run on exitatexit.register( maya.app.finalize ) &emsp;&emsp;自动桌的脚本注释还挺全的。&emsp;&emsp;从注释可以知道这个脚本每次启动都会自动加载。 &emsp;&emsp;executeUserSetup 通过代码可以知道如果环境变量存在 MAYA_SKIP_USERSETUP_PY 这个，就不会被执行。&emsp;&emsp;后续也是自动执行 userSetup.py 这个脚本， 其实都是 python 脚本，甚至可以修改这里 userSetup 命名，让 Maya 启动其他名称的脚本 (如果真的这么干的话 TD或TA 估计会疯掉的)&emsp;&emsp;所以代码查到这里，我还额外发现了 MAYA_SKIP_USERSETUP_PY 这个不错的环境变量来加速 Mayapy 的启动。&emsp;&emsp;使用方法也很简单。 12345import os# NOTE 注意环境变量只能赋值字符串os.environ["MAYA_SKIP_USERSETUP_PY"] = ""from maya import standalonestandalone.initialize() &emsp;&emsp;下面的代码可以再逐个分析。&emsp;&emsp;setupScriptPaths 函数会自动将 Maya 一些默认的 scripts 目录路径添加到 sys.path 里面方便导入。&emsp;&emsp;stringTable 就是个字典类， 主要为了实现类似 mel的 res 脚本实现多语言匹配的效果，maya 包里有其他的脚本有用到，可以对照参考。&emsp;&emsp;shellLogHandler 可以追查源码，和 logging 库相关&emsp;&emsp;最后一句则是让 Maya 正常退出的时候执行退出操作。 &emsp;&emsp;processCommandList 可以去找 commands 的 python 脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344import maya.cmdsimport sys, os.path# Locations of commandList file by OS type as returned by maya.cmds.about( os=True )commandListLocations = &#123; 'nt' : 'bin', 'win64' : 'bin', 'mac' : 'Resources', 'linux' : 'lib', 'linux64' : 'lib'&#125;def __makeStubFunc( command, library ): def stubFunc( *args, **keywords ): """ Dynamic library stub function """ maya.cmds.dynamicLoad( library ) # call the real function which has replaced us return maya.cmds.__dict__[command]( *args, **keywords ) return stubFuncdef processCommandList(): """ Process the "commandList" file that contains the mappings between command names and the libraries in which they are found. This function will install stub functions in maya.cmds for all commands that are not yet loaded. The stub functions will load the required library and then execute the command. """ try: # Assume that maya.cmds.about and maya.cmds.internalVar are already registered # commandListPath = os.path.realpath( os.environ[ 'MAYA_LOCATION' ] ) platform = maya.cmds.about( os=True ) commandListPath = os.path.join( commandListPath, commandListLocations[platform], 'commandList' ) file = open( commandListPath, 'r' ) for line in file: commandName, library = line.split() if not commandName in maya.cmds.__dict__: maya.cmds.__dict__[commandName] = __makeStubFunc( commandName, library ) except: sys.stderr.write("Unable to process commandList %s" % commandListPath) raise &emsp;&emsp;这里的操作主要是读取 commandList 文件的 dll 对应关系。&emsp;&emsp;如果前面的 standalone 初始化有些命令没有顺利加载，可以通过 mel 命令引入的 dynamicLoad 方法&emsp;&emsp;重新加载命令。 总结 &emsp;&emsp;Maya 已经和 Python 深度结合了，启动的时候会执行下面的操作 首先加载 dll 添加 cmds 库的 mel 命令 加载 maya.app.startup.batch 库 通过 mel 命令获取 我的文档的 maya 目录一些默认的 scripts 路径 | 添加到 sys.path 里面 初始化 StringTable 调用 通过 processCommandList ， 避免一些 mel 命令漏网之鱼没有加载 初始化信息打印 注册关闭 Maya 事件 executeUserSetup 执行 sys.path 下所有的 userSetup.py 脚本&gt;]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梅开二度 - 校招总结]]></title>
    <url>%2Fposts%2F5e76f729.html</url>
    <content type="text"><![CDATA[背景补充 &emsp;&emsp;去年我校招成功之后，也写了一篇文章总结自己的校招经历，现在回过头来看，我的观点也基本没有变化。 校招之路&emsp;&emsp;最近临近毕业了，老师邀请我给师弟师妹做分享，在今年疫情的大环境下，我感觉还是有很多值得分享的东西。 演讲稿前言 &emsp;&emsp;各位师弟师妹们，下午好，其实我做分享也不是第一次了，基本上每年有机会分享我都来了，相信你们很多人都听过我之前的演讲。&emsp;&emsp;很高兴，这次能够受邀再次过来分享自己入职腾讯的经验和心得。 &emsp;&emsp;这次老师也给我列了一些点，基本上都围绕着大四招聘就业的问题，的确因为疫情关系大家都说 2020 年开启了地狱模式，每年都是最难的求职季，今年更是史上最最最难求职季。&emsp;&emsp;不过在我看来，最难的其实不是我们 2020 届而是你们 2021 届，因为秋招的日子已经快到了。&emsp;&emsp;我们去年的秋招黄金期并没有疫情的影响，所以前期求职顺利的人都还算稳定的。 &emsp;&emsp;当然，你们也不必恐慌，危中有机，只要做好充分准备，找到一份工作其实并没有那么难，毕竟我们国家已经基本全面复工复产了。&emsp;&emsp;比起还在混乱中的美国，我们内部的大环境是要好很多的。 入职回头看 &emsp;&emsp;这个部分我先从我目前在腾讯干的工作。 职业介绍 &emsp;&emsp;我目前就职于 魔方工作室下属的魔术师工作室 岗位是 技术美术。&emsp;&emsp;恐怕大部分人都不太了解技术美术是什么岗位，发挥什么作用。&emsp;&emsp;所以在这里给大家普及一下。 &emsp;&emsp;PPT 上显示的这张图是老外做的 技术美术 技能树 总结&emsp;&emsp;来，我给大家翻译翻译，什么是惊喜。&emsp;&emsp;惊喜就是学到秃头也学不完的技能树。 &emsp;&emsp;的确从图中看到的技能涵盖了程序开发和美术制作的各个流程。&emsp;&emsp;技术美术就是我们数字媒体系所推崇的复合人才，不仅仅会美术制作同时还会编程开发，挺高程序和美术的沟通效率&emsp;&emsp;当然，由于涵盖的范围很广，大部分人都可能掌握图上所有的技能，所以技术美术内部也有自己的细分。&emsp;&emsp;有偏向把控美术效果的 A类 TA ，也有偏向工具开发的 T类 TA。&emsp;&emsp;这些细分主要看公司的规模和流程，理论上公司越大细分就越细。所以大公司更看重特定领域的深度，而小公司人手不够会在技能树的各个方面都得到锤炼。 &emsp;&emsp;其实这个岗位很早就存在，但是过去基本不进行校招，大都只进行社招。&emsp;&emsp;从上面的技能树就可以知道，技术美术需要经验比较丰富的人才，过去大部分技术美术都是入行的 美术制作 或者 程序开发 通过技术和经验的积累转过来的。&emsp;&emsp;不过随着网易等一批大厂开始注重这个岗位的培养，这几年技术美术越来越火。 职业分析 &emsp;&emsp;技术美术这领域的特点是特别契合我们 数字媒体系的专业，我们专业教学领域之广也属大学中比较罕见的。&emsp;&emsp;当然相信大家也都有所体会的，我们学得广然而却学不深。&emsp;&emsp;不过本科就已经开设计算机图形学课程的专业也算是国内不多见的专业了。&emsp;&emsp;正因为这些加成，技术美术这个岗位的对口专业直接指出了我们数字媒体类专业优先。 &emsp;&emsp;是的，这个岗位恰好是刚开始迅猛发展的朝阳岗位，而且我们专业是很对口的。&emsp;&emsp;这让我想起当年我大一入学的时候，大四要毕业的师兄师姐也说过类似的话。&emsp;&emsp;2016年时候国内前端网页开发，刚刚开始经历 JQuery 和 ES5 技术的大洗牌。&emsp;&emsp;前端的三大框架逐步在国内推广，但是行业发展尚不成熟。&emsp;&emsp;那个时候只要比别人多会点框架知识，就已经很有竞争力，去大厂也不是梦。&emsp;&emsp;可是经过几年的发展，前端这个行业已经逐步成熟，培训机构的大力发展更是让这个行业的竞争越来越大。&emsp;&emsp;现在如果打算往前端网页开发方向走的同学，学习前端主流框架是必须的知识，同时还要应付算法题、计算机网络等等考验。&emsp;&emsp;难度可谓是今年前翻了一番。 &emsp;&emsp;所以我在这里引入前端行业蓬勃发展的例子是想要说明，行业发展的确存在红利期的。&emsp;&emsp;就像雷军说的，站在风口上，猪都会发。&emsp;&emsp;目前前端行业不如成熟，技术红利期基本结束，想要入职大厂已经远远没有前几年那么轻松了。 &emsp;&emsp;所以我通过这样的分析，觉得自己很幸运，把握住了时机，我虽然搞程序开发，但是并没有刷过算法题就成功进了大厂。 &emsp;&emsp;这么一说，你们恐怕眼睛都亮了，这个岗位岂不是去大厂的捷径了。&emsp;&emsp;NO, NO, NO, 其实行业的不成熟也有它的难点，只是各自的特点不一样，所以要进大厂还是需要自己脚踏实地，做好积累。 &emsp;&emsp;就现在还不成熟的技术美术岗位来说。&emsp;&emsp;刚才发出的技能树图片，国内有中文的资源就已经特别少了，别说专门针对这个岗位的培训了。&emsp;&emsp;很多教程都是老外录制的没有翻译的教程。&emsp;&emsp;甚至后面开发东西的需求是教程没有的，你要对软件很熟悉，并且对 API 命令文档有基本的认识。 API 文档就相当于软件字典。&emsp;&emsp;你需要自己查软件提供的命令来开发工具解决当前的需求。&emsp;&emsp;这些东西很难在网上找到具体的解决方案，国内就更少了，有时候需要自己琢磨分析，自己订立一套流程方法。&emsp;&emsp;因为资源少，所以基本上靠自学，因为涉及的领域太广，工作上的同事也未必各个方面都懂，所以求人不如求己。&emsp;&emsp;工作上可以交流，有经验的人会给你指个方向，但是具体的实现方法就只能靠自己来弄了。&emsp;&emsp;这个就是行业不成熟的痛点，英语要求过硬，并且要有自己一套解决问题的方法论，大部分时候只能靠自己，靠谷歌查外国的论坛。 &emsp;&emsp;如果时光回到几年前刚开始迁移框架的前端领域，其实遇到的问题也和目前技术美术相似，只是领域跨度没有技美那么夸张。 &emsp;&emsp;分析了这么多，我想强调的是，不要听风就是雨。&emsp;&emsp;我觉得就业最可怕的就是对行业不了解，以为自己进了理想中的岗位，然而现实的情况却和自己的想象天差地别。&emsp;&emsp;我大一的时候也或多或少受到师兄说辞的影响，大二也学了一年的前端开发。&emsp;&emsp;当时跟着创业的师兄做项目，我是亲身感受到了前端行业的快速发展，后来因为抓到了去影视公司实习的机会，我还是投身到了自己最初所热爱的行业里去了。&emsp;&emsp;目前大家准备就大四了，相信职业方向也基本明确了，在求职之前最好找一下往届走自己同一个方向的师兄师姐，跟他们聊聊目前行业的情况以及求职面试各方面的经验，如果从事相关领域工作的，我相信给出的建议会比我更好的。 校招的重要性 &emsp;&emsp;校招对于应届毕业生来说非常非常重要。&emsp;&emsp;校招是人生仅有的一次的优惠券，大学的校招差不多是最后一场同龄人之间的竞争了。&emsp;&emsp;以后步入社会，社招的情况就是各种年龄段的牛鬼蛇神都会冲到一起竞争，特别是大厂，竞争压力会非常大。&emsp;&emsp;而且校招校标准是看重应届毕业生的潜力，公司注重培养，有试错的空间。&emsp;&emsp;所以校招进入大厂算是比较轻松的方法，以后社招进大厂就很难很难了。 &emsp;&emsp;要想进大厂，只要你的竞争力远超你的同龄人，你的胜算就很大了。&emsp;&emsp;那竞争力要如何体现的，我觉得曹政大大的文章很有收获 人生的选择题和证明题&emsp;&emsp;很多人会说选择大于勤奋，就像我刚好选了技术美术这个岗位，去年腾讯竞争比例只有 10:1 (大部分岗位都在 50:1 左右)，一起竞争的同龄人少，自然是更容易脱颖而出的。&emsp;&emsp;但是正如曹大所说的，做人生的选择题是有前提，你只有把自己的证明题做好了，你才有权利做选择题。&emsp;&emsp;证明题做不好，选择题没法做。证明题做好了，即便选择题做错了，还有源源不断的选择题可以做。&emsp;&emsp;那么如何才能做好证明题，考研、实习、比赛这些都可以成为能力的证明。&emsp;&emsp;所以校招要拿到 offer ，证明自己能够胜任这份工作是很重要的。 &emsp;&emsp;我是那种追逐自己热爱的东西，讨厌应试教育的人，所以我在比较早的阶段就放弃了考研这个方向。&emsp;&emsp;下面就是实习和比赛到底哪个证明题更好做呢？&emsp;&emsp;其实这个答案我基本呼之欲出了，毕竟我们学校是双非，我们专业的竞赛选择也极度有限。&emsp;&emsp;如果不能参加一些企业认可的比赛，那这道证明题等于白做了。&emsp;&emsp;所以我选择了实习来快速证明自己。&emsp;&emsp;为了证明自己，你最好要留下自己的印记。&emsp;&emsp;比如我就是不断更新自己的个人博客，将很多问题的研究和解决方案都复盘写成文章记录到博客上。&emsp;&emsp;虽然这样需要花很多额外的时间进行复盘，但是这样的积累是很有收获的，有些工作上的问题，自己解决了也不一定记得住。&emsp;&emsp;这个时候就可以翻翻博客，可以找到以前的一些技术细节。&emsp;&emsp;面试的时候，博客的文章可以看到时间线的，面试官也会觉得你一路走来是这么成长的，很有说服力。&emsp;&emsp;另外实习不要嫌苦嫌累，作为学生能自己赚钱养活自己，我当时真的很满足了，钱少一点也无所谓的。&emsp;&emsp;实习可以找往届的师兄师姐或者可靠的人推荐，但是一旦选好去了实习，没有3个月不建议更换。&emsp;&emsp;特别是在疫情大环境的当下，实习时间太短反而是负印象，而且时间太短也学不到太深的东西，证明题做不好的。&emsp;&emsp;当然虽然不建议换，但是如果实习公司真的不靠谱，还是得有壮士断腕的勇气的。 &emsp;&emsp;那么校招一般从什么时候开始，又是什么时候结束呢？&emsp;&emsp;其实不同行业的时间是不统一的，互联网企业会比较早，像去年腾讯 8月1日 就开放了 2020届的校招简历投递了。&emsp;&emsp;而一些传统行业比如房地产公司、银行会到 9月甚至10月才开始校招。&emsp;&emsp;秋招有金9银10的说法，基本过了 9月 10月 之后，第一梯队的大厂招聘就结束了，后面可能个别岗位还有补招的机会，但是大部分岗位都将招满。 校招复盘 &emsp;&emsp;下面这个部分我就针对大四校招这个重要的话题来分享，复盘一下我去年的校招经历。&emsp;&emsp;我去年是先去了影视公司实习，主攻 Maya 的工具开发和流程建设。&emsp;&emsp;当时完全没有考虑过像腾讯这么大的游戏公司，因为当时对游戏行业的了解还不够深入。&emsp;&emsp;以为游戏开发都是用 3dsMax 的，我搞 Maya 可能没有用武之地。&emsp;&emsp;所以我当时也完全没有关注腾讯相关的招聘，其实早在 3-4 月份，腾讯就会开始招大三的同学去暑假实习了。&emsp;&emsp;后来我们专业有同学通过了腾讯的测试，去大厂暑假实习，我才后知后觉。 &emsp;&emsp;那个同学也是在腾讯做技术美术，所以当时我也找他聊了很多东西。&emsp;&emsp;希望补足自己短板，抓住秋招的机会。&emsp;&emsp;如果没有他，我可能现在还在影视公司工作。 &emsp;&emsp;现在已经 6月份 腾讯的暑假实习通道已经结束了，有准备的同学相信已经提前准备好投递了。&emsp;&emsp;因此下面的时间里，如果大家没有升学计划的话，一定要抓住校招的机会。 &emsp;&emsp;我的校招只投了两家公司，因为我当时实习的公司已经确定让我留下来了，我有保底的选项。&emsp;&emsp;我当时第一时间就投了腾讯提前批，然后又找了靠谱的同学去走网易的内推流程。&emsp;&emsp;这里如果大家没有什么经验的话还是推荐先海投公司，即便是些小公司也无所谓，面试这个是需要通过社会的毒打来锻炼的。&emsp;&emsp;不建议一开始面试就是大厂，应该先投些自己心中二三梯队的公司锻炼自己临场发挥的能力，并且掂量一下自己实力程度如何。&emsp;&emsp;有了充足的准备和经验积累再去挑战大厂的 offer 。 &emsp;&emsp;当时投递过了17天，是我现在的导师直接打电话联系我的，当时就着我实习的工作问了我很多技术上的问题。&emsp;&emsp;好在我在实习公司都有所涉猎，回答得比较顺利。&emsp;&emsp;后续就给我出了一道测试题，让我在1周内完成。&emsp;&emsp;然后我就花了好几天时间把测试题做好，发过去。&emsp;&emsp;几天之后就通知进行面试，我当时暑假在深圳实习，就直接去腾讯面试了。&emsp;&emsp;因为是提前批，面试就只有两个人，一个主美另一个是我现在的导师，环境和氛围比较轻松，我也不太紧张。&emsp;&emsp;面试也问了好多问题，因为我的技能树比较片面，所以只能避重就轻，不懂的就直接不懂 pass 掉。&emsp;&emsp;有时候不懂装懂反而不好，显得很虚伪。但是如果这个又不懂，那个也不懂，印象分还是会掉很多的。&emsp;&emsp;当时面试结束就很稳了，面试官直接和我说回去等 HR 的消息了 ~ &emsp;&emsp;网易那边先是做内推的测试题。&emsp;&emsp;8月份做完发过去之后，大概 9 月份通知面试。&emsp;&emsp;网易的面试压力比腾讯要大很多，当时是 程序大佬、美术大佬、技术美术大佬、HR一群大神围着我，在个小房间里轮流问我问题。&emsp;&emsp;有点接近压力面，只要自己准备充分，其实也不是很慌，我还是按照之前的做法，不懂直接 pass 掉。&emsp;&emsp;当然这个过程中，自己也吃了个大亏，我在简历里面写了大学开发了寻路系统，有了解过地杰斯特拉算法。&emsp;&emsp;结果程序大佬直接让我讲解这个算法，我之前没有重视简历的内容，吃了很大的亏。&emsp;&emsp;所以这个方面我也只能回答不懂，但是尽量将算法研究的问题引到自己懂的地方，比如我在实习公司有特别学习研究过的空间切分算法来挽救印象。&emsp;&emsp;最后整个过程还算顺利。 &emsp;&emsp;最后 9 月底就都收到了两家公司的 offer&emsp;&emsp;以上就是我去年校招的经历，我主要经历了秋招的过程，如果大家秋招不如意也不必气馁。&emsp;&emsp;来年还有春招的机会，好好复盘，查漏补缺。 总结 - 回答 &emsp;&emsp;这里我总结一下我校招的整个历程，顺带回复老师给我的几个问题。&emsp;&emsp;专业能力上我认为需要时间的积累和沉淀，极度推荐通过实习来让自己的专业能力快速提升，特别是互联网相关的行业。&emsp;&emsp;综合素质上首先要肯定的是，校招看重的是潜力以及达到岗位要求的能力，如果没有这个前提，其他的情况都是免谈的。&emsp;&emsp;当然学校的表现等等也是有参考价值的，特别是竞争激烈的岗位，如果有很多人才给企业抉择，企业就会想方设法刷掉有问题的人。（比如被学校记大过等等的情况）&emsp;&emsp;心态上，一定要放平心态，我们刚开始步入社会，未来的人生路还很长。&emsp;&emsp;你可以想想10年后的自己回想现在找工作的状态，也不过是人生的一个阶段的转折而已，&emsp;&emsp;爷青结，但求无悔。 校招必备哪些技巧 校招日历公众号 - 关注校招公司的时间知页简历 - 做简历的好帮手 &emsp;&emsp;说实话，我校招过了之后，后续就没有太关注招聘的事情，因此分享的工具也比较少。&emsp;&emsp;如果大家自认为自己能力还不太够的话，强烈推荐海投公司，投了还有机会，不投就真的没有机会了。 校招日历 &emsp;&emsp;由于我没有采用海投的策略（反面素材），所以校招日历并没有很好地用起来。&emsp;&emsp;这个公众号会定期公布各个大公司的校招时间，及早关注不容易错过。 简历 &emsp;&emsp;知页简历可以比较轻松地完成一份好看的简历，很推荐。 &emsp;&emsp;在简历的制作上，我推荐把简历弄精简，不用写太多无用的东西。&emsp;&emsp;我当时投个腾讯的简历也就写了 2 页。&emsp;&emsp;简历内容一定要和所投的工作强烈相关，大学时期获得一些无关的经历和奖项不建议写到简历里了。&emsp;&emsp;除非简历里真的没有什么可以写，才把那些东西拿来凑数。 面经 &emsp;&emsp;面经即为面试经验分享，大家可以去知乎和B站看一些大佬的分享。&emsp;&emsp;不同行业，不同岗位的情况都不一样，你们可以找些岗位相关的经验来看看。&emsp;&emsp;如果自己简历太差，走不到面试环节，还有传说中的霸面可以做，也就是没有收到面试邀请，前行参与面试。&emsp;&emsp;只要有机会，就要相信自己，牢牢把握住，往年也有不少大佬是通过霸面拿到 offer 的。 总结 &emsp;&emsp;我自己行业和岗位是技术性很强的，因此面试环节比较松，只要技术过硬，都好说。&emsp;&emsp;如果是行政或者销售类的岗位，可能面试情况会很复杂，比如说有群面的环节。&emsp;&emsp;这方面也有很多技巧和策略的，大家可以自行到网上查找相关的内容。 寄语 &emsp;&emsp;在疫情的大环境下，我希望大家不要好高骛远，先就业再择业，虽然有点官方套话，但还是有它的道理。&emsp;&emsp;我想起了《三体》的一句名言 弱小和无知不是生存的障碍，傲慢才是 同样 弱小和无知不是就业的障碍，傲慢才是&emsp;&emsp;就业也是同样的道理，有的人校招可能很顺利，那是因为在校招之前就已经准备了很多付出了很多。&emsp;&emsp;今年我们专业也有成功去了字节跳动的师姐，她也准备了1年的面试和算法题才成功进去的。&emsp;&emsp;机会是留给有准备的人。 &emsp;&emsp;今年的校招会在疫情的大环境下有很大的变化，提早适应变化的人可以抢占先机。&emsp;&emsp;最后还是要强调，切忌急功近利，我相信知识都是有用的，技多是不压身的，只是这个过程是需要长时间的积累和沉淀的。&emsp;&emsp;太过功利反而会捡了芝麻丢了西瓜。]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业设计 - WebGL三维网站全栈开发]]></title>
    <url>%2Fposts%2F7bc09203.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;毕设说实话并没有花费太多的时间投入进去，毕竟工作上的事情也很多。&emsp;&emsp;最初聪哥是和我说直接帮我解决毕设的问题的，我的毕设其实和大学打的创业比赛的那套 WebGL 模型预览网站的东西是一样。&emsp;&emsp;当时报备毕设的时候就想着应付一下，不打算花费太多的心神。 &emsp;&emsp;后来师兄的工作室开发 Zeus 三维素材预览软件。&emsp;&emsp;于是我就掺和了进去，为了实现跨DCC实现三维预览，我这里也借助了 WebGL 的功能，并且开发了 CefWidget&emsp;&emsp;随着开发的深入，后面我也想着不如就把这个资产浏览器当做自己的毕设好了。&emsp;&emsp;但是毕竟代码都是师弟他们弄得，我就过来打打辅助而已，怎么可以直接拿别人的代码当毕设呢？&emsp;&emsp;所以我最初打算分成两条线开发，我自己也写一个资产管理的软件。&emsp;&emsp;于是那段时间开始开发 Qt 数据双向绑定的库，打算拿资产开发作为这个库最终效果的测试。&emsp;&emsp;为了搞这个，又去研究 Vue.js 的 MVVM 架构，去学习了解了 Flux 设计模式。（搞了一大通，最后其实一脸懵逼） &emsp;&emsp;后来双向数据绑定的开发难产（现在也没有完全搞完，思路还改了一波），自己开发资产库的计划就一拖再拖。&emsp;&emsp;最后临近5月份，老师催着要交论文了，没有办法。&emsp;&emsp;我只好改变思路，直接做毕设差不多的网站出来算了。 &emsp;&emsp;想到做网站，需要用到服务器，要做全栈开发，突然觉得可以去学学 Go 开发，也挺好的，最近各路神仙大佬都推荐学习这个。&emsp;&emsp;于是就自己学 Go 来做一下后端开发了。所以就开始了一个星期突击学习速成毕设的过程。 技术选型 &emsp;&emsp;决定要独自搞毕设之后，首先就要进行技术选项评估了。&emsp;&emsp;后台毋庸置疑选用 Go 来实现了，前端还让我纠结了好一会。&emsp;&emsp;想到之前还在研究 Vuex 的全局状态管理是如何实现的，于是我打算这次前端也用 Vue 来搭建吧。&emsp;&emsp;因为赶时间，就直接用后台框架去 vue-element-admin 做了，结果是个大坑。&emsp;&emsp;服务器端因为用来了 宝塔面板 ， 可以快速建站，搭建 MySql 数据库也非常简单。&emsp;&emsp;由于网站搭建的内容不太够，所以又拿了之前研究的 CefWidget 跨 DCC 浏览器进行凑数。 &emsp;&emsp;下面就把论文的部分整理出来，相当于水了一篇文章。 摘要 &emsp;&emsp;基于WebGL技术驱动的三维网站，实现跨 Digital Content Creation软件的三维资产库。基于 Go Iris 框架搭建软件的后台系统，进行服务器端的数据交互，通过腾讯云的 Linux服务器上搭建 MySql 数据库进行数据保存。通过前端框架 Vue Element Admin 搭建后台管理系统的前端页面，实现线上模型素材的管理。通过 Python Cefpython3 库实现浏览器在 Qt 框架下的嵌入，实现将WebGL技术封装到 Digital Content Creation软件中，最后使用 Python 的 Qt 框架搭建出可以在不同软件平台下启动的三维资产库客户端。 &emsp;&emsp;由于 Digital Content Creation软件下的 Python 经过了特殊的修改，并不支持一些Cython 编译的程序库，因此这里将 Cefpython3 实现的浏览器通过 Socket 套接字编程搭建Python服务器端口来进行进程通信，利用 Cef 的嵌入原理将浏览器嵌入到Qt图形界面当中。 关键字：WebGL，Vue, Go, Python，Qt, CEF 1.绪论1.1 课题简介 &emsp;&emsp;WebGL基于 OpenGL ES2.0 的标准在网页浏览器中实现三维图形渲染的效果，因为其所具备跨平台交互体验好的基础，目前在网页开发中越来越受到青睐。 &emsp;&emsp;这里我们基于 Three.js 使用 WebGL 技术搭建出可在网页上预览三维模型的编辑器，Three.js 是开源的 WebGL 框架，内置了许多关于三维操作的函数，可以极大简化开发难度。 &emsp;&emsp;网站的搭建基于前端框架 Vue.js 搭建出后台数据管理系统，Vue.js 是目前主流的网页渲染框架，其技术开发借鉴了 Angualr.js 和 React.js 兼具模板引擎和js拆分功能。目前Vue的社区非常活跃，在前端开发中具有不可磨灭的影响。 &emsp;&emsp;后台服务端使用 Golang 语言的 Iris 框架，使用 mysql 数据库进行后台数据存储。Golang语言由Google开发并维护的编程语言，是目前服务器后端开发中的后起之秀，由于其性能优秀，使用简单，已经越来越广泛地运用到各种编程的领域里面。 &emsp;&emsp;桌面客户端这是基于跨平台的 Qt 框架利用 Python 绑定，使用 python 进行编写，因为目前各种 Digital Content Creation(以下简称 DCC ) 软件大部分都是 Qt 框架开发的，都支持 Python Qt 图形化界面开编写软件的工具，通过 Python Qt 编写图形化界面就可以将我们的 WebGL 网站嵌入到 DCC软件中。 2.Vue前端页面开发2.1 Vue 框架介绍 &emsp;&emsp;Vue.js是一套构建用户界面的渐进式框架，采用自底向上增量开发的设计，通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 &emsp;&emsp;Vue.js 是目前主流的前端三大框架之一，比起原生JavaScript，Vue不再需要让用户操作DOM元素，解放了用户的双手，让程序员可以更多时间去关注业务逻辑，并且Vue使用了MVVM模式实现了数据的双向绑定，这样数据的更新操作更加简单使用，开发效率更高。 &emsp;&emsp;在使用 Vue .js 之前需要先安装 node.js 引擎，node.js 借助谷歌chromium V8引擎实现JavaScript 脱离浏览器运行，让 JavaScript 的开发边界极大扩大了，因此基于 node.js引擎让不仅仅诞生了服务于后端的 express 框架甚至可以用 electron 框架进行桌面开发。 &emsp;&emsp;安装了 node.js 之后就可以在系统的命令行中访问 npm 模块管理器，通过 npm 可以下载 JavaScript 生态下社区所贡献的各种不同的模块，极大丰富了编程世界的活力。 &emsp;&emsp;Vue 也是基于 node.js 对 .vue 文件进行解析编译，然后通过 Webpack 工具将开发好的页面精简打包成一个静态网站。 &emsp;&emsp;可以通过 npm 安装 vue-cli 来快速配置 vue ，直接通过 npm install –global vue-cli 即可，然后就可以使用 vue init 命令初始化一个简单的 Vue 工程。 &emsp;&emsp;Vue工程已经配置好所有的 JavaScript 依赖库，以及 webpack 等工具的配置，查看 package.json 可以看到 dev 命令已经配置了 webpack 服务器，可以直接使用 npm run dev 来开启服务器预览 Vue 生成静态页面。 2.2 Vue 前端页面概览 &emsp;&emsp;前端的界面借助于饿了么开发的 element 框架，使用搭建 admin 后台，这里借助了 Github 上开源的 Vue-element-admin 进行简单的构建。 &emsp;&emsp;首先我先去 Github 上将相关的仓库 clone 下来，然后通过 npm 模块管理器安装 Vue 相关的 JavaScript 模块。由于国内的网络原因，这里我采用了淘宝的镜像源来加快模块的下载速度。 &emsp;&emsp;执行 npm install 命令安装模块可以读取当前目的 package.json 文件，自动安装项目的相关依赖。安装完成之后会在当前的目录下增加一个 node_modules 目录，当前目录里面就包含了启动项目所有的依赖项，通过执行 npm run dev 命令.启动前端页面。 图2.1 前端登录页面 &emsp;&emsp;后续点击登录即可进入到框架提供的后台管理页面，登录进去之后的页面如下: 图2.2 模型列表页面 &emsp;&emsp;后台系统包含了用户中心可以查看用户注册的信息，以及所有的模型列表还有模型的贴图和上传用户的名称。 &emsp;&emsp;整个模型列表页面包含了数据库的增删改查所有的操作，其中左上角有搜索栏可以进行模型搜索，也可以点击添加按钮添加新的模型项。 &emsp;&emsp;模型列表的右侧有每一个模型记录的修改按钮和删除按钮。 &emsp;&emsp;删除按钮通过 element-ui 的 el-popconfirm 进行了防误删处理，给用户一个提醒。 图2.3 防止误删除警告 &emsp;&emsp;修改按钮点击可以打开外部链接进入到 WebGL开发的编辑器进行模型文件的修改。 2.3 Vue 代码开发 &emsp;&emsp;成功启动项目之后，我们可以去到 src\router 文件夹去配置页面的路由， Vue-element-admin 的路由和侧边栏是绑定到一起的，因此只需要配置路由就可以完成后台系统的侧边栏配置。 &emsp;&emsp;路由配置分别指向对应的组件页面就可以实现点击侧边栏进行相应页面的跳转，使用Vue.js 的前端框架比起过去的 JQuery 操作会更加方便有效。 图2.4 路由配置 &emsp;&emsp;配置好路由之后就就可以去到相应的组件进行页面编写了，这里配置的 Component路径 \@ 表示 src 的目录，这个配置可以在 jsconfig.json 文件中找到。 &emsp;&emsp;用户中心的代码文件再 profile 文件夹里面，这里使用了三个组件来组成分别修改用户的头像信息以及用户个人信息和修改密码。 图2.5 用户中心代码 &emsp;&emsp;在 js 的路径部分，这里使用了 Vuex 进行全局的状态管理，通过 axios 来发送响应的 http 请求访问后端程序，实现从数据库中获取数据。 &emsp;&emsp;模型列表的部分就比较复杂一点，这里通过 el-table 组件实现数据的呈现，从后端获取了数据之后，通过前端 js 的filter 对数据进行过滤和展示。 &emsp;&emsp;点击修改按钮执行 js 命令打开 WebGL 编辑器外链接，点击删除按钮则直接删除当前列表中的数据。 图2.6 模型列表代码 &emsp;&emsp;目前的开发阶段还没有搭建起后端数据，这里可以使用 Mock.js 来模拟后端数据返回的效果，从而测试我们网站的接口功能是否运行正确。 图2.7 Mock 模拟接口返回的数据 &emsp;&emsp;下面就可以在 Vue 里面通过 axios 库来进行 http 请求访问模拟的数据端口获取模拟数据返回到前端页面当中。 图2.8 axios 访问请求后端接口 &emsp;&emsp;其中request脚本封装了 axios 库的请求操作，让这里的代码更加清晰。 3.WebGL 编辑器开发3.1 Three.js 三维基础 &emsp;&emsp;Three.js 极大的简化了 WebGL 的操作，不再需要手动去处理 GL 的缓存，也不需要调用 compileShader 等一系列 WebGL 内置的API ，这些操作 Three.js 已经封装好了。使用 Three.js 搭建三维页面只需有三件套接口，即 场景 摄像机 渲染器 三样东西。 &emsp;&emsp;有了这三样东西的确就可以搭建出一个三维场景,但是我们依然什么都看不到，还需要搭建出一个几何体来进行观察， Three.js 提供了一些创建简单几何体的 API ，可以通过BoxGeometry 创建几何体，然后赋予材质 MeshBasicMaterial ，最后通过 mesh 将所有的数据整合到一起，并且将 mesh 添加到场景中，就可以通过渲染看到场景中的几何体了。另外由于 WebGL 是图形化的处理，因此也需要类似游戏一样不断地去刷新页面来实现页面更新的交互，代码处理需要通过 js 的内置命令 requestAnimationFrame 的递归来实现自我调用的效果，从而实现帧刷新。 &emsp;&emsp;下面就是搭建一个简单的 Three.js 场景的代码。 图3.1 简单三维场景搭建 3.2 Three.js 编辑器开发 &emsp;&emsp;由于 Three.js 是基于 es5 的标准下开发的，这是一个历史问题了，因此这里没有使用前端的框架而是使用 JQuery 脚本来处理浏览器的 DOM。 &emsp;&emsp;这里我们借助 Three.js 内置的 ui.three.js 脚本所提供的简单 UI 来讲来进行不同界面的编写。 &emsp;&emsp;通过 Editor 脚本将所有的 UI 以及 Three.js 的场景全部整合到一起。其中利用 signal 脚本给编辑器创建了一个观察者模式，从而实现各种不同函数的注册方便后续进行相应的回调。 &emsp;&emsp;最后会在 Eidtor 脚本里面搭建出 Three.js 场景所需的三件套。 图3.2 Editor脚本搭建 &emsp;&emsp;这样就可以创建出一个 Editor 的类，然后通过 Editor 类将相关的 UI 挂在到Editor 上面。 &emsp;&emsp;这里通过 MenuBar 来实现上方的菜单栏挂载，这里添加了编辑菜单，文件菜单，帮助菜单等菜单。 图3.3 Menu菜单处理 &emsp;&emsp;另外还需要 Viewport 脚本处理摄像机控制，否则显示的页面里摄像机是无法动弹的，因此这里需要 EditorControl 来实现摄像机的控制器，通过raycaster通过发射射线来获取视窗里面点击的物体。 图3.4 射线获取点击 &emsp;&emsp;最后获取到点击的物体之后，通过 Three.js 内置的 TransformControl 来显示控制轴从而实现控制器位置的更改。 图3.5 TransformControl 相关处理 &emsp;&emsp;写完上述的脚本之后可以在 index.html 里面调用这里相关的类的来启动编辑器页面了。 图3.6 编辑器启动代码 &emsp;&emsp;实现上面的脚本之后就可以在浏览器启动看到我们简单编辑器页面了。 图3.7 简单的编辑器页面 &emsp;&emsp;后续就是进一步完善编辑器的功能，给编辑器添加编辑面板侧边栏和下方工具架。 &emsp;&emsp;编辑面板需要集成大纲类表和物体的位移编辑以及材质编辑的功能，这里也运用了类似于菜单的集成方式，通过一个主要 SideBar 脚本将其他的组件集成到一起。 &emsp;&emsp;其中会在界面中生成所有物体可能出现的属性，然后通过字典判断物体是否存在相关属性从而实现对数据的显示和隐藏。 图3.9 属性显示过滤 &emsp;&emsp;物体的材质属性显示运用了同样的原理，读取物体的材质是否存在相关属性，存在属性才显示，从而实现编辑面板属性的动态更新。 &emsp;&emsp;相关的属性更新则是通过命令模式，通过 Editor 注册相关的命令，然后在这里显示的组件发生更新的时候触发更新命令实现全部更新的统一。 &emsp;&emsp;大纲列表的显示则是其实也很简单，通过递归的方式遍历场景中所有的物体，然后根据遍历到的层级添加响应的侧边宽度，实现一种属性结构的显示，这里使用了闭包的方式进行场景物体的遍历。 图3.10 简单的编辑器页面 &emsp;&emsp;最后则是通过浏览器的 addEventListener 来实现鼠标的拖拽事件从而改变物体相应的层级，并且添加响应的信号槽来触发相应的注册事件。 &emsp;&emsp;接下来就是底下的工具架创建了，这里要添加上位移旋转缩放的切换功能，还要有移动吸附的相关功能。 &emsp;&emsp;只需要添加点击按钮提供的功能，然后根据 TransformControl 里提前设置好的信号槽进行属性设置就可以实现点击按钮切换控制轴的效果。 图3.11 工具架的控制轴设置 &emsp;&emsp;至于工具架上的位置吸附功能也是通过信号槽事件进行触发，这里还添加多了以个场景信息的显示控制，场景信息通过遍历所有的场景获取出场景中包含的几何体个数以及边数面数，这里还增加了点击更新选择的数据的效果，从而可以统计单个模型的带线面效果。 &emsp;&emsp;这里添加了编辑器网格显示的可视化控制，网格则是通过 GridHelper 辅助显示工具显示出来的。 &emsp;&emsp;最后将上面的面板集成到 index.html 里面就有了基本的编辑器效果。 图3.12 面板集成 &emsp;&emsp;这里生成物体使用了 uuid 的方式进行记录，确保生成的物体有唯一辨识码。可以快速获取物体而不会产生混淆。 &emsp;&emsp;不过这里的面板显示会极大减少模型显示的空间，因此这里我在有下角添加了一个主菜单按钮，可以快速方便地隐藏掉编辑器的面板显示。 图3.13 右侧菜单 &emsp;&emsp;这个菜单动画通过 JQuery 插件实现，面板的隐藏则是直接获取面板的 id 标记进行toggle动画隐藏，另外这里还添加了正侧顶视图的正交视图效果，通过修改 Three.js原生的 EditorControl 实现透视摄像机和正交摄像机两种不同视角的切换。 图3.13 判断当前摄像机的类型从而实现不同的操作方式 &emsp;&emsp;另外默认情况下，编辑器是没有默认灯光的，因此添加了模型之后就是黑漆漆的显示，因此我参考了 Maya 一类的软件添加了默认的摄像机灯光，光照方向沿着摄像机方向照射过去，确保即便没有灯光也可以观察到模型的基础显示效果。 4. Go后端服务开发4.1 Golang 语言概览 &emsp;&emsp;Go语言是谷歌推出的一种全新的编程语言，可以在不损失应用程序性能的情况下降低代码的复杂度。 &emsp;&emsp;Go具有现代程序语言的特色，包括垃圾回收、内存管理等功能。而且Go的运行速度非常快，几乎和 C 或 C++ 程序媲美，能够快速迭代开发。 &emsp;&emsp;Go专门为构建服务器所设计的，因此他的并发性能非常良好，而且解决了多核心处理器调用的难题，让Go能够充分发挥现代计算机硬件的性能。 &emsp;&emsp;相较于边语言，Golang的语言特性让其短短十几年内快速发展，越来越多大公司的后端服务都开始转向 Go 语言进行构建，大名鼎鼎的 Docker 项目就是用 Go 开发的。 4.2 Iris 框架介绍 &emsp;&emsp;Iris 是Go语言中用来开发 Web应用的框架，他可以在不同的机器上高效率运行，而且API非常简单功能却非常强大，最重要的是支持后端的 MVC 框架，更加方便企业级项目的管理。 &emsp;&emsp;目前Iris框架是后端领域中性能最强的框架之一。 图4.1 Iris框架性能对比 &emsp;&emsp;Go 服务器采用 Iris 框架，基于 Xorm 进行进行 mysql 数据库绑定。服务器后台使用腾讯云购买的服务器，使用宝塔面板搭建数据库进行管理。 4.3 服务器环境配置 &emsp;&emsp;首先去到腾讯云的服务器上安装 Linux 操作系统的镜像，然后通过 ssh 配置登录到服务器的命令行面板里面，执行宝塔面板的安装命令即可全自动安装宝塔面板，然后通过宝塔面板可以图形化配置服务器。 图4.2 宝塔面板的安装命令 &emsp;&emsp;yum模块是 Centos 自带的系统包管理器，可以获取一些别人整理好的模块安装到当前系统里面。 &emsp;&emsp;安装完成之后就可以顺利通过宝塔面板的提示登录到面板系统当中。 图4.3 宝塔面板的安装完成提示 &emsp;&emsp;顺利登录进入宝塔界面之后可以根据提示快速配置服务器需要用到的环境。比如Mysql数据库以及数据库管理工具 phpMyAdmin 来图形化管理 Mysql数据库。 图4.4 快速配置服务器环境 &emsp;&emsp;可以去到宝塔面板的数据库页面去新建一个新的数据库。 图4.5 新建数据库 &emsp;&emsp;新建数据库可以配置数据库的登录账号和密码，自动分配数据库访问权限，也可以设置数据库只供本机 IP 进行访问，防止被恶意利用。 图4.6 phpMyAdmin界面 &emsp;&emsp;完成数据库搭建之后就可以登录到 phpMyAdmin 界面里管理 MySql 数据库里的表和数据了。 4.4 Go代码编写 &emsp;&emsp;编写Go需要先安装 Go编译器，可以去中文官网下载Go编译器的安装包进行安装。 &emsp;&emsp;安装完成之后，就可以通过命令行调用 go 命令来执行 Go 语言的代码。 图4.7 简单的Go代码运行 &emsp;&emsp;下面就可以通过 Go 来安装搭建服务器所需要依赖的代码库了，通过 go get 命令可以直接将 github 上的源码库下载 GOPATH 环境变量路径所指向的 src 目录里面，get下来的模块就可以全局 import 导入来使用了。 图4.8 代码目录结构 &emsp;&emsp;Go的后端代码基于 MVC 框架加 Service 服务实现，由于后端没有界面，因此这里的View指代的是路由地址，前端界面通过 http 请求访问不同的路由地址，Go会根据请求去调用对应路由的 Model 和 Controller ，而 Service 则将数据库的操作从 Controller 分离出来，方便不同 Controller 之间的相互调用。 &emsp;&emsp;首先需要去 config.json 文件配置服务器监听的地址以及数据库访问的一些信息。 图4.9 配置文件 &emsp;&emsp;然后通过读取 json 文件配置来连接到线上的数据库。 图4.10 Go 解析json数据 &emsp;&emsp;读取的数据可以用来初始化 Iris 框架的挂载，并且配置好 xorm 模块的数据绑定实现数据库的自动录入更新。 &emsp;&emsp;下面可以创建Model文件来描述数据库数据存储的格式，通过 xorm 提供的sync2方法可以自动在数据库创建出相应的表格。 图4.11 配置Model数据绑定 &emsp;&emsp;通过StaticWeb 命令配置服务器的静态资源目录，这样只要启动 Go 服务，就可以通过本地域名加端口来访问到这些目录所配置的静态资源了。 图4.12 配置静态资源路径 &emsp;&emsp;下面就是 Main 函数里面最重要的 mvcHandle 函数的处理了，这里定义了路由的设置并且通过路由调用相关的 Model 和 Controller ，不同的 Controller 调用相应的 service 来实现数据库的读写操作，这样分层的好处在于各个模块不会耦合到一起，方便代码管理和拆分，也方便来团队协作开发。 图4.13 路由挂载 &emsp;&emsp;接下来就可以去到 Controller 来控制具体的请求了。 &emsp;&emsp;Iris框架可以根据函数的命名来匹配响应的请求以及请求地址，比如我这里有PostLogin 函数，Iris 会自动转换为 /api/users/login 地址下的 Post 请求所执行的函数，这样就让配置更加简洁清晰。 图4.14 访问请求处理 &emsp;&emsp;通过上面的配置就实现了管理员登录接口的功能，GetByAdminNameAndPassword函数会调用 service 的数据库查询方法来查询管理员账号是否存在。 图4.15 数据库查询 &emsp;&emsp;如果管理员存在并且密码和存储的密码一致，才会返回存在的数据，从而实现用户的登录功能。 &emsp;&emsp;下面还需要通过接口测试工具 postman 模拟 http 请求来测试接口编写是否存在问题。 &emsp;&emsp;可以先将Go服务器运行起来，我的默认配置是监听到本地的 8080 端口。 图4.16 运行Go服务 &emsp;&emsp;这样Go服务器就已经运行起来了，这时候就可以通过浏览器访问 localhost:8080 访问到之前静态挂载的页面了，下面就可以通过MVC配置的路由地址通过 postman 软件来模拟浏览器发送的http请求，从而可以测试接口返回的数据是否符合我们的预期。 &emsp;&emsp;Postman的使用非常简单，只需要输入访问地址，然后选择请求的类型，然后将请求相关的数据配置好就可以点击 Send 发送请求了。 &emsp;&emsp;下面的 Body 可以看到访问的端口所返回来的数据。 图4.17 Postman 测试端口 &emsp;&emsp;端口返回的数据可以通过前端的 Vue 进行解析，从而在前端页面显示出相关的错误信息。 &emsp;&emsp;最后前端端口全部配置完成通过测试之后，可以通过 npm run build 将 Vue 的界面听过 WebPack 打包精简成一个小型的静态页面，通过 Iris 静态挂在到服务器上，Vue发送请求就可以调用 Iris 来进行数据交互，我们的 WebGL 三维网站就初步搭建完成了。 5. Python Qt CefWidget 开发5.1 基于PySide构建桌面程序 &emsp;&emsp;通过上面的步骤，我们已经成功搭建起了一个运行的WebGL 网站，下面我需要将这个网站嵌入到 DCC 软件中，比如 Maya 三维软件，从而搭建出一个简易的三维资产库来管理这些生产工具所创建出来的三维资源。 &emsp;&emsp;当前主流的 DCC 软件都是由 Qt 框架搭建，Qt框架是一门跨平台的 C++ 图形界面开发的框架，可以实现 Python 绑定从而大大简化了界面开发的难度，而主流的Python绑定库大都使用了Qt 官方提供的 PySide 库。 &emsp;&emsp;使用 PySide 构建一个桌面应用程序非常简单，首先安装 Python ，然后通过 pip 命令安装 PySide 库，这样就可以在 Python 代码里面 import PySide 模块。 图5.1 简易的 PySide 界面搭建 5.2 Cef浏览器嵌入框架 &emsp;&emsp;有了图形化界面的概念之后，下面需要将浏览器嵌入到 PySide 的界面当中，尽管PySide已经提供了一部分浏览器功能，可以访问大部分的网上页面，但是对 WebGL的支持依然不友好。 &emsp;&emsp;因此这里我需要另辟蹊径解决 Qt 的浏览器嵌入问题，经过我不懈的努力我找到了一个很不错的解决方案，通过 cefpython 嵌入到 PySide 界面中。 &emsp;&emsp;CEF 全称是 Chromium Embedded Framework，中文名称Chromium嵌入式框架，可以将谷歌浏览器的内核 Chromium 嵌入到任意界面当中，实现JavaScript 代码的编译与运行。 &emsp;&emsp;cefpython 则是 CEF 框架的 Python 绑定，通过 CEF 框架的嵌入特性，只需要提供窗口的id就可以将浏览器窗口嵌入进去，操作起来很简单。 &emsp;&emsp;由于 CEF 框架是由 C++ 模块编写的，python 绑定会涉及到 Cython 编译的 pyd 文件，这种情况下是无法在诸如 Maya 之类的 DCC 平台进行导入的。 &emsp;&emsp;因此这里我采用了 socket 套接字编程将CEF模块通过 pyinstaller 封装成一个可执行的 exe 文件进行外部启动，通过 socket 来进行进程见得数据通信，从而在 Maya 上仍然可以控制到 CefPython 启动的浏览器模块。 5.3 CefWidget Python代码编写 &emsp;&emsp;为了兼容 Qt 框架不同 Python 绑定，这里我使用了 Github 上开源的 Qt.py&emsp;&emsp;来导入相关的Python Qt 模块。 &emsp;&emsp;这里的代码结构包含两个脚本，一个是用来提供浏览器嵌入窗口的 Qt&emsp;&emsp;组件，组件上提供了连接 socket&emsp;&emsp;的方法来操控浏览器，而另一个脚本则是创建一个远程端口来运行 CEF 浏览器。 图5.2 remote 创建一个socket 套接字 &emsp;&emsp;通过socket绑定到端口上，后续通过 while&emsp;&emsp;循环获取传递到端口中的字符串数据，根据传递进来的字符串数据就可以解析出需要执行的事件，从而实现&emsp;&emsp;CEF窗口的控制。 图5.3 通过 while 死循环不断监听端口数据 &emsp;&emsp;浏览器窗口也需要类似于Qt的界面一样不断执行来响应窗口的事件，cefpython提供了cef.MessageLoopWork()的方法来调用窗口的事件序列，这样只要将这个方法放到死循环里面执行就可以保持浏览器的持续响应，同时也不会因为端口监听互相冲突，这样就可以通过&emsp;&emsp;socket.accpet()&emsp;&emsp;来获取到端口的客户端，再从客户端获取传递进来的数据，根据传递的数据调用不同的方法，诸如创建一个新的浏览器，以及加载特定链接等等功能。 图5.4 函数功能判断 &emsp;&emsp;这里通过 terminate 关键字来打断循环，从而正确结束掉端口和运行中的 CEF&emsp;&emsp;浏览器，否则死循环会一直占用端口，导致下次端口监听导致端口已经被占用报错的情况。 &emsp;&emsp;除了一些特殊的关键字信息处理之外，大部分数据处理都传递到 self.callback_dict&emsp;&emsp;中进行通用的函数处理，大大简化了代码量。 &emsp;&emsp;搭建好了 cef&emsp;&emsp;后台socket的脚本之后，Qt组件的脚本可以添加一个装饰器来自动开启和关闭这个&emsp;&emsp;socket。 图5.5 scoket初始化和关闭 &emsp;&emsp;通过 python 的 subprocess&emsp;&emsp;模块来外部运行脚本，初始化socket，然后这里可以通过构建客户端 socket 来发送&emsp;&emsp;terminate 关键字来结束所有的socket。 &emsp;&emsp;CefBrowser 组件继承与 QWidget ，通过 QWidget 提供的 winId&emsp;&emsp;方法可以获取到当前组件的唯一winId，随后就可以通过这个 id&emsp;&emsp;将浏览器窗口嵌入到这个组件的界面当中。 图5.6 CefBrowser获取窗口的id &emsp;&emsp;通过embed 函数将窗口嵌入到当前组件中。 图5.7 CefBrowser 为当前组件生成浏览器并嵌入 &emsp;&emsp;这里通过python 的 uuid&emsp;&emsp;模块获取当前组件的唯一辨识符，并且传递到生成的浏览器当中，这样发送数据到浏览器&emsp;&emsp;socket 的时候就可以通过唯一辨识符知道要对哪一个浏览器窗口进行处理。 图5.8 Connect函数封装了端口访问的代码 &emsp;&emsp;通过Connect 函数封装，方便数据发送。 图5.9 调用不同的函数向端口发送不同的数据 &emsp;&emsp;通过发送字符串数据，就可以发送到浏览器运行的端口程序里，从而让&emsp;&emsp;CefBrowser嵌入的浏览器响应事件，封装成浏览的处理函数之后也支持 Qt&emsp;&emsp;内置的点击按钮触发事件功能。 图5.10 浏览器嵌入测试 &emsp;&emsp;后面根据 cefpython 官方提供的 pyinstaller 打包方案，将 remote.py&emsp;&emsp;打包成一个可执行文件，这样脚本就不再需要依赖 python 进行运行，也不会因为 maya&emsp;&emsp;等软件的python.exe是特殊编译的版本导致不兼容运行出错。 &emsp;&emsp;Pyinstaller 是 python 程序打包成 exe&emsp;&emsp;可执行文件的方案，这个包支持跨平台程序打包，使用起来非常友好，cefpython 需要配置&emsp;&emsp;pyinstaller.spec&emsp;&emsp;来定义需要进行打包的程序以及路径，具体操作可以参照官方的打包文件案例。 &emsp;&emsp;我这里在官方的基础加上了一些改良，比如打包成功之后自动打开打包的文件，自动读取当前运行脚本目录下的&emsp;&emsp;remote.py 进行打包等等。 图5.11 使用 pyinstaller 打包程序 &emsp;&emsp;打包程序需要花费一些时间，打包完成之后会在目录中生成build文件夹，其中的cefapp.exe可执行文件执行的效果就和&emsp;&emsp;remote.py 一样，但是不再需要依赖于当前执行的python就可以在 Maya 等 DCC&emsp;&emsp;软件中启动当前程序。 图5.12 在Maya中启动 CefBrowser &emsp;&emsp;同样的方法，我们可以将之前做好的WebGL网站运行起来，就可以在网站上访问到WebGL编辑器并且查看上传的三维资产了。 图5.13 在Maya中启动 WebGL 三维模型展示网站 图5.14 在Houdini中启动 WebGL 三维模型展示网站 总结 &emsp;&emsp;前端使用 Vue-element-admin 其实并不太好。&emsp;&emsp;一方面是我对这个后台前端框架不熟悉，使用起来磕磕绊绊的，最主要的是默认提供的功能过于冗杂了。&emsp;&emsp;其实我的网站非常简单的，很多代码模块都可以删除。 &emsp;&emsp;后面用 Go 做后端测试，遇到了很多问题。比如我本地测试遇到了跨域问题。&emsp;&emsp;网上搜索了一下 Vue 可以借助 node.js 进行请求转发，毕竟跨域保护是在浏览器生效的， node.js 没有跨域强求的限制。&emsp;&emsp;然而某些情况还是会出问题。&emsp;&emsp;后面在 Response Header 上加上跨域的信息之后也不行。&emsp;&emsp;于是神奇的情况出现了，使用 postman 进行请求模拟没问题，但是当我尝试复制 postman 生成的代码到浏览器执行会出现 Network Error 访问不到的情况。&emsp;&emsp;后来是关了请求转发才可以，真的是日了狗了。 &emsp;&emsp;然后就是 sql 语句编写，Go 的 Iris 框架通过 MVC + Service 来操作 sql&emsp;&emsp;Iris 框架也是个大坑，网上的资料比较少，出问题查询起来有点麻烦，好在 Stack Overflow 依然很实用。&emsp;&emsp;sql 语句我写得少，其实用得还不是很顺手，后续打算弄个 sqlite 练习熟悉一下 sql 语句。 &emsp;&emsp;Go 语言完全没有练习基础就对照着教程提供的 Iris 框架代码进行开发，其实个人感觉不太好，有点不知其所以然的感觉。&emsp;&emsp;而且遇到问题需要不停的查找，可能还是初期的不适应有关系。&emsp;&emsp;总之是 Go 的使用经验还不足。 &emsp;&emsp;关于 Three.js 编辑器改良上，其实无非就是用了 ES5 JQuery 插件和 Bootstrap 界面开发的方法改良的。&emsp;&emsp;不过是 ES5 的东西都是几年前过时的标准了，初学前端还是学了这一套，bootstrap 有可视化编程，感觉依然是很香的。&emsp;&emsp;整个编辑器主要还是从 Three.js 官方编辑器上改的，用了官方提供的 dark.css 样式，所以工作量不大。&emsp;&emsp;主要添加了 四视图摄像机切换 ， 这个过程设计到 正交摄像机和透视摄像机的切换， 操作过程嵌入到了 EditorControl 里面了。&emsp;&emsp;另外就是添加了根据镜头方向照射的默认灯光，类似Maya，不至于让场景纯黑。 &emsp;&emsp;CefWidget 嵌入 DCC 其实都是之前帮师兄搞 宙斯 搞的东西了。&emsp;&emsp;具体可以参照我之前的博客文章，不过 WebGL 的效率其实不高，而且如果不从浏览器底层剥离 WebGL 的相关程序，整个浏览器过于臃肿了。&emsp;&emsp;师兄推荐用 USDview ，的确是值得考虑的。 &emsp;&emsp;一转眼大学就毕业了，时间真是一把杀猪刀呐~]]></content>
      <categories>
        <category>大学</category>
        <category>我的作品</category>
      </categories>
      <tags>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
        <tag>ࡂVue</tag>
        <tag>࠴编程/Go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya插件 SiShelf 改良]]></title>
    <url>%2Fposts%2F27d5d78d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近动画组这边也有类似的工具排布需求，Maya本身的工具架放了固定的工具图标。&emsp;&emsp;但是大家使用的习惯不太相同，真的众口难调，所以一个更好的自定义工具架才能让美术人员整理出自己喜欢的工具架。 &emsp;&emsp;凑巧我无聊的时候在 Github 上搜索仓库，无意中找到了这个很棒的自定义工具架插件 SiShelf 工具改良 &emsp;&emsp;原工具实现的功能已经非常非常棒了，但是我还是有自己的需求，想要做得更好。 moudle Installer 安装 &emsp;&emsp;还是 RJ 大神的模块安装的思路厉害，可以很便捷地安装 Maya 的任意模块。&emsp;&emsp;这样可以简化安装难度。 工具架图标添加获取更多信息 &emsp;&emsp;原本的工具无法直接获取工具架图标的很多信息。&emsp;&emsp;因为 PyQt 的 drop 事件只提供了 工具架图标的 代码信息。&emsp;&emsp;我这里通过获取的信息找到当前工具架的具体图标，从而获取图标的一些数据。&emsp;&emsp;实现更好的交互。 角标实现小图标窗口模式 &emsp;&emsp;给插件添加了一个角标按钮，点击可以缩小成一个图标窗口。&emsp;&emsp;图标窗口右键可以激活 XPOP 菜单模式。 &emsp;&emsp;右上角的角标图标是 Maya 内置图标叫做 window_dragCorner.png，我通过 Qt pixmap 将角标翻转&emsp;&emsp;然后通过 gridLayout 让角标保持在窗口的右侧。&emsp;&emsp;后面就是添加按钮的窗口事件了。 &emsp;&emsp;点击切换到小窗口模式，默认 Maya 的最小化 最大化 关闭按钮 顶住了最小宽度。&emsp;&emsp;为了让窗口宽度更小，需要将窗口转成只有一个关闭按钮的模式，我发现可以通过 windowsFlag 设置 drawer 来实现。&emsp;&emsp;缺点是这种做法无法使用 Maya Mixin ，我只好使用 QDialog Parent 到 Maya 主窗口的方式实现。 &emsp;&emsp;我后面测试 Maya Mixin 也可以改为 Drawer 的形式，只是操作方法比较特殊&emsp;&emsp;需要先执行 show 命令让 Maya 获取到 窗口 的存在，然后设置 windowsFlag 才有效。&emsp;&emsp;这样设置 windowsFlags 会让窗口关闭，需要再执行一遍 show 命令 123456789101112from maya.app.general import mayaMixinfrom PySide2 import QtWidgetsfrom PySide2 import QtCoreclass TestLabel(mayaMixin.MayaQWidgetBaseMixin,QtWidgets.QDialog): passwin = TestLabel()win.show()win.setWindowFlags(win.windowFlags() | QtCore.Qt.Drawer)win.show() &emsp;&emsp;后面思考了一下其实可以重写 show 函数的方法，这样代码看起来更加合理&emsp;&emsp;查了 Mixin 类之后也可知道 _makeMayaStandaloneWindow() 让窗口 parent 到主窗口上是关键操作。 12345678910111213141516from maya.app.general import mayaMixinfrom PySide2 import QtWidgetsfrom PySide2 import QtCoreclass TestLabel(mayaMixin.MayaQWidgetBaseMixin,QtWidgets.QDialog): def show(self): if self.parent() is None: self._makeMayaStandaloneWindow() self.setWindowFlags(self.windowFlags() | QtCore.Qt.Drawer) super(TestLabel,self).show()win = TestLabel()win.show() 总结 &emsp;&emsp;最终我 fork 了这个仓库，并且将自己的修改添加到了 pull request 上，希望原作者接纳我的改良。 github仓库&emsp;&emsp;其实我改良的东西并不多，源工具已经设计得非常好了。&emsp;&emsp;而且看了部分工具的代码又学到了新的东西。&emsp;&emsp;原来 Maya 提供了 Mixin 内置类，可以轻松创建出基于 Qt 的 Dockable 窗口。&emsp;&emsp;不一定需要通过 OpenMaya 转 Qt 的方式这么麻烦。 &emsp;&emsp;下面是 Maya Mixin 类的源码（可以在 Maya 的 python site-packages 中找到源码），代码中有具体的操作方法。&emsp;&emsp;通过 from maya.app.general import mayaMixin 进行导入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621#!/usr/bin/env python"""Maya mixin classes to add common functionality for custom PyQt/PySide widgets in Maya.* MayaQWidgetBaseMixin Mixin that should be applied to all custom QWidgets created for Maya to automatically handle setting the objectName and parenting * MayaQWidgetDockableMixin Mixin that adds dockable capabilities within Maya controlled with the show() function"""import uuidfrom maya import cmdsfrom maya import melfrom maya import OpenMayaUI as omui# Import available PySide or PyQt package, as it will work with bothtry: from PySide2.QtCore import Qt, QPoint, QSize from PySide2.QtCore import Signal from PySide2.QtGui import * from PySide2.QtWidgets import * from shiboken2 import wrapInstance, getCppPointer _qtImported = 'PySide2'except ImportError, e1: try: from PyQt4.QtCore import Qt, QPoint, QSize from PyQt4.QtCore import pyqtSignal as Signal from PyQt4.QtGui import * from sip import wrapinstance as wrapInstance _qtImported = 'PyQt4' except ImportError, e2: raise ImportError, '%s, %s'%(e1,e2) mixinWorkspaceControls = dict()def workspaceControlDeleted(controlName): global mixinWorkspaceControls if controlName in mixinWorkspaceControls: del mixinWorkspaceControls[controlName]def workspaceControlClosed(controlName): global mixinWorkspaceControls if controlName in mixinWorkspaceControls: mixinWorkspaceControls[controlName].dockCloseEventTriggered()def workspaceControlReparented(controlName, isFloating): global mixinWorkspaceControls if controlName in mixinWorkspaceControls: mixinWorkspaceControls[controlName].floatingChanged(isFloating)class MayaQWidgetBaseMixin(object): ''' Handle common actions for Maya Qt widgets during initialization: * auto-naming a Widget so it can be looked up as a string through maya.OpenMayaUI.MQtUtil.findControl() * parenting the widget under the main maya window if no parent is explicitly specified so not to have the Window disappear when the instance variable goes out of scope Integration Notes: Inheritance ordering: This class must be placed *BEFORE* the Qt class for proper execution This is needed to workaround a bug where PyQt/PySide does not call super() in its own __init__ functions Example: class MyQWidget(MayaQWidgetBaseMixin, QPushButton): def __init__(self, parent=None): super(MyQWidget, self).__init__(parent=parent) self.setText('Push Me') myWidget = MyQWidget() myWidget.show() print myWidget.objectName() ''' def __init__(self, parent=None, *args, **kwargs): super(MayaQWidgetBaseMixin, self).__init__(parent=parent, *args, **kwargs) # Init all baseclasses (including QWidget) of the main class self._initForMaya(parent=parent) def _initForMaya(self, parent=None, *args, **kwargs): ''' Handle the auto-parenting and auto-naming. :Parameters: parent (string) Explicitly specify the QWidget parent. If 'None', then automatically parent under the main Maya window ''' # If the input parent happens to be a Native window (such as the main Maya # window) then when we are parented to it, we also become a Native window. # Being a Native window is okay, but we don't want our ancestors to be # switched to Native, such as when we are docked inside a tabWidget. self.setAttribute(Qt.WA_DontCreateNativeAncestors) # Set a unique object name string so Maya can easily look it up if self.objectName() == '': self.setObjectName('%s_%s'%(self.__class__.__name__, uuid.uuid4())) def _makeMayaStandaloneWindow(self): '''Make a standalone window, though parented under Maya's mainWindow. The parenting under Maya's mainWindow is done so that the QWidget will not auto-destroy itself when the instance variable goes out of scope. ''' origParent = self.parent() # Parent under the main Maya window mainWindowPtr = omui.MQtUtil.mainWindow() mainWindow = wrapInstance(long(mainWindowPtr), QMainWindow) self.setParent(mainWindow) # Make this widget appear as a standalone window even though it is parented if isinstance(self, QDockWidget): self.setWindowFlags(Qt.Dialog|Qt.FramelessWindowHint) else: self.setWindowFlags(Qt.Window) # Delete the parent workspace control if applicable if origParent: parentName = origParent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): cmds.deleteUI(parentName, control=True) def show(self): '''Show the widget. Overrides standard QWidget.show() ''' # Set parent to Maya main window if parent=None if self.parent() is None: self._makeMayaStandaloneWindow() QWidget.show(self) def setVisible(self, makeVisible): ''' Show/hide the widget. Overrides standard QWidget.setVisible() ''' # If showing, set parent to Maya main window if parent=None if (makeVisible == True) and self.parent() is None: self._makeMayaStandaloneWindow() QWidget.setVisible(self, makeVisible) class MayaQDockWidget(MayaQWidgetBaseMixin,QDockWidget): '''QDockWidget tailored for use with Maya. Mimics the behavior performed by Maya's internal QMayaDockWidget class and the dockControl command :Signals: closeEventTriggered: emitted when a closeEvent occurs :Known Issues: * Manually dragging the DockWidget to dock in the Main MayaWindow will have it resize to the 'sizeHint' size of the child widget() instead of preserving its existing size. ''' # Custom Signals closeEventTriggered = Signal() # Qt Signal triggered when closeEvent occurs windowStateChanged = Signal() # Qt Signal triggered when the window is moved or resized. def __init__(self, parent=None, *args, **kwargs): super(MayaQDockWidget, self).__init__(parent=parent, *args, **kwargs) # Init all baseclasses (including QWidget) of the main class # == Mimic operations performed by Maya internal QmayaDockWidget == self.setAttribute(Qt.WA_MacAlwaysShowToolWindow) # WORKAROUND: The mainWindow.handleDockWidgetVisChange may not be present on some PyQt and PySide systems. # Handle case if it fails to connect to the attr. mainWindowPtr = omui.MQtUtil.mainWindow() mainWindow = wrapInstance(long(mainWindowPtr), QMainWindow) try: self.visibilityChanged.connect(mainWindow.handleDockWidgetVisChange) except AttributeError, e: # Error connecting visibilityChanged trigger to mainWindow.handleDockWidgetVisChange. # Falling back to using MEL command directly. mel.eval('evalDeferred("updateEditorToggleCheckboxes()")') # Currently mainWindow.handleDockWidgetVisChange only makes this updateEditorToggleCheckboxes call def setArea(self, area): '''Set the docking area ''' # Skip setting the area if no area value passed in if area == Qt.NoDockWidgetArea: return # Mimic operations performed by Maya dockControl command mainWindow = self.parent() if isinstance(self.parent(), QMainWindow) else wrapInstance(long(omui.MQtUtil.mainWindow()), QMainWindow) childrenList = mainWindow.children() foundDockWidgetToTab = False for child in childrenList: # Create Tabbed dock if a QDockWidget already at that area if (child != self) and (isinstance(child, QDockWidget)): if not child.isHidden() and not child.isFloating(): if mainWindow.dockWidgetArea(child) == area: mainWindow.tabifyDockWidget(child, self) self.raise_() foundDockWidgetToTab = True break # If no other QDockWidget at that area, then just add it if not foundDockWidgetToTab: mainWindow.addDockWidget(area, self) def resizeEvent(self, event): super(MayaQDockWidget, self).resizeEvent(event) if event.isAccepted(): self.windowStateChanged.emit() def moveEvent(self, event): super(MayaQDockWidget, self).moveEvent(event) if event.isAccepted(): self.windowStateChanged.emit() def closeEvent(self, evt): '''Hide the QDockWidget and trigger the closeEventTriggered signal ''' # Handle the standard closeEvent() super(MayaQDockWidget, self).closeEvent(evt) if evt.isAccepted(): # Force visibility to False self.setVisible(False) # since this does not seem to have happened already # Emit that a close event is occurring self.closeEventTriggered.emit()class MayaQWidgetDockableMixin(MayaQWidgetBaseMixin): ''' Handle Maya dockable actions controlled with the show() function. Integration Notes: Inheritance ordering: This class must be placed *BEFORE* the Qt class for proper execution This is needed to workaround a bug where PyQt/PySide does not call super() in its own __init__ functions Example: class MyQWidget(MayaQWidgetDockableMixin, QPushButton): def __init__(self, parent=None): super(MyQWidget, self).__init__(parent=parent) self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred ) self.setText('Push Me') myWidget = MyQWidget() myWidget.show(dockable=True) myWidget.show(dockable=False) print myWidget.showRepr() ''' # Custom Signals closeEventTriggered = Signal() # Qt Signal triggered when closeEvent occurs windowStateChanged = Signal() # Qt Signal triggered when the window is moved or resized. def __del__(self): global mixinWorkspaceControls workspaceControlName = self.objectName() + 'WorkspaceControl' if workspaceControlName in mixinWorkspaceControls : del mixinWorkspaceControls[workspaceControlName] def setDockableParameters(self, dockable=None, floating=None, area=None, allowedArea=None, width=None, widthSizingProperty=None, initWidthAsMinimum=None, height=None, heightSizingProperty=None, x=None, y=None, retain=True, plugins=None, controls=None, uiScript=None, closeCallback=None, *args, **kwargs): ''' Set the dockable parameters. :Parameters: dockable (bool) Specify if the window is dockable (default=False) floating (bool) Should the window be floating or docked (default=True) area (string) Default area to dock into (default='left') Options: 'top', 'left', 'right', 'bottom' allowedArea (string) Allowed dock areas (default='all') Options: 'top', 'left', 'right', 'bottom', 'all' width (int) Width of the window height (int) Height of the window x (int) left edge of the window y (int) top edge of the window :See: show(), hide(), and setVisible() ''' if ((dockable == True) or (dockable is None and self.isDockable())): # == Handle docked window == # By default, when making dockable, make it floating # This addresses an issue on Windows with the window decorators not showing up. if floating is None and area is None: floating = True # Create workspaceControl if needed if dockable == True and not self.isDockable(): # Retrieve original position and size # Position if x is None: x = self.x() # Give suitable default value if null if x == 0: x = 250 if y is None: y = self.y() # Give suitable default value if null if y == 0: y = 200 # Size unininitializedSize = QSize(640,480) # Hardcode: (640,480) is the default size for a QWidget if self.size() == unininitializedSize: # Get size from widget sizeHint if size not yet initialized (before the first show()) widgetSizeHint = self.sizeHint() else: widgetSizeHint = self.size() # use the current size of the widget if width is None: width = widgetSizeHint.width() if height is None: height = widgetSizeHint.height() if widthSizingProperty is None: widthSizingProperty = 'free' if heightSizingProperty is None: heightSizingProperty = 'free' if initWidthAsMinimum is None: initWidthAsMinimum = False if controls is None: controls = [] if plugins is None: plugins = [] workspaceControlName = self.objectName() + 'WorkspaceControl' # Set to floating if requested or if no docking area given if floating == True or area is None: workspaceControlName = cmds.workspaceControl(workspaceControlName, label=self.windowTitle(), retain=retain, loadImmediately=True, floating=True, initialWidth=width, widthProperty=widthSizingProperty, minimumWidth=initWidthAsMinimum, initialHeight=height, heightProperty=heightSizingProperty, requiredPlugin=plugins, requiredControl=controls) else: if self.parent() is None or (long(getCppPointer(self.parent())[0]) == long(omui.MQtUtil.mainWindow())): # If parented to the Maya main window or nothing, dock into the Maya main window workspaceControlName = cmds.workspaceControl(workspaceControlName, label=self.windowTitle(), retain=retain, loadImmediately=True, dockToMainWindow=(area, False), initialWidth=width, widthProperty=widthSizingProperty, minimumWidth=initWidthAsMinimum, initialHeight=height, heightProperty=heightSizingProperty, requiredPlugin=plugins, requiredControl=controls) else: # Otherwise, the parent should be within a workspace control - need to go up the hierarchy to find it foundParentWorkspaceControl = False nextParent = self.parent() while nextParent is not None: dockToWorkspaceControlName = nextParent.objectName() if cmds.workspaceControl(dockToWorkspaceControlName, q=True, exists=True): workspaceControlName = cmds.workspaceControl(workspaceControlName, label=self.windowTitle(), retain=retain, loadImmediately=True, dockToControl=(dockToWorkspaceControlName, area), initialWidth=width, widthProperty=widthSizingProperty, minimumWidth=initWidthAsMinimum, initialHeight=height, heightProperty=heightSizingProperty, requiredPlugin=plugins, requiredControl=controls) foundParentWorkspaceControl = True break else: nextParent = nextParent.parent() if foundParentWorkspaceControl == False: # If parent workspace control cannot be found, just make the workspace control a floating window workspaceControlName = cmds.workspaceControl(workspaceControlName, label=self.windowTitle(), retain=retain, loadImmediately=True, floating=True, initialWidth=width, widthProperty=widthSizingProperty, minimumWidth=initWidthAsMinimum, initialHeight=height, heightProperty=heightSizingProperty, requiredPlugin=plugins, requiredControl=controls) currParent = omui.MQtUtil.getCurrentParent() mixinPtr = omui.MQtUtil.findControl(self.objectName()) omui.MQtUtil.addWidgetToMayaLayout(long(mixinPtr), long(currParent)) if uiScript is not None and len(uiScript): cmds.workspaceControl(workspaceControlName, e=True, uiScript=uiScript) if closeCallback is not None: cmds.workspaceControl(workspaceControlName, e=True, closeCommand=closeCallback) # Add this control to the list of controls created in Python global mixinWorkspaceControls mixinWorkspaceControls[workspaceControlName] = self # Hook up signals #dockWidget.topLevelChanged.connect(self.floatingChanged) #dockWidget.closeEventTriggered.connect(self.dockCloseEventTriggered) else: # == Handle Standalone Window == # Make standalone as needed if not dockable and self.isDockable(): # Retrieve original position and size dockPos = self.parent().pos() if x == None: x = dockPos.x() if y == None: y = dockPos.y() if width == None: width = self.width() if height == None: height = self.height() # Turn into a standalone window and reposition currentVisibility = self.isVisible() self._makeMayaStandaloneWindow() # Set the parent back to Maya and remove the parent dock widget self.setVisible(currentVisibility) # Handle position and sizing if (width != None) or (height != None): if width == None: width = self.width() if height == None: height = self.height() self.resize(width, height) if (x != None) or (y != None): if x == None: x = self.x() if y == None: y = self.y() self.move(x,y) def setSizeHint(self, size): ''' Virtual method used to pass the user settable width and height down to the widget whose size policy controls the actual size most of the time. ''' pass def show(self, *args, **kwargs): ''' Show the QWidget window. Overrides standard QWidget.show() :See: setDockableParameters() for a list of parameters ''' # Update the dockable parameters first (if supplied) if len(args) or len(kwargs): self.setDockableParameters(*args, **kwargs) elif self.parent() is None: # Set parent to Maya main window if parent=None and no dockable parameters provided self._makeMayaStandaloneWindow() # Handle the standard setVisible() operation of show() QWidget.setVisible(self, True) # NOTE: Explicitly calling QWidget.setVisible() as using super() breaks in PySide: super(self.__class__, self).show() # Handle special case if the parent is a QDockWidget (dockControl) parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): if cmds.workspaceControl(parentName, q=True, visible=True): cmds.workspaceControl(parentName, e=True, restore=True) else: cmds.workspaceControl(parentName, e=True, visible=True) def hide(self, *args, **kwargs): '''Hides the widget. Will hide the parent widget if it is a QDockWidget. Overrides standard QWidget.hide() ''' # Handle special case if the parent is a QDockWidget (dockControl) parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): cmds.workspaceControl(parentName, e=True, visible=False) else: QWidget.setVisible(self, False) # NOTE: Explicitly calling QWidget.setVisible() as using super() breaks in PySide: super(self.__class__, self).show() def close(self): '''Closes the widget. Overrides standard QWidget.close() ''' parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): cmds.workspaceControl(parentName, e=True, close=True) else: QWidget.close(self) def isVisible(self): '''Return if the widget is currently visible. Overrides standard QWidget.isVisible() :Return: bool ''' parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): return cmds.workspaceControl(parentName, q=True, visible=True) return QWidget.isVisible(self) def setVisible(self, makeVisible, *args, **kwargs): ''' Show/hide the QWidget window. Overrides standard QWidget.setVisible() to pass along additional arguments :See: show() and hide() ''' if (makeVisible == True): return self.show(*args, **kwargs) else: return self.hide(*args, **kwargs) def raise_(self): '''Raises the widget to the top. Will raise the parent widget if it is a QDockWidget. Overrides standard QWidget.raise_() ''' # Handle special case if the parent is a QDockWidget (dockControl) parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): # Raise the workspace control cmds.workspaceControl(parentName, e=True, restore=True) else: QWidget.raise_(self) # NOTE: Explicitly using QWidget as using super() breaks in PySide: super(self.__class__, self).show() def isDockable(self): '''Return if the widget is currently dockable (under a QDockWidget) :Return: bool ''' parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName): return cmds.workspaceControl(parentName, q=True, exists=True) else: return False return False def isFloating(self): '''Return if the widget is currently floating (under a QDockWidget) Will return True if is a standalone window OR is a floating dockable window. :Return: bool ''' parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): return cmds.workspaceControl(parentName, q=True, floating=True) else: return True return True def floatingChanged(self, isFloating): '''Triggered when QDockWidget.topLevelChanged() signal is triggered. Stub function. Override to perform actions when this happens. ''' pass def dockCloseEventTriggered(self): '''Triggered when QDockWidget.closeEventTriggered() signal is triggered. Stub function. Override to perform actions when this happens. ''' pass def dockArea(self): '''Return area if the widget is currently docked to the Maya MainWindow Will return None if not dockable :Return: str ''' dockControlQt = self.parent() if not isinstance(dockControlQt, QDockWidget): return None else: mainWindow = self.parent().parent() if isinstance(self.parent().parent(), QMainWindow) \ else wrapInstance(long(omui.MQtUtil.mainWindow()), QMainWindow) dockAreaMap = &#123; Qt.LeftDockWidgetArea : 'left', Qt.RightDockWidgetArea : 'right', Qt.TopDockWidgetArea : 'top', Qt.BottomDockWidgetArea : 'bottom', Qt.AllDockWidgetAreas : 'all', Qt.NoDockWidgetArea : 'none', # Note: 'none' not supported in maya dockControl command &#125; dockWidgetAreaBitmap = mainWindow.dockWidgetArea(dockControlQt) return dockAreaMap[dockWidgetAreaBitmap] def setWindowTitle(self, val): '''Sets the QWidget's title and also it's parent QDockWidget's title if dockable. :Return: None ''' # Handle the standard setVisible() operation of show() QWidget.setWindowTitle(self, val) # NOTE: Explicitly calling QWidget.setWindowTitle() as using super() breaks in PySide: super(self.__class__, self).show() # Handle special case if the parent is a QDockWidget (dockControl) parent = self.parent() if parent: parentName = parent.objectName() if parentName and len(parentName) and cmds.workspaceControl(parentName, q=True, exists=True): cmds.workspaceControl(parentName, e=True, label=val) def showRepr(self): '''Present a string of the parameters used to reproduce the current state of the widget used in the show() command. :Return: str ''' reprDict = &#123;&#125; reprDict['dockable'] = self.isDockable() reprDict['floating'] = self.isFloating() reprDict['area'] = self.dockArea() #reprDict['allowedArea'] = ?? if reprDict['floating']: if reprDict['dockable']: pos = self.parent().pos() else: pos = self.pos() reprDict['x'] = pos.x() reprDict['y'] = pos.y() sz = self.geometry().size() reprDict['width'] = sz.width() reprDict['height'] = sz.height() # Construct the repr show() string reprShowList = ['%s=%r'%(k,v) for k,v in reprDict.items() if v != None] reprShowStr = 'show(%s)'%(', '.join(reprShowList)) return reprShowStr# ===========================================================================# Copyright 2016 Autodesk, Inc. All rights reserved.## Use of this software is subject to the terms of the Autodesk license# agreement provided at the time of installation or download, or which# otherwise accompanies this software in either electronic or hard copy form.# ===========================================================================]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 工具开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 输出顶点动画到引擎]]></title>
    <url>%2Fposts%2F5c00f85e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近特效那边给我提了需求，需要在 Maya 输出 unreal 的顶点动画。&emsp;&emsp;顶点动画输出工具其实 unreal 官方也提供了一个 链接&emsp;&emsp;但是这个顶点动画输出工具是针对 3dsMax 的，需要做一个 Maya 版本。 &emsp;&emsp;特效那边需要给角色做一个跟随的路径动画面片，然后将面片的动画以上述的纹理图片的形式 在 unreal 中用 shader 驱动动画。&emsp;&emsp;过去整个流程也一直是在 Max 里面完成的，最近需要配合 Maya 的动画进行处理，所以如果有 Maya 相应的工具会方便很多。&emsp;&emsp;我研究了一下 Max 的导出流程，还原 Max 的面片生成处理其实不难。&emsp;&emsp;最大的问题反而是 Max 导出流程中微不足道的点，那就是 exr 数据导出的问题。&emsp;&emsp;在 Max 里面提供了 exr 导出的 API ，而且 Max 的坐标轴和 unreal 一样，不需要额外的处理。&emsp;&emsp;但是 Maya 的 exr 导出 API 藏得非常深，而且数据处理不好弄。 OpenMaya 输出 exr &emsp;&emsp;OpenMaya 的图像 API 有两个，分别是 MImage 和 MTexture&emsp;&emsp;MImage 有 setPixels 命令但是支持 0 - 255 区间的数值，输出格式不支持 exr 等纹理。 &emsp;&emsp;这方面的研究我之前在做 MayaViewportCapture 工具的时候有研究过。&emsp;&emsp;Maya MImage 可以通过 setPixels 赋值像素数据，也可以对像素数据进行 0 - 255 的修改。 123456789101112131415161718192021222324252627282930313233343536# coding:utf-8from __future__ import unicode_literals,division,print_function__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-05-24 10:35:32'"""MImage 无法存储浮点数(8bit) | 存储格式也有限制 不支持 exr"""import maya.api.OpenMaya as omimport maya.api.OpenMayaUI as omuiimport maya.api.OpenMayaRender as omr# NOTE 如果裁剪区域超过原图范围则限制到原图的边界上width = 400height = 400# NOTE https://groups.google.com/forum/#!topic/python_inside_maya/Q9NuAd6Av20pixels = bytearray(width*height*4)for w in range(width): for h in range(height): pos = (w+h*width)*4 # NOTE 这里加数字代表当前像素下 RGBA 四个通道的值 pixels[pos+0] = 255 pixels[pos+1] = 255 pixels[pos+2] = 255 pixels[pos+3] = 255# NOTE 返回裁剪的 Imageimg = om.MImage()img.setPixels(pixels, width, height)DIR = os.path.dirname(__file__)img.writeToFile(os.path.join(DIR,"MImage.png"), 'png') &emsp;&emsp;MTexture 格式可以输出 exr 格式，这个和 MImage 不一样，用来定义 Maya 的纹理贴图。&emsp;&emsp;这个对象无法像 MImage 一样进行实例化，需要借助 MTextureManager 来生成 MTexture 实例。&emsp;&emsp;而且 OpenMaya1.0 的 API 已经不支持，只可以使用 2.0 的 API 进行获取。 &emsp;&emsp;通过查C++文档的案例可以知道 MTextureManager 也需要通过 MRenderer 获取，无法直接实例化（属于单例模式？！） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# coding:utf-8from __future__ import unicode_literals,division,print_function__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-05-24 10:35:32'"""MTexture 不支持 OpenMaya 1.0MTexture 无法实例化MTexture 比起 MImage 可以输出 exr 格式"""import osimport ctypesimport structimport maya.api.OpenMaya as omimport maya.api.OpenMayaUI as omuiimport maya.api.OpenMayaRender as omrmanager = omr.MRenderer.getTextureManager()print (dir(manager))path_list = manager.imagePaths()# NOTE ----------------------------------------------------------------# NOTE 读取本地图片# NOTE ----------------------------------------------------------------DIR = os.path.dirname(__file__)file_name = os.path.join(DIR,"test7.exr")texture = manager.acquireTexture(file_name)# print ("bytesPerPixel",texture.bytesPerPixel())pixel,rowPitch,total = texture.rawData()ptr = ctypes.cast(pixel.__long__(), ctypes.POINTER(ctypes.c_char))pixels = ctypes.string_at(ptr, total)height = int(total/rowPitch)width = int(rowPitch/4)# texture.freeRawData(pixel)# print(height,total,width)pixels = range(width*height*4)for w in range(width): for h in range(height): pos = (w+h*width)*4 # NOTE 这里加数字代表当前像素下 RGBA 四个通道的值 pixels[pos+0] = 255 pixels[pos+1] = 1 pixels[pos+2] = 1 pixels[pos+3] = 255img = om.MImage()img.setPixels(pixels, width, height)img.writeToFile(os.path.join(DIR,"MImage.png"), 'png')# NOTE 无法执行 update 修改像素数据 _(:з」∠)_texture.update(pixels,False,rowPitch)manager.saveTexture(texture,os.path.join(DIR,"MTexture.exr")) &emsp;&emsp;MTexture 没有研究出如何通过 Python 修改像素数据，我用上面的代码可以修改 MImage 的像素却修改不了 MTexture 的像素（输出的图片为黑色） OpenEXR 库输出 &emsp;&emsp;鉴于上面的 MTexture 无法操作的原因，我只好退而求其次，用外部的 Python 库来进行修改。&emsp;&emsp;反正可以通过 PyInstaller 打包然后用 Maya 的 Python 外调 exe 来实现 exr 数据输出。&emsp;&emsp;网上查了一下 Python 有 OpenEXR 的库。 &emsp;&emsp;第一步安装就出现了问题，安装提示缺少了头文件，windows 平台安装失败。&emsp;&emsp;网上搜了一下，提到 Linux 系统安装 libopenexr-dev 的系统库之后才可以正常安装。&emsp;&emsp;救救 windows 平台吧 o(╥﹏╥)o &emsp;&emsp;后来再 stack overflow 上找到了相关问题的回答 链接&emsp;&emsp;评论下面推荐使用 https://www.lfd.uci.edu/~gohlke/pythonlibs/ 这个文章下载 build 的二进制 wheel 进行安装&emsp;&emsp;然而坑爹的情况出现了。&emsp;&emsp;我使用 QQ浏览器 点击链接下载居然跳转到 404 目录，我以为是网站出问题了。&emsp;&emsp;继续找其他网站的 build 版本，无果，之后网上搜了一下这个网站 404 的问题，没想到居然是 浏览器 的锅。&emsp;&emsp;使用 Chrome 浏览器就可以正常下载了(:з」∠) &emsp;&emsp;好不容易才终于可以正常安装 OpenEXR 这个库了，尝试过在 Maya 安装，果然转完之后无法执行 dll 。&emsp;&emsp;所以转而去到外部的 Python 进行安装。 &emsp;&emsp;后续流程就是 Maya 记录特效物体每一帧的每一个顶点的位置，然后输出 json 文件。&emsp;&emsp;后续利用 OpenEXR 这个库读取 json 数据 生成 EXR 图片。&emsp;&emsp;当时没有考虑到 Maya 的轴向和 Unreal 不一样，结果输出的 图片 信息看起来不对，放进引擎更加不对ε=(´ο｀*))) Python 输出 exr &emsp;&emsp;因为上述的原因，这个 Max 插件导出转成 Maya 导出一直卡主。&emsp;&emsp;后来我搜了一下有没有现成的 Maya 插件，没想到还真让我搜到了 Maya 版本的插件。&emsp;&emsp;就在 Unreal 的官方论坛里面 链接&emsp;&emsp;这个插件还在不断更新中，就在今天写文章之际还更新了一版。 &emsp;&emsp;既然上面输出 Exr 碰到那么多问题，这个插件到底是怎么做到 Exr 的输出呢？&emsp;&emsp;当我翻阅它的代码时候，我惊呆了，居然使用了 纯 Python 二进制输出方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227# coding:utf-8from __future__ import division,print_function__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-05-25 21:12:22'"""https://www.openexr.com/documentation/openexrfilelayout.pdfhttps://www.openexr.com/documentation/TechnicalIntroduction.pdf根据 OpenEXR 规范通过 Python struct 输出二进制"""# Written by user "Styler" on Tech-Artistsimport osimport structimport binasciifrom math import copysign, frexp, isinf, isnan, truncNEGATIVE_INFINITY = b'\x00\xfc'POSITIVE_INFINITY = b'\x00\x7c'POSITIVE_ZERO = b'\x00\x00'NEGATIVE_ZERO = b'\x00\x80'# exp=2**5-1 and significand non-zeroEXAMPLE_NAN = struct.pack('&lt;H', (0b11111 &lt;&lt; 10) | 1)def dump_to_exr_rgb16uncomp(height, width, data, filename): """ :param height: Height of image :param width: Width of image :param data: A sequence (list/tuple) of float point values in format [r, g, b, r, g, b ...] :param filename: filename for output """ def make_chlist_value(name, typ, linear=0, samx=1, samy=1): # NOTE 定义好了 chlist 输出格式 https://www.openexr.com/documentation/openexrfilelayout.pdf#page=14 return ''.join([ # NOTE https://www.openexr.com/documentation/TechnicalIntroduction.pdf#page=7 # NOTE 包含 名称 和 类型 name, '\x00', struct.pack('I', typ), struct.pack('B', linear), '\x00\x00\x00', # reserved # NOTE RGBA 图片 为 1 struct.pack('I', samx), struct.pack('I', samy)]) def make_attr(name, typ, size, value): # NOTE Attribute Layout https://www.openexr.com/documentation/openexrfilelayout.pdf#page=8 return ''.join([ name, '\x00', typ, '\x00', struct.pack('I', size), value]) def binary16(f): # NOTE IEEE 754-2008 https://stackoverflow.com/questions/31464022/ # NOTE https://gist.github.com/zed/59a413ae2ed4141d2037 """Convert Python float to IEEE 754-2008 (binary16) format. https://en.wikipedia.org/wiki/Half-precision_floating-point_format """ if isnan(f): return EXAMPLE_NAN sign = copysign(1, f) &lt; 0 if isinf(f): return NEGATIVE_INFINITY if sign else POSITIVE_INFINITY # 1bit 10bits 5bits # f = (-1)**sign * (1 + f16 / 2**10) * 2**(e16 - 15) # f = (m * 2) * 2**(e - 1) m, e = frexp(f) assert not (isnan(m) or isinf(m)) if e == 0 and m == 0: # zero return NEGATIVE_ZERO if sign else POSITIVE_ZERO f16 = trunc((2 * abs(m) - 1) * 2**10) # XXX round toward zero assert 0 &lt;= f16 &lt; 2**10 e16 = e + 14 if e16 &lt;= 0: # subnormal # f = (-1)**sign * fraction / 2**10 * 2**(-14) f16 = int(2**14 * 2**10 * abs(f) + .5) # XXX round e16 = 0 elif e16 &gt;= 0b11111: # infinite return NEGATIVE_INFINITY if sign else POSITIVE_INFINITY else: # normalized value assert 0b00001 &lt;= e16 &lt; 0b11111, (f, sign, e16, f16) """ http://blogs.perl.org/users/rurban/2012/09/reading-binary-floating-point-numbers-numbers-part2.html sign 1 bit 15 exp 5 bits 14-10 bias 15 frac 10 bits 9-0 (-1)**sign * (1 + fraction / 2**10) * 2**(exp - 15) +-+-----[1]+----------[0]+ # little endian |S| exp | fraction | +-+--------+-------------+ |1|&lt;---5--&gt;|&lt;---10bits--&gt;| &lt;--------16 bits---------&gt; """ return (sign &lt;&lt; 15) | (e16 &lt;&lt; 10) | f16 # return struct.pack('&lt;H', (sign &lt;&lt; 15) | (e16 &lt;&lt; 10) | f16) def pack_half(value): # NOTE 将传入的 浮点数 转换为 half 类型 # NOTE 参考文章 https://akaedu.github.io/book/ch14s04.html F16_EXPONENT_BITS = 0x1F F16_EXPONENT_SHIFT = 10 F16_EXPONENT_BIAS = 15 F16_MANTISSA_BITS = 0x3ff F16_MANTISSA_SHIFT = (23 - F16_EXPONENT_SHIFT) F16_MAX_EXPONENT = (F16_EXPONENT_BITS &lt;&lt; F16_EXPONENT_SHIFT) a = struct.pack('&gt;f', value) b = binascii.hexlify(a) f32 = int(b, 16) f16 = 0 sign = (f32 &gt;&gt; 16) &amp; 0x8000 exponent = ((f32 &gt;&gt; 23) &amp; 0xff) - 127 mantissa = f32 &amp; 0x007fffff if exponent == 128: f16 = sign | F16_MAX_EXPONENT if mantissa: f16 |= (mantissa &amp; F16_MANTISSA_BITS) elif exponent &gt; 15: f16 = sign | F16_MAX_EXPONENT elif exponent &gt; -15: exponent += F16_EXPONENT_BIAS mantissa &gt;&gt;= F16_MANTISSA_SHIFT f16 = sign | exponent &lt;&lt; F16_EXPONENT_SHIFT | mantissa else: f16 = sign return f16 depth = 3 # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=6 第 5 - 6 页有描述 # NOTE \x76\x2f\x31\x01 固定数据 10 进制为 20000630 | 用来区分 OpenEXR 格式 # NOTE \x02\x00\x00\x00 这四个数据为 Version Field | \x02 表示 2.0 版本 fdata = ['\x76\x2f\x31\x01\x02\x00\x00\x00'] # magic and version if width*height*depth != len(data): raise ValueError('Data length does not fit with image size') # build header # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=8 # NOTE 定义属性通道描述 channels = '%s\x00' % ''.join([make_chlist_value(name, typ) for name, typ in (('R', 1), ('G', 1), ('B', 1))]) fdata.append(make_attr('channels', 'chlist', 18*depth+1, channels)) # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=15 fdata.append(make_attr('compression', 'compression', 1, '\x00')) # 0 - uncompressed # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=14 # NOTE box2i 包含 4 个 int | int 占用 4 个字节 | 前面 '\x00'*8 表示 0 , 0 windata = ''.join(['\x00'*8, struct.pack('i', width-1), struct.pack('i', height-1)]) fdata.append(make_attr('dataWindow', 'box2i', 16, windata)) fdata.append(make_attr('displayWindow', 'box2i', 16, windata)) # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=15 fdata.append(make_attr('lineOrder', 'lineOrder', 1, '\x00')) # inc y # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=8 fdata.append(make_attr('pixelAspectRatio', 'float', 4, struct.pack('f', 1.0))) fdata.append(make_attr('screenWindowCenter', 'v2f', 8, struct.pack('ff', 0, 0))) fdata.append(make_attr('screenWindowWidth', 'float', 4, struct.pack('f', 1))) fdata.append('\x00') # end of the header # NOTE https://www.openexr.com/documentation/openexrfilelayout.pdf#page=10 # NOTE 计算 offset Tables | offset Tables 用来读取像素的映射表 # NOTE offsetChunk 使用 unsigned long 类型 占 8 个字节 # NOTE 添加了 height 个 offsetChunk 数据(所以 + height*8) # calc lines offset offtab_size = sum([len(x) for x in fdata]) + height*8 # NOTE 每个单元格像素包含 RGB 三个通道 depth | 2 代表 half 类型的大小(float 为 4 字节, half 为 2 字节) # NOTE 前面加 8 是因为 每行开始需要有 起始结束的描述数据 | 两个 int 类型共占 8 个字节 # NOTE https://www.openexr.com/documentation/TechnicalIntroduction.pdf#page=13 line_size = 8 + width*2*depth # fill offsets table for i in xrange(height): fdata.append(struct.pack('Q', offtab_size + i*line_size)) data_size = struct.pack('I', width*2*depth) # NOTE Scan Lines # add data by scanlines for j in xrange(height): # NOTE 起始和结束的行描述数据 line = [struct.pack('i', j), data_size] n = j*width*depth for i in xrange(depth): # NOTE 读取传入的像素数据 转换为 half 类型 chdata = [binary16(data[n+x+i]) for x in xrange(0, width*depth, depth)] # NOTE 使用 short 类型的长度代指 half 占用的空间 line.append(struct.pack('%sH' % len(chdata), *chdata)) fdata.append(''.join(line)) # write to file dirname = os.path.dirname(filename) if not os.path.exists(dirname): os.makedirs(dirname) with open(filename, 'wb') as f: f.write(''.join(fdata))if __name__ == "__main__": # NOTE 测试输出 400 * 400 蓝色的 exr 图片 width = 10 height = 10 pixels = range(width*height*3) for w in range(width): for h in range(height): pos = (w+h*width)*3 # NOTE RGB 的顺序是反过来的 pixels[pos+2] = 0.0 pixels[pos+1] = 0.0 pixels[pos+0] = 255.0 DIR = os.path.dirname(__file__) file_name = os.path.join(DIR,"test.exr") dump_to_exr_rgb16uncomp(width,height,pixels,file_name) github地址 &emsp;&emsp;这个文件如何输出 exr 我进行了进一步的研究，代码的注释都在上面。&emsp;&emsp;主要通过 struct 模块进行 二进制 的操作，根据 OpenExr 提供的操作文档给文件添加相应二进制信息。&emsp;&emsp;其中比较厉害的操作是通过 python 创建 half 类型的二进制数据，需要通过 bitwise 位运算实现，目前还没有完全弄懂原理。&emsp;&emsp;在 Stack Overflow 上找到了不同打包 half 类型的方案 链接&emsp;&emsp;其中 binary16 的代码虽然写法不一样，但是可以得到上面 pack_half 函数的效果，原理同样还没有完全搞清楚。&emsp;&emsp;根据 https://akaedu.github.io/book/ch14s04.html 上面对浮点数的描述。&emsp;&emsp;half 类型的浮点数应该是通过科学计数法记录数据的，因此计算和转换的时候会有误差&emsp;&emsp;有时间再进一步研究 浮点数 转换， Exr 的输出原理基本就是这样。 顶点动画输出 &emsp;&emsp;搞了这么久我们貌似将主题给搞偏了，虽然 输出 EXR 格式花了大部分的研究时间，其实我们的根本目标是输出 Maya 的顶点动画。&emsp;&emsp;还有很重要的一步没有做，如何将 Maya 的模型动画输出来。&emsp;&emsp;其实 Unreal 论坛的脚本也有很详细的操作。&emsp;&emsp;主要利用了 Maya 的 snapShot 命令生成时间内的模型 快照。&emsp;&emsp;不过我拿几个月前的老版本处理会有 Bug ，直接输出在运动路径的模型的快照是固定不动的。&emsp;&emsp;后面我将 snapShot 的操作改为逐帧处理即可，就是输出效率大大降低。 &emsp;&emsp;有了快照信息就有了模型再运动时间内的顶点位置数据，然后将这些数据打包整理到 EXR 的 RGB 通道上就完成了顶点动画信息的转移。&emsp;&emsp;最后只需要输出动画模型的 FBX 即可。&emsp;&emsp;这种处理方式也是有问题的，只支持一些小模型的动画，如果模型点数太多超过 8K 贴图，就无法正常输出了。（我没有测试过，是 Unreal 论坛的老哥自己说的） 总结 &emsp;&emsp;本来想搞 顶点动画 的，没想到却花了大量时间研究 EXR 的 binary 数据输出了。&emsp;&emsp;最后有没有搞清楚 half 类型是如何输出的，倒是发现纯 Python 也可以输出类似 EXR 这样复杂的数据。&emsp;&emsp;Python 的功能果然很强大，这次又开阔了我的眼界。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 根据贴图在模型表面散列物体]]></title>
    <url>%2Fposts%2F77ed9d8.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;偶然在网上看到了一个视频，视频里面有相关的代码 链接&emsp;&emsp;感觉实现的效果很赞，所以特意抽时间来研究一下这个东西是怎么实现的。 代码抄写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# coding:utf-8from __future__ import unicode_literals,division,print_function__author__ = 'timmyliang'__email__ = '820472580@qq.com'__date__ = '2020-05-23 23:08:58'"""https://vimeo.com/85522402"""import math,randomfrom maya import OpenMaya as omfrom maya import OpenMayaRender as omrdef placeObjects(filename, duplicates=5): meshObject = om.MObject() parentPath= om.MDagPath() meshPath = om.MDagPath() meshList = om.MSelectionList() dgMod = om.MDagModifier() om.MGlobal.getActiveSelectionList(meshList) meshList.getDagPath(1,meshPath) meshList.getDagPath(0,parentPath) meshList.getDependNode(0,meshObject) parentFn = om.MFnMesh(parentPath) meshFn = om.MFnMesh(meshPath) count = 0 while count &lt; duplicates: uv = [random.uniform(0.01,1),random.uniform(0.01,1)] uvUtil = om.MScriptUtil() uvUtil.createFromList(uv,2) uvPoint = uvUtil.asFloat2Ptr() # NOTE 获取随机 UV 的颜色 rgb = getRGBatUV(filename,uv) if rgb &gt; [0.4,0.4,0.4]: meshIter = om.MItMeshPolygon(meshObject) outPoint = om.MPoint() space = om.MSpace.kWorld while not meshIter.isDone(): faceId = meshIter.index() try: # NOTE 获取模型在 UV 上的点 | 获取失败直接报错跳过 parentFn.getPointAtUV(faceId,outPoint,uvPoint,space) # NOTE 复制第二个选择的物体 name = meshPath.fullPathName() dupName = "%s_dup%s" % (name,count+1) dgMod.commandToExecute('duplicate -n "%s" "%s"' % (dupName,name)) dgMod.doIt() dgMod.commandToExecute("select -r %s" % dupName) dupMeshPath = om.MDagPath() dupList = om.MSelectionList() om.MGlobal.getActiveSelectionList(dupList) dupList.getDagPath(0,dupMeshPath) transform = om.MFnTransform(dupMeshPath) # NOTE 根据法线计算旋转角度 faceNormal = om.MVector() dupObjVector = om.MVector(0,1,0) meshIter.getNormal(faceNormal) rotAxisOrig = dupObjVector ^ faceNormal rotAxis = rotAxisOrig.normal() angleOrig = dupObjVector * faceNormal angleOrig2 = math.acos(angleOrig) angleUtil = om.MScriptUtil(angleOrig2) anglePtr = angleUtil.asFloatPtr() angle = om.MDoubleArray(anglePtr,1) quat = om.MQuaternion(angle[0],rotAxis) tXYZ = om.MVector(outPoint.x,outPoint.y,outPoint.z) # NOTE 设置位置和角度 transform.setTranslation(tXYZ,om.MSpace.kWorld) transform.setRotation(quat,om.MSpace.kWorld) count += 1 except RuntimeError: pass meshIter.next()def getRGBatUV(filename,uv=[0,0]): # NOTE file 节点名称 texutreFileName = filename uCoord = uv[0] vCoord = uv[1] # NOTE 获取输入的 UV uUtil = om.MScriptUtil(uCoord) vUtil = om.MScriptUtil(vCoord) uPtr = uUtil.asFloatPtr() vPtr = vUtil.asFloatPtr() uCoord = om.MDoubleArray(uPtr,1) vCoord = om.MDoubleArray(vPtr,1) # NOTE file 节点的 MObject textureList = om.MSelectionList() om.MGlobal.getSelectionListByName(texutreFileName,textureList) textureObject = om.MObject() textureList.getDependNode(0,textureObject) # NOTE 获取纹理颜色采样 resultColor = om.MVectorArray() resultAlpha = om.MDoubleArray() omr.MRenderUtil.eval2dTexture(textureObject,uCoord,vCoord,resultColor,resultAlpha) return [resultColor[0].x,resultColor[0].y,resultColor[0].z] placeObjects("file1",500) &emsp;&emsp;需要注意 “file1” 传入的名称必须存在 这个名称的 file 节点。&emsp;&emsp;eval2dTexture 方法将会采样这个节点指向的图片像素数据，从而获取特定UV位置的颜色信息。 &emsp;&emsp;后面我写了一个 OpenMaya2.0 的获取方案，复制圆锥以及旋转都可以用 cmds 来处理，比起 OpenMaya 的方式要简单不少 github 总结 &emsp;&emsp;旋转的处理比较麻烦，如何通过矩阵变换算出欧拉没有搞出来，看 Stack Overflow 的介绍是使用 AimConstraint 约束 链接&emsp;&emsp;或者使用矩阵变换。&emsp;&emsp;后面我是使用 cmds.angleBetween 这种取巧的方式。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya HumanIK 动画重定向]]></title>
    <url>%2Fposts%2F79818906.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;很多年前，Maya 就有了 HumanIK 插件用于对接 MotionBuilder 动捕。&emsp;&emsp;不过目前我还没有对接过动捕相关的东西，所以 MotionBuilder 对接这方面还不懂。&emsp;&emsp;那么 HumanIK 有什么特点呢？ 相较于传统的绑定有什么区别 HumanIK的特点？ - 知乎https://www.zhihu.com/question/264587401 &emsp;&emsp;知乎上的回答很不错，HumanIK 的缺点就是功能过于单一，只能匹配类人二足动物的效果。&emsp;&emsp;不过它在这个单一领域上是极其强大的，出了回答中提到的 IKFK无需转换之外，还有极其强大的动画重定向功能。 &emsp;&emsp;关于 HumanIK 的一些基础使用方法可以参考网上的一些中文教程 在Maya2019中使用HumanIK对人型角色进行绑定设置并制作动画&emsp;&emsp;HumanIK 是一款很棒的绑定插件，但是不仅仅可以做绑定，HumanIK的骨架定义赋予了它更为强大的功能，动画重定向。（专门用来对接动捕的） &emsp;&emsp;最近工作上遇到了非常坑爹的问题，需要活用 HumanIK 重定向来解决问题。&emsp;&emsp;由于制作上赶时间，我们使用的绑定文件是一套临时的影视流程绑定，虽然我提供了将影视绑定转为游戏骨骼进引擎的方案，毕竟是临时的。&emsp;&emsp;后面新的绑定到了之后，我们需要将旧的绑定动画还原到新的绑定上，这个时候 HumanIK 就可以发挥它的巨大作用。&emsp;&emsp;本篇就来重点讲解一下 HumanIK 重定向的使用 ， 以及一些 Python 处理方法。 HumanIK 重定向 &emsp;&emsp;重定向的教程可以参考 3DMotive Intro to Human IK in Maya&emsp;&emsp;下面我也来简单讲解一下使用流程。 &emsp;&emsp;HumanIK的图标在 Maya 右上角，点击可以开启。&emsp;&emsp;然后点击 Create Character Definition 来创建角色。&emsp;&emsp;这里可以将已有的一些绑定系统的骨骼添加到定义中，最后角色的定义化之后就可以通过 HumanIK 进行重定向。 &emsp;&emsp;HumanIK 添加定义有两种方式，一种是选择骨骼然后再 UI 上右键选择 Assign Selected Bone &emsp;&emsp;另一个方式就是双击 UI 然后选择骨骼。 &emsp;&emsp;HumanIK自带了一套基础的镜像选择骨骼的规则，如果绑定系统的规则不太一样可以手动添加新的匹配规则。 &emsp;&emsp;下面我以 ADV 绑定系统为例，实现角色化。 &emsp;&emsp;如果当前角色不是 T-pose ，那么 HumanIK 会有警告，建议手动将角色调整为 T-pose 进行匹配。 &emsp;&emsp;重定向操作可以导入 HumanIK 的参考动画进行重定向。 &emsp;&emsp;HumanIK 上索引动画文件&emsp;&emsp;结果并没有教程中的那么顺利，可以看到 ADV 蒙皮全乱了。&emsp;&emsp;主要原因是 ADV 的骨骼被绑定系统所约束或连接控制了。&emsp;&emsp;解决这个问题有两个方案。 方案一 打断控制 &emsp;&emsp;可以通过打断所有的连接来正确匹配。&emsp;&emsp;当然这样虽然匹配到一起，但是由于打断了控制器，因此后面处理需要将骨骼重新约束到新不绑定的控制器上，操作会比较麻烦。 方案二 利用 Custom Rig 匹配控制器 &emsp;&emsp;HumanIK 提供了自定义控制器的匹配机制，点击最后一个按钮，可以将控制器添加到匹配的UI中 &emsp;&emsp;后续就是将 ADV 的控制器添加到控制器定义中，这里我使用 IK 系统进行匹配。 &emsp;&emsp;添加完控制器如上图。 &emsp;&emsp;如果直接将极向量控制器添加到 HumanIK 进行匹配，匹配效果并不理想。&emsp;&emsp;后面我用 Locator 来约束极向量控制器，然后将 locator 添加到 HumanIK 的匹配关系中，效果就好了很多。 &emsp;&emsp;注：角色的权重只是大概刷了下，权重问题可以忽略。 &emsp;&emsp;最后通过 HumanIK 的面板 bake 关键帧即可。 方案比较 &emsp;&emsp;方案一的匹配比较好，但是多了一步反向约束FK的操作，比较麻烦。&emsp;&emsp;方案二虽然差不多一步到位了，但是有时候控制器的匹配效果不好，反而不如方案一的骨骼匹配准确。&emsp;&emsp;而且方案的自定义控制器无法匹配手指，还是欠缺了不少。 HumanIK Python 自动重定向探讨原理分析 &emsp;&emsp;由于工作上遇到的绑定就是无法使用 方案一 的，使用方案一即便 T-pose 已经对上了，但是控制器匹配就差了10万8千里。&emsp;&emsp;所以我后面就放弃了方案二了。&emsp;&emsp;下面需要实现的是如何批量将上面看到的操作自动化，毕竟动画如果很多的话，人工处理还是太费时间了。&emsp;&emsp;角色定义化其实还好，在绑定文件做好，动画文件引用是没有问题的。&emsp;&emsp;最大的问题在于 HumanIK 的匹配选择。 &emsp;&emsp;通过查底层的 Mel 代码可以找到 HumanIK 切换的时候执行的命令。 12345// 这里默认选择第二个选项，也可以遍历 optionMenuGrp 的 item 来获取特定的序号optionMenuGrp -e -select 2 hikCharacterList;hikUpdateCurrentCharacterFromUI(); hikUpdateContextualUI();optionMenuGrp -e -select 2 hikSourceList;hikUpdateCurrentSourceFromUI(); hikUpdateContextualUI(); &emsp;&emsp;这个背后就是操作 HumanIK UI 的操作&emsp;&emsp;我一开始开发因为赶时间，没有去深究 hikUpdateCurrentSourceFromUI 函数里面的命令操作。&emsp;&emsp;反而给我带来了很多麻烦，因为 UI 更新是异步的，我需要等UI更新了才可以获取到 source 的选项。&emsp;&emsp;因此我需要活用 evalDeferred 命令来解决异步操作之后的同步问题。 &emsp;&emsp;具体的操作方法可以参考我写的临时脚本 github&emsp;&emsp;利用 evalDeferred 的 lowestPriority 属性可以实现优先级错开执行的效果。 &emsp;&emsp;后来我进一步研究发现 HumanIK 可以用 hikSetCharacterInput 命令来加载两个 HIKCharacterNode 实现匹配功能。&emsp;&emsp;这样就不需要等待 UI 的更新了。 自动化工具github &emsp;&emsp;参照 github 仓库的说明。&emsp;&emsp;可以批量重定向多个动画文件。&emsp;&emsp;重定向之后输出包含两个不同绑定的文件，需要在 HumanIK 的面板属性上细调来完善匹配效果。&emsp;&emsp;匹配好了之后导出 FBX ，通过 FBX 的骨骼来约束 FK 控制器，然后再 Bake 一遍关键帧即可。 &emsp;&emsp;后续的操作因为FBX导出的流程可能都不大相同，所以没有给自动化操作。 总结 &emsp;&emsp;这次 HumanIK 自动重定向 在工作上其实并没有发挥太大的作用，因为时间实在是太赶了。&emsp;&emsp;重定向的效果也不是特别直接理想，所以动画师是直接替换引用再调整的。&emsp;&emsp;我是后面抽时间再将整个操作流程和工具整理了一遍，顺便学习了一下 pymel 的一下用法。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Rigging</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>🇨🇬CG/HumanIK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 法线获取归纳]]></title>
    <url>%2Fposts%2Fd50b3a73.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近我看到TD群里有人问关于 Maya 法线获取的归纳汇总，恰好我前段时间就因为工作的需要有做过相关的开发。&emsp;&emsp;具体可以参照我之前写的文章 Maya 法线解锁 Maya 法线解锁进阶&emsp;&emsp;因此在这里总一下法线获取的归纳，希望对大家有有所帮助。 什么是法线 &emsp;&emsp;首先需要理解三维软件法线的概念，具体还是可以参照我之前翻译的教程， 平滑着色概述 平滑着色例子 &emsp;&emsp;看完教程可以知道，法线是用来描述光线射碰撞到模型上之后光线的反射行为。(不是搞图形渲染的，如有不当之处请多多包涵) &emsp;&emsp;通过上面的截图，调整点法线的角度就可以改变模型的着色效果，因此法线贴图的原理也在这里。&emsp;&emsp;通过高模烘焙的法线信息，在低模上扭曲光线让渲染的时候模拟出高模的细节。因此法线贴图比较省资源，但是效果的精细程度比不上置换贴图。 Maya中的法线 &emsp;&emsp;在Maya中，模型上有面法线和顶点法线，面法线是垂直于面的，但是实际对着色起作用的是点法线。&emsp;&emsp;我们可以在 Maya 中简单构建出两个球来说明法线对着色的影响。&emsp;&emsp;首先将其中一个球执行硬边操作。 &emsp;&emsp;从上图可以看到默认的球是软边的，两个一对比就很明显了。&emsp;&emsp;硬边的球看起来的面片非常明显，我们可以开启模型的点法线来进行对比。 &emsp;&emsp;可以看到软化边的顶点法线都是合并到一起的，硬化边的法线则根据面的朝向相互独立了。&emsp;&emsp;这就造成了平滑着色之间的区别。 &emsp;&emsp;通过上面的硬边例子可以知道，Maya的法线信息是根据面顶点进行存储的，这里的面顶点区别于模型的顶点。&emsp;&emsp;每个面上的顶点是单独计算的，进入 Maya 的 VertexFace 模式就非常清楚 &emsp;&emsp;这个模式下的面都是间隔开的，可以清晰看到每个面顶点。 使用 Mel &amp; cmds 命令获取模型法线 &emsp;&emsp;常用的命令有如下这些 polyNormalPerVertex polyAverageNormal polyNormal polySetToFaceNormal polySoftEdge &emsp;&emsp;其中最强大的命令是 polyNormalPerVertex 可以精确获取到法线的信息，并且精准调整法线。 &emsp;&emsp;另外需要额外注意的是，调整法线如果选择顶点而不是面顶点的话，那么修改的时候会将顶点相邻的面顶点一并修改。&emsp;&emsp;就无法实现法线的精准调节了。 使用 pymel &amp; OpenMaya 获取法线 &emsp;&emsp;pymel 对 OpenMaya 进行了封装，内核相通，使用起来简单很多，因此这里重点讲解 pymel 的获取。&emsp;&emsp;除了 mel 提供的命令之外，获取法线的方法还有有三种方式， 模型 面 顶点 模型获取 Mesh &emsp;&emsp;通过 pymel 获取一个模型， pymel 的 Mesh 类提供了大量和法线相关的命令（大部分都是调用 OpenMaya 实现的） 1234567import pymel.core as pmimport pymel.core.nodetypes as nt# NOTE 打印 pyeml 的 Mesh 类函数print (dir(nt.Mesh))['BoolOperation', 'MAttrClass', 'MColorRepresentation', 'MObjectColorType', 'MPublishNodeType', 'MdgTimerMetric', 'MdgTimerState', 'MdgTimerType', 'SplitPlacement', '__add__', '__apicls__', '__apihandle__', '__apimdagpath__', '__apimfn__', '__apimobject__', '__apiobject__', '__apiobjects__', '__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__melnode__', '__melobject__', '__metaclass__', '__module__', '__ne__', '__new__', '__nonzero__', '__or__', '__radd__', '__readonly__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__slots__', '__str__', '__subclasshook__', '__unicode__', '__weakref__', '_attr', '_componentAttributes', '_formatter_field_name_split', '_formatter_parser', '_getAssociatedColorSetInstances', '_getAssociatedUVSetInstances', '_getDagParent', '_getUVAtPoint', '_name', '_node', '_numCVsFunc_generator', '_numColorSets', '_numColors', '_numEPsFunc_generator', '_numEdges', '_numFaceVertices', '_numNormals', '_numPolygons', '_numUVSets', '_numUVs', '_numVertices', '_updateName', 'activeColor', 'addAttr', 'addChild', 'addHoles', 'addPrefix', 'area', 'assignColor', 'assignColors', 'assignUV', 'assignUVs', 'attr', 'attrDefaults', 'attrInfo', 'attributeCount', 'booleanOps', 'boundingBox', 'canBeWritten', 'cast', 'center', 'child', 'childAtIndex', 'childCount', 'classification', 'cleanupEdgeSmoothing', 'clearColors', 'clearUVs', 'comp', 'componentTypeFromName', 'componentTypeName', 'connectAttr', 'connections', 'count', 'createColorSet', 'createUVSet', 'dagPath', 'dagRoot', 'deleteAttr', 'deleteColorSet', 'deletePreset', 'deleteUVSet', 'deselect', 'destinations', 'disconnectAttr', 'dormantColor', 'drawOverrideColor', 'drawOverrideEnabled', 'drawOverrideIsReference', 'drawOverrideIsTemplate', 'duplicate', 'enableDGTiming', 'endswith', 'exists', 'extractNum', 'find', 'firstParent', 'firstParent2', 'format', 'fullPath', 'fullPathName', 'future', 'getAllParents', 'getAllPaths', 'getAssignedUVs', 'getAssociatedUVSetTextures', 'getAttr', 'getAxisAtPoint', 'getBinormals', 'getCheckSamePointTwice', 'getChildren', 'getClosestNormal', 'getClosestPoint', 'getClosestPointAndNormal', 'getColor', 'getColorRepresentation', 'getColorSetFamilyNames', 'getColorSetNames', 'getColors', 'getConnectedSetsAndMembers', 'getCurrentColorSetName', 'getCurrentUVSetName', 'getDisplayColors', 'getEdgeVertices', 'getFaceNormalIds', 'getFaceUVSetNames', 'getFaceVertexBinormal', 'getFaceVertexBinormals', 'getFaceVertexColorIndex', 'getFaceVertexColors', 'getFaceVertexNormal', 'getFaceVertexTangent', 'getFaceVertexTangents', 'getHoles', 'getIcon', 'getInstances', 'getMembers', 'getNormalIds', 'getNormals', 'getObjectColor', 'getObjectColorType', 'getOtherInstances', 'getParent', 'getParentContainer', 'getPath', 'getPoint', 'getPointAtUV', 'getPoints', 'getPolygonNormal', 'getPolygonTriangleVertices', 'getPolygonUV', 'getPolygonUVid', 'getPolygonVertices', 'getPublishedNames', 'getPublishedNodes', 'getPublishedPlugs', 'getRootTransform', 'getSiblings', 'getSubcontainers', 'getTangentId', 'getTangents', 'getTransform', 'getTriangleOffsets', 'getTriangles', 'getUV', 'getUVAtPoint', 'getUVSetFamilyNames', 'getUVSetNames', 'getUVSetsInFamily', 'getUVs', 'getUvShellsIds', 'getVertexNormal', 'getVertices', 'hasAlphaChannels', 'hasAttr', 'hasChild', 'hasColorChannels', 'hasParent', 'hide', 'hiliteColor', 'history', 'inModel', 'inUnderWorld', 'index', 'inputs', 'instanceCount', 'instanceNumber', 'intersect', 'isChildOf', 'isColorClamped', 'isColorSetPerInstance', 'isDefaultNode', 'isDisplaced', 'isEdgeSmooth', 'isFlagSet', 'isInstanceOf', 'isInstanceable', 'isInstanced', 'isInstancedAttribute', 'isIntermediate', 'isIntermediateObject', 'isLocked', 'isNormalLocked', 'isParentOf', 'isPolygonConvex', 'isReadOnly', 'isReferenced', 'isRightHandedTangent', 'isShared', 'isTrackingEdits', 'isUVSetPerInstance', 'isUniquelyNamed', 'isUsingObjectColor', 'isVisible', 'isdecimal', 'islower', 'isnumeric', 'isupper', 'join', 'listAliases', 'listAnimatable', 'listAttr', 'listComp', 'listConnections', 'listFuture', 'listHistory', 'listPresets', 'listRelatives', 'listSets', 'ljust', 'loadPreset', 'lock', 'lockFaceVertexNormals', 'lockVertexNormals', 'longName', 'lower', 'lstrip', 'makeLive', 'model', 'name', 'namespace', 'namespaceList', 'nextName', 'nextUniqueName', 'node', 'nodeName', 'nodeType', 'numChildren', 'numColorSets', 'numColors', 'numEdges', 'numFaceVertices', 'numFaces', 'numNormals', 'numPolygonVertices', 'numSelectedEdges', 'numSelectedFaces', 'numSelectedTriangles', 'numSelectedVertices', 'numTriangles', 'numUVSets', 'numUVs', 'numVertices', 'objExists', 'objectColorIndex', 'objectColorRGB', 'onBoundary', 'outputs', 'parent', 'parentAtIndex', 'parentCount', 'parentNamespace', 'partialPathName', 'partition', 'pluginName', 'polyTriangulate', 'prevName', 'referenceFile', 'registerVirtualSubClass', 'removeChild', 'removeChildAt', 'removeFaceColors', 'removeFaceVertexColors', 'removeVertexColors', 'rename', 'renameUVSet', 'replace', 'rfind', 'rindex', 'rjust', 'root', 'rpartition', 'rsplit', 'rstrip', 'savePreset', 'select', 'setAttr', 'setCheckSamePointTwice', 'setColor', 'setColorClamped', 'setColors', 'setCurrentColorSetName', 'setCurrentUVSetName', 'setDisplayColors', 'setDoNotWrite', 'setDynamicAttr', 'setEdgeSmoothing', 'setFaceColor', 'setFaceColors', 'setFaceVertexColor', 'setFaceVertexNormal', 'setIcon', 'setInstanceable', 'setIntermediate', 'setIntermediateObject', 'setLocked', 'setNormals', 'setObject', 'setObjectColor', 'setObjectColorType', 'setParent', 'setPoint', 'setPoints', 'setSomeColors', 'setSomeUVs', 'setUV', 'setUVs', 'setUseObjectColor', 'setVertexColor', 'setVertexNormal', 'shadingGroups', 'shortName', 'show', 'sources', 'split', 'startswith', 'strip', 'stripNamespace', 'stripNum', 'swapNamespace', 'syncObject', 'transformationMatrix', 'type', 'unlock', 'unlockFaceVertexNormals', 'unlockVertexNormals', 'updateSurface', 'upper', 'usingHiliteColor', 'usingObjectColor', 'worldArea'] &emsp;&emsp;通过 python dir 可以打印出 pymel 封装好的函数。&emsp;&emsp;其中和 normal 相关的操作如下 | 使用方式参考官方文档 getBinormals getClosestNormal getClosestPointAndNormal getFaceNormalIds getFaceVertexBinormal getFaceVertexBinormals getFaceVertexNormal getNormalIds getNormals getPolygonNormal getVertexNormal isNormalLocked lockFaceVertexNormals lockVertexNormals numNormals setFaceVertexNormal setNormals setVertexNormal unlockFaceVertexNormals unlockVertexNormals pymel Mesh 文档 面获取 MeshFace &emsp;&emsp;可以用上面的方法同理获取到内置的 normal 函数 getNormal getNormals normalIndex pymel MeshFace 文档 顶点获取 MeshVertex getNormal getNormals getNormalIndices pymel MeshVertex 文档 注意事项 &emsp;&emsp;MeshFace getNormal 获取面法线&emsp;&emsp;MeshVertex getNormal 获取顶点法线 也就是该顶点下相邻面顶点的法线平均值 &emsp;&emsp;MeshFace getNormals 和 MeshVertex getNormals 可以获取到相邻面顶点的法线信息，但是返回的是数组，不知道这些信息对应的面顶点关系 &emsp;&emsp;我在 Maya 2017 使用 Mesh getFaceVertexNormal 会导致 Maya 崩溃，还是用 mel 命令比较稳定 获取法线数据OpenMaya 2.0 获取 &emsp;&emsp;我之前是通过 OpenMaya 2.0 遍历模型上的面顶点来构建一个面顶点法线字典来提取法线的信息数据。&emsp;&emsp;缺点是数据不是动态的。 1234567891011121314151617181920212223from maya.api import OpenMaya as omfrom maya import cmdsimport syssel_list = cmds.ls(cmds.pickWalk(d="down"),type="mesh")sel = sel_list[0] if sel_list else sys.exit(0)sel_list = om.MSelectionList()sel_list.add(sel)dagPath = sel_list.getDagPath(0)# NOTE 获取 mesh 所有的法线信息mesh_normal = &#123;&#125;itr = om.MItMeshFaceVertex(dagPath)while not itr.isDone(): face_id = itr.faceId() vert_id = itr.vertexId() normal = itr.getNormal() mesh_normal.setdefault(vert_id,&#123;&#125;) mesh_normal[vert_id][face_id] = normal itr.next()print(mesh_normal) PyMel 获取 &emsp;&emsp;OpenMaya 用起来比较麻烦，用 pymel 获取就优雅很多。（效率会低些） 1234567891011121314import sysimport pymel.core as pmfrom collections import defaultdictsel_list = pm.ls(pm.pickWalk(d="down"),type="mesh")sel = sel_list[0] if sel_list else sys.exit(0)mesh_normal = defaultdict(dict)for vtxFace in sel.vtxFace: # NOTE currentItemIndex 获取到 ComponentIndex | 查 pymel 源码可知是 tuple 类型 vert_id,face_id = vtxFace.currentItemIndex() mesh_normal[vert_id][face_id] = pm.polyNormalPerVertex(vtxFace,q=1,normalXYZ=1)print(mesh_normal) 动态获取法线 &emsp;&emsp;如果要动态获取模型的法线信息，可以通过构建类的方式来获取。 1234567891011121314151617181920212223242526import pymel.core as pmimport pymel.core.nodetypes as ntclass NormalData(object): def __init__(self,mesh): mesh = mesh[0] if hasattr(mesh,"__iter__") else mesh mesh = mesh.node() if hasattr(mesh,"node") else mesh self.mesh = mesh.getShape() if hasattr(mesh,"getShape") else mesh if type(self.mesh) is not nt.Mesh: raise RuntimeError("Please Pass a Mesh object to NormalData Class") def __getitem__(self,item): vtxFace = self.mesh.vtxFace[item] return &#123;face_idx:pm.polyNormalPerVertex(vtxFace[face_idx],q=1,normalXYZ=1) for _,face_idx in vtxFace.indicesIter()&#125; def __repr__(self): return "%s('%s')" % (self.__class__.__name__,self.mesh)mesh_normal = NormalData(pm.selected())print(mesh_normal)print(mesh_normal[0])print(mesh_normal[0][0])# NormalData('pSphereShape1')# &#123;19: [0.19055484235286713, -0.9797220230102539, -0.06191524863243103], 0: [0.19055484235286713, -0.9797220230102539, -0.06191524863243103], 379: [0.19055484235286713, -0.9797220230102539, -0.06191524863243103], 360: [0.19055484235286713, -0.9797220230102539, -0.06191524863243103]&#125;# [0.19055484235286713, -0.9797220230102539, -0.06191524863243103] 总结 &emsp;&emsp;以上就是 Maya 的法线获取的总结。&emsp;&emsp;另外我补充一下关于法线解锁的问题， OpenMaya 中的 MFnMesh 有命令可以获取到模型的边是否为硬边和软边 isEdgeSmooth&emsp;&emsp;但是如果导出 FBX 之类的格式没有保留平滑组信息，或者是 Max 导入到 Maya 之类的情况，上面提到的命令就不管用了,即便看起来是有软硬边，但是获取的数据都是 False&emsp;&emsp;这也导致法线解锁所有的法线变硬边了，这种情况下是可以通过遍历获取面顶点的法线来重新恢软硬边的信息的，虽然我针对这个情况开发了 Maya 法线解锁工具，但是工具实现的效果并不理想。 github]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Tkinter Windows 磁盘映射工具]]></title>
    <url>%2Fposts%2Fcbe510e2.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;windows 的本地目录映射为磁盘的操作貌似没有图形化界面。&emsp;&emsp;windows 下只能映射网络路径。 &emsp;&emsp;当然，可以通过命令行 subst 来实现这样的功能。&emsp;&emsp;刚好工作上有人给我提了这个需求，因此我就做了图形化界面来简化操作。 &emsp;&emsp;最开始我是打算使用 PyQt 进行开发的，但是打包之前大小有点太大了。&emsp;&emsp;一个简单的图形程序超过 10M 就有点过分了。&emsp;&emsp;所以后面我又去学习 Tkinter 开发，来减少程序的大小。&emsp;&emsp;Tkinter 是 Python 自带的跨平台图形界面开发库，开发起来虽然没有 Qt 那么方便(QtDesigner 是真的香)，不过 Qt 的各种功能大都能在 Tkinter 实现。&emsp;&emsp;只是 Tkinter 的UI组装方式和 Qt 有些许差别。 &emsp;&emsp;开发的界面我已经放到 Github 上 链接 Tkinter GUI 开发 &emsp;&emsp;前段时间弄 mini_maya 的时候就接触过了 Tkinter 的开发，有 Qt 的开发背景，其实学起来还是很快的。&emsp;&emsp;不过 Tkinter 学习也遇到了不少的坑。 &emsp;&emsp;Tkinter 最大的坑在于文档非常不全面，很多方法有什么参数不知道哪里查，只能在 Stack overflow 上找程序案例。 &emsp;&emsp;Tkinter 没有 Qt 的 Layout 概念&emsp;&emsp;所有的组件都会继承三种不同的排列方法， place grid pack &emsp;&emsp;place 指定到 GUI 的任意位置，位置相对于组件的父对象而言，不使用二维坐标，而是使用 0-1 的百分比。&emsp;&emsp;grid 就和 Qt 的 QGridLayout 差不多&emsp;&emsp;pack 就类似 QVBoxLayout 和 QHBoxLayout 的结合体，通过 side 参数来定义嵌入的方式。 &emsp;&emsp;Tkinter 的 Frame 就相当于 Qt 的 QWidget 可以作为组件的容器。 &emsp;&emsp;一开始 Tkinter 开发的坑在于没有 Layout 概念&emsp;&emsp;组件没有办法类似于 Qt 一样自动根据窗口大小进行拉伸，就像是 mel 语言写的窗口一样。&emsp;&emsp;后来发现其实并不是不能实现的。 &emsp;&emsp;grid 方法有 sticky 参数可以传入 东西南北 来定义组件在 grid 的显示，比如传入 “WE” 就会在 grid 这一个单元格中适应横向的大小。&emsp;&emsp;grid的单元格缩放可以通过， row_config 和 column_config 进行调整。&emsp;&emsp;pack 也有 expand 和 fill 参数实现类似于 Qt Layout 那样顶掉空白区域的效果。 &emsp;&emsp;当然要实现类似 Qt 的效果操作起来就会麻烦一点。 &emsp;&emsp;另外 Tkinter 开发让我最不适应的点就是没有最小大小的概念。&emsp;&emsp;在网上查了很多，还是没有办法实现大小的限制，如果缩放窗口最后会将所有的 GUI 塌陷隐藏。 &emsp;&emsp;后来 Stack Overflow 有个 Tkinter 的大神有提到。&emsp;&emsp;如果是单独成行的组件 可以用 pack&emsp;&emsp;如果是多个组件组装到一起的，建议用 grid&emsp;&emsp;grid可以起确保单元格没有缩放到消失。 &emsp;&emsp;目前为止还是没有办法实现固定组件的长宽，有点小遗憾&emsp;&emsp;虽然找到了可以后面设置组件长宽的方法，但是在 调整窗口大小的情况下 起不到固定长宽的目标。&emsp;&emsp;如果长宽调整输入的数值没有变化的话组件的长宽就不会跟着改变，即便加上 resize 时间回调也不起作用。 总结 &emsp;&emsp;这次又进一步加深了我对 Tkinter 的了解，并且这次用上了类的概念进行开发，已经很接近 Qt 的开发的效果。&emsp;&emsp;下次可以考虑一下 WPF 或者 AutoHotkey 的图形开发，虽然是 Windows 平台独占的，但是相信大小可以更进一步减少。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠕPython/Tkinter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 模型掰直处理]]></title>
    <url>%2Fposts%2F4de57da5.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近模型师那边遇到了一些比较麻烦的需求。&emsp;&emsp;当前制作的模型弯曲过度了，如何才能将模型掰直回去 (:з」∠)。&emsp;&emsp;刚听到这个问题的时候，下意识就想到了使用 Bend 变形器来解决。&emsp;&emsp;或者将模型打平还通常会用 缩放到 0 的方式。&emsp;&emsp;然而事实上并没有那么好处理。 缩放方案研究 &emsp;&emsp;最开始我测试了缩放调整的方式。&emsp;&emsp;但是效果不是很理想。 &emsp;&emsp;这样其实只是把模型压扁。&emsp;&emsp;后来我想到了使用 squash 变形器来压，这样可以控制压的幅度，但是本质还是压扁，效果不太理想。 Bend 弯曲方案研究 &emsp;&emsp;其实最靠谱的方案应该是 Bend 弯曲方案，但是直接对模型进行弯曲达不到预期的效果。 &emsp;&emsp;于是我开始想其他的方案，我觉得最靠谱的方法应该是用 曲线 来控制模型。&emsp;&emsp;然后通过弯曲曲线实现模型的整体控制。&emsp;&emsp;从模型提取曲线其实不难， Maya 有将边转换为 曲线 的命令。 &emsp;&emsp;提取出曲线之后可以我最先想到用 wrap 变形器实现曲线控制模型的效果。&emsp;&emsp;然后再给曲线添加 Bend 变形器。&emsp;&emsp;然而这个方案的效果也不理想。 &emsp;&emsp;后来还想到表情绑定里面也有用到 wire 变形器来实现曲线控制模型的效果。&emsp;&emsp;于是抱着试一试的形态去测试效果。 &emsp;&emsp;wire 变形器的添加比较特别，左下角有使用帮助提醒。&emsp;&emsp;需要先选择模型按 Enter 然后再选择 曲线 按 Enter，可以参考 mel 的 scriptCtx 命令&emsp;&emsp;直接赋予 wire 变形器并不能完全控制模型，&emsp;&emsp;因此这里还需要调整 wire 变形器的权重来控制整个模型。 &emsp;&emsp;然后对曲线添加 bend 变形器。 &emsp;&emsp;这个效果就相当好了。&emsp;&emsp;必要的话还可以控制曲线的缩放来将模型打直。 总结 &emsp;&emsp;以上就是我研究出的掰直模型的方案。&emsp;&emsp;Maya 建模的时候活用 MASH 和 变形器 可以实现非常复杂的模型效果，我之前在 youtube 上看了一个系列，让我大开眼界。 链接]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 影视绑定 转 游戏绑定]]></title>
    <url>%2Fposts%2Ffa091109.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近工作上遇到了一个大问题，一个新的项目进行测试，测试用的角色绑定居然是影视流程的绑定。&emsp;&emsp;如果使用这种绑定方式导入游戏引擎会出现很多问题，甚至直接发生错误导致无法导入的情况。&emsp;&emsp;于是针对这个问题，我弄了一个提取方案，实测 TSM 和 ADV 两种绑定系统都支持。 影视绑定 和 游戏绑定 区别 &emsp;&emsp;其实游戏绑定完全可以照搬影视的绑定。&emsp;&emsp;其中最大的区别在于，绑定文件导入引擎只需要蒙皮的骨骼就足够了，额外的控制器、IKFK切换系统等等辅助的绑定都不需要导出。&emsp;&emsp;而影视绑定里面因为不需要考虑输出到引擎的缘故，辅助系统和蒙皮骨骼基本都是混搭在一起。&emsp;&emsp;ADV 还好，还有对蒙皮的骨骼单独分离，现在项目用到的绑定就是完全混搭的状态。 &emsp;&emsp;综上所述，游戏绑定需要单独弄一套 root 骨骼层级用来蒙皮到模型上，影视的绑定系统可以约束到这套 root 骨骼上。&emsp;&emsp;这样导出蒙皮骨骼和模型就没有问题了。 绑定分离分析 &emsp;&emsp;既然目前的状态就是绑定骨骼和辅助骨骼混搭在一起了，就需要通过一些方法将这些骨骼找出来输出，这里我使用 pymel 进行获取 &emsp;&emsp;首先通过 for mesh in pm.ls(ni=1,v=1,type=&quot;mesh&quot;) 获取场景中可视的模型，当然可能会有误选和漏选，最后是将输出模型弄一个规范放到特定的层级之下。&emsp;&emsp;然后通过 for skin in mesh.listHistory(type=&quot;skinCluster&quot;) 获取模型下所有的 skinCluster 节点。&emsp;&emsp;最后通过 skin.listHistory(type=&quot;joint&quot;) 就可以找到 蒙皮节点 相连的骨骼了。 &emsp;&emsp;接下来就是在根层级上创建一个 root 骨骼，然后将获取到的蒙皮骨骼统统 parent 到上面去。&emsp;&emsp;这样就完成了蒙皮节点的剥离。&emsp;&emsp;不过直接这么操作会出大问题的，因为之前骨骼在很深的层级里面，它的坐标位置并不是世界坐标。&emsp;&emsp;如果直接 parent 不做处理那位置全部乱套了。&emsp;&emsp;所以 parent 之前需要获取骨骼的位置，结果有发现很多骨骼的一些属性被锁定和连接了。&emsp;&emsp;于是我这里就将骨骼的 位移 旋转 缩放 属性统统解锁断开连接。&emsp;&emsp;这里可能会担心这一步操作影响绑定，的确是个有损操作影响到绑定了，但是没有关系，这里的目标是输出 FBX 绑定文件，导出完成不保存即可。 &emsp;&emsp;进行上面的parent操作之后，角色大部分都没有问题，但是手腕和脚踝的部分会变形。&emsp;&emsp;经过我的研究，我发现是 IK 系统的 ikEffector 导致的，parent 之前将这些节点删除即可。 pm.delete(pm.ls(type=&quot;ikEffector&quot;)) &emsp;&emsp;parent的骨骼，有一些骨骼会带上 transform 节点。&emsp;&emsp;而且无论怎么parent 都会自动生成 transform 节点，后来再 Stack Overflow 找到了问题的原因 链接&emsp;&emsp;主要是因为骨骼或者骨骼的上层级缩放存在负值，骨骼虽然可以输入负值，估计是 Maya 不推荐这么操作所以新建一个 transform 来接收负值。&emsp;&emsp;这里我将 transform 的缩放值和 骨骼 同步，然后骨骼重新 parent 到 root 骨骼上，最后将 transform 节点删除&emsp;&emsp;这里不输出 transform 节点是因为游戏引擎也会将这个东西看做骨骼，可能会导致后续输出的骨骼数量不一致导致动画和绑定不匹配的情况。 &emsp;&emsp;最后 root 层级下的骨骼下面还带有很多不相干的骨骼节点 &emsp;&emsp;这些统统都可以删除掉 [pm.delete(node) for jnt in jnt_list for node in jnt.getChildren()]&emsp;&emsp;最后我还在提取之后给骨骼的命名加上了 ‘_bind’ 的后缀，方便后续动画输出(动画分离再做补充) &emsp;&emsp;最后输出的效果如上图。&emsp;&emsp;截图是是使用 ADV 绑定，模型来自 HumanIK 内置模型。&emsp;&emsp;虽然骨骼的层级结构全部没了，其实这恰恰是游戏引擎所喜欢的。 动画分离 &emsp;&emsp;一开始我也觉得动画分离应该和绑定分离采用同一套方案。&emsp;&emsp;但是结果反而导致很多问题，因为我的提取过程会损坏绑定系统，绑定文件还没有用到这些绑定系统，但是动画文件用到了。&emsp;&emsp;这么提取会导致动画全乱套了。 &emsp;&emsp;后来我想到 FBX 的骨骼动画匹配其实是完全更具骨骼的命名来的。&emsp;&emsp;只要命名一样就会自动将动画信息匹配过去，因此动画文件没必要做有损剥离，只需要新建一套输出骨骼即可~ &emsp;&emsp;在动画文件首先执行 [ref.importContents(True) for ref in pm.listReferences()] 这个命令。&emsp;&emsp;这个命令可以将所有的参考文件导入进来，importContents(True) 传入 True 属性可以去掉参考的命名空间，详细信息可以参照 pymel 的文档。&emsp;&emsp;后续获取骨骼的操作和绑定分离一样。 &emsp;&emsp;获取到骨骼之后根据骨骼名称生成一套带 “_bind” 后缀的骨骼。&emsp;&emsp;然后让绑定系统里面的蒙皮骨骼约束到新的骨骼上，烘焙关键帧输出骨骼即可。&emsp;&emsp;这样操作就简单了很多，不需要考虑蒙皮的关系了。 &emsp;&emsp;上面就是用 ADV 内置的走路动画进行导出的演示。&emsp;&emsp;然后选择生成的 root 骨骼导出当前选择即可。 &emsp;&emsp;导入到 虚幻引擎 完全没问题。 总结 &emsp;&emsp;工具的源码已经上传到 github 链接&emsp;&emsp;工具的导出流程没有做自动导出 FBX 的处理，因为暂时还是个临时使用的方案，真正的流程应该把 FBX 导出的操作也自动化处理，避免制作人员搞出幺蛾子。&emsp;&emsp;另外这里的导出方案完全没有考虑影视流程的 Blendshape 导出，理论上应该是不冲突的。&emsp;&emsp;除非绑定里面使用了影视流程的骨骼驱动 Blendshape 方案，可能这种方案本身就不适合导出到游戏引擎里面。 更新 2020-5-10骨架层级结构还原 &emsp;&emsp;我之前的做法将提取到的骨骼全部 parent 到 root 骨骼上，其实是非常不好的操作。&emsp;&emsp;骨骼的层级结构还是需要保留的，一些游戏引擎的动画压缩技术可能会对没有层级的骨骼产生很大的误差影响。&emsp;&emsp;而且我后面和同学交流有提到，游戏引擎的骨骼连接数是有上限的，我上面这种简单粗暴地提取方法是在跳过不符合规范了。&emsp;&emsp;而且如果要在引擎做 IK 系统，这套没有层级的方案也不可行。&emsp;&emsp;所以我又想办法复现提取骨骼的层级结果。 &emsp;&emsp;最初我没有思路，只能想到想把骨架层级结构转换成一个 json 字典进行存储。 github 123456789101112131415161718import pymel.core as pmimport pymel.core.nodetypes as ntimport jsondef hierarchy2json(parents,dump2json=True,tree=None,init=True,): parents = parents if isinstance(parents,list) else [parents] _tree = &#123;str(p):&#123;&#125; if isinstance(p,nt.Transform) else p.type() for p in parents&#125; if not isinstance(tree,dict) else tree for parent in parents: tree = _tree[str(parent)] if init else _tree for child in parent.getChildren(): tree[str(child)] = &#123;&#125; if isinstance(child,nt.Transform) else child.type() hierarchy2json(child,tree=tree[str(child)],init=False) if init: return json.dumps(_tree) if dump2json else _treeprint(hierarchy2json(pm.selected())) 1234567891011121314151617181920212223&#123; "joint1": &#123; "joint2": &#123; "joint3": &#123; "joint4": &#123;&#125; &#125; &#125; &#125;, "pSphere1": &#123; "pSphereShape1": "mesh", "nurbsCircle1": &#123; "transform1": &#123;&#125;, "nurbsCircleShape1": "nurbsCurve" &#125;, "pSphere2": &#123; "pSphereShape2": "mesh", "locator1": &#123; "locatorShape1": "locator" &#125;, "polySurfaceShape1": "mesh" &#125; &#125;&#125; &emsp;&emsp;上面是一个 hierarchy 转json 的通用方案，如果只是获取骨骼，可以修改一下递归函数的获取。&emsp;&emsp;这样的确可以生成出一个 json 树来描述骨骼的位置，但是如何从中剥离出骨骼的关系依然是个大难题。&emsp;&emsp;后来看了 Stack Overflow 的一个解答之后，突然有了灵感，其实并不需要构建这个 json 树。&emsp;&emsp;因为物体的 longName 其实就包含了层级结构的描述。&emsp;&emsp;那么利用这个特点，可以通过追述这些字符串中是否在 蒙皮骨骼列表中。 123456789101112131415161718192021def getRelParent(self,jnt_list,root): """getRelParent 根据长名称获取骨骼列表的父子关系 :param jnt_list: 蒙皮骨骼列表 :type jnt_list: list :param root: 根骨骼 :type root: [pymel.core.nodetypes.Joint] :return: 骨骼的父子关系 :rtype: dict """ jnt_parent = &#123;&#125; for jnt in jnt_list: hi_tree = jnt.longName().split("|")[1:-1] parent = None while parent not in jnt_list: if not hi_tree: parent = root break parent = pm.PyNode(hi_tree.pop()) jnt_parent[jnt] = parent if parent != root else parent return jnt_parent &emsp;&emsp;Maya 的长名是这样的形式 |pSphere1|pSphere2 我可以切分 | 获取出每个层级的物体名称的数组。&emsp;&emsp;然后从数组后面提出元素，逐个逐个判断这个元素是否在蒙皮列表里面。&emsp;&emsp;如果找不到就给到默认的根骨骼。 &emsp;&emsp;通过这个方法就可以重建骨骼的层级结构。 移动骨骼 &emsp;&emsp;在绑定状态下移动骨骼会导致变形，其实 Maya 针对这个情况有相应的功能可以开启。&emsp;&emsp;后面在 Autodesk 的官方论坛上学习到的，开启了之后就不需要处理 iKeffector 之类的绑定节点导致变形了。 &emsp;&emsp;开启关闭可以用 mel 来执行，看maya代码回调即可。 12from maya import melmel.eval('moveJointsMode 1;') transform 节点处理 &emsp;&emsp;由于这里多了一步 parent 的操作，transform 需要多一次处理。&emsp;&emsp;我之前的 transform 处理方案稍稍麻烦一点，而且遇到约束的情况，我赋值就没有意义了，后面我采用 ungroup 的方式去掉 transform。&emsp;&emsp;这样会操作会比较好。 &emsp;&emsp;遗憾的是，在复杂绑定的情况下，处理完成之后可能导致骨骼存在缩放值。&emsp;&emsp;这会导致模型的 bindpose 不匹配，特别是部分区域缩放的情况，导入到 unreal 引擎会看到骨骼蒙皮全部因为没有了骨骼的缩放而错位了。&emsp;&emsp;这里 Maya 的解决方案只能是 重新绑定(重新拷贝权重) ， unreal 引擎则可以勾选 Use t0 as ref pose 选项来解决问题。 脚本升级 &emsp;&emsp;最后我把脚本稍微升级了一下，直接拖拽到 Maya 可以生成一个工具架图标，图标是基于 Qt 的 qrc 编译出来的。&emsp;&emsp;生成图标的同时，会在我的文档maya目录下生成 filmSkin2GameSkinMod 文件夹，通过 mod 的方式在开启 Maya 的时候加载 qrc 图标。&emsp;&emsp;这样确保下次打开 Maya 也可以看到工具架上的自定义图标。 &emsp;&emsp;点击导出绑定自动在生成一个和当前打开绑定文件同名的 FBX&emsp;&emsp;导出动画则会在当前打开文件的目录下创建一个 FBXAnim 文件夹，然后将生成的 FBX 放到该生成的目录下。&emsp;&emsp;批量导出也是同理。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 模型拓扑变动检查]]></title>
    <url>%2Fposts%2F5e43c76c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这两天有朋友请教我 Maya 模型拓扑 检查的问题，通常来说检查工具是流程里面必不可少的环节。&emsp;&emsp;之前我在华强的时候也弄过流程开发的拓扑检查。&emsp;&emsp;我当时测了 Maya 内置的 Blendshape 拓扑检查，发现这个检查其实就是验证顶点数是否一致而已，因此当时没有细想，就这么简单粗暴地处理了。&emsp;&emsp;这两天我往更深的方向想了一下，点数一致并不一定就是拓扑相同的。 什么是拓扑 &emsp;&emsp;拓扑其实就是布线，模型的点线面排布结构的统称，数学上也有拓扑学，我了解甚少，至少在 CG 行业里这么理解拓扑应该没有错。&emsp;&emsp;我之前也翻译过一个教程，用 Maya 讲解了拓扑的区别 Maya建模结构拓展训练教程 &emsp;&emsp;从截图可以看到，同样是球体但是可以用不同的布线来构成，外观看起来一样但是布线结构是完全不同的。&emsp;&emsp;通常来说只要符合 四边面构线 都是符合规范的，当然建模也尽量避免极点(多条线汇集的点)，所以 Maya 默认的球体是 经纬线布线 ，这会导致上下有极点，其实并不是很好地拓扑结构。 &emsp;&emsp;综上所述，拓扑就是布线结构，顶点的位置并不影响拓扑。 &emsp;&emsp;所以上图两个模型没有布线的修改的话，拓扑是完全一致的，即便这个形状看起来差距很大。 拓扑检查 &emsp;&emsp;通常来说，拓扑的变化都会导致模型的点面线的数量变化，因此最简单粗暴地检查方法就是检查两个模型的点线面数量是否一致。&emsp;&emsp;Maya 的 Blendshape 属性也有 Check Topology 复选框，勾选也是检查顶点数是否一致。&emsp;&emsp;如何获取模型的点线面，这可以利用 cmds.polyEvaluate 来获取 &emsp;&emsp;但是经过我再次思考之后，我发现有时候点线面数量完全相同，但是也会有拓扑不一致的情况。&emsp;&emsp;可以简单地演示这个问题。 &emsp;&emsp;细分之后，两个球体的拓扑结构是不相同的，而且符合建模的规范，但是点线面的数量是完全一样的。 方案一 遍历模型面的顶点序号 算 md5 进行比较 &emsp;&emsp;这个方案是大神提供的解决方案，比较简单粗暴，直接有效。&emsp;&emsp;缺点就是效率太慢了，我用 OpenMaya 的方式进行了一定的优化来加快速度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import jsonimport timeimport hashlibimport pymel.core as pmfrom maya import OpenMayafrom functools import partial, wrapsdef logTime(func=None, msg="elapsed time:"): """logTime log function running time :param func: function get from decorators, defaults to None :type func: function, optional :param msg: default print message, defaults to "elapsed time:" :type msg: str, optional :return: decorator function return :rtype: dynamic type """ if not func: return partial(logTime,msg=msg) @wraps(func) def wrapper(*args, **kwargs): curr = time.time() res = func(*args, **kwargs) print(msg,time.time() - curr) return res return wrapperclass MeshTopology(object): def __init__(self, mesh_node): self.py_node = pm.PyNode(mesh_node) if self.py_node.type() == u'transform': self.py_node = self.py_node.getShape() if self.py_node.type() != u'mesh': raise TypeError('mesh_node must be a mesh type object.') @property def topology_structure(self): # data = &#123;&#125; # for f in self.py_node.f: # data[f.index()] = f.getVertices() # NOTE OpenMaya 优化 data = [] dag = self.py_node.__apimdagpath__() itr = OpenMaya.MItMeshPolygon(dag) while not itr.isDone(): vtx_list = OpenMaya.MIntArray() itr.getVertices(vtx_list) data.append(list(vtx_list)) itr.next() return data def to_json(self): return json.dumps(self.topology_structure) def to_md5(self): return hashlib.md5(self.to_json()).hexdigest() @logTime def __eq__(self, other): return self.to_md5() == other.to_md5()if __name__ == "__main__": i, j = pm.selected() print(MeshTopology(i) == MeshTopology(j)) &emsp;&emsp;节点类的写法非常牛逼，个人还不太适应这种高端写法，但是这种写法的确很适合在 Maya 里运用。&emsp;&emsp;原理其实也非常浅显，如果将 OpenMaya 的 while 去掉，用上面注释掉的 pymel 就更加清晰了。&emsp;&emsp;遍历函数所有的面，然后获取面上的顶点序号，这个是 面顶点序号 注意和 顶点序号 是不一样的。&emsp;&emsp;然后将顶点序号存储起来，通过 json 将字符串序列化，然后通过 md5 比较字符串是否有差异。 &emsp;&emsp;缺点就是需要遍历所有的面，获取速度比较慢，经过 OpenMaya 优化之后大概快了 10 倍，但是40+万面的比较还是需要 2-3s。 方案二 环边选择过滤 &emsp;&emsp;这个方案是利用 Maya 双击选择循环变的方式获取边的组成结构。&emsp;&emsp;如果拓扑一样的话，获取的循环边序号就是完全一致的。&emsp;&emsp;核心思想就是利用 cmds.polySelect(edgeLoop=int) 来选择给定序号的循环边。&emsp;&emsp;选到的循环边的边序号从模型所有边序号的集合中取出，直到模型所有边序号的集合取空为止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import jsonimport timeimport hashlibimport pymel.core as pmfrom maya import OpenMayafrom functools import partial, wrapsdef endPorgress(func): def wrapper(*args, **kwargs): res = None try: res = func(*args, **kwargs) except: import traceback traceback.print_exc() finally: pm.progressWindow(ep=1) return res return wrapperdef logTime(func=None, msg="elapsed time:"): """logTime log function running time :param func: function get from decorators, defaults to None :type func: function, optional :param msg: default print message, defaults to "elapsed time:" :type msg: str, optional :return: decorator function return :rtype: dynamic type """ if not func: return partial(logTime,msg=msg) @wraps(func) def wrapper(*args, **kwargs): curr = time.time() res = func(*args, **kwargs) print(msg,time.time() - curr) return res return wrapper@logTime@endPorgressdef checkTopology(display=False,sleep=0.05): sel_list = [mesh for mesh in pm.ls(pm.pickWalk(d="down"),type="mesh")] if len(sel_list) != 2: pm.headsUpMessage("Please select 2 Mesh") return num_list = [(sel.numVertices(),sel.numEdges(),sel.numFaces()) for sel in sel_list] if num_list[0] != num_list[1]: return False edge_num = num_list[0][1] pm.progressWindow( title="Check Topology", progress=0.0, isInterruptable=True ) res_list = [] for i,sel in enumerate(sel_list): edge_loop_list = [] edge_list = set(range(edge_num)) pm.progressWindow( e=1, status = 'second mesh Analysis' if i else 'first mesh Analysis') while len(edge_list) &gt; 1: idx = next(iter(edge_list), None) if pm.progressWindow( query=1, isCancelled=1 ) : return pm.progressWindow( e=1, progress=(1-len(edge_list)/edge_num)*100 ) if idx is None: break if display: edge_loop = pm.polySelect(sel,edgeLoop=idx,r=1) pm.refresh() time.sleep(sleep) if sleep &gt; 0 else None else: edge_loop = pm.polySelect(sel,edgeLoop=idx,ns=1) edge_loop_list.append(edge_loop) edge_list -= set(edge_loop) res_list.append(edge_loop_list) return res_list[0] == res_list[1]if __name__ == "__main__": print (checkTopology(display=False)) &emsp;&emsp;这个方案我加了进度条，所以在模型不复杂的情况下 GUI 会拖慢速度 (:з」∠)。&emsp;&emsp;另外我加入了 display 标记，这个标记为 True 的时候可以在 Maya 看到获取循环边的动画效果。 &emsp;&emsp;这个方案不需要用 OpenMaya 而且遍历速度会更快，40+万面的比较需要大概 0.6 s 总结 &emsp;&emsp;上面两个方案都有个缺点，如果模型的顶点序号是不一致的，都会显示拓扑不匹配。&emsp;&emsp;除了这个问题之外，这两个方案可以满足绝大多数的模型拓扑检查情况了，而且点序号不一致也检查出来是挺好的，可以提前避免后续的 Blendshape 出问题。&emsp;&emsp;最终代码也汇总到 github 上 地址]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python unicode_literal 坑爹记录]]></title>
    <url>%2Fposts%2F12108ee7.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近打算逐渐熟悉一下 Python3 的语法效果，经过网上查找，如果在 Python2 中还原 Python3 的效果可以通过 __future__ 引入一些 Python3 的功能。&emsp;&emsp;于是我就引入了 from __future__ import unicode_literals,division,print_function 这一句。 &emsp;&emsp;unicode_literals 可以让 Python2 的字符串全部编程 unicode 模式，也就是所有字符串默认前面带 u 了，中文就不会变成乱码。 &emsp;&emsp;division 引入之后 Python2 的整数除法也可以输出浮点数了。&emsp;&emsp;比如说 1/2 默认输出是 0，因为 被除数不是浮点数 因此输出变整数了，以前我是通过 float(1)/2 来解决这个问题，现在就可以通过 __future__ 来解决 &emsp;&emsp;print_function 引入之后就可以支持 Python3 的 print ，所以 print 的写法也要和 Python3 一样加括号。&emsp;&emsp;这样 print 命令就可以直接嵌入到 lambda 函数里面，不引入的话 lambda 函数打印只能使用 sys.stdout.write &emsp;&emsp;交代了一下背景，终于要扯出今天的主角 unicode_literals 的坑了。 setProperty 要设置 byte string &emsp;&emsp;最近在开发 QMVVM 模块状态管理模块，使用 Qt 的 DynamicProperty 发现无法正确设置。 123456789101112131415161718192021222324252627282930# coding:utf-8from __future__ import unicode_literals,division,print_functionimport osimport sysfrom Qt import QtWidgetsfrom Qt import QtCorefrom Qt import QtGuiclass WidgetTest(QtWidgets.QWidget): def __init__(self): super(WidgetTest, self).__init__() # NOTE 设置 Property 为空 self.setProperty("test","hello,world") print(self.dynamicPropertyNames()) # NOTE 解决方案是去掉 unicode_literals 或者 添加 byte string self.setProperty(b"test2","hello,world") print(self.dynamicPropertyNames()) # NOTE 打印 [PySide2.QtCore.QByteArray('test2')]if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) widget = WidgetTest() widget.show() sys.exit(app.exec_()) 注: Qt 无法导入可以去 Github 下载兼容脚本 &emsp;&emsp;上面的代码就很清晰了，这背后可能也和 Qt 框架有关， Qt 可能不支持 Python unicode string&emsp;&emsp;即便这里不引入 unicode_literals ，只是 setProperty(u&#39;test&#39;,&#39;hello&#39;) 这样设置也照样不行了。 signal 调用造成递归永动机 &emsp;&emsp;我觉得正常使用几乎不会遇到这个问题，碰巧我在开发 QMVVM 模块，所以用了一些比较偏门的方法来构造变量，结果引入 unicode_literals 出了大问题。 12345678910111213141516171819202122232425262728293031323334353637# coding:utf-8from __future__ import unicode_literals,division,print_functionimport osimport sysfrom Qt import QtWidgetsfrom Qt import QtCorefrom Qt import QtGuiclass WidgetTest(QtWidgets.QWidget): # ComputedSignal = QtCore.Signal() # StateSignal = QtCore.Signal() _var_dict = &#123;&#125; _var_dict["ComputedSignal"] = QtCore.Signal() _var_dict["StateSignal"] = QtCore.Signal() locals().update(_var_dict) def __init__(self): super(WidgetTest, self).__init__() # NOTE 信号槽套娃处理 getattr(self,"StateSignal").connect(getattr(self,"ComputedSignal").emit) # NOTE 如果加上这行就会打印一堆 computed signal # self.ComputedSignal.connect(lambda:print("computed signal")) # ! 报错 RuntimeError: maximum recursion depth exceeded while calling a Python object getattr(self,"StateSignal").emit()if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) widget = WidgetTest() widget.show() sys.exit(app.exec_()) &emsp;&emsp;这里构建信号槽变量用了比较 tricky 的方法，因为 QMVVM 需要根据传入的字符串动态生成变量。&emsp;&emsp;Python 的变量背后其实就是一个 locals 的字典来产生对应关系，可以通过 update 方法更新字典从而更新到本地变量里面。&emsp;&emsp;当然除了这个方法之外 类里面 也可以使用 setattr 方法添加类属性，只不过用字典也方便我后面获取动态生成的变量。 &emsp;&emsp;后面 __init__ 函数里面 QMVVM 通过 getattr 根据字符串动态获取类属性，因此这里测试我也不直接 self.StateSignal 来获取了。&emsp;&emsp;然后这里进行了套娃处理，两个信号槽，一个触发同时会触发另一个。&emsp;&emsp;然后触发 信号槽 就会导致调用永动机从而报错了。 &emsp;&emsp;上面的代码就是我花了大半天调试精简出来的，在 QMVVM 内部的运行还是挺绕的，更何况一开始完全没有预料到问题出在 unicode_literals 里面 (:з」∠)&emsp;&emsp;解决方案也不复杂，可以去掉 unicode_literals 或者构建信号槽的变量的时候给字符串加上 b’’ 转换为 byte string 总结 &emsp;&emsp;上面的代码测试我汇总到了 github 的仓库上 代码&emsp;&emsp;后面我又测试不同版本的Python，发现 Python 2.7.16 版本已经解决了这个问题，但是 Python 2.7.14 还是出错， Maya 的 Python 2.7.11 也照样有问题。&emsp;&emsp;Python 3.7.6 完全 OK ，所以可以相当肯定这个就是 Python2 的 BUG。&emsp;&emsp;经过了这个坑之后，我还是不推荐使用 unicode_literals 了，毕竟中文乱码至少还可以运行，开了 unicode_literals 之后出问题的代价太大了。 更新 2020-5-7 &emsp;&emsp;在 Stack Overflow 上发现了类似的问题 链接&emsp;&emsp;或许这真的是 Qt 的 Bug 而已，如果用起来方便的话还是可以考虑一下的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Standalone 提取]]></title>
    <url>%2Fposts%2F946c38e7.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近因为毕设还有开发 Python Qt 的数据绑定框架拖了很长的时间，两个都没有彻底完成，所以都没有进行文章总结。&emsp;&emsp;直接导致最近没有更新 博客 (:з」∠) &emsp;&emsp;上次在研究 Maya 内置图标的时候就有发现Maya bin目录下的 commandList 记录了 Maya mel 命令所调用的 dll 文件&emsp;&emsp;那么理论上 Maya 要运行起来其实并不需要所有的功能，我们可以从中抽丝剥茧，大大降低它的大小。&emsp;&emsp;于是就有了今天这篇文章，整理完成的 github 地址 提取 Maya Standalone &emsp;&emsp;其实提取过程并没有什么神奇的，就是将 Maya 安装目录下的文件拷贝到新的路径上。&emsp;&emsp;然后运行 mayapy 测试 standalone 的 initialize 方法是否会出错。&emsp;&emsp;如果出错了就想办法找到对应的 dll 继续进行拷贝。 &emsp;&emsp;最初只是将 bin 目录下的 dll 拷贝测试，后来发现初始化还会用到 qt-plugin 以及 python 的依赖&emsp;&emsp;因此 bin 目录外的东西也需要挪出来。 &emsp;&emsp;后面就主要测试 bin 目录下关于 dll 的依赖了。&emsp;&emsp;一个个去测试太花时间了，这里用了个小技巧。&emsp;&emsp;先将 Maya bin 目录下的文件都拷贝到我的测试目录里面，然后运行 mayapy 进行初始化&emsp;&emsp;后面再将所有的文件删除，此时由于 mayapy 处于运行状态，加载的dll将无法被删除。&emsp;&emsp;通过这样的方法就可以快速定位出在使用的 dll 。 &emsp;&emsp;这里遇到了一些坑，都是和保存文件有关的。&emsp;&emsp;为了方便调用 mayapy ，我将 bin 目录路径添加到了系统环境变量里面了，这就导致一些确实的 dll 居然加载了我 Maya 原来的目录位置。&emsp;&emsp;后来我测试的时候只好将 Maya 的 bin 目录稍微改一下名字来解决这个问题。 &emsp;&emsp;经过一番调整测试，总算是 standalone 初始化不会提示 dll 报错了。&emsp;&emsp;但是没想到这种状态下保存 Maya 文件还是会出错，加载 OpenMaya.dll 出错了。&emsp;&emsp;于是又进行了 dll 的测试，借助 git 版本 管理可以将当前可运行的 dll 一次 commit 进行记录保护，这样继续测试就很舒服了。 &emsp;&emsp;后续保存文件的时候还会出现摄像机名称全部编程 transform 了，然后 shape 的命名也不正确导致 Maya 打开显示不出模型。&emsp;&emsp;后来经过我的排查，我发现只要将 Maya resource 目录下的 MayaStrings 文件添加上就正常了。 &emsp;&emsp;最后我还将 python 的一些依赖包给删除了，比如 alembic 包，用得比较少，大小有点大。 &emsp;&emsp;最后精简的大小大概在 350M&emsp;&emsp;这个结果其实非常不理想，原本是希望精简到 100M 以下的，而且这个状态还没有 FBX 插件，不过 FBX 插件也就 12 M，加上也还可以接受的。&emsp;&emsp;还有许多内置插件也被干掉了，就在 bin 目录下的 plug-ins GUI 开发 &emsp;&emsp;弄好了精简版的 Maya 之后，我就打算弄一个 python 脚本自动将相关的 dll 文件拷贝出来，开箱即用。&emsp;&emsp;原本只是打算开发命令行的版本，后来想了一下不如就开发一个图形化界面版本吧。&emsp;&emsp;考虑到 Python 执行的脚本，那么图形化工具还是用 Python 自带的 tkinter 吧。&emsp;&emsp;毕竟这个包几乎所有的 Python 都有的，可是万万没想到 Maya 的 Python 似乎砍掉了。&emsp;&emsp;于是我只好写两个版本的图形化界面了。&emsp;&emsp;正好可以学习一下 Tkinter 的界面开发。 &emsp;&emsp;可能我已经习惯了 Qt 开发方式了，所以使用 Tkinter 开发还是非常的不习惯。&emsp;&emsp;Tkinter 的教程可以参考国外的教程网站 geeksforgeeks ，有很完善的代码案例&emsp;&emsp;Tkinter 还有一个缺点就是 Python2 和 Python3 的调用有很大不同，兼容需要一些处理。 源码参考 总结 &emsp;&emsp;其实这次的精简操作突然兴起就干了起来，这几天一直在研究 Qt 的双向数据绑定的实现方案。&emsp;&emsp;QMVVM 的开发有了很大的进展，不过我还真的不确定我所使用的模式是否真的是 QMVVM 模式，先开发完成再看吧。&emsp;&emsp;明天就 五一 了，继续加班，撸起袖子加油干。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arnold 风格化渲染研究]]></title>
    <url>%2Fposts%2F84ce2047.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近我的上级有个关于 Arnold 风格化渲染的研究方向，刚好没有人搞，所以我就来搞这个东西的研究了。&emsp;&emsp;当时他就针对 osl 相关的问题咨询了我。&emsp;&emsp;虽然我听说过 osl ，不过对于他的理解和研究也只是浮于表面而已。&emsp;&emsp;记得去年快过年的时候，上家公司的主管也找了我让我去研究 osl 开发 和 Alembic API&emsp;&emsp;可惜过年回来之后就是各种 publish 流程开发所以一直没有时间和精力去弄这个。 &emsp;&emsp;后来对于 osl 的功能也是通过一次 TD 交流会里面学到的。&emsp;&emsp;当时渲染大佬有讲到他们使用 osl 来处理贴图的方案。 &emsp;&emsp;当时就提到 TriplanerProjection 立体投射的概念，让我想起了之前看 unreal 教程处理贴图。 教程文章&emsp;&emsp;通过这个方法可以做出无缝衔接无线纹理的贴图效果。&emsp;&emsp;osl作为 shader 语言自然也是可以类似 unreal 的 hlsl 一样实现的。 &emsp;&emsp;不过这一次上级给了我一个更神奇的风格化效果。链接&emsp;&emsp;国外的大佬已经做好了，原理也已经写在了上面，具体怎么实现的还是需要花时间去研究出来。 素材研究准备 &emsp;&emsp;上面的链接已经提供了免费且完整的素材资源，但是如果要 C++ 源码就需要花 60 欧元购买了。&emsp;&emsp;其实我还是很疑惑的，我认为既然有 osl 为啥还需要 C++ 生成 dll，莫非这个 dll 也是 osl 生成的。 &emsp;&emsp;于是我又去到了 osl 的 github 仓库搜罗了一圈，发现 osl 需要 C++ 编译成工具，然后通过工具编译 osl 源码才能运行起来。&emsp;&emsp;于是我又开始研究怎么编译出 osl的编译工具，根据 github 上提供的 build指引，开始准备很多 C++ 库_(:з」∠)__&emsp;&emsp;不过也在这里重新认识了一遍 LLVM 神器，以及完美的 CLang 编译工具， 总算是知道怎么在 windows 下编译 C++ 而不需要通过安装 VS 这种庞然大物了。&emsp;&emsp;以前看教程看到 Mac 内置了 gcc 就觉得特别方便，不过网上的所有资料都指出在 windows 下还是推荐 VS 全家桶来编译，我之前搞 Maya C++ 开发就已经装了所以我就不需要多做其他的操作。 &emsp;&emsp;然后就是继续下载各种神奇的 C++ 库，趁着有时间，又去学习翻 Arnold 的文档看 osl 以及去 youtube 找 osl 相关的教程。教程链接&emsp;&emsp;于是我就发现，Arnold 貌似已经内置了 osl 的编译工具了，在 youtube 上找到教程，可以看到 Maya2019 的版本已经提供了 osl 节点实时编译 osl 生成效果了。&emsp;&emsp;所以我搞到这里就此打住了，应该 arnold 已经配套好 osl 的编译工具了，我不需要把这一步编译操作也做了。 &emsp;&emsp;于是我进一步研究 Arnold 的官方文档，折腾了一圈才知道，这个 dll 是 Arnold 的 C++ shader 开发做的， osl 存在一些不能实现的效果 参考链接&emsp;&emsp;osl是用来定义 shader 显示的效果，没有办法控制渲染器采样，因此关于 raytracing 相关的东西需要用 Arnold 的 C++ shader 来配合。 Arnold C++ 开发简单的插件开发方法 &emsp;&emsp;基于上面的信息，可以去 Arnold 的文档研究怎么通过 C++ 编译器生成一个 Arnold 可用的 dll 文件。&emsp;&emsp;官方的文档就有怎么实现一个简单的插件，操作只需要跟着官方做一遍就大致了解了。文档 &emsp;&emsp;直接将官方提供的 ass文件 和 cpp文件 弄成本地的文件。 github参考&emsp;&emsp;然后就是下载 Arnold SDK 调用 clang-cl 来编译了。&emsp;&emsp;Arnold SDK 可以在这个链接下载。&emsp;&emsp;需要注意自己使用软件的 Arnold 版本，存在版本不兼容的情况。 &emsp;&emsp;上面做准备研究的时候就已经装上了 LLVM ，因此就可以使用 clang-cl 来编译 C++ 了。&emsp;&emsp;我个人觉得 VS 太过复杂了，反而搞不清楚这些编译操作的原本面貌，不太友好。&emsp;&emsp;arnold 官方给的编译命令也是 命令行代码，只需要复制到命令行，将 cl 改为 clang-cl 就 OK 了。 &emsp;&emsp;我自己测试的时候， Arnold 的 SDK 环境变量貌似不太奏效，因此我还是用了绝对路径。&emsp;&emsp;后面我就干脆写成了一个 python 文件，直接遍历文件目录下所有的 cpp 文件自动编译输出。 &emsp;&emsp;编译的时候会有一个警告，只需要将 strcpy 内置函数改为 strcpy_s 就不会有警告了。&emsp;&emsp;编译成功之后就是一个完整的 dll 文件， python代码也将一些不相干的文件统统删除了。&emsp;&emsp;最后就是将 dll 文件放到 arnold 的 plugins 目录下即可读取。&emsp;&emsp;以 Maya 的 Arnold 为例，只需要将 dll 放到 C:\solidangle\mtoadeploy\$maya_version\plugins 这个路径即可。 ($maya_version 指 Maya的版本比如 2017、2018) &emsp;&emsp;最后一步就是将 ass 文件拖到 Maya 里面，点击 Arnold 渲染。&emsp;&emsp;就可以看到和官方文档完全一致的 红色球体 了。 &emsp;&emsp;当然如果编译的版本对不上或者哪里操作不对就是 紫色 的。 Arnold 插件开发规范123456789101112131415161718192021222324252627282930313233// https://docs.arnoldrenderer.com/display/A5ARP/Creating+a+Simple+Plugin#include &lt;ai.h&gt; AI_SHADER_NODE_EXPORT_METHODS(SimpleMethods); enum SimpleParams &#123; p_color &#125;; node_parameters&#123; AiParameterRGB("color", 0.7f, 0.7f, 0.7f);&#125; node_initialize&#123;&#125;node_update&#123;&#125;node_finish&#123;&#125; shader_evaluate&#123; // sg 是指 AtShaderGlobals 类型 sg-&gt;out.RGB() = AiShaderEvalParamRGB(p_color);&#125; node_loader&#123; if (i &gt; 0) return false; node-&gt;methods = SimpleMethods; node-&gt;output_type = AI_TYPE_RGB; node-&gt;name = "simple"; node-&gt;node_type = AI_NODE_SHADER; strcpy_s(node-&gt;version, AI_VERSION); return true;&#125; &emsp;&emsp;一个 Arnold cpp 文件必须要包含有上面这种结构&emsp;&emsp;根据名字就可以判断出这个节点的 生命周期 ， 学过 threejs 就很好理解了。&emsp;&emsp;node 对应的是 节点层 的操作 而 shader_evaluate 就是材质层的操作了。 &emsp;&emsp;这里面用到了 sg 对象让我非常困惑，而且这个东西在 文档 搜索也找不出所以然。&emsp;&emsp;后来在看其他的代码中发现 sg 原来是 AtShaderGlobals 类型，再查一下这个类型的文档就清楚了 &emsp;&emsp;至于 enum 类型类需要罗列出可以接入的属性名称，需要加入 p_ 前缀，这个为啥没有找到佐证，最好还是按照官方的写法加上 p_ 开头的前缀和下面 AiParameterRGB 以及 AiShaderEvalParamRGB 调用对应。 风格化渲染研究 &emsp;&emsp;经过上面的一番折腾之后，我们可以逐步回到最开始要研究的效果了 链接 &emsp;&emsp;我研究的过程是非常坎坷的，但是现在研究透了，可以重头梳理一遍，不容易产生混乱。&emsp;&emsp;首先这个 Demo 里面提供的文件，我梳理之后整个流程包括了几个步骤 渲染场景的搭建 Houdini 获取模型的点云信息 Maya 搭建渲染处理节点 通过 Arnold 的 C++ shader 和 osl shader 对渲染效果进行风格化处理 Demo 文件下载地址 渲染场景梳理 &emsp;&emsp;下载 Demo 文件之后打开 Maya 文件夹里面的 maya 场景就有下面所示的效果。&emsp;&emsp;打开之前需要先将相应的 dll 和 osl 挪到 Arnold 的插件目录 C:\solidangle\mtoadeploy\$maya_version\plugins&emsp;&emsp;dll 只有两个 Arnold 的编译版本，比如我使用的 2019 就没有对应的版本，需要去下载 Arnold SDK 找到对应版本重新编译源码。 &emsp;&emsp;案例提供的场景源文件包括模型文件、灯光组、三层点云层&emsp;&emsp;arnold 的 ass 默认情况下是以 boundingbox 显示，可以在属性编辑器里面切换为 点云 方便预览。&emsp;&emsp;另外模型并没有使用贴图，而是使用了顶点颜色。&emsp;&emsp;默认情况下 Maya 的视窗是无法预览到 模型的顶点颜色的。&emsp;&emsp;最后我是参考了 Arnold 的一个教程解决问题 链接 &emsp;&emsp;显然三个 ass 文件都是 houdini 导出的点云信息的文件&emsp;&emsp;如果去掉三个 ass 点渲染就是纯粹的没有任何风格化的渲染效果了。 &emsp;&emsp;因此在研究 Arnold 渲染之前首先需要搞清楚这些点云信息是如何通过 Houdini 生成的。&emsp;&emsp;作者的 Demo 网页也提供了相关的信息。&emsp;&emsp;我们可以打开 Houdini 文件查看一下，由于这里利用了 Arnold 插件导出 ass 如果没有安装 Houdini 的 Arnold 插件是会有警告的。 &emsp;&emsp;这个不影响研究 点云 生成 Houdini 点云生成 &emsp;&emsp;Houdini 打开包含有两个模型文件、三层生成点云的组还有一个 abc 相机文件。&emsp;&emsp;abc相机文件用了绝对路径，需要重新指定一下路径，否则路径就在原点了。 &emsp;&emsp;base_geo 组生成了模型的法线。&emsp;&emsp;而 foxhead 则通过绘制 density 的方式用来单独调整鼻子周围的 scatter 操作。 &emsp;&emsp;scatter 节点还要输出 UV 的信息给后面的 wrangle 节点使用 &emsp;&emsp;后面就是主要的 wrangle 节点进行的操作了 12345678910111213v@p_orig &#x3D; @P;&#x2F;&#x2F; 根据 UV 空间获取模型的法线信息 | 输出的两个属性是从 scatter 节点生成的@N &#x3D; primuv(1, &quot;N&quot;, i@sourceprim, v@sourceprimuv);&#x2F;&#x2F; 沿着法线方向 进行随机偏移@P +&#x3D; @N * rand(@ptnum) * ch(&quot;distance&quot;);&#x2F;&#x2F; rand 获取的数值 0 - 1 之间重新映射到 1.5 - 3.0 之间&#x2F;&#x2F; 设置点云每个点的半径 | 后面点云转卡片通过这个属性定义卡片的大小@ar_radius &#x3D; fit(rand(@ptnum+1), 0.0, 1.0, 1.5, 3.0);&#x2F;&#x2F; 设置两个用来导出到 ass 的属性v@worldPosition &#x3D; v@P;v@worldVelocity &#x3D; v@N; &emsp;&emsp;最后就是删除掉不相干的信息进行 ass 导出即可。 &emsp;&emsp;上面就是第一层点云生成的方案，第二层和第三层的点云生成方案其实也 大差不差 。&emsp;&emsp;主要是添加了沿着摄像机偏移的操作。 1234567&#x2F;&#x2F; 获取 abc摄像机的 transformmatrix m &#x3D; optransform(&#39;&#x2F;obj&#x2F;rendercam_moving_001&#x2F;group2&#x2F;rendercam&#39;);&#x2F;&#x2F; https:&#x2F;&#x2F;www.sidefx.com&#x2F;docs&#x2F;houdini&#x2F;vex&#x2F;functions&#x2F;cracktransform.html vector cam_pos &#x3D; cracktransform(0, 0, 0, set(0, 0, 0), m);&#x2F;&#x2F; 沿着摄像机的方向偏移点云@P +&#x3D; normalize(cam_pos - @P) * chf(&quot;dist&quot;); &emsp;&emsp;最初我也不太理解 cam_pos 的操作是什么意思。网上找到了一篇文章讲解 链接 &emsp;&emsp;这样做的好处是摄像机观察的点云不会有任何变化，但是点云相对摄像机的位置更近了，这样就有了不同层的叠加效果。&emsp;&emsp;后面点云在 Arnold 渲染成面片，由于更加靠近的缘故，因此渲染的面片会更大。 &emsp;&emsp;在 Houdini 阶段可能还不太能理解上面动图的含义，还没有关系&emsp;&emsp;后续导出需要注意的部分，已经在网页上写得很清楚了。 &emsp;&emsp;点云的类型需要选择 quad ，这样 Arnold 渲染的时候就会将点云当成朝向摄像机的面片进行渲染。 &emsp;&emsp;最后导出的时候需要将 点云 设置到 points 的 trace_set 。&emsp;&emsp;后面用 C++ shader 进行采用的时候可以自动过滤掉。 Maya 节点搭建 &emsp;&emsp;终于到了噩梦的开始了。 &emsp;&emsp;Maya 里面搭建出上述的节点进行处理。&emsp;&emsp;Houdini 导出 ass 已经包含了相关的 属性&emsp;&emsp;因此在 Maya 里面可以通过 userdata 读取到渲染器中。 &emsp;&emsp;中间 绿色框的 aiQuantizeCutEdge 和 粉色 aiQuantize 就是 C++ 编写的 shader 节点。 源码 aiQuantize &emsp;&emsp;aiQuantize 节点的作用就是给点云面片上色。 &emsp;&emsp;上面的效果就是 layer_1 输出渲染透明度为 1 的效果。 123456789101112131415161718192021222324252627282930ShaderData* data = (ShaderData*)AiNodeGetLocalData(node); AtVector pos = AiShaderEvalParamVec(p_pos); // NOTE 法线的相反方向 AtVector dir = - AiShaderEvalParamVec(p_dir); if (data-&gt;trace_set.length()) &#123; AiShaderGlobalsSetTraceSet(sg, data-&gt;trace_set, false); &#125; AtRay ray_intersect_along_normal = AiMakeRay(AI_RAY_SUBSURFACE, pos, &amp;dir, AI_BIG, sg); AtScrSample hit = AtScrSample(); if(AiTrace(ray_intersect_along_normal, AI_RGB_WHITE, hit))&#123; // NOTE 获取点云碰撞到模型点的颜色 AtVector hitpoint = hit.point; // NOTE 获取摄像机到碰撞点的方向 AtVector dir_cam_hit = AiV3Normalize(hitpoint - data-&gt;cam_pos); AtRay ray_intersect_camera = AiMakeRay(AI_RAY_SUBSURFACE, data-&gt;cam_pos, &amp;dir_cam_hit, AI_BIG, sg); AtScrSample hit2 = AtScrSample(); // NOTE 如果摄像机也能碰到的点才赋值颜色 if(AiTrace(ray_intersect_camera, AI_RGB_WHITE, hit2))&#123; sg-&gt;out.RGB() = hit2.color; &#125; &#125; AiShaderGlobalsUnsetTraceSet(sg); &emsp;&emsp;C++的代码里面是 获取了点云点的位置和法线信息，然后生成一个新的采样光线，从点云的点出发朝法线的反方向 向 模型射去。 (AiMakeRay 创建光线)&emsp;&emsp;然后可以获取到碰撞到模型的点 (AiTrace 获取到 AtScrSample 数据) &emsp;&emsp;然后再算 碰撞到模型的点到摄像机的方向，再从摄像机发射光线去碰撞模型获取正对摄像机的颜色色块。&emsp;&emsp;获取到的颜色赋予给点云的点上，由于点云是以面片的形式渲染，因此就渲染成了一大块颜色。 &emsp;&emsp;可能上面的颜色一大坨不太好区分，我单独将 Fox 鼻子区域的点云渲染出来就比较清晰了。 &emsp;&emsp;因此这一步的处理之后是一大堆色块堆叠在一起的效果。&emsp;&emsp;这个就是风格化处理的底色，后面就是遮罩的处理从而过滤出更好的风格化效果。 &emsp;&emsp;这里也可以回过头来看看上面提到的 Houdini 沿摄像机偏移的作用。&emsp;&emsp;由于点云更加靠近摄像机，因此生成的面片范围显得更大了。 aiQuantizeCutEdge &emsp;&emsp;通过上面的底色效果可以知道，由于面片的大小会导致颜色的溢出，需要有区分边界的方法来过滤。&emsp;&emsp;这个节点就是生成这样一张过滤贴图。 &emsp;&emsp;处理方法其实和 aiQuantize 大同小异 12345678910111213141516171819202122232425262728293031ShaderData* data = (ShaderData*)AiNodeGetLocalData(node);AtVector pos = AiShaderEvalParamVec(p_pos);AtVector dir = - AiShaderEvalParamVec(p_dir);if (data-&gt;trace_set.length()) &#123; AiShaderGlobalsSetTraceSet(sg, data-&gt;trace_set, false);&#125;AtVector p_orig = sg-&gt;P;AtRay ray_intersect_along_normal = AiMakeRay(AI_RAY_CAMERA, pos, &amp;dir, AI_BIG, sg);AtScrSample hit = AtScrSample();if(AiTrace(ray_intersect_along_normal, AI_RGB_WHITE, hit))&#123; AtVector dir_cam_hit = AiV3Normalize(p_orig - data-&gt;cam_pos); AtRay ray_intersect_camera = AiMakeRay(AI_RAY_CAMERA, data-&gt;cam_pos, &amp;dir_cam_hit, AI_BIG, sg); AtScrSample hit2 = AtScrSample(); if (AiTrace(ray_intersect_camera, AI_RGB_WHITE, hit2))&#123; // NOTE 判断是否碰撞点所获取的物体是否一致 if (hit2.obj != hit.obj)&#123; sg-&gt;out.RGB() = AI_RGB_BLACK; &#125; else &#123; sg-&gt;out.RGB() = AI_RGB_WHITE; &#125; &#125;&#125;AiShaderGlobalsUnsetTraceSet(sg); &emsp;&emsp;主要的区别在于第一次碰撞之后，第二次发射光线是射向点云的位置。&emsp;&emsp;在模型边缘的点比较稀疏，会稍微溢出模型的，因此第二次碰撞是碰不到模型的。&emsp;&emsp;因此处于边缘的点云就全部过滤出来渲染变成了黑色。 &emsp;&emsp;这个节点主要用来过滤出第一层风格化的效果。 align_uvcoords_to_vec osl 处理 &emsp;&emsp;C++ 的部分已经讲完，下面就是针对 osl 的过滤处理。&emsp;&emsp;align_uvcoords_to_vec 的作用幸好作者输出了将风格化笔触替换为箭头的渲染图，就非常好理解了。 &emsp;&emsp;我也测试了一下如果去掉 align 的渲染效果。 &emsp;&emsp;虽然整体看起来似乎不知其所以然，如果是箭头的话没有align肯定都是不带偏转角度朝上的。 123456789101112131415161718192021222324252627282930313233float magnitude(vector v) &#123; &#x2F;&#x2F; NOTE 计算向量的长度 return sqrt(v[0] * v[0] + v[1] * v[1]);&#125;shader align_uvcoords_to_vec( point p &#x3D; point(0), point vec &#x3D; point(0), vector scale &#x3D; vector(1), output vector uv &#x3D; vector(u,v,0))&#123; &#x2F;&#x2F; NOTE 获取点云 屏幕 坐标 point p_ss &#x3D; transform(&quot;world&quot;, &quot;screen&quot;, p); &#x2F;&#x2F; NOTE 获取点云屏幕坐标的法线方向 point p_v_ss &#x3D; transform(&quot;world&quot;, &quot;screen&quot;, p+vec); &#x2F;&#x2F; NOTE 获取点云屏幕坐标的向上方向 point p_up_ss &#x3D; transform(&quot;world&quot;, &quot;screen&quot;, p+point(0, 1, 0)); vector a &#x3D; normalize(p_ss - p_v_ss); vector b &#x3D; normalize(p_ss - p_up_ss); vector a2 &#x3D; a[0] &lt; 0.0 ? a : -a; &#x2F;&#x2F; NOTE 计算出向上向量和法线向量的角度差 float angle &#x3D; acos(dot(a2, b) &#x2F; (magnitude(a2)*magnitude(b))); &#x2F;&#x2F; NOTE 居中根据角度差旋转 uv &#x3D; vector(u, v, 0); uv -&#x3D; 0.5; uv &#x3D; rotate(uv, angle, point(0,0,0), vector(0,0,1)); uv &#x2F;&#x3D; scale; uv +&#x3D; 0.5;&#125; facingratio_cam &emsp;&emsp;通过这个 osl 和 法线算出模型的朝向摄像机的区域，越朝向摄像机就越呈现白色。 1234567891011shader facingratio_cam( point pos &#x3D; point(0), point vec &#x3D; point(0), output float result &#x3D; 0.0)&#123; &#x2F;&#x2F; NOTE 获取摄像机的位置 point camerapos &#x3D; point(&quot;camera&quot;, 0, 0, 0); &#x2F;&#x2F; NOTE 摄像机到点云的向量和法线向量的点乘 | 当法线和射向摄像机的向量重合时 角度值为 0 cos值为 1 result &#x3D; dot(normalize(camerapos - pos), vec);&#125; &emsp;&emsp;这个过滤主要是为了过滤朝向摄像机相关向量的偏转，因为点云的法线越是朝向摄像机，法线屏幕向量就非常接近原点。&emsp;&emsp;到这里的时候计算偏转角度就没有什么意义了，因此可以通过这个来过滤，当然这里还需要翻转一下颜色 &emsp;&emsp;这也是为啥箭头图的法线朝向摄像机的部分颜色会变浅。&emsp;&emsp;并且第二层的边缘效果处理也是用了这里的效果进行处理， 输出 &emsp;&emsp;最后将上面的处理全部合并到一起所看到的贴图如下 &emsp;&emsp;第一层透贴 &emsp;&emsp;第二层透贴 &emsp;&emsp;最终效果 总结 &emsp;&emsp;这一次又查了很多 Arnold 的文档，学到了很多新东西。&emsp;&emsp;后面我还在 github 上发现了用 Arnold 处理 卡通 效果的库，后面有空可进一步研究 github]]></content>
      <categories>
        <category>CG</category>
        <category>Arnold</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/Arnold</tag>
        <tag>🇨🇬CG/OSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya MGTools&animBot 动画插件研究]]></title>
    <url>%2Fposts%2F64ea31cc.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 7ed5605b8a93603a1230fbfbd13bfee06324fb01f61286aa90f84b0435603b129a770257f23c16bbba1ab0daaff2ac4d24553463d917cb80a8c6a3d4e1567f8109f83c4fb432fffb481a7efeefa783adfe04aa5c5679d43190cdf31b0709e7d1770a1b936e104bf34de5ac8442022c4f12ddc982f05ccbbc4f533c056776287857c3fa623bf87c7cde1e6b98f2899026bbb5b9d8552c505774d392baa2a4e02bdd6cd872cb1db6a540c59f3b9c510ca0df0ac579f9e044d80d0da6c124834d63607fbef2d5403c6a186f107512ec9609b4c5f2f1648763f1e9ca8aa5170b2c9659a8601e06de5bbe2bd1959ffadf5cba8471121946b9b308498a7ef4c2cbb466db2f29df07b63f035465a603eaa310d608f42902c746858e3b46c564b95275ff0736288e2f5eac7caca587162d968a485cab4f78fb878649f2eda8dc5c7a032234e8b22f5bcfa5e560f46c88aef552745207d0c0ffb2d573d518940dd3535190104a1eae11c78bf944af75a0ef151121f8eebb97f114194ab537b2cb3138ab5f6e9e4db2cbeb941ec5ee824aec550a29810a2ed1f3ff15c640fa9272bc41fa8af334bc4ff4b1417e4a0d6b71355bc804bbc722300b13ae54dc90ed3a519eb1ead3eef357848116a5d6d27812169f9cd91832547c4880886d4a683915c5f1506806e50466ede5e2173231fa23086c92c1f0ff21fe5686667fa84096f4eacaa131df461549ed58ee9ce365ce733bf23478d2e958c4f8a1ff970412d549258165e4cdca2282b19a79e96727c51f244974654afa06bfd2f1e0b1bd454a5bc95041b5f1ff5ef54392c8141c5626e500ddcd16c212915349b9501243ad256e9b7a4dd7acd0e7e0e54cc76e5fa725ecebcc86a628b07301da9a9bdad1bb5ccf476581db4d090412ade2300026cf87d8db105e42ba2c19962c53ae3509bb4577de2bd27d5ddb827d2072282491441b42a424f6b49102ad3ce10e9f04b7ee280342a01dbd692ab0d474bff7e8ce9b978d90a1c0de593b313051f02add246f0cde86cb19fb633dfc9380bfc82f13df4e7327b9e406e995aa8fa6c20b70563653b716cc05629baf1ec3cd768e55f24d3706f322440e7292fbb2775484086c072af86672c686165a531abd8880cf0f3ce321a172095c958b66229d36c46a92352bb5de77caf94be70df489a7250d85919fea2ef3ac6c9327af4eaac87d2dd3714efe09b82b7871df9e10c044d0a92977e30f9e7d89dced9abce01cea007d8bed3ff4321640f959b9e0ba6a728737d6db6d83bf602f08176874eb981cc5649342eb188ef264af9a8c0e61b12392a4a59639304149f146b41c211bfc4ad22acefc0266d7267cf72df34b3bd62c724ea984595b70a2d853bea1cfdb77e46ca71de3c0b35c2123395f0fde747aee3205f01b45ae59fad7f7776e2c27669a24509a3e0ed0389fae387438e33214fd97a182242342f1020449c091f45b7cd410780e994accb1777bd96d349c49aeeadaf2081051e880d27e01d4a23451de50697c872c7db26c8719e0a382ff08f86ad2911864faae1a7b06764d1835014deff5c0bdef02e2b5f9b0b954c88f3dd3eea045115e2f8678f1f207a7687fa6e266af7539980d9b975dca573616b75ef7c4e66458baaa3da26a0c9953156a2815db149e0f6102fb356e2cfe3dc417ef9852af758c71c7617812974e8d635fc6c15eb64331187e286fa248bd2925a4ce9f94a520d4918f6793731c403d8be1460ee0ba625ffea7a448e44f02d6803360775d411ec6e11935818b42398bb52bf31202dff55d3665b21ef627e798fbcb929fc2ab17c930ce037c0ea69ea3a2da92d2cea69b58338bd16299a05de4b271a6d02672bd28f6fa6ac6c96e167340bddee742fdac7f937620f5f78f5e100b4f870bf8fa311dfc70ec739389aa6eec92f8c4957c71ebe201d4d8d1ca8cc5afb13ce31fcfb81a28159b90640bbb962ce766812816ce77610d3fa3e53ce45fc31559748b7102bb17b0079143256096f9ac3475d77bd7c2d92f1565234c93ae299630693d6730ad853b00516a0eb3049fe34e0fd1776d43d9baee5b76e3d10db5ba2c0af1d0bdc0861bda03504c8b85ba3103c20d3db22f48d4141c13d7273b0046aa6ed53a709e7427b00a325c5de19d552a3b50906239510bed81a46adf9fb4016e97b45c171e51a8ef3b62c7b8dc9bbb1aedd0e11c1d9796e0d4815103873e84ba5760b4f5fd7c846f7bdd15c21bdb2b75b98e460407d10e3a3553bf31edd1c682ee6ce5bff1b27879e608a043451e578f8fb3319478ad4eabf9273e966be6d1a6bfef62a92a1b146e99420eb4a6037e60bab4be771f2e0078ed967b4f22fa5593525f3c201ab3eafb852ef83ed56af3a15ff49ffed44f387ed4a11fdfb1efc7c241e01d6863ef7c1e5036ee205a9ff7f492934aa17435a030b1d0159c55e10e106c5e9ed6fb72214c8007e5b29dec8b55520cab3d46102adf82a469437b1398483e6a0ce3d7fe3eb57cbf31499404d84013de13da8ed3694d25b26ad85e229415be46a5273cb74d7e4473e0a1022574521d30e0c5575faa59ba2e2909a15317cf6b47c0fe895c0ffc169338abc4ba512c739ae641b6a1d450c3c3f10ea745d511de4c74f8db9d0a7f9b69679846acece39c599d490901cd217139fabd510c26bed581c35a64e5119cdb97db9df15d17cb7f98288f138daff8dcf24fbf20c93797b0c180dab0453d8c2df962199de20dc84eec2b04a83ec5f77ccf7e6ba68ed40c464c84ad12e85cfe5abeb34a7b8f4086d5ff9fee55d854fed65ecd199a622f248b8b1e40e8572d46c9773a08eaf48ecebcd428028430e6989ec021e5371b85ef5639dbe66eae5373050e4b169df99645a3176e94afe440c1dfca4e21d09601fcb35e3a599228f673ad5dc833e150ad4ba392c40f09cbd14ea4d0421655a74e6e136c781a121a805398e2b9c436053cdae1eee39f5a3463e6c45726a1b451b864ecb4c4af83df14df758c22f653e2014dfaf88b798a903038d84ec0a25fb8c192cbd602a173c67b5f9d65e7613bfb8a485e77da8a96b8425b8090d074861241edfe808bdf015c03fa0283d64ccee00a99ba278287000721c1a2625dbe34748f0bc34435892c797a81d4c4c79285c634ad8f041190cea15018b6542c0b68ea68a90a63ee1267cfd9e9d8d379f6015c2070c4b2340cd39e6313c417885ff03e8458f4574b1d1fd028e0dffd6e05496f52c15a07c5bc16a94de5e764e79a2441d7dfc1954c80a653b39152f8412eba82137ebaf1be69b07e71e6797b48206927dbdf26edf6cc39547f49080585d77f6d33ecdc1cd97e8b46d8d477b63f4633f46aa0ff042fddb95a7443bd72e80defdfaaac31ab8b9380c4e815abb9f90064a5474a2cd7675d2ba703e829b8bff640cb20b62ced82c091f5159578562b7d2bbd43d925c256652318bc39033cecaf49db9a15a09fd2dd09033363ef67c8d74fac3019a293d74e0a5b54d97fa3e6a1874e9a81532aa1b9132e8e7337d2534f21e38de24b739485bb812f9abd91f0681d30062356c8b9915a6cda32b3d6e8dcd4c034ab4a63aa1471731b976372c4681ed23544e92bbeef41e850e52f2585eb30ca065873aeb6f24f1d753a50000173cf40828a61e7a8d7579213e9fe11133e49eab8236663b5fbc6e8b2db14353cd1c929c686dae221b243e433255cec64c5d826459a2e9853c5d5ffbb9ced80663a558ab4970b40b83888f2d9a0f74f715219f2b2ad1169db74f65e23276fa5a47c4f278d423234cfdff8ed3e784aae131d5a2de4ba782c76c9d649f9f5ede549f3eeb4651122afd70f352f100a3165e1b6716bce52464a07122e32fb891e316b2bd6ad67855453072f984b08581947b40b00119a504d4a625e95573c847e495a6e899c6f2dcf2130baa08c8d59b62d97f641d972f5164d4d970a529d7d9b249643a1691e750188ae384ab18277a82a000f63d8a74c8b5f1b75491beb566de06460602b648d91f702f39339a7cc5d554bee2dcbc4c055b83f7d387598d545647382358aa5cbf47816c13e6819326c4be7659e53cac8f5ca50acea9bf18c1b829f378f700e53f584e8fc3ced3a41fd58142a013cf63a182eb29686869a068b5236e04cf93d68223a3f891f24ece9f274abe1f302c111bd934d18a9af8a6b9dd9c17eb5475d371d39205d6f96754d0b136e54eaa2a531e86254f4d27c1ea1f442afb2ac51c06cab38d9ca65bb191f61ef9a6707c1211680480bbae4bb287a66b10c982f09d5dc81cc56867384fb8b2ffd240e2d0949343d5748713b6898b6219cff72f49cde7f6640aef1a71faa994df94390b4dfd1c0f19382bf98630e727ae1b85526b1b55245b2c6c8cf1bb9dca9009db923bd1d0f962868d87e19e40d0c7c081a10cbc27cfec6a43e8d39e225d3845f44c70e54602173b46bad718d63b9d1e99a72f0732af731fc25b42feaed5b9b9490afbd2191e999eb922af4daabd6c97cf8666c91b1d2804af76caba627cfd2e9121f4eefcf71466cf05644be3d7b9f3e896835e3fd1ba5af6e1d466500439a5401fc5f4e5b285118cc04b0b49b43ccde6883ce1288087f0544ce57cefd5fbede0127560c3c638cdbf2912f91f94d3d3f966be2809362e3670e43955283a7c5221c5302e14b4f11665c955455d539559e69f54932d7a9791fcbd3774e42b7bec1afc19cd64de22bcb072cee502feea9d303735550778d27fd7ebef66e706e877d8c5036d110594684d89db9a509264a6987d8b3590780f34293943ff63e57f65cfd4affdc2454e7c68eb21cab21ebe77809c898535de574f60ec4ef6dee39cd82b5fd5e4a95d2d5788894201f1ec71ede5e59ed6e8467e449792a4c25cc8867082aece2bd92173ace0f63a3851377ec20cbf632947429aef4043a49aca923c06589e7427d17e60e10271d466af467769c6d3b5f6bf88f59470ea7a88498e710a077616cc7550f9bde87e20efe61c72d9eed2da00ea24e46f166fd92a1c8b01153a586ef74b37aa6c7b689708525bc7471c57d87b59938c683b3ec8cd99fe8be94a9750fcbf804c831a567f8644f487bf95cf290911e43ca361a9ea1f3cf755f1a7c4af65029cf5b5192eb4303ad418bf005b6f3b4ff37e34e14f60639eb0a52d385d284da3e347c2f2ede8601ba3e35f02825681f0c3802ed31c484376c073919b663f4f0c7041da3134552ab2201c1cc2111facf739e00e39e84b175179b90a01f17e7c8dbd5abc7459b57b76ebc203c28092cd8cf705796730c4b428337ccc19b95b73a8000dd690fc8e1ca1525b31b2c31118aa00a2ca80fe59005c5a9d82246678f1d146d70b6bfb6a69c64f568b6f15c2f2fc3da0c679be7ff4a04d5ec89a30de23c5c71ff9979ea2238a893bffcff653a8ddacd2e50c644011b3efe3ad070d8eee7d43160298b19da87f44e70d4b2573461a701097deb6a687469f4bcc1a04eb8ea3535ad4a6524eca027bb1faea9e8a49150c9339db84085ec90cd06a90899a4a725728eb66a7cab65c62f51807b383ae4b53d525c2bca838f738c575e31be6a71834ff745b812b10f516927149ed0e9099f0a56fe88f232d18a550bfd662cdd747d1f73966f1792de0b3db05548ff9ea8665f28b3792b7a40f0e3408f4c1cd9dda6cec11c7fbcbdf09afff4cb9804dded124f20dd11a3a6b2045d2d343ab699ea5c6afdb9252b1b10b1ca95615238a4acca1bf78d190286a4b2c5315d16c34a6ff1bbae08b5738af95a7fc56a12b0d72bbead80f7d5a00122c2096499074f804ed8ad30ffdd85b13a253e676c1cbb82379c41a4e419601ae9fe882a0f4ef78ee5a0c272425ff78bffddfd952a1729ae647a98f197b97beeafe6128dc1dcf061d2f3b86d8df2ca67a563260861844619e65f65e9dc2652c5cc7faa146ce01a1bbdff02488a9695d794550416c60f62fe5243eff74113aa94c1bb72d0eda84819cce080dbc5cb25dbdd895de5fbc3f4e658ab47cbf3f7461a95dc1e61777c2d7d349b61e783f5780d1f77139402409e3eeaa2766cb224c25d4ca24fbc594c424f74e5e088a33f229025e88cfcc54002f209209339710f8f925542fcadc6a677a5cefca27a0f3ad29a2b783de835834a8546b02716bab8f33c18d11f0884dfd3d5c813d5e1753dfd880372c23589bbf919b4985dd439f64c907b7dbaff17431edd11f870e0a059e53362e054bfce4ed0fcf93f4b9a5b93e5ea3137cb9bfdc07158499bb88e1efb51e46542446164138929cd9f1abbfca303645370977c1ba05eb0da6e8a600922556ed0dacd7f5cec6d43360af2f5e88b7459653c420e217e20d62247014dca1b60b19d46dacab17de34f9160534dee34a0fdcb6aad99a810d14ba42bbfc4b28d2f70aa6059ea4abac96ddce0edaaf544fd5218765dc4e7465d73cd4b0e4972f09a5b0775686eb74a47e38adc333b428b614f0204898db0dc1d30f646e52efae34c76c933eec12fdc69f6da3fced7d668605795d264932a82620edb3040c63b2ff4d320bd1764670c7a28905edcd29668ec75904a98f6295bd8f229893c6b44bf52e9b529b7ccdf0c2af1ea3a01423facd8d2511fcdf65f27f3ec04bf14e118280359e6adf9250d25b82e1b782507a15b428aaa30a95ec083dc49a11df9fd21e2f0b532c6f6b0552b45e68e8df08dfc4cf6576be3088510f5a88e4c6c74f0147287f0418dfec0436eb6b67dbf10ad572735826faa8eadae4fe1ea96cd2b25a04a6ec9f8593b00c3e4197f3c25471d16069d3a96c55e67b08d3d036f6de105cdb6089d2dde8bb21a63f33f88dae811ee8372b85a5a79e6cd48da9fddbdc4f5f2ccdda3b43e22a4aad767802aed9641cfec03174aacf9a9c68f65a7a9140acc8da4163b45de1d47be5855673492c98538400055460ab36ed9af60645f54bade68b0aaf66304c0ad9be4cb545966c5c16671ccd3cf1bc814bb8c88d7d9a0e454ffa215e704699cf9ca92a9bd593c8322b4a4b57bd37ee105bddb4a7556c6c65007fc27d149572a2fd0810ebbcdba5fdeede94b7ce93bc3bc7a141c74490eeb9065e8d5c343429b224f3f5892ff7840e2d41e755a72d183a4d591c1f2775955d2db0d5a1622cb586b773f7534e36677f748fff3731ce97cfa4b4a613aa12312ae2b58082bc5bfc506181003c22927016f68e3ca6309331c829152de25e69deeb61baa9768add899cda2537714e07591b7ceb12142b6164475c4fad67a586d16d8cf65f36176d8ed8a5c06baceae789f7bb30c01f6353fbb37b934f6b8000d90f4925254fc2b54b86acbe1db17eed16452f63eb0412915f160ccd1a145245ed22adedd36a43a357ccb655cb54d9d08944c0325b9bfc7187fb9deb20c7d7fb2b8347b339491920937e17c7d45554a55dee1e4f5a9867519f2f60e1fa266b754dce6281f4cb47486d8d365d32d0669af46da9f7e0751fdcb1a48a5d4a9909cad91928e144726d0a14828579ac6aeb9e06689f746dc83fc75101a3fef017566f7ddfaf922060ad591174fc6c570577a6850f97391ad71b284930242bfa4480ecaa7a781feda1412e7c2725b7e97f651a5643fcb4ebeba71bf83c6a162d83218aec4b260a68c0498489d3e7aa0ee5fd9c4c912dd66643b0b436337af3abc7bbc9e9bb37ae8f73548b8445fc2f8ffa7639a837e250863d740bce1a151debd55541a8b7638717d83bbfa6ca50e983d09ad3ef79817a1e36f3d2492799155738ef4df72c18f7f47d3ac9da3f22301f3bec613bf93d9418449d680784fa9cee92f5d5ed5fc0d9f18b3d2845b4cf4c59c73a97b7f219a20f18e4a7f554a49faf83380d8161923f357b4a16e0a6d86c57e033b152837905071c76efab955c40cc8d5fca405967e2e0b731036a96919999704657ceb748b90b4abd74c214f6d8496191320bc56320eb7b484a74a0c9a2093d311aac46d347b35706b712115866d72941152c456814a674d1cb3065c40959ab89a3dbf657e1c92e6a93475b3608f84d5fff77e2fd841df87a489c439f46b6a75aa049f44a6d4211cb1e6f42401ec472e6c21c066a194cb057b64cfc9b1f27d078ebe4d5473bd8f287b81d640a20e766fa29d4446f0d9cef884218e0cc809631c4c2b7c9662baae434a2247321e314f8ac6643185a71ae8af35db0fa496df889aaa9fb9e681e96f3f4a7be78dda0896a0cb2f8717c9fe0a8c2cbb8682e69ad9ed7ac661d74d39b45a50139678fd44aa89116482016dbc991cdc506c2af75816910dfabd51222a96813c575ed030aed122faeba34a9f88082129385becb485f00b0d460a0965cd272f6db1efad879d83e632a7f26831a7fcc040f19bdefa196a70a57c243eff71af7c51110934c897f596eaeed946630c642471ee1af022c27a8f73193a69a11b956fb1045eca52c6ace4c86c8e35d085c58721bab84e17c7d616f95b3a3bcae0d3c455e27277fb4203056680f76348feaa3e897bef49fadc0e5b6491e7bf4213536e1573327f793cae0fe798a4d7acaca00cb8a9c5e5a0df512135a2892420403a4125d95974f504fcf388b88ffc18dc53259b61ddc55a2ea587d1440e8830453f4d06e080cf899e77944e96a60e7f07adfb415740452f96f719434e0591217d0181af66d7989379169bfd24c91952dac5739691825f3f7bf114b951e87e225ec4f0035c4ec97aa7c8b8ed6c1bf6f42cd65988c25a139af72ccf77a803fc06122813f30f797ab127394dc47c6f2b0a7ef71405f01403ebdb1b0ab13cf06b5b2e98eb3498bb96da3d1baa8f3e1245c84f22aa28ac12dceab58e828b804d50ef0790d66faf50feff1b5b3f55866612a24f0af85f382cdc5cf221827a9ead44dedc6ec21fd0f89b48e4f4b2061aa1102f56223d0ca4cfac26e8b02d6554eaee735af859057d03c66421aa7fcc805b78c9ed4e41617eb0936a0c52ac7345fff6152ffaaf15647b09a954d69528176c883c9780187e35f8c7761ecfbe917a7f7ce769eed640927f9246dc5597d27aba0ce58896981d8127fbe4f759871dbd20ab5cdad92f9d6f26d1c1cac29436896486b33240438bc848dd38252fffce045527616da5c9c32680772186533368fb81f4bab16421ad31f921095e88d64baa59cce4491a6425b38fdeba5956b16801aed79a323c69e19adcbcb630c3fe495cc0e0012d83904d186f6bccbfdfe1d24fb895df7a8369d58b389e3319cf795379ef0c875ddebd952c8ff508b2afa573ec8d9cd40b74da8327f676fb26590bc7529cbebc0bc3518c52d8cd8e1e84e25bf941ea2176b2ed519562c658dbe50f8726617365099734abd1a0fa071568cc394adef63fb5529d86b02027afe41eff53a0431480115112d16f28da763efa05092e88d73ab7cbb1bc7187c513a95d31cc83a41b15e9c34058f43077ff53e80487503532747be2c5c2f8c40c6f33e674268856d749c02b8f2521410c44ae6d8fb6be6c5ec20f8cada9ce27be5b7100f4aab3edd32fe3478c7c8751d172ea068fd2cdd06dabc03a8ba49c66f32d99395216ad4a3a4300ef070c9d4330f93f226ab6d7976224cccb08038ab2b9caca71fa1299626d18deb2d93f9148b958fe85da045d6164b7ac276a76873111ff7943a0d8716020ab8a41974f2012d5daa9beb490a73ce5863dc83601f252601e77cdb356dc63fdc21a86afe7eb3b6c07069e917c3a9c87f171051e13b4b732c5a7503390c864251aa2ba8ea4a79b6b010a5425b679170dd9e73b168f13a3a770c555e13f4960d040e2aecdabd45b363223723c17f339a462d0e2cb841d6f937654109dadd9d4a63802670809f2662856fdbe7b92799c4790314ad1e2c08ddf12caadc1cfdd278a1d29ee56ff6778d02df29af2d48b9b4f9427ede6b758f42a179df5ecadd23c3cc333ab0598517bdba019e949567653daa1d706f4853cbbfcb377e9734d46a43e68caff00d1174d04775b6b54f59f83c635aeb6769cf455fe38c2aed80946b707864f24875ba9a2344588b6dea065c11717b0361319e46bde18630cf4421dbc7d6973c41588efd20b0dd757ee88eb60bde64bd0a68679975af8222d8e8f7956b93474fe1d4214a054490ab083167d3d79aa5cdc385870a4b5d89257f7462bd63f7f9c8746f488fc74e2749dd51774e03c7d68b866015bed5cc78ad3c3db2d2d791bcba7fca53baa040836e9b6233996c06c442d848014325ced7e8ae324884dfd54e773047002b7b55060262b6835eadcae2bddaee2dfaed61056f0032af813893661a130673e7ef99fb4522c6d14cf8959ae158d5895c3176c3a3e431bb9b8789536716c464fcdc6460dfdbdcd1187ac77016166b39fc4370f9340e702b0fa47b5fb2a849f9677a3e46fd650a7b401b9f3ccec4fd4bcd0f638ba6c46c70aa9209b290ff8b1e19c9a802c9240b8cc58c83b77fd2069aecc16d1b165e5b42a422a2952c9247e34905a772049b97d284a53de5986c48cc5cadd7852df5f6090cf7d836252329fcfd77e844463c2f5a0c230b626fbb37098fdc3370a538e022d05efa2286d00547a47125ffd0accbe4c68a35f21b9be574be22677590be01d2fea6d952abc30eb965fa110bb66b0deb09e044f99f481630308e0a61977425eea65d9db72fd9933202d48c76f81556253e1d479bf1993df0a7e3cb89251ffbf93759aae18aa7e66cde432960022f5d69bf16027caea07dca2114271211c03ff089e5ae2ef65511f20b4f02f28eae4dee21d68ecf8d6cc7bca22467d03e76fa1f189d24e6d411f74afb98fff294e87a1b902e1fa424a0e92ea9a6c0346883c243c73b08425734b904a4510ecc41f68bcec2ec7d81e53cb092ee84027151b2f3ce26cf27433df0c7d14d12f57f8e8e33848d5dfd7f922123d89a69b846a0156e3b00f0f830a10c07d4004a9665e1f6a629147f35de3d1ac01bb48c68a91fee7070aa2783525193231207a1fa835a775ce55331e8d9bc622b13df27e14c9d0c2658f9c211b21ba3a089ec0bbde41c6e3766adfc88880e401fb0344b067a84a8e71e411bb31230d2127246bdd969a4f79493c04fd9769cda5b7f132cc899f2c533497cfbe230c29ed8d66a6fdc34b9e0cb90da28607a60e2ce70e62ef2fe80033f8e1fc635c647c8eb0e73a09df010768ffe178c36f3fa19bc280da0421678bf597d7854a07398a92ca9b427847f5a8dc1e9bcfefb52676836e17ac70df213e12fc2a02204b880062d5293e0e05cd82f2ae716836ba108c92d3d028658c746f43a288fa640052d3fe35b7b923ce28c81dec9f6dc7d59b81342b53a69d2a7e6c063774b40cd276ebae414c10bb5e12ff149d4de143dbdbf0471ad37ebffeca29278f73ac2e29bf99eb28592bb77d09c08aaf61c3e52164646b06764db2316f51b63947344090cff590c736a8117effd6a73c2b6be153d9e08dced62ec098362ecde3d43b66ff04ce135b67ea3c3717168c3ac8f31b8fe816a1a8c1eae9a3069af37ea2c0deb4fcd5ecec60011fa3d3f6a272d0fcae111052feb97850e860363fede6d68a6b4b0204813c6d2c53057a5aa0f3a242424ed310350e0dc07b2785b0d5b63b602026659a2f3ad606e95143019dc3ef921e40c8cc17a24ef07785e4a3ff568c0eff68abc0182096464b1523c3967829b25e9ec2280de609c3aac9836bedb37e77bbe3c4df1b7a48887a755d79b1f12582d1a700bdf6ff101c710cfb13d7bf35151af1194c8021f00a23db75998ae6531776aad5fc6afbfb9950cf96cf998a48e0ad16064e4709fdf85aa2d6b30d7938f0edf53e1a954a87a16fa4d25d4fd627b417447a20a24090d5bc01e67541dec47b05735e87d8cd9dee068ee38560bb545bf2ffce13ffb7e44d6b25f4434acdf69eeecfc25c7f1fa488d500282092a8da583e53ad914c70c6f2183e6788d3a83e675315bc866e54b2ab7f7e284b337857329edda1227a28f8ee8aeafb9a8ff8e7dc155de5a1725f01de20b6814a90b94b822b89f09f225282b9f90ea1bced0bf7127a451a1e37614028289d3c5e6cb7167919bd8697c6c018445a22dd866af1bcfb7a5e36d65eb5664067236760c6167dce58ec685c3c93024c26342a8f15255daca8475ace2b4886e593a71ea3c62d20e7518dd85d85a335551b850edfd5cd934e267f6e0150a20c69af1194f2c085bfca54bbfecab0e61b5bd3165e50b5d9213f8e87e8529725ba21c7cf11e2a25620585b1fb486db38e8cc693371266e54f5c015aea20c3d90a1d4d91ad1b8cd0fed7db7521301f7e453a98824a4267fd3040068123b3e135ce07f0d272f1c3ffe0ece5d1334a74f038d20e40311b01ad56adc6fdff82a3fac1c19654af8a3eaefe9c7f1e171d93b5db408714ae5789883e0b953789d7cce77bc0e9b72afbad835082f8e1dc932523ed099eb745679f491cd85060f21f99b40cab9ac04d42ba4b817557010e9dacbd7f8dc3f4307a368a161824fdac961d8d022e12829bbbdf03417bd208ab3446183425dd726fd60f0698e1524f2714fbb52966d03ace268cbc6645e6c8fd3d1f6cb625c999d128eec74f9c12226962e9cb0495878e475201e13c64221dfc032b9636265f53724beeaacaf76bba1000a8d99da781b469f23936ce381c17f735afd011bc692540f75d41635651ae072790b4a4641243214f1727740ee8e118efa14d128f52cffd6a2801a5d15b15c6ab4989aa79ad43d5b5432af71a0762504e82d33138ba703ed33efd2d7a4ece9cada87d95ae64edaa2d16bd3bfea8e335c84d2c32c2238b257503350eb7cf648b7ca8dfe5ebebecc88f2d20d361a0b53c19aa24d4a0d10cb7d83b8ee4ee55dd411be4fa755555dd2393d023bbb32c5242f0de01a35e10a68aa654cf8a2e548867d874e784cfb996fc4553756dd00503771e653dc83cd426f48ae3f97e166b58cb1620c297f3be5195d602fd2759ae954c3ad53b31367dad9221a1c496b5ef6d37d16bbe75da67ea35d41747d1b5b5e6e9277cdce9cce513b376ab656222733434d7cb457bcac0a398c7a303f9c29cc0fbbb283a890314c78b1a0a276e20273aaa1341f2ed6b397d227c0461dcb6125e37d5aa5721b600752b6b7f27713e4d2aea467df304dd68053438a28d3aede530c672aeb3bd44678c99d53388e726051f9de9b3c3772027c0065f4c4d7918c4ad3c7af6de3915ebf9087d03fd9e05018a28c596f7d96c949d6b4da1e91579ae42e498f0cb18047105e7cb6581cca8405b2550383188b0558614255040a78181609683a4225465628de7ae462755e3e85dcc66708b5bee7bc9e6e942fbcab28b998ac73c728bc1de4057aa7cd735ae14689e0370b39147c1ae88cc9cefb3b9e441486b3abba57e4053b3297009ddde55d031dc592f2693f7901d4c883ffc39d2c76f23cf510ef974ecb96ab2103b5633db28b909d3557b7bedf720084b8c4b3d7a1a00dd516c497d14f36ff16be0be3002aac9d015c23343e372df520595df4fbb1eccb711be19764baa58c32536b73bd0a29a05496e1e80f7cbf833737570f34a6545a4c1a07839dfa684642985e93652c1c6c21053a9f31769b88c7f30a359ddf7da194103ffc3f14e1c34dcdbd46121cd39ae2a504c8e8a458276b410860e90295266c14d5a86f128aa31a67eb2475a2ed138c2cb7e64452e8891ab3d665e59afa2730fe84e8d5b94aefe062c8fbc8752db4262a80d88ef3b448a558f762c28b9cd1761a3b5ae8aa28477936ef64b1aeeb9a874746cc5869ae163ed92a1f364b09a3e4cb7d7beacad7959594787cd3268716984e5434332365f41d9f2c7d786b7ffff8bf7063cae0e09aa1f0b6e6590de76cc33fb0f9e4aeb970070c6877d7b4110f7f3feef0606923184ca79500eedac683e3018ea02cbe4b3a5a52db4727632b09dc3fb313067b62bd12e517ec1b11d536cc3444c5e788693f2331b83a566133fbed7c552edb943c6f69e9f55714fcddf4ab7305517d6153e6845818179a31e60a37c133ee51875a6e5b887352b3380c9fa3064288ab41414602259202abfe80387071028701f60e8349d42744cbad7cd44877527762715b5876663e35b3f2d174788f924bc58d007294824dfc579f04c09ed8763a5ac0926dd89fcc18353e9e7e140517dbb824bc54c3612590ac9e75efd85e6643a00f741005613307f3bd5a8c455d2859dc12ec6c1b203695450328c9dfe9963b81abc44594186906a378474850386d9c6a9b6370c9cba9ad0d1c4e02977f4aebecc0090c5cb9fc35d18edc70bc4b3775df79659203403ae61414701d0d6a087af19149657fe17eac4198a81e9858ef582a1e070e0301c41c982873a8bf25c3c9cc72cef05cd3a5e3e2f7bbd187aa95ba7c57a9da2f4963cb2b62910d2e9075071ccf7aab543980f2d717d1ec0d8aa1755e59acaa1fd4c49e7d3c2efbf5fcee61f887e850c9b8964b98fdfb4e3279b9a2e8ec77d935c765775e7506c654c081d44d5faf2bc9f4ceaecabbc6fa2b9d16db8c0b10f6068517f93d38aad177534f3f31ea8ae47946953b679fdb1859bfbfdbbfa4d4151e406ee6fa021c89e7a945a75563a8333016c6feae51eca1191730a90b815ad36da87b9ee7167d2f14e64b0aea993be5f9a246544ea9545aea4e7752ef14b88a59b6982c76e4889af3236b7e3873d0c227b2bb22e2a6f2c05d767dadb0df2937154e8e09140872365fbcbee276a905579825c2960775fb3eae9673dc71d05326cbaec6fac284f58e98ccd5cdac6f005560e67df2daf7dbc9b9b2312a908ba084b1c5223fc4f162172c9c253deb98893746aeb2e573813e3a8fd1e9027d5100c3043ae527e3cc75d6e8e5364f29fd0b60b9ecaed66c141ece5d75df9110c7654ea418cb8be9072c03df75716838e826273acc6404dc2a7cd0bde84a4adb229c74a3d024e964c94b1a6fd0e22acae339d9b81d03365fc4c7acc82fa5856b3382da38771ddaa8cb5fe04049c2a8c1aa854cbfb8198dcd683347152b433f6dbccb580ca7b93efce2e0489209e7220e1f208b6b34f0e9123e4efa83dc3573e37a9dffc7748dddef25f01d7978e9f13782573606d92b6256bcdbc5fd0672cdc1384f709db6c37bd192765deb45fbf2a1671f5bdd9e2f3689d94f8370ad6bee4a7770f3cbd393309d9436b0a56fda70aa49607cd23f4d43a43e3a146f4c84f136252e5cc9bd162bf85620030761099434a5c6ded87376610e3ff8b91cf4ebb842d44d0b5439e81dba9689ba30779a1bc97441c6d0f769d2dc0d9f5314d860ca4eb0d014e4597ffe53658a86a2c9694d11f2f8d40b2502e007b14a94efc7700bdfd0d7e71506698ae081d8e25c8106a47c4293de6f5c9be729e71a19a9bacbc053cbc4cd8e1ca61394e31eeaf3e4a444bb90f98bbf301cd0ccd5014e3eab2f1215ea5a953f4102c748bf1a6b33a074c4af521a16e346c795590af54f19ba48d1bc5979cf3df25511081924acb9a95e68122f8222712f75cb2ca336db63b711eb7d09cec7bb742038fb8ee0a2191bea9eb2e27cc7c931edae3dfcd5c45e42ae4f77ff64cff8c2c155d2c5fbe9a3d22a3bc0e2ebc5f2284bc4083424992bdbdbcd2276191e8b99c5acbd092079de6a1bc6d554eb64eedee37950a78de1639aea4d9d41fa97e6b0032778c63cf7eef1bd9bb916bd74e952cd3f96f05c32748f712beef9c65f5cd42b9e137a090654f99563c237cc7727f4e3285acaeb013e6bbbbb3c263fa9e47ad75dcfaf4db1774c96a80e7eb644a28f149dd49ea03e729136bce37300e0eb9a440b61e9723d499254eebfe19a47a89232755942f2cc93ddccd74fbf424cace8d65b0220c7570ad90f36e7db4644c6931611d5fcc3b65e33e9f8bd3a676634913b41509d9ff083784d306a7a1a5da12576df4cc6318402a4cbb70d444d4f42f2612ba23016f8dd070b2680d22c6f2a704997ea83f05616aa10101cc7945339a64c75f2182d2f64e86301444e89eef1896fefdd046378269ac428a9fd65667371ce7cae76c59362c02d0cf8320e8d6c53753324b590add9af793908358da55012688dd253b68a855a7945c4f5d172212edb2decb0170b73c22c6e58881611a0e755827510f7b1ce5c770b89dac22fe7a7742ecd4cf6040839895f58b03f89b07f4e42646352e51ac18a82dec51e93ba8c2fb57903d7d5745798ce901b62fbe1faa5a1ec9f7a925fee3ddbfdaa7e53caba2bb9f8969684537a58635ff5851d17a60800e9eeee66fdcf0b548950f81acf9ab99953c5edc893efb10a105564c92bc56843ea15eaede0c6ae43c04935cf06fec38a7ca35d0697f49d21f3be6f836ee0f28d59f28b62b01f6cf81908777a7305c36bfc638afa40055e75ed4f752ef71bebcd61908bc6c6c7191b37715b375df7b09fc9541a9e1ff2aa36226ef528960ac9964db3bf9e5282f6eaf2d6c473596ed2823e3cffcd1c70bbc810e3fc3781c6da51fdeb9d64c565f97d97d562cc71606e30b9f7ead3e51c21bd07d1b8bcf927c752ff3d23470480dc80f0bc406583bfd9e7f3b39a225ddb3b8e3acc40c131c1f3c81a7bc623c4c3d4020d592871c0e31c897ecd7a30987a33d7169510fc7aa7a115937bc91062803ed4c6e3e50b55a9c8a70217d2efcf82b9e397283eabacab37ee0edee64248489e2ed4bdc7b3867a9c4efdf242630b5551ea22d01fa7e16494e1a1126078ec8b12afa7fc47f96926798fab2230fb44c2aaf35ccf8798e978765daf252f63aa2957ca081b82fd67f5cf1a3b896c7fed129a9155e48e0ea73802c68143119ef21e507273f686c3ba74e7903a2d69331bdea3ce8a7889f11d54a11f9c646fafd7ece98c30a594240390dde587676298dd6e5816b789f00cabefe6ca92811770a1ebf77ebf287d9270831c65ea8e06e28088f7162d8f6de6eefcce8a255d5bf7ce73c24556d03ad6e3fa19a57b403707e9d31ac2fbae1216d50eff932cdf0e41f3bf4d3fb41291cc32d3655812f69ac1f443e799efcbe40eb066e16527561822bee337ad8a7674fba0d2edcb866f66e63d3e3f232167d0da5ee2190b3330fba3773ccf3f062cc2febbbcad50dbfb7be0732fb330e79bdfcad241a000bdebd337e6c089cccb50ee141fdc381cf62d278ddd2332baca8076b92f1bc31d7aedf6ddd5fd5cd8934dc1f4574c3f95cb12545502e9d26b7387ee6ce49ef5db8a47dfd091074c02138f650631f71e12797948fcacb9b2fb55234c5105eb13789891c7068866320952c881dd599b2146b1e99bc4bf031c1bf01d49bc551a835f6350a99141664c9d0736df05838b639d3d3a07395f020eed3c69298d54e4015690903a98de94758a21c161750bbeff0122a51b48fb6525a47b7417d3b3ff38a4b8fdff21894cabe9c5f45389ade69471afad5089173ba04517eae727751b5f4abd5e1df0fe5bfbfc03d808bde33d50e8223ec2837a1d6767cedcffa0d5218e744dbaeeb3c921b09bea4220cb56f373663cd6f9f061c1264a1e5767101e60a44ca794e49521170557bf5dae195e57549c8fa63b8bee630ed27d180b46c4ad968953ea6c5757e53b763c7e751dd4475d482463bff6980568e7b8affb4e201754e215ceba8ce61c81ef801c26be196026c26260e5056f0446d20f89cf29474a035d7f875cc6d5151e82591a2ff2b07094f07564f7b3d372188d93f266b2463c75c7a64ce4ead35e6e0ecdcd2def659da1d28c707b4a187af96ae28b6c615d828d6493ab1ea11466323047b266d85030050f3671c22f4261b247f0946bbd66700035ae96580fab4e30027b9545af1cdf3a6a1d747e6290f4fd45cbb1c7403e457e2f1651875a592109acf4f2145cdee6c8e0d453aeeb987029a7b149131ea20b409dd19f551f960e544cd514991bcf19add89d1bd6b57545970fda9c3e02c0e2edbdcbadc7a22ab30751266fa22b9525dbbbdac95ca46b5cbd204e85fe03b3b9c91f931bd222e1ccc6eae0734981009284b61015003f2ced2a8cd773b3577822f1b05c07376387cfde27609c4b687aca1dae6d214ffc9f2e71becc9fed32760e53608fa432f44df0da69290d42fe8cef462f3ec35b28a4bfabb3da9a829198f510711201787e9db771cf38c5da7ad28554867d5364ce812d22ff78156a652ba588f4074c792856da342caefdc904eb7eb80550d410abd506b044761fc027f92f92a5db892d20de7a3a0d512b49c139bcb0e67d86a9a7106be9c29f81c68e8a852b77e8177a21104e11d88440ad5a5ae5ae2b70bcd3573bb5d9f7b40c81e899ab182f0c54f8672571b61f8d82078235c89befee3a3dbd3a034d3dce60cdba21872f50f07c2957d201c8d638ba60fb795a5ec21c19e0d44e6dad8aef8c04074637d5d42c2fa7eecd6050916c8eeeedb642a0721905222ec5f02ebf90b7aba2037574ebaa7aacd2b18458b30ae9ed8be59897a392697680d42c443ea27a2384bc483532d5ec00339f086f4d72a91ca4c7075ee5148b506cf0b9f126a841e8]]></content>
      <categories>
        <category>神秘研究</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unreal 导入 FBX 选项事项]]></title>
    <url>%2Fposts%2F4ad87fc3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;由于工作的关系，对接引擎就会遇到很多导入导出的问题，这里总结一波。 动画勾选 step &emsp;&emsp;动画导入到虚幻的时候务必要勾选 step&emsp;&emsp;否则动画读取小数位的关键帧会有抖动的问题。 绑定导入 &emsp;&emsp;绑定导入到虚幻的时候通常都需要将 normal 的切换为 imported normal&emsp;&emsp;否则一些特殊修改的法线信息就不会导入了 Use T0 As Ref Pose &emsp;&emsp;关于 Unreal 绑定导入最坑爹的属性莫过于这个了&emsp;&emsp;关于这个属性相关的问题几乎无法在网上找到相关的描述&emsp;&emsp;而官方文档的介绍也只是说会将模型动画的第一帧作为绑定 pose&emsp;&emsp;但是在实际流程中，这个选项勾选和不勾选会导致很多很奇怪的问题。 &emsp;&emsp;有时候 Maya 导出的绑定文件会导致动作产生奇奇怪怪的错位。&emsp;&emsp;比如某些骨骼会莫名其妙地偏转了一定的度数。&emsp;&emsp;但是神奇的是将 FBX 导回 Maya 查看是一切正常的。&emsp;&emsp;然而如果勾选 Use T0 As Ref Pose 选项就可以解决问题 &emsp;&emsp;本来以为勾选就万事大吉了，可是后来有出了差错。&emsp;&emsp;如果勾选 Use T0 As Ref Pose 有时候会导致法线的显示异常。&emsp;&emsp;而且只会对 imported 的法线产生问题，如果是 computed 的法线则显示正常。 &emsp;&emsp;结果是两个问题无论是否勾选都会出问题。 动作错位 &emsp;&emsp;后来折腾了好久也没有解决方案，只好求救于我的导师了。&emsp;&emsp;关于 Pose 的问题，我导师很快就给出了一针见血的解决方案。&emsp;&emsp;原来这个问题和 Maya 绑定的 bindpose 有关，有可能是绑定文件修改过多导致产生多个 BindPose&emsp;&emsp;bindpose 直接不匹配就有可能导致偏移问题。 &emsp;&emsp;解决方法也很简单，只需要将这些 bindpose 全部删除掉，重新生成一个新的 bindpose 就可以了。&emsp;&emsp;这个操作也不影响到绑定和权重，非常方便。&emsp;&emsp;bindpose 的生成可以选择模型执行 Maya 的 mel 命令 1dagPose -bp -save 法线错乱 &emsp;&emsp;最初按照上面的方法的确解决了pose的问题，因此法线错乱的问题也就放在一边没有管了。&emsp;&emsp;不过按照导师的说法就是尽量不要勾选 Use T0 As Ref Pose &emsp;&emsp;可是后来就出现了完全反过来的情况。&emsp;&emsp;也就是勾选 Use T0 As Ref Pose 的话法线是正常的，但是如果不勾选的话 法线 是错乱的。&emsp;&emsp;于是我又测试了好久，期间尝试对重新绑定等操作。&emsp;&emsp;于是我中间的测试过程中，尽管中间过程中有些错误的操作，但是重新绑定的模型导入到引擎就好了。&emsp;&emsp;于是我就把完善的后续工作交给外包处理，等重新绑定完成了之后再放到引擎测试。&emsp;&emsp;结果回来的模型还是错乱的。&emsp;&emsp;于是我人都傻了，为啥我之前简单的测试是可以的呢？&emsp;&emsp;于是我自己完善了一边导出流程，结果发现自己导出的也是有问题的。 &emsp;&emsp;于是我又对比了之前那个不完善版本的区别，最后发现模型有转了 90 度的区别。&emsp;&emsp;这边绑定模型都是默认转了 90 度对接到引擎里面的。&emsp;&emsp;而这个模型我把他旋转到 0 度导入到引擎就是正确的法线效果了。 &emsp;&emsp;这个法线让我目瞪口呆了，后来咨询了绑定外包之后。&emsp;&emsp;得出大概是模型没有锁定法线导致的。&emsp;&emsp;的确模型的法线是特殊修改过的，而且不可以在 90 度的状态下锁定，必须要在 Maya 的 0 度状态下锁定法线。&emsp;&emsp;然后再旋转回 90 度，这样子导出的模型就不会有奇奇怪怪的法线问题了。 总结 &emsp;&emsp;没想到虚幻的导入会涉及到这些问题。&emsp;&emsp;特别是 Use T0 As Ref Pose 这个选项居然会影响到法线。&emsp;&emsp;不过都还好，问题最后都顺利解决了。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠃUnreal</tag>
        <tag>🇨🇬CG/FBX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python future-fstring库 原理解析]]></title>
    <url>%2Fposts%2F595dd86f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;很找之前我就发现了一个 python 黑科技一样的库，没错就是兼容 python2 的 future-fstrings 实现&emsp;&emsp;这个库的使用方法也是奇妙得很。 123# -*- coding: future_fstrings -*-thing = 'world'print(f'hello &#123;thing&#125;') &emsp;&emsp;只要正确安装了 future-fstrings 就可以通过 coding 的方式来兼容 python3 才可以使用 f-string&emsp;&emsp;而且这个黑科技居然没有用到 C 语言的支持，完全依靠原生 python 实现的。&emsp;&emsp;打开 future-fstrings 的主脚本也不到 300 行的代码&emsp;&emsp;到底是怎么做到的呀~ future-fstrings 主脚本探索 &emsp;&emsp;打开 github 仓库可以看到除了 setup.py 用来安装的脚本之外，主脚本就只有一个 future-fstrings.py&emsp;&emsp;一开始我都把目光关注到了 main 函数上了。&emsp;&emsp;然而 main 函数貌似只是个命令行调用工具，如果在 python 中直接运行这个脚本是会报错的，要求我传入参数。&emsp;&emsp;很显然脚本不应该是怎么用的。&emsp;&emsp;于是我继续往上面代码翻阅， 123456789101112131415161718192021222324fstring_decode = decodeSUPPORTS_FSTRINGS = _natively_supports_fstrings()if SUPPORTS_FSTRINGS: # pragma: no cover decode = utf_8.decode # noqa IncrementalDecoder = utf_8.incrementaldecoder # noqa StreamReader = utf_8.streamreader # noqa# codec apicodec_map = &#123; name: codecs.CodecInfo( name=name, encode=utf_8.encode, decode=decode, incrementalencoder=utf_8.incrementalencoder, incrementaldecoder=IncrementalDecoder, streamreader=StreamReader, streamwriter=utf_8.streamwriter, ) for name in ('future-fstrings', 'future_fstrings')&#125;def register(): # pragma: no cover codecs.register(codec_map.get) &emsp;&emsp;我发现这里运行的代码其实都是一些常亮的声明，并没有找到脚本的入口函数的位置(:з」∠)&emsp;&emsp;并且上面的字典运用也是震惊到我了，没想到 python 的字典还可以这么写的。&emsp;&emsp;这么写获取到的 codec_map 打印出来如下 12print codec_map&#123;u'future-fstrings': &lt;codecs.CodecInfo object for encoding future-fstrings at 0x266d888&gt;, u'future_fstrings': &lt;codecs.CodecInfo object for encoding future_fstrings at 0x2cba4c8&gt;&#125; &emsp;&emsp;这个操作不仅仅是给字典赋予了 key 值， key 值还传入到 CodecInfo 的类声明参数里面。&emsp;&emsp;可以通过这个方法快速生成不同传参的实例 &emsp;&emsp;好的，我们差点扯远了，目前需要找到的 future-fstrings 的入口函数&emsp;&emsp;然而只是从主脚本来看除了 main 函数之外就没有其他入口函数了。&emsp;&emsp;后来我仔细阅读 future-fstrings 的 readme 文档，里面提到 A .pth file which registers a codec on interpreter startup.&emsp;&emsp;这个 .pth 文件是什么东西来的呢？&emsp;&emsp;于是网上查了一下，原来这个 .pth 文件里面存储的 python 代码可以在 python.exe 运行的时候立刻执行，&emsp;&emsp;通过这个方法可以实现一些函数的初始化。 &emsp;&emsp;不过 github 仓库里面并没有 .pth 的文件，于是我去看了 setup.py 的代码&emsp;&emsp;果然找到了 python 代码生成 .pth 的代码 12345678PTH = ( 'try:\n' ' import future_fstrings\n' 'except ImportError:\n' ' pass\n' 'else:\n' ' future_fstrings.register()\n') &emsp;&emsp;也可以去到 python 的 site-packages 可以找到名字为 aaaaa_future_fstrings.pth 的文件 (这名字起得也是够随意的) 1import sys; exec('try:\n import future_fstrings\nexcept ImportError:\n pass\nelse:\n future_fstrings.register()\n') &emsp;&emsp;现在就找到入口的代码了，每当 python.exe 运行的时候都会执行 register 方法的 12def register(): # pragma: no cover codecs.register(codec_map.get) &emsp;&emsp;而 register 方法执行的是 codecs.register 方法，这个貌似是定义了一个新的编码格式。 codecs 库研究 &emsp;&emsp;codecs 库 python 原生的字符编码处理库，查阅了官方文档可以知道python支持自定义编码的扩展的。&emsp;&emsp;不过具体要怎么使用，还是得找 Stack Overflow 来解决。 链接 &emsp;&emsp;Stack Overflow 的代码是针对 python3 写的，我改写了一个 python2 的版本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import codecsimport string# NOTE https://stackoverflow.com/questions/38777818/how-do-i-properly-create-custom-text-codecs# prepare map from numbers to letters_encode_table = &#123;str(number): bytes(letter) for number, letter in enumerate(string.ascii_lowercase)&#125;# prepare inverse map_decode_table = &#123;v: k for k, v in _encode_table.items()&#125;def custom_encode(text): # example encoder that converts ints to letters # see https://docs.python.org/3/library/codecs.html#codecs.Codec.encode return b''.join(_encode_table[x] for x in text), len(text)def custom_decode(binary): # example decoder that converts letters to ints # see https://docs.python.org/3/library/codecs.html#codecs.Codec.decode return ''.join(_decode_table[x] for x in binary), len(binary)def custom_search_function(encoding_name): return codecs.CodecInfo(encode=custom_encode, decode=custom_decode, name='Reasons')def main(): # register your custom codec # note that CodecInfo.name is used later codecs.register(custom_search_function) binary = 'abcdefg' # decode letters to numbers text = binary.decode('Reasons') print(text) # 0123456 # encode numbers to letters binary2 = text.encode('Reasons') print(binary2) # abcdefgif __name__ == '__main__': main() &emsp;&emsp;通过上面的例子就可以自定义自己的编码处理方式，将字符串转换成其他的字符串。&emsp;&emsp;通过 encode 将字符神奇地转换为了数字的形式。 &emsp;&emsp;通过这个简单的例子我们可以大致窥探到 future-fstrings 的实现原理。&emsp;&emsp;我们也可以用下面的例子来验证我们的想法。 1234text = "world"fstring = 'f"hello &#123;text&#125;"'.decode('future-fstrings')print fstring# "hello &#123;&#125;".format((text)) &emsp;&emsp;可以看到 future-fstrings 其实就是将 f-string 形式的代码转换为了 format 的方式。&emsp;&emsp;所以 futre-strings 毕竟是没有使用 C 语言的方式实现，运行效率肯定不可能达到 python3 的速度了。&emsp;&emsp;但是能够实现代码转换的方式也着实让我震惊不已。 &emsp;&emsp;我之前研究过 pdb 代码追踪的过程，我知道如果是在 pyc 之类的文件上是实现不了源码的追踪的(除非源码还放在pyc的同级目录下)&emsp;&emsp;因为 pyc 已经转换为了 python 的字节码，可以通过 dis 库看到里面类似汇编语言的操作。&emsp;&emsp;于是我就开始疑虑，这种字符替代的方式是需要读取源码的，那恐怕 pyc 文件里面就不奏效了。 &emsp;&emsp;然而我测试了官方的 coding 放在开头的用啊，future-fstrings 完全可以在 pyc 里面使用，不受影响。&emsp;&emsp;于是我就开始好奇了，全局代码替换的方式是怎么实现的。 coding声明 全局替换的实现 &emsp;&emsp;最初我是打算使用断点测试研究 coding声明 设置背后的原理的&emsp;&emsp;但是这个 coding声明 必须放到最上面根本就没办法启动 pdb&emsp;&emsp;不过使用 encode 方式的话倒是可以通过 pdb 追踪到 future-fstrings 的脚本。&emsp;&emsp;代码会自己执行到 decode 函数中并且将相关的字符串传到 函数的 参数里&emsp;&emsp;于是我还是用传统的 print 方式测试打印&emsp;&emsp;然后就一目了然了。 &emsp;&emsp;如果添加了头声明，decode 传入了整个文件的源码。&emsp;&emsp;然后future-strings 用各种字符的操作将所有的 f-string 转换为了 python 的 format 字符处理形式。&emsp;&emsp;然后编码转换过程结束了之后， python 才会编译源码进行执行。&emsp;&emsp;这也解释了为啥 pyc 执行不受影响。&emsp;&emsp;因为 pyc 文件里面封存的是字节码也就是先完成了 编码 之后再编译出来的。&emsp;&emsp;所以通过 pyc 执行的时候，即便用于编译的 py 文件是有 coding 声明的 ，但是 pyc 却不会触发到 future-fstrings 的 decode 函数。 &emsp;&emsp;这个就是 future-fstrings 的原理~ 总结 &emsp;&emsp;的确理解了 codec 的方式之后，通过 codec 可以实现很多黑科技，毕竟是直接对源码进行的操作。&emsp;&emsp;而且通过 python 逻辑可以知道 pyc pyd 等等编译方案都不受影响的。&emsp;&emsp;唯一的缺点就是 python 的 coding 只能接受一个，如果使用了 future-fstrings 的编码就意味着无法使用其他的编码格式了。 &emsp;&emsp;另外利用类似的黑科技的还有 dropbox 公司开发的 pyxl&emsp;&emsp;也是通过 coding 的方式让 python 支持 html 代码的嵌入]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Reference Edit 属性清理]]></title>
    <url>%2Fposts%2F864bfe61.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;你永远也不知道制作人员会对软件做出怎样的操作，这次我就遇到了坑爹的问题。&emsp;&emsp;制作人员居然在引用的文件上进行了了各种模型处理的操作。&emsp;&emsp;结果导致UV乱了，源模型无法更新到引用的文件里面。&emsp;&emsp;因此我就要想办法来收拾这些烂摊子。 &emsp;&emsp;引用文件的大小通常不会很大的，因为里面只记录相关的关键帧信息，尽管 maya 可以进行模型编辑，但也绝对不推荐这种操作。&emsp;&emsp;结果导致这个引用文件居然有 100+ M&emsp;&emsp;于是我就想尽办法来解决这个问题。 解决方案 &emsp;&emsp;遇到这个问题其实也可以通过上面的方法进入到 reference 内部然后查看所有的编辑信息的。 &emsp;&emsp;当然也可以将 文件 保存为 ma 也可以看到模型的编辑信息 &emsp;&emsp;但是由于数据量过于庞大，这个操作非常卡顿，而且这中间掺杂了很多额外编辑信息还需要逐一过滤。&emsp;&emsp;于是我要想办法用代码来清理这里的操作命令。 基于 mel 命令找到 Maya 的操作逻辑 &emsp;&emsp;首先还是得从 mel 命令的执行开始入手研究怎么操作。&emsp;&emsp;从 reference 窗口的 GUI 界面可以快速在 Maya 自带的 scripts 目录下找到脚本的位置。&emsp;&emsp;可以直接搜索 List Reference Edits … 可以直接搜索出 referenceEditorPanel.res.mel 脚本&emsp;&emsp;通过 res 可以定位到这个语句对应的变量是 m_referenceEditorPanel.kItemListReference&emsp;&emsp;再通过这个变量去搜索 referenceEditorPanel.mel 就可以很快定位到 右键菜单执行的功能代码了 (Maya2017 在 referenceEditorPanel.mel 198 行) 123456menuItem -label (uiRes("m_referenceEditorPanel.kItemListReference"))-annotation (uiRes("m_referenceEditorPanel.kListModifications"))-command ("string $referenceFile[] = `sceneEditor -q -si $gReferenceEditorPanel`;" + "referenceEditsWindow $referenceFile[0] false;")listEditsToReference; &emsp;&emsp;这个脚本就是 Reference 编辑面板生成的 mel 脚本。&emsp;&emsp;可以看到这里通过 $gReferenceEditorPanel 获取到了 reference 面板，从而获取到面板上显示的文件路径。&emsp;&emsp;下面就是 referenceEditsWindow 命令的代码查阅。 &emsp;&emsp;这部分的代码又可以在 referenceEditsWindow.mel 这个文件中找到。(Maya2017 在 referenceEditorPanel.mel 433 行)&emsp;&emsp;到了这里进一步查阅代码逐渐就可以找到 reference 去除编辑的按钮的功能代码了。 1234567891011string $refreshButton = `button -label (uiRes("m_referenceEditsWindow.kRefreshEdit")) ($window + "_refreshButton")`;string $removeButton = `button -label (uiRes("m_referenceEditsWindow.kRemoveEdit")) ($window + "_removeButton")`;button -edit -command ($windowRefreshCmd) $refreshButton;button -edit -command ("referenceEditsWindowRemoveSelectedEdits \"" + ($referenceFile) + "\" " + ($referenceNode) + " " + ($textScrollList) + " " + ($queryCmdString) + " " + ($unknownEdits) ) $removeButton; &emsp;&emsp;上面的 refreshButton removeButton 是不是很熟悉了。 &emsp;&emsp;已经是对应到了上图下方的两个按钮了。&emsp;&emsp;而删除编辑的按钮已经找到了调用的代码，执行的是 referenceEditsWindowRemoveSelectedEdits 命令&emsp;&emsp;于是我又去进一步研究这个 referenceEditsWindowRemoveSelectedEdits 命令调用逻辑是怎样的。 &emsp;&emsp;由于这个函数的名字很长，可以很轻松地在同一个文件下找到这个函数的调用 (Maya2017 在 referenceEditorPanel.mel 49 行) 12345678// 省略无数代码string $cmd = "referenceEdit -failedEdits true ";$cmd += "-successfulEdits true -editCommand ";// 省略无数代码evalEcho($cmd); &emsp;&emsp;可以看到 mel 的主要在这里调用了 底层的 referenceEdit 的命令来实现的。&emsp;&emsp;于是又可以去查 Maya 的命令文档查看相关的命令是怎么实现的了。 文档&emsp;&emsp;其实从 mel 的去除功能也可以看到这里的删除处理是非常繁琐的。&emsp;&emsp;后面我花了一些时间将这些 mel 代码转成了 python 来写。&emsp;&emsp;可以参考 github &emsp;&emsp;当然上面的脚本其实在实际运行起来还有很多问题，我当时运行的时候最大的问题就是运行效率极其缓慢。&emsp;&emsp;由于文件的修改信息都达到 100+ M， ma 文件也是几十万行的量级，所以我等了大概1个小时才遍历完。&emsp;&emsp;因此在遍历的过程中，我直接就开始着手用 OpenMaya 来提高运行效率了。 OpenMaya 处理 reference edit &emsp;&emsp;这次查询了 OpenMaya1.0 的命令，没想到发现了个有意思的MitEdits 遍历器&emsp;&emsp;通过这个就可以快速遍历引用的 edit 操作，也可以对 assembly reference 起作用。 &emsp;&emsp;通过上面的遍历器就可以快速遍历引用节点里面的操作然后批量去掉无关的处理。&emsp;&emsp;遍历器的使用参考 github &emsp;&emsp;上面是我经过改良的版本，原本是想通过 OpenMaya 来清理掉 edit 的，但是貌似只有遍历器有 removeCurrentEdit 的方法&emsp;&emsp;然而这个方法需要加载的 reference 的才可以使用。&emsp;&emsp;如果要在不加载的 reference 的情况下清理掉 edit 貌似就只有通过 cmds.referenceEdit 的方法，这样清理速度还是比较慢(:з」∠) 总结 &emsp;&emsp;通过上面的方法可以清理掉大部分 reference edit ，但仍不可避免地还是有很多操作需要人工处理。&emsp;&emsp;第一次接触 MitEdits 遍历器还是挺有趣的~]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya插件 - collapsableShelf]]></title>
    <url>%2Fposts%2F204db704.html</url>
    <content type="text"><![CDATA[更新 2020-5-27 &emsp;&emsp;这个工具会破坏 Maya 的工具架机制，无法中键拖拽图标，修改图标，而且一不小心就导致图标数据丢失。&emsp;&emsp;推荐使用第三方的工具架 SiShelf 源github链接 前言 &emsp;&emsp;最近工作上，动画制作人员都想要更好地管理工具架上的图标。&emsp;&emsp;他们突发奇想给我提了个需求 ， 希望让 Maya 的工具架有类似于 StatusLine 上面那样有伸缩功能。&emsp;&emsp;我想了一下，如果通过 Qt 的骚操作的未必不能实现。&emsp;&emsp;于是我就愉快地接受了挑战。 github 仓库 前期研究 &emsp;&emsp;由于工具架的数据是会报错到本地 mel 文件里面去的。&emsp;&emsp;因此如果我自己添加一个可以收缩的组件的话会影响到 工具架 的按钮存储的。&emsp;&emsp;因此需要用现有的widget来转成可伸缩的效果。 &emsp;&emsp;最初我是想到要写一个新的 mel runtimeCommand 的形式生成一个带layout的组件，后续的伸缩可以转成 Qt 来实现。&emsp;&emsp;但是这样就需要改写 工具架的 mel 脚本 ， 还是不够方便。&emsp;&emsp;于是我注意到了 工具架的一些分隔图标。&emsp;&emsp;在 Maya 里面是无法通过 工具架 的编辑器进行添加的。&emsp;&emsp;不过可以通过修改 用户文档的 pref/shelves 里面的mel来实现 separator 的添加。 遇到的问题 &emsp;&emsp;于是我就开始着手写方案。&emsp;&emsp;其实整个流程我之前都有所接触过了，因此主要的框架搭建起来算是驾轻就熟。 工具架加载问题 &emsp;&emsp;之前开发 commandLauncher 的时候踩过 工具架 的坑。&emsp;&emsp;Maya默认是不会加载所有的工具架的，只会加载当前显示的工具架，这样就导致无法获取工具架上的图标信息。&emsp;&emsp;我之前开发 commandLauncher 的时候就已经弄了一个 自动加载所有工具架的函数。&emsp;&emsp;于是这里可以直接套用毫无问题。 伸缩组件搭建 &emsp;&emsp;我之前在 开发 QtLib (或者说更早的时候)，就已经弄好了一个 Collapsible 组件。&emsp;&emsp;效果是带动画的。&emsp;&emsp;这里的伸缩效果也是参考当时的效果进行修改开发，不过是纵向改为了横向。 &emsp;&emsp;当然这个过程中遇到了一些伸缩的坑，特别是一开始不知道要给主组件添加宽度。&emsp;&emsp;导致添加进去的图标都挤在了一起，后面通过 setFixedWidth 解决了问题。 添加工具选项 &emsp;&emsp;我一开始也是打算类似于 commandLauncher 一样在 StatusLine 上添加一个 图标 进行提示的。&emsp;&emsp;后来还是打算添加到 工具架 的 option 按钮上了，这样更加合乎道理。 &emsp;&emsp;在原先的 menu 基础上添加 选项其实不难， 直接用 cmds 库也可以解决。 * 程序退出卸载功能 &emsp;&emsp;这个功能就非常坎坷了。&emsp;&emsp;上面的功能虽然完美，但是一旦影响到了整个工具架的 mel 文件信息就完蛋了。&emsp;&emsp;而且由于用了 Qt 的骚操作，那些可以伸缩的组件全部无法被 Maya 识别出来了。&emsp;&emsp;如果是以伸缩组件的形式推出 Maya 会导致这些伸缩部分的图标丢失的。 &emsp;&emsp;所以为了避免这个情况，我需要在 Maya 推出保存 shelf 的时候触发一个事件来还原工具架。&emsp;&emsp;我最初想到的是通过 scriptJob 的事件来完成这个操作。&emsp;&emsp;去看了 scriptJob 的文档，果然发现了 quitApplication 的事件。&emsp;&emsp;于是我用了测试代码如下 123import sysfrom maya import cmdscmds.scriptJob(runOnce=1,event=['quitApplication',lambda:sys.stdout.write("quit")]) &emsp;&emsp;但是经过我的测试，上述的命令是无法在Maya的脚本编辑器看到输出的。&emsp;&emsp;于是为了验证这个事件是否触发了，我又单独写了一个文件读写的操作，&emsp;&emsp;这样我就可以通过查看目标文件有没有写入我预期的数据来确定程序是否触发。 &emsp;&emsp;经过一番折腾，我的确可以通过 IO 操作看到程序是触发了的，但是再这个阶段运行卸载程序似乎已经没有意义了。&emsp;&emsp;Maya已经完成了保存 mel 的操作。 &emsp;&emsp;于是我开始寻找更好的触发条件，最开始我想到了 OpenMaya 的 Message 相关的类。&emsp;&emsp;我之前也有接触过，可以参考我的文章 Maya 轴心移动研究 &emsp;&emsp;于是我又查了一下，在 OpenMaya2.0 的 MEventMessage 里面的确找到了退出事件。&emsp;&emsp;然而这个事件本质上和 scriptJob 是一样的，也是 quitApplication &emsp;&emsp;最后又折腾了一番之后，感觉 Maya 的确没有提供一个退出之前执行的勾子。&emsp;&emsp;于是没办法了，只好抓住最好的救命稻草，通过 Qt 的 eventFilter 来获取退出事件。&emsp;&emsp;但是 Filter 出来的事件太多，而且程序退出的时候并不是所有的事件都可以显示到 脚本编辑器 里面的。&emsp;&emsp;于是我就改写为每获取一个事件就进行一个 IO 操作将数据输出到 txt 文本里面。&emsp;&emsp;综合上面的显示的事件列表，我发现每次退出最后执行的事件类型都是 ChildRemoved&emsp;&emsp;当然如果点击右上角的关闭按钮还有 Close 的事件触发，这个事件感觉更为准确，但是如果是在 菜单 里面点击退出的则没有触发 Close&emsp;&emsp;但是 ChildRemoved 每次都能触发出来。&emsp;&emsp;于是我抱着最后的希望在 ChildRemoved 事件下触发 uninstall 事件。&emsp;&emsp;然后就成功解决了目前的问题了，无论是用什么形式的退出，都可以还原 工具架 而不会导致图标丢失。 2020-3-21 更新 &emsp;&emsp;后来我网上查了一下，发现 QCoreApplication 有 aboutToQuit 的信号槽&emsp;&emsp;可以通过这个信号槽在程序退出的时候触发相应的函数。&emsp;&emsp;虽然触发的时候，工具架已经存档了一次了。&emsp;&emsp;但是没有关系，我可以还原工具架然后再保存一遍就不会有问题了。&emsp;&emsp;这个方案就不会导致一些意外误触的情况。 总结 &emsp;&emsp;这次开发感觉有之前的研究铺路，明显要踩的坑少了很多了。&emsp;&emsp;后续还需要完善一下 github 仓库的说明 ， 还有 UI 的美化也可以考虑一下的。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 工具开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python DCC 嵌入 浏览器 探索]]></title>
    <url>%2Fposts%2Fd2b44b01.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近打算开发一个 DCC 间共同的资源浏览器，计划通过 WebGL 实现三维视窗的效果。&emsp;&emsp;Maya 内置的 PySide2 是可以构建浏览器的。&emsp;&emsp;但是对 WebGL 的支持非常糟糕 ，那么就需要嵌入一个通用的的三维浏览器窗口来实现。 &emsp;&emsp;即便是 maya 之外的环境实现的 PyQt WebEngine 实现的效果都不太理想，比如 threejs 官方编辑器会没有显示白屏。 &emsp;&emsp;于是我就开始想如何如何才能更好地将浏览器嵌入到 DCC 软件中，从而让前端技术可以引入进去。 &emsp;&emsp;欢迎到我的 github 仓库 CefWidget上查看嵌入的源码 技术选型 &emsp;&emsp;虽然 PyQt 的 WebGL 似乎有点问题，但是基础的一些显示起码是可以用的。&emsp;&emsp;但是要将 Maya 外部的 Python 跑起来的话需要解决将外部第三方的窗口嵌入到 Maya 窗口里面的问题。&emsp;&emsp;我看了网上大部分的解决方案都需要获取 窗口 hwnd 也就是 不同系统下的窗口 ID 然后只能通过 Qt5 的方案来嵌入。 QWindow.fromWinId()&emsp;&emsp;首先获取 hwnd 还没有多平台兼容的方案，而且由于只有Qt5支持嵌入，所以 Qt4 无法兼容了。 &emsp;&emsp;后来我也尝试在 Maya 嵌入 winId 的，但是无法直接传入整形数，可能还需要一些 ctypes 或者 shiboken 转换方案。&emsp;&emsp;太麻烦了我就没有找解决方案。&emsp;&emsp;而且第三方软件接入的痛点在于完全独立于目前运行的程序，如果软件本身没有开放的接口就无法调用了。&emsp;&emsp;所有的 UI 程序都是一个不断监听进行事件处理的死循环，即便是 Qt 嵌入 Qt 两头都是源码清楚的情况下也无法交互。&emsp;&emsp;因为两者的事件监听是不共通的，这边 Qt 窗口的信号无法在另一头的 Qt 窗口上触发。&emsp;&emsp;所以就导致修改窗口大小不同步，点击按钮无法触发另一个窗口的事件诸如此类的问题。 &emsp;&emsp;后来我转换思路，不再搜索嵌入第三方窗口，而是嵌入浏览器，反而是开阔了很多。&emsp;&emsp;其中就找到了很好的一个方案，那就是 CEF。&emsp;&emsp;CEF 全称是 Chromium Embeded framwork, 因此就是针对 Chromium 谷歌浏览器内核的嵌入第三方的框架&emsp;&emsp;并且 github 上还可以找到 cefpython 库实现了 CEF 框架的 python 绑定。 &emsp;&emsp;看了一下官方的那里，不仅仅支持 Qt ，很多 Python 的图形化框架都是支持嵌入的，而且嵌入的方式是获取 Qt 的 winId ， 背后的跨平台嵌入操作由框架完成&emsp;&emsp;因此我就决定使用 cefpython 方案了。 cefpython &emsp;&emsp;由于 cefpython 是由 C++ 绑定过来的，因此就不用想在 maya 这些软件上面调用了，不可能兼容的。&emsp;&emsp;当然有源码或许可以用 mayapy 重新编译一个针对 Maya 版本的 cefpython ，但是这样跨软件兼容的实现就失败了。&emsp;&emsp;因此一定要活用 cef 框架自带的嵌入功能，以第三方的形式嵌入到 Qt 的 Widget 里面。 cefpython 使用 &emsp;&emsp;在研究如何使用 cefpython 之前还是需要了解清楚这个库是怎么使用的。&emsp;&emsp;网上可以找到国内的一些文章 12345678910from cefpython3 import cefpython as cefimport platformimport sysdef main(): cef.Initialize() cef.CreateBrowserSync(url="http://www.baidu.com",window_title="Hello World!") cef.MessageLoop() cef.Shutdown()if __name__ == '__main__': main() &emsp;&emsp;运行 pip install cefpython3 安装库之后就可以调用了。&emsp;&emsp;我去掉了上面的版本检测，让代码看起来更加简单一些。 &emsp;&emsp;上面的例子就是个 hello world 例子而已。&emsp;&emsp;那么如何才能将 浏览器 嵌入到 Qt 的窗口当中呢？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import sysimport osimport ctypesfrom PySide.QtGui import *from PySide.QtCore import *from cefpython3 import cefpythonclass CefWidget(QWidget): browser = None def __init__(self, parent = None): super(CefWidget, self).__init__(parent) self.show() self.createTimer() def createTimer(self): self.timer = QTimer() self.timer.timeout.connect(self.onTimer) self.timer.start(10) def onTimer(self): cefpython.MessageLoopWork() def embed(self): # it needs to be called after setupping the layout, windowInfo = cefpython.WindowInfo() windowInfo.SetAsChild(int(self.winIdFixed())) self.browser = cefpython.CreateBrowserSync(windowInfo, navigateUrl="https://blog.l0v0.com/my_work/OPENGL_homework/old_Method/") def winIdFixed(self): # PySide bug: QWidget.winId() returns &lt;PyCObject object at 0x02FD8788&gt;, # there is no easy way to convert it to int. try: return int(self.winId()) except: if sys.version_info[0] == 2: ctypes.pythonapi.PyCObject_AsVoidPtr.restype = ctypes.c_void_p ctypes.pythonapi.PyCObject_AsVoidPtr.argtypes = [ctypes.py_object] return ctypes.pythonapi.PyCObject_AsVoidPtr(self.winId()) elif sys.version_info[0] == 3: ctypes.pythonapi.PyCapsule_GetPointer.restype = ctypes.c_void_p ctypes.pythonapi.PyCapsule_GetPointer.argtypes = [ctypes.py_object] return ctypes.pythonapi.PyCapsule_GetPointer(self.winId(), None) def moveEvent(self, event): cefpython.WindowUtils.OnSize(int(self.winIdFixed()), 0, 0, 0) def resizeEvent(self, event): cefpython.WindowUtils.OnSize(int(self.winIdFixed()), 0, 0, 0)class MainWindow(QMainWindow): def __init__(self, parent = None): super(MainWindow, self).__init__(parent) self.setGeometry(150,150, 800, 800) self.view = CefWidget(self) m_vbox = QVBoxLayout() m_label = QLabel("Another Widget") m_label.setMaximumHeight(100) m_vbox = QVBoxLayout() m_vbox.addWidget(m_label) m_vbox.addWidget(self.view) frame = QFrame() frame.setLayout(m_vbox) self.setCentralWidget(frame) self.view.embed()if __name__ == "__main__": settings = &#123;&#125; settings["browser_subprocess_path"] = "%s/%s" % ( cefpython.GetModuleDirectory(), "subprocess") settings["context_menu"] = &#123; "enabled": False, "navigation": False, # Back, Forward, Reload "print": False, "view_source": False, "external_browser": False, # Open in external browser "devtools": False, # Developer Tools &#125; cefpython.Initialize(settings) app = QApplication(sys.argv) win = MainWindow() win.show() app.exec_() &emsp;&emsp;没错主要是通过 ctypes 转换 self.winId 的方法来获取窗口的整数 ID&emsp;&emsp;后面只需要将 id 传入到 SetAsChild 方法里面就可以实现嵌入了。&emsp;&emsp;需要注意的是需要用定时器来 MessageLoopWork 的方法来不断同步浏览器的状态。 &emsp;&emsp;上面的例子还只是个简化版的嵌入，更进一步的多平台兼容可以参照官方提供的 qt.py cefpython 打包 &emsp;&emsp;当然上面的例子是无法在 DCC 软件里面跨平台使用的，因此需要通过 pyinstaller 打包成可执行的 exe 文件。&emsp;&emsp;好在官方提供了 cefpython 用 pyinstaller 打包的例子&emsp;&emsp;不过由于要打包自己的脚本还需要修改一下 spec 文件里面定位的编译源代码路径。&emsp;&emsp;并且我自己打包测试的时候出了一些 Bug 打包失败，发现 hook-cefpython3.py 的输出路径缺少了个 “.” &emsp;&emsp;另外编译的时候虽然是直接运行 pyinstaller.py 文件，但是命令行运行路径必须要切换到当前脚本的目录，否则就无法找到 hook-cefpython3.py 脚本。&emsp;&emsp;我上传到 github 的仓库已经修复了这个问题。 &emsp;&emsp;打包完成之后会有 100 多M那么大(:з」∠)&emsp;&emsp;其中主要是 libcef.dll 这个就有 90+M 的大小，没办法这个就是使用 cef 的代价。 rpyc 通信 &emsp;&emsp;成功打包之后的确可以实现浏览器嵌入到任意的 Qt 窗口了。&emsp;&emsp;但是正如我在技术选型上提到的，组件是完全独立，如何解决两个窗口之间的通信问题就很关键。&emsp;&emsp;最原始的方法其实可以通过本地的 IO 操作，不过网上查了资料之后还是用了 socket 端口的方案。&emsp;&emsp;轮子是不可能自己去造的，于是就用了现成的 rpyc 方案，实现 python 程序的相互通信。&emsp;&emsp;而且 rpyc 没有 C 相关的调用，以你可以再不同的平台下通用。 &emsp;&emsp;原本是打算将 rpyc 和 浏览器 两者的调用合并到一起的。&emsp;&emsp;但是问题就来了， rpyc 也会开启一个死循环进行监听，这和 浏览器 的事件调用冲突了。&emsp;&emsp;所以没办法，最后也将 rpyc 的 server 单独分离出来调用。 &emsp;&emsp;由于运行的 CefBrowser 是死循环的缘故，因此我只能让 CefBrowser 不停地连接 rpyc 保持状态的同步。&emsp;&emsp;这个操作增加了很多非必要的开销。 socket 通信 &emsp;&emsp;写文章的时候感觉通过 rpyc 独立成三份代码有点奇怪，应该可以将 浏览器和 rpyc 调用合并到一起的。&emsp;&emsp;毕竟 rpyc 的阻塞肯定也是类似于 while True 的方式实现的，刚好可以和 浏览器的 UI 事件处理合并，就不需要单独分出来了。&emsp;&emsp;而且这样也就不需要 浏览器 不断地连接 rpyc 实现同步了，调用起来更加高效。 &emsp;&emsp;花了大半天的代码修改，最后决定使用 python 自带的 socket 模块， 根本不需要 笨重的 rpyc 模块了。&emsp;&emsp;当然转换到 socket 之后也遇到了很多坑，花了我贼多的时间。&emsp;&emsp;特别是 创建浏览器嵌入的过程，我生成 uuid 记录到 服务端的字典里面，下次调用就知道这个 CefBrowser 对应的 CEF 框架的浏览器了。&emsp;&emsp;一开始 uuid 是在服务端生成的，所以我要通过 socket 将这个 uuid 数据返回到 客户端。&emsp;&emsp;但是这个操作会有个奇葩的BUG，我调试了好久才发现只要是获取服务端返回值并且添加了窗口的嵌入 CreateBrowserSync 这个函数就会直接卡死。&emsp;&emsp;但是如果不嵌入浏览器的话又完全没有问题，不获取返回值也没有问题，让我着急得干瞪眼了。&emsp;&emsp;后来测试了好久，灵机一动，uuid其实可以在生成 CefBrowser 类的时候生成然后传进 服务端，这样就不需要 获取 返回值了。&emsp;&emsp;通过这个方法解决了这个坑爹的卡死问题。 CefBrowser 调用 &emsp;&emsp;整体的原理已经在上面说了。&emsp;&emsp;后续就是做一个 QWidget 包裹成 CefBrowser 来完成 rpyc 相关的通信处理。&emsp;&emsp;简化 API 调用的复杂度。 loadUrl str 加载网页路径 reload 刷新当前页面 goBack 后退 goForward 前进 getUrl 获取当前的网页地址 embed int str 传入窗口 id 嵌入窗口，后一个是初始化网页的传参 &emsp;&emsp;另外需要注意的是 embed 必须要所有的窗口构建完成才可以使用。&emsp;&emsp;否则获取的 winId 不对无法嵌入会报错的。&emsp;&emsp;我特意做了一个装饰器 autoCefEmbed 可以嵌入到主窗口 UI 的 init 函数里面，自动实现窗口的 embed&emsp;&emsp;autoCefEmbed 装饰器会先开启 Widget 的显示，然后再隐藏，否则嵌入浏览器将会出错。 &emsp;&emsp;具体的运行例子可以参照 master 仓库下的 test 文件夹中的 importTest.py&emsp;&emsp;只要将路径改为自己本地的 CefWIdget 路径就可以运行起来了。 CEF 框架缺点 &emsp;&emsp;CEF实在是太大了，虽然完美实现了跨平台多端兼容，但是 libcef.dll 的大小显然非常的不友好。&emsp;&emsp;主要是因为集成了很多不需要的功能比如说js的后台调试器之类的。 &emsp;&emsp;而且大小几乎接近便携版的 Chrome 却依然无法支持 h.264 等诸多视频格式，H5视频都不支持，貌似是商业license的缘故 &emsp;&emsp;后来我在网上找到了更好的嵌入方案 miniblink&emsp;&emsp;这个对 CEF 框架做了极致的大小优化，而且还可以将 node.js 集成实现 electron 的运行。&emsp;&emsp;只可惜是纯 C++ 的调用，也不知道是否可以做到类似 CEF 一样嵌入的效果。&emsp;&emsp;以后有时间再进一步研究 C++ 的问题。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode 结合git的全面使用流程（下）]]></title>
    <url>%2Fposts%2Fa91a4c58.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上一篇介绍了 VScode 内置使用 git 的功能&emsp;&emsp;也提到了内置功能的不足，因此可以使用一个很强大的 VScode 插件 GitLens 来补充缺失的功能。&emsp;&emsp;加上 GitLens 的支持基本让 VScode 实现了全功能的 git 客户端了。 GitLens 插件 &emsp;&emsp;插件安装也非常简单，搜索插件 git 第一个就是 GitLens &emsp;&emsp;安装完成之后侧边的工具栏会多出一个 git 分支图标，点击就可以查看更详细的信息了。 文件更新显示 &emsp;&emsp;使用 Gitlens 之后侧边会有颜色块告诉你代码的更新情况 红色箭头表示删除 蓝色块表示修改 绿色块表示增添 &emsp;&emsp;点击颜色块也可以看到修改前和修改的变化。 &emsp;&emsp;也可以打开右上角的图标查看代码更新的信息。&emsp;&emsp;甚至可以查看具体的每一行代码是什么人上传贡献的。 回退 &emsp;&emsp;在 Gitlens 的左侧视图可以看到很详细的仓库信息。&emsp;&emsp;第一个分割查看仓库的所有变化&emsp;&emsp;第二个分割查看当前打开文件的变化&emsp;&emsp;第三个分割查看当前打开文件每一行的变化&emsp;&emsp;第四个分割则可以比较不同的分支标签的文件区别&emsp;&emsp;第五个分割则可以更具不同参考快速搜索每一次 commits &emsp;&emsp;我比较常用的是第一个分割的 回退 功能。&emsp;&emsp;可以找到特定的 commit 然后右键 switch 回到之前的开发代码上。&emsp;&emsp;可以在分支的地方会到 master 分支下。&emsp;&emsp;一些使用细节大家可以自己摸索，其实工具都很浅显了。 代码冲突 &emsp;&emsp;通常多人合作同时修改了同一个文件的时候就会产生代码冲突。&emsp;&emsp;也就是这一部分的代码不知道采用谁的。&emsp;&emsp;由于 git 的设置， push 之前必须要 pull 到最新的文件。&emsp;&emsp;而 pull 的文件极有可能会和自己尚未上传的 commit 产生冲突，这个时候 git 也会在文件做修改来告诉你。 &emsp;&emsp;我自己开发的时候由于 公司 和 家 分开开发,因此也会遇到类似的情况。&emsp;&emsp;VScode 内置的 git 会告诉你有冲突的文件，然后通过 Gitlens 可以快速调整冲突。 &emsp;&emsp;VScode 内置的 git 会告诉你有冲突的文件，然后通过 Gitlens 可以快速调整冲突。&emsp;&emsp;Gitlens 提供了四个按钮来快速清理 git 插入的分隔符，调整代码重提非常方便。&emsp;&emsp;而且右侧有的滚动条添加了冲突高亮，如果文件很大很复杂的时候寻找冲突也比较方便。 &emsp;&emsp;以上就是 Gitlens 中我比较常用的功能，还有搜索功能之类的也非常好用的，只不过我用得少。 .gitignore 文件 &emsp;&emsp;另外补充 .gitignore 文件的使用。&emsp;&emsp;通常我们的仓库会有很多文件，但是并不是所有的文件到想要添加到追踪里面去。&emsp;&emsp;这个时候就可以通过 .gitignore 来过滤不需要追踪的文件，比如时候 build 代码编译文件夹 .vscode 编辑器设置文件夹 还有 python 烦人的 pyc 文件。&emsp;&emsp;都可以通过 .gitignore 文件来进行过滤追踪。&emsp;&emsp;VScode 可以直接创建一个 .gitignore 文件，但是 windows 下不可行，因为 . 后缀会认定为后缀名，因此 windows 下需要 .gitignore. 输入这样才可以创建成功 &emsp;&emsp;具体 .gitignore 怎么配置推荐廖雪峰大神的文章 github 功能补充 &emsp;&emsp;github 其实本身还提供了特别多很好的功能，大家也可以用起来。 Issue &emsp;&emsp; Issue 类似于论坛，用来给开发者提意见或者 Bug 提交的。&emsp;&emsp;一些成熟的项目会有很多 Iseue， Issue 如果是 opened 状态说明还没有解决。&emsp;&emsp;如果 Issue 是 closed 的状态说明是已经解决的问题。&emsp;&emsp;有时候 Issue 的答案比 Stack Overflow 还管用，大家搜索的时候也不要忽视这里，特别是一些小众的开源项目。 &emsp;&emsp;另外 Issue 遵循 Github 发布的 API ，有些有意思的项目都快把 Github 的 Issue 功能玩坏了。&emsp;&emsp;比如典型的 gittalk 通过 Issue 来实现评论的数据记录，白嫖 Github 的服务器。 Pull request &emsp;&emsp;上一篇博客提到，社区是没有权限直接将代码合并到仓库中的，但是可以通过 pull request 来做贡献。&emsp;&emsp;首先需要先 Fork 仓库到自己的仓库上，然后修改完之后，将fork的仓库上传 pull 到开源项目中。&emsp;&emsp;至于代码是否合并就要看开源项目维护者的意愿了。 Projects &emsp;&emsp;提供了非常便捷的看板视图，方便做代码迭代和敏捷开发。 wiki &emsp;&emsp;wiki 则是仓库的说明文档。&emsp;&emsp;不过 github 的 wiki 完全基于 md 编写比较简单，很多复杂项目都是用文档生成工具来自动构建 wiki 的。 Release &emsp;&emsp;Release 界面通常包含一些需要编译发行的版本。&emsp;&emsp;特别是一些 c 和 C++ 的项目，编译一次需要很长的时间，通常仓库所有者会将编译好的版本打包压缩放到 Release 上供大家使用。 git 服务器环境 | git 钩子 &emsp;&emsp;关于 git 在服务器上构建仓库以及 git 钩子的构建 参考之前写的文章&emsp;&emsp;git 钩子可以在 git 的特定流程中执行 钩子 设定的脚本 , 比如 post-receive 可以再 push 之后出发特定脚本，具体参考上面的文章。&emsp;&emsp;在自己的服务器上搭建 git 使用 git 的钩子会更加自由一些, github 这些服务出于安全考虑 只有 网络钩子。 总结 &emsp;&emsp;以上就是 git 配合 VScode 的使用流程。&emsp;&emsp;后续还会录制一个视频详细讲解这其中的一些细节，希望大家赏脸，三连支持一下~]]></content>
      <categories>
        <category>VScode</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
        <tag>ࠑGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode 结合git的全面使用流程（上）]]></title>
    <url>%2Fposts%2F94ffdbdf.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;几个月前写过一篇文章，阐述了怎么搭建 git 的环境，方便在服务器上管理好自己的代码。&emsp;&emsp;最近和师弟他们沟通，发现他们依然用着原始的压缩包备份的方式来管理代码，于是就打算写一篇完整的使用教程，方便你我他。 git介绍 &emsp;&emsp;这里需要阐明一个概念，说到 git 很多人会想到 github&emsp;&emsp;其实 github 只是 git 的远程服务器端而已，github并不等于 git ，实际上 git 是一个代码管理软件。&emsp;&emsp;不用 github 也可以用 gitlab 或者 国内的 码云 和 coding&emsp;&emsp;如果不需要图形化界面的话，甚至不需要把代码放到github上，完全可以在自己搭建的服务器上进行代码同步管理。 &emsp;&emsp;说到 git 也很容易联想到一个老牌的代码管理工具 SVN&emsp;&emsp;其实两者在使用上的区别不是很大，重点是 git是去中心的分布式管理， SVN 则刚好相反。&emsp;&emsp;不过我自己也没有深入使用 SVN ，因此我也是在网上看的文章得到的片面之词，只是阐述自己目前的理解。 &emsp;&emsp;SVN就好比银行，我们所有的交易都要以它为中心进行解算，因此银行之下的我们是不知道所有的数据的，我们只需要管理好手中的数据就可以了。&emsp;&emsp;git的话就是每个人都是银行，所有的交易都会同步到每个人的身上。&emsp;&emsp;SVN管理的好处就是简单清晰，管理好自己负责的代码即可。&emsp;&emsp;git的好处就是代码安全，如果中心服务器挂了，每个人都可以成为中心来重新建立彼此的同步。&emsp;&emsp;当然现在大行其道的是 git 代码管理。&emsp;&emsp;至于更多SVN 和 git 区别可以参考 链接 git 使用 &emsp;&emsp;git本质上是一个命令行工具，可以去到 git 的官网安装其客户端。 链接&emsp;&emsp;安装成功之后就可以在命令行上输入 git 获取到 git 的操作指令了。 &emsp;&emsp;下面关于 git 的命令行使用就详细说明了，可以参考菜鸟学院里面的教程 链接&emsp;&emsp;下面是一些常用的命令 123456789git init // 初始化本地仓库git config --global user.name "myname" // 配置用户名git config --global user.email "myname@mymail.com" //配置邮箱git remote add origin code@github.git //绑定本地和远程仓库 git pull // 拉取远程仓库的变化来同步本地的状态git add // 确认本地仓库的变化到本地缓存区git commit // 确认本地缓存区的内容，可以准备pushgit push // 提交本地仓库到远程仓库git status // 确定本地缓存区的状态 &emsp;&emsp;补充一下配置了 user 之后就可以在 git 上看到上传代码的用户，这个未必和github用户一样的。&emsp;&emsp;另外如果上传到 github 的话需要github账号的验证，每次都需要输入账号密码很麻烦。&emsp;&emsp;可以利用 ssh 进行 github 免密登录 链接 github ssh免密登录 &emsp;&emsp;ssh 是通过 口令的机制 实现免密登录的。&emsp;&emsp;目前后端的服务器登录很常用的免密登录技术，由于口令非常复杂且无序，比输入人为的密码要安全很多 1234567891011121314151617181920212223$ ssh-keygen -t rsa -C "myname@mymail.com"Generating public/private rsa key pair.Enter file in which to save the key (/d/Users/82047/.ssh/id_rsa): testEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in test.Your public key has been saved in test.pub.The key fingerprint is:SHA256:9h/yLOap8OzlXb5s440DqmXAVeHqwik+/azYi21YRI0 myname@mymail.comThe key's randomart image is:+---[RSA 3072]----+| o o. || E .o || . . . || ... . || .S . || o.= . || o++ B.... || .oXoB+B =+o || ++@O*.=o*+.|+----[SHA256]-----+ &emsp;&emsp;ssh-keygen -t rsa -C &quot;myname@mymail.com&quot; 语句&emsp;&emsp;默认情况下生成名字为 id_rsa ,也可以输入自定义的名字&emsp;&emsp;下面的 passphrase 可以不填写，直接留空即可&emsp;&emsp;会在当前两个文件 id_rsa 和 id_rsa.pub&emsp;&emsp;我上面输入了 test ，因此生成了 test 和 test.pub 文件。 &emsp;&emsp;不过秘钥的存放路径是在 用户文件夹下的 .ssh 目录 (默认生成的 id_rsa 会在那里) &emsp;&emsp;如果秘钥不放在这个路径是读取不了的。&emsp;&emsp;下面可以打开我刚刚生成的两个秘钥文件，直接用文本编辑器打开即可。 &emsp;&emsp;第一张图是私钥&emsp;&emsp;第二张图是带pub 后缀是公钥 ， pub 就是 public 的缩写。 &emsp;&emsp;可以看到两个文件是一长串乱码。&emsp;&emsp;可以简单将公钥理解为锁，私钥就是唯一匹配这把锁的钥匙。&emsp;&emsp;从这个乱码的复杂程度可以知道它的安全性是很高的，如果秘钥没有暴露的话基本上无法破解的。 &emsp;&emsp;后面的操作就是将 pub 的公钥添加到 github 账号的位置即可，具体操作可以参考上面提供的链接的截图操作。&emsp;&emsp;github1每次需要登录信息的时候，都会调用 .ssh 目录下的秘钥进行匹配，匹配成功即登录成功。 &emsp;&emsp;.ssh 目录可以添加一个 config 文件(不带后缀)，可以参考下面的格式填写。 123456789101112131415#Default GitHub Host github.com HostName github.com User git IdentityFile ~&#x2F;.ssh&#x2F;id_rsa Host github-personal HostName github.com User git IdentityFile ~&#x2F;.ssh&#x2F;821412111 Host l0v0.com HostName 129.204.87.195 User git IdentityFile ~&#x2F;.ssh&#x2F;blog &emsp;&emsp;这个配置文件可以根据 clone 网址配置来读取不同秘钥&emsp;&emsp;比如说github上面默认 clone 下来的网址是 git@github.com:FXTD-ODYSSEY/mpdb.git&emsp;&emsp;@后面的部分就是 Host&emsp;&emsp;可以像我上面那样修改 Host 对应的名字调用不同的秘钥进行登录 (如果秘钥是不同的 gihub 账号就可以免密切换登录账号)&emsp;&emsp;HostName 就对应的 IP 地址 (域名的背后也是根据 DNS 服务获取 IP 地址，可以利用 ping 命令获取域名地址) &emsp;&emsp;理解这个之后就可以根据我上面的 ip 地址来登录我自己构建的服务器的 git&emsp;&emsp;比如说 git@l0v0.com:/home/git/repos/blog.git&emsp;&emsp;就会调用我上面的 blog 的秘钥然后利用服务器上的 ssh 服务来登录服务器。 &emsp;&emsp;因此免密登录更加安全，也更加方便。 VScode 内置 git 使用方法 &emsp;&emsp;经过前面一通的铺垫之后，终于开始今天的主角了。&emsp;&emsp;VScode 默认内置 git 的支持，当然图形化界面客户端也不一定要用 vscode ，git本身自带了一个图形化界面&emsp;&emsp;安装了 git 之后在任意目录下右键就有 Git Gui Here 的选项 &emsp;&emsp;使用上其实大同小异，VScode本身的功能加上插件辅助基本也可以实现差不多的效果。 认识界面 &emsp;&emsp;主要包含上面的按钮以及菜单的选项。&emsp;&emsp;不过通常只会菜单里的功能通常只会用到 pull 和 push 而已，其他杂七杂八的选项都可以不管。 文件更新示例 &emsp;&emsp;当你对仓库已经被跟踪的文件进行修改的时候，会有三种文件状态。 M 是 modify 的缩写即该文件存在修改 D 是 delete 的缩写即该文件被删除了 U 是 Update 的缩写即该文件是新添加 &emsp;&emsp;选中显示的文件可以对比前后修改的区别。 commit 代码 &emsp;&emsp;文件按钮的的意思。&emsp;&emsp;如果是新添加的文件，放弃修改就会提示彻底删除文件。&emsp;&emsp;如果是删除的文件，选择放弃修改就会从仓库中恢复文件(再也不用担心误删的文件找不到了)&emsp;&emsp;点击 + 号确认文件的修改就会提到 stash Changes 上 (对应 git add 命令) &emsp;&emsp;确认了文件之后，在输入框输入这次更新的内容，然后点击打勾就可以保存这一次更新了 (对应 git commit 命令)&emsp;&emsp;如果当前所有的 Changes 都要 commit ，那可以直接输入上传的信息并且打勾就可以快速 commit 了。 push 代码 &emsp;&emsp;这个时候 vscode 的右下角就会出现上箭头的数字为 1 (上箭头是push的更新,下箭头是可以pull的更新)&emsp;&emsp;当然如果之前没有 push 过代码的话，这个可能会没有数字显示。&emsp;&emsp;这个时候就可以将代码 push 到 github 上了 (对应 git push 命令) &emsp;&emsp;完成这一步之后就可以打开 github 仓库查看代码的更新了。 补充 &emsp;&emsp;另外 push 的时候如果没有设置 ssh 秘钥登录的话， VScode 会弹出账号密码的输入窗口进行登录。&emsp;&emsp;默认情况下个人仓库只能仓库创建者更新仓库代码，第三方的更新只能发布 pull request (这个流程后续补充)&emsp;&emsp;这因为如此，github 的 public 仓库可以被所有人读取，但是只有仓库拥有者可以对仓库进行写入(需要登录)&emsp;&emsp;因此多人协作的话可以使用 github 组织功能，参与开发的人加入到组织，然后再让组织开发成员的写入权限即可。 github 查看代码 &emsp;&emsp;打开 github 的仓库可以看到之前 commit 的信息已经显示出来了。 &emsp;&emsp;这个就是 git 的基础用法，只需掌握上面的步骤就可以完成个人开发并且把代码上传到 github 。&emsp;&emsp;如果只是在一个电脑上开发，基本上也不会用到 pull 的功能的。 pull 代码 &emsp;&emsp;有时候比如说公司和家里分别开发代码，那么 push 之后两边的电脑就不同步了。&emsp;&emsp;这个时候就需要 pull 拉去 github 上的新代码来实现仓库同步。&emsp;&emsp;也可以通过 vscode 右下角的下箭头看到仓库是否可以 pull &emsp;&emsp;然后点击菜单的 git pull 进行仓库更新 (对应 git pull 命令) 分支切换 &emsp;&emsp;代码开发的过程中，可能有不同的开发思路或者不同版本的代码想要留存个快照。&emsp;&emsp;可以通过创建分支来实现，默认的仓库其实也是一个分支，默认名字叫做 master&emsp;&emsp;vscode 可以直接在左下角创建分支 &emsp;&emsp;在上面的输入框中输入分支的名字即可 &emsp;&emsp;我在上面创建了 release 分支，这样我就可以在 VScode 切换到 release 分支&emsp;&emsp;我可以像之前那样对 release 分支进行各种修改 push 和 pull，这些修改就不会影响到 master 分支了。 &emsp;&emsp;第一次上传新的分支 VScode 会有弹窗提示。&emsp;&emsp;上传成功之后也可以通过 github 来切换查看分支。 总结 &emsp;&emsp;上面就是 VScode 内置 git 的支持，基本覆盖日常的使用流程。&emsp;&emsp;如果是个人开发已经完全够用了。&emsp;&emsp;但是如果涉及到一些团队协作的功能，那么 VScode 还是不够强大，比如处理代码冲突之类的支持就不太友好。&emsp;&emsp;那么下一篇就来介绍 VScode 的功能增强实现。]]></content>
      <categories>
        <category>VScode</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
        <tag>ࠑGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 函数传参验证探索]]></title>
    <url>%2Fposts%2F67e3cff5.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近开始开发 QtLib 库，将一些 Qt 的黑科技功能进一步集成到一起。&emsp;&emsp;在这个过程中会遇到某些复杂的函数，当中需要大量的可选参数，而且很多参数是不同模式下才需要的。&emsp;&emsp;由于 Python 没有 C++ 那种对函数重载的功能，如果写多个同名函数，会覆盖掉前面的函数。&emsp;&emsp;因此我只好在参数上做判断进行过滤。&emsp;&emsp;那么怎样才能快速判断传入的参数是否合法，如果全部都要写判断就太浪费时间了。&emsp;&emsp;自己开发一个参数验证库也觉得的很麻烦，总觉得应该有人也遇到和我一样的问题，因此我开始网上搜索现成的库。 系列文章推荐 &emsp;&emsp;后来在简书上搜到了非常棒的系列文章，介绍了三个不同的参数验证库。 Python数据验证库(一) validators Python数据验证库（二）validator Python数据验证库（三）voluptuous &emsp;&emsp;前面两个库比较小巧，功能相对简陋，但是可用。&emsp;&emsp;第三个的 voluptuous 是非常成熟的库了，在github上有上千颗星，非常推荐。 &emsp;&emsp;我看完了三篇文章之后可以看到三个库都有大量的功能是重合的，而 voluptuous 在使用上更胜一筹。&emsp;&emsp;上面的文章有很详细的使用方法介绍，我感觉也非常受用。 voluptuous 使用介绍 &emsp;&emsp;其实上面的文章也有很详细的使用说明。&emsp;&emsp;我简单说用代码的形式罗列有用的点。 12345678910111213141516171819202122232425from voluptuous import Schemaschema = Schema(&#123; 'text': str, 'active': bool, 'index': int,&#125;)data = &#123; 'text': 1, 'active': True, 'index': 1,&#125;data = schema(data)Traceback (most recent call last): File "c:/Users/Administrator/Desktop/hexo/source/_posts/Python/officail_explore/test.py", line 14, in &lt;module&gt; data = schema(data) File "D:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\voluptuous\schema_builder.py", line 267, in __call__ return self._compiled([], data) File "D:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\voluptuous\schema_builder.py", line 589, in validate_dict return base_validate(path, iteritems(data), out) File "D:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\voluptuous\schema_builder.py", line 427, in validate_mapping raise er.MultipleInvalid(errors)voluptuous.error.MultipleInvalid: expected str for dictionary value @ data['text'] &emsp;&emsp;通过定义数据类型，可以将传参进行判断。&emsp;&emsp;参数传递不正确就会报错提醒 123456789from voluptuous import Required, All, Length, Rangeschema = Schema(&#123; # NOTE 限定必传参数，并且字符串长度是1 Required('q'): All(str, Length(min=1)), # NOTE 限定必传参数，默认值为5，数字在 1-20 之间 Required('per_page', default=5): All(int, Range(min=1, max=20)), # NOTE 数字表小于0 'page': All(int, Range(min=0)),&#125;) &emsp;&emsp;更多用法还是参考上面的文章介绍。 singledispatch 原生库 &emsp;&emsp;后来再研究 dayu_widget UI库 的时候发现里面使用了 singledispatch 库&emsp;&emsp;查了一下原来 singledispatch 在 Python3 的官方包 functools 里面引入了。&emsp;&emsp;可以通过这个库来实现类似上面说的C++函数重载的效果，也就是传入不同的参数函数调用不同。 &emsp;&emsp;由于是 python3 才有的新特性，如果要在 Python2 中使用需要使用第三方做好的兼容库来实现。 pypi地址 123456789101112131415161718192021222324252627282930from singledispatch import singledispatch@singledispatchdef fun(arg, verbose=False): if verbose: print("generic usage") print(arg)@fun.register(int)def _(arg, verbose=False): if verbose: print("int usage") print(arg)@fun.register(list)def _(arg, verbose=False): if verbose: print("list usage") for i, elem in enumerate(arg): print(i, elem)fun("1",True)fun(1,True)fun([1],True)# generic usage# 1# int usage# 1# list usage# (0, 1) &emsp;&emsp;也可以将已有的函数注册为特定函数的重载函数。 1234def nothing(arg, verbose=False): print("Nothing.")fun.register(type(None), nothing)fun(None,True) &emsp;&emsp;也可以通过 dispatch 方法获取特定调用的函数 1234# 获取上面定义的 list 传参方法fun.dispatch(list)# 甚至可以传入错误参数进行调用_(:з」∠)_(这就没有办法检测参数是否合法了)fun.dispatch(int)("5",True) 总结 &emsp;&emsp;上面就是我最近接触到用来简化参数调用的方法。&emsp;&emsp;singledispatch 可以很方便将函数拆解成不同类型调用，把一个复杂函数的功能分割出来。&emsp;&emsp;voluptuous 则是用于快速验证传入参数是否是预想的类型。&emsp;&emsp;两者结合对于复杂程序开发非常方便。 &emsp;&emsp;有时间的话要研究一下 singledispatch 这种黑科技是怎么在 Python2 中实现的。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 奇怪的Callback报错]]></title>
    <url>%2Fposts%2Fa7c99667.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;去年我还在动画制作公司的时候，绑定那边就提到了一个神奇的 callback 问题。 12345// Error: line 1: Cannot find procedure "CgAbBlastPanelOptChangeCallback". //// Error: line 1: Cannot find procedure "CgAbBlastPanelOptChangeCallback". //// Error: line 1: Cannot find procedure "CgAbBlastPanelOptChangeCallback". //// Error: line 1: Cannot find procedure "CgAbBlastPanelOptChangeCallback". //// Error: line 1: Cannot find procedure "CgAbBlastPanelOptChangeCallback". // &emsp;&emsp;只要在视窗切换模型的显示操作就会弹出这么一大堆的报错(按4 、 5 键切换)&emsp;&emsp;虽然报错没有什么影响，但是下面的显示总是报 红色 ，制作起来就很烦。&emsp;&emsp;最神奇的是，新打开的 Maya 不会有这个问题，但是打开一些 Maya 文件就会这样，而且一旦出错就无法消除，打开其他文件也一直报错。 &emsp;&emsp;一开始最简单的解决方案就是 global proc CgAbBlastPanelOptChangeCallback 定义一个这样的 mel 程序。&emsp;&emsp;但是为什么会出现这个错误，要从根源解决问题。&emsp;&emsp;于是我花了好长一段时间自己找到了问题的根源所在，并且弄了一段代码解决这个问题。 123for modelPanel in cmds.getPanel(type="modelPanel"): if cmds.modelEditor(modelPanel, q=1, ec=1) == "CgAbBlastPanelOptChangeCallback": cmds.modelEditor(modelPanel, e=1, ec="") &emsp;&emsp;只要执行上面这段代码，就可以从根源上解决问题。 &emsp;&emsp;最近想着写文章，又简单探索了一下这个问题，没想到去年在我研究出解决方案之后也有人发布到 github 上了。链接 123456789101112from maya import cmdsfor model_panel in cmds.getPanel(typ="modelPanel"): # Get callback of the model editor callback = cmds.modelEditor(model_panel, query=True, editorChanged=True) # If the callback is the erroneous `CgAbBlastPanelOptChangeCallback` if callback == "CgAbBlastPanelOptChangeCallback": # Remove the callbacks from the editor cmds.modelEditor(model_panel, edit=True, editorChanged="") &emsp;&emsp;可以说和我上面的操作代码 一毛一样， 哈哈~ 问题查找 &emsp;&emsp;最开始我以为 CgAbBlastPanelOptChangeCallback 是 Maya 的内置 callback。&emsp;&emsp;于是我在 Maya 的安装目录里面搜索 CgAbBlastPanelOptChangeCallback ，毫无收获。 &emsp;&emsp;于是我猜想是 scriptJob 引入进去的，但是罗列了所有的 scriptJob 也一无所获。 &emsp;&emsp;唯一确定的就是 切换视窗会报错 ，并且Maya文件会像病毒一样污染整个 Maya。&emsp;&emsp;于是保存了一个空的 Maya 文件出来，查看到底是什么导致的。&emsp;&emsp;然后就发现这个问题和 modleEditor 有关。 &emsp;&emsp;于是我进一步研究 modleEditor 命令，然后发现是 editorChanged 添加了这个回调，并且通过 scriptNode 添加。&emsp;&emsp;一旦打开文件就会添加，并且文件关闭没有消除这个命令，因此导致其他文件就会报错。 &emsp;&emsp;但是我到最后还是没有研究出这个 callback 是什么插件引入的。 总结 &emsp;&emsp;我去年3、4月份的时候在网上貌似找不到答案，但是现在查的时候就查到了两篇日本人的博客有很详细的描述，而且和我解决问题思路有 90% 是一样的。 年末大掃除! 対 謎のcallbackエラー [Maya]恐怖！Cannot find procedure の怪 &emsp;&emsp;当然最后他们也没有查出到底是什么插件引入的，只是可以通过上面的脚本来解决这种问题。&emsp;&emsp;因此上面的博客也提到，不要再 scriptNode 里面写这些花里胡哨的东西，很容易导致全局污染，用到这种 callback 的操作都要谨慎小心。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 内置图标探索]]></title>
    <url>%2Fposts%2F19ce97d6.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近研究 Maya 的工具架的图标，让我感到很困惑。&emsp;&emsp;Maya 工具架上的图标找不到文件路径，如果可以找到的话就可以替换图标实现对 Maya 内置图标的替换了 (～￣▽￣)～ &emsp;&emsp;工具架的图标选择是可以选择很多内置的图标的，但是这些图标来自何方呢？&emsp;&emsp;最初的想法是去到 Maya 相关目录去查找，首先是 我的文档 的个人设置路径，其次是 Maya 安装目录。&emsp;&emsp;然而并没有找到这些图标保存的路径。 目录寻找 &emsp;&emsp;倒是在 Maya 安装目录的 icons 目录下找到了很多插件相关的图标。&emsp;&emsp;也有启动页面的图片，修改 MayaStartupImage.png 这张图片就可以替换掉启动页面了 o(￣▽￣)ｄ&emsp;&emsp;但是我想要找的图片还是没有找到。 &emsp;&emsp;这种操作让我想起以前安装非官方 3ds Max 时候还有在启动页面嵌入广告的，大概也是那么简单(:з」∠) 代码寻找 &emsp;&emsp;既然目录寻找失败，也可以从 Maya 的代码机制进行寻找。&emsp;&emsp;看看图片是怎么通过代码加载出来的，毕竟 Maya 大部分的界面都是开源可编辑的。 &emsp;&emsp;在工具架面板上点击图标打开选择菜单弹出的是一段奇奇怪怪的代码 123formLayout -nd 100;// Result: |formLayout115 // &emsp;&emsp;根本没办法复现代码，于是只好去翻找 工具架编辑面板的 UI 一探究竟。&emsp;&emsp;依然是使用 Maya 的命令回显功能查看。 1234567/*dSBRMBMI*/python("import maya.app.general.shelfEditorWindow as myTempSEW\nmyTempSEW.doIt(selectedShelfButton='shelfButton4',selectedTabIndex=1)\ndel myTempSEW");import maya.app.general.shelfEditorWindow as myTempSEWmyTempSEW.doIt(selectedShelfButton='shelfButton4',selectedTabIndex=1)del myTempSEWglobal string $gShelfTopLevel; string $tmp=$gShelfTopLevel;// Result: Shelf|MainShelfLayout|formLayout13|ShelfLayout // if(! `exists shelfLabel_uiToMel` ) &#123;source "shelfLabel.mel";&#125;; &emsp;&emsp;可以看到主要的 mel 语句是一行 Python 的代码调用。&emsp;&emsp;于是我抽丝剥茧，可以通过下面这段 python 代码打开编辑窗口。 123import maya.app.general.shelfEditorWindow as myTempSEWmyTempSEW.doIt(selectedShelfButton='shelfButton4',selectedTabIndex=1)del myTempSEW &emsp;&emsp;可以看到这个包的目录是个 shelfEditorWindow.py 文件，可以手动 print myTempSEW一下查找到 路径。 123import maya.app.general.shelfEditorWindow as myTempSEWprint myTempSEW&lt;module 'maya.app.general.shelfEditorWindow' from 'C:\Program Files\Autodesk\Maya2017\Python\lib\site-packages\maya\app\general\shelfEditorWindow.py'&gt; &emsp;&emsp;直接在脚本里面搜索 icon 可以找到 itemIcon 函数，注释里面提到是改变图标的函数，就是它没错了。&emsp;&emsp;另外在第 360 行开始有 InternalIcon 内部图标的构建。&emsp;&emsp;于是我执行判断里面的代码 1234import maya.app.general.resourceBrowser as resourceBrowserresBrowser = resourceBrowser.resourceBrowser()path = resBrowser.run()del resBrowser &emsp;&emsp;上面的代码就可以打开图标替换的窗口了。&emsp;&emsp;感觉离目标越来越近了，于是继续追查 resourceBrowser 包&emsp;&emsp;这个包就在同级目录的 resourceBrowser.py 里面 &emsp;&emsp;下面的重点是 saveCopy 这个函数，就是像知道 另存为的功能是怎么实现的。&emsp;&emsp;于是看到最后的 95 行 1cmds.resourceManager(saveAs=(resName, path)) &emsp;&emsp;没想到居然会用到 cmds 命令的函数，失算了。&emsp;&emsp;于是去查 cmds 文档说明 &emsp;&emsp;万万没想到原理这些内置的图标居然是通过内置的 cmds 命令进行读取和输出的。 dll 查找 &emsp;&emsp;经过上面的一番搜索依然是没能达成目标，只知道可以通过 resourceManager cmds 命令来输出。&emsp;&emsp;于是我就网上查了一番，没想到还真的找到论坛上的提问 链接 &emsp;&emsp;链接中提到可以去到 Maya 的 bin 目录找到 MayaRes.dll 文件，然后用 dll 资源读取工具来读取 dll 的图标。&emsp;&emsp;然而我找了一圈也没有找到 MayaRes.dll 文件。&emsp;&emsp;看了回答的时间才豁然开朗，原来是 2008 年回复，那个时候 Maya 还没有使用 Qt 框架。&emsp;&emsp;因此调用机制大概是不太一样的。 &emsp;&emsp;但是藏在 dll 里面是个好思路，于是我用回答里面推荐的 restorer 软件一个一个 dll 打开查看。&emsp;&emsp;然而看了大部分的dll依然是一无所获。 搜索 resourceManager &emsp;&emsp;没了办法只能死马当活马医了，于是我用 VScode 打开 Maya 的安装目录，直接搜索 resourceManager 这个关键字。&emsp;&emsp;没想到居然还搜到了 bin 目录下的 commandList 文件，这个文件刚好记录的是 cmds 命令调用 对用的 dll 文件。&emsp;&emsp;而 resourceManager 指向的是 bin 目录下的 sharedUI.dll ， 然而我用之前的软件打开 dll 什么都没有。&emsp;&emsp;貌似是真相大白了，还需要其他更好的 dll 查看器。 dll查看 &emsp;&emsp;我用了好机款 dll 查看器，但是都已失败告终。&emsp;&emsp;只有 eXescope 软件是报错的， 貌似是 autodesk 有保护， eXescope 读取会提示 EAccessViolation 导致内存错误无法访问。&emsp;&emsp;另外 dll export viewer 可以看到 dll 内部包含的函数表，但是没有什么用。&emsp;&emsp;我也尝试用 python 去读取 dll ， 读取的 dll 没有报错，但是什么函数都没有(:з」∠) 123456import ctypestestlib = ctypes.CDLL(r"C:\Program Files\Autodesk\Maya2017\bin\SharedUI.dll")print dir(testlib)['_FuncPtr', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattr__', '__getattribute__', '__getitem__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_func_flags_', '_func_restype_', '_handle', '_name'] 总结 &emsp;&emsp;最后研究一轮之后，还是以失败告终了(:з」∠)&emsp;&emsp;不过这个过程还是挺有趣的，就简单记录下来。 2020-5-10 补充 &emsp;&emsp;虽然无法直接找到 Maya 内置的图标，但是可以通过 Qt 的机制获取 Maya 图标。&emsp;&emsp;这个操作我是从 Rj 大神的 Command Search 插件里面学到的，后来我进一步开发 CommandLauncher 的时候有了更深的理解。 123456789101112131415161718from Qt import QtCore,QtWidgets,QtGuiclass TestWidget(QtWidgets.QWidget): def __init__(self): super(TestWidget,self).__init__() layout = QtWidgets.QVBoxLayout() self.setLayout(layout) pixmap = QtGui.QPixmap(":\hyper_s_OFF.png") label = QtWidgets.QLabel() label.setPixmap(pixmap) layout.addWidget(label)if __name__ == "__main__": widget = TestWidget() widget.show() &emsp;&emsp; hyper_s_OFF 就是 Maya 内置的图标，可以在工具架上修改图标查看 Maya 所有内置的图标。&emsp;&emsp;通过 :\ 前缀即可获取得到这些图标。&emsp;&emsp;另外这些图标是通过 Qt 的机制加载的，完全可以利用 Qrc 编译的机制来添加新的内置图标。&emsp;&emsp;具体操作可以参考我后来写的脚本 flimSkin2GameSkin&emsp;&emsp;通过 QtCore.qRegisterResourceData 注册的图标也可以通过 Maya 命令 resourceManager 进行获取。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya插件 - CommandLauncher]]></title>
    <url>%2Fposts%2F18de3838.html</url>
    <content type="text"><![CDATA[前言这个插件基于以下两款插件的启发进行开发 CommandSearch quicklauncher 代码结构完全是在 CommandSearch 的源码上进行的修改此外 Listary5.0 软件的使用逻辑也启发了我 &emsp;&emsp;最近在看 mGear 开源绑定框架的教程。(已经是去年2019年的事情了)&emsp;&emsp;偶然发现了大佬使用一个相当方便的 quickLauncher 工具快速启动脚本&emsp;&emsp;于是激发了我研究的兴趣。 &emsp;&emsp;后来，还是因为 mGear 提到的一些插件，于是去 Autodesk 官方的商店查找工具。&emsp;&emsp;在那里我找到了另一个UI做得非常棒的工具 CommandSearch &emsp;&emsp;最初是接触 3dsMax 和 Houdini 都相关的搜索框，而 Maya 的命令搜索功能非常落后。 &emsp;&emsp;于是我就萌生了进一步结合两个插件的功能进行开发，弄一个命令启动器。&emsp;&emsp;插件的使用方法参照 github 上的 readme 文档 插件分析CommandSearch &emsp;&emsp;不愧是 RJ 大师的作品， CommandSearch 整体以及 UI 多做得特别棒。&emsp;&emsp;特别是还原了 Maya 的菜单显示风格，还有复选框的和图标的功能都逐一还原。&emsp;&emsp;整一个思路都非常好，我特别喜欢。 &emsp;&emsp;可惜 这个插件搜索的结果需要鼠标点击，没有办法通过键盘来完成点击。&emsp;&emsp;并且只能搜索到 Maya 的菜单数据. quicklauncher &emsp;&emsp;相对而言 quickLauncher 就小巧很多。&emsp;&emsp;但是它利用 Qt 的 completer 来实现补全触发。&emsp;&emsp;而且真正做到随处弹出的效果，继承了Maya的 cmds 命令，可以快速调用。 &emsp;&emsp;可惜没有什么设计可言，UI非常简单。&emsp;&emsp;唤起需要手动设置快捷键调用代码才可以。 总结 &emsp;&emsp;最后我将是将两个插件的有点全部集合到一起，所以 命名为 CommandLauncher ，两者合并之意。&emsp;&emsp;开发的过程中也的确遇到了很多问题，主要的插件框架是在 CommandSearch 上面进行魔改的。&emsp;&emsp;毕竟 CommandSearch 开发得比较完善，当然要事先看懂代码也花费了很多很多的时间。&emsp;&emsp;但是都怪我的开发断开了，我在2019年开发了大部分功能之后因为要肝学校的实训作业，所以就停止了开发。&emsp;&emsp;后来又遇到了很多事情，比如说突然想开发 mpdb 模块出来，然后这个插件的临门一脚就一直还没有完成。&emsp;&emsp;原本我是想在过年的时间把手尾都收拾好的，结果还是又搞这搞那的，拖到了现在了(:з」∠) 遇到的问题使用 Tab 键作为启动快捷键 &emsp;&emsp;无论是 Houdini 还是 Maya 的节点编辑器都是使用 Tab键打开输入的。&emsp;&emsp;原本是想在 快捷键编辑器 里面设置 Tab 快捷键的。&emsp;&emsp;没想到 Tab 居然不支持作为快捷键。 &emsp;&emsp;后面我还是利用了 eventFilter 来帮我获取到键盘输入事件。&emsp;&emsp;通过抓取 Tab 键的点击来启动 命令启动器。&emsp;&emsp;但是在视窗里面 Tab 键使用来切换 Drag 拖拽选择的操作的，这样子我就和这个操作冲突了。&emsp;&emsp;不过 Drag 操作通常都是长按来使用的，于是我又加了一个计时器，如果点击时间少于 300 毫秒，就是启动器，否则就是长按。 任意位置弹出 | 点击其他地方隐藏 &emsp;&emsp;默认 CommandSearch 是固定在 Status Line 上面的。&emsp;&emsp;因此弹出操作我参考 quickLauncher 的弹出效果。&emsp;&emsp;show 的时候将组件 move 到鼠标的位置 &emsp;&emsp;点击其他地方就消失其实这个需求和我之前写的 Qt 教程想要的效果是一样的。&emsp;&emsp;还是利用 eventFilter ，如果点击了其他的地方就消失。 面板的键盘操作 &emsp;&emsp;具体细节我已经不太记得了，隔离3个多月。&emsp;&emsp;不过按键的功能都单独分开成一个函数了。&emsp;&emsp;按箭头可以实现在菜单上的滚动，解决了 CommandSearch 极大的短板。&emsp;&emsp;按箭头之后会获取当前处于 菜单 的序号数字，然后选中的 item 需要给出颜色变化予以提示。&emsp;&emsp;然后当下箭头移动到相应的位置之后还要自动滚动滚动条。 &emsp;&emsp;另外还添加了 alt+数字 进行快速跳转，以及 ctrl+数字 的快速触发组件。&emsp;&emsp;另外还有 ctlr + alt + 数字 跳到置顶图标上。&emsp;&emsp;ctrl + 数字键触发的想法是 根据 listary5.0 的新功能启发的。&emsp;&emsp;这个想法特别好，远在天边也可以快速启动我想要的功能。 &emsp;&emsp;整个流程其实很清晰，就是写起来有点繁琐。&emsp;&emsp;我的 pressKeyEvent 通过 if else 来判断 keySequence 其实不太好。&emsp;&emsp;把 if else 写得太长了。&emsp;&emsp;其实应该用字典来调用，代码就会清晰很多，不过是以前写好的功能了，自己也懒得去修改了。 工具架搜索支持 &emsp;&emsp;菜单搜索 CommandSearch 已经做好了&emsp;&emsp;Maya cmds 模块搜索也可以根据 quickLauncher 里面的写法依葫芦画瓢。&emsp;&emsp;最后唯独缺少了工具架的搜索功能。 &emsp;&emsp;一开始的想法也是按照 菜单 的获取方法一样。&emsp;&emsp;获取 Maya 的工具架 Qt 组件，然后逐一遍历。&emsp;&emsp;但是发现很多工具架上的 按钮都是空的。 &emsp;&emsp;经过一番折腾之后才发现（找 mel 源码查看），原来工具架上面的标签切换点击之后才读取相关的 mel 脚本生成图标。&emsp;&emsp;因此一打开 Maya 其实工具架都是空的，处理一开始看见的工具架之外。&emsp;&emsp;针对这个情况，我将 mel 的读取 工具架的源码抽出来，然后在获取的时候自动读取生成。&emsp;&emsp;读取完了之后再用 cmds 的命令获取图标、名称、点击事件。 cmds命令拆分 &emsp;&emsp;根据 quickLauncher 的方法，我发现不仅仅获取 cmds 模块的命令，还顺带将 Maya 的 runTimeCommand 以及一些插件引入的命令都索引进来了。&emsp;&emsp;分析了函数的类型之后，我发现 cmds 模块的原生命令都是 builtinFunctionType 的&emsp;&emsp;因此可以通过 types 模块引入 builtin 类型进行判断。&emsp;&emsp;当然即便是 builtin 也有一些 cmds 文档没有收录的命令，可能是一些测试命令。 &emsp;&emsp;根据上面的方法就成功将 cmds 的命令拆分成 cmds 和 command 两个过滤组。 搜索过滤 &emsp;&emsp;通过快捷键 ctlr + q w e r t 可以切换不同的过滤标签。&emsp;&emsp;实现搜索结果的过滤。&emsp;&emsp;其实主要过滤的是 item 里面的 category 类型。&emsp;&emsp;获取数据的时候已经实现分好类了，因此不匹配的类型隐藏过滤掉就可以了。 多线程启动 &emsp;&emsp;这一次的代码虽然有多线程的部分，但是启动时间耗费还是很巨大。&emsp;&emsp;主要是最耗费时间的部分没有办法放到多线程里面优化速度。 &emsp;&emsp;其中遇到很多坑，坑了我非常多的时间。&emsp;&emsp;多线程代码没有报错显示，其实我是知道有 traceback 库可以通过 try 来打印详细的报错信息。&emsp;&emsp;但是我自己死脑筋，就没有想到这个方案试一下，反而是注释代码来测试。&emsp;&emsp;由于这一次也接入了 i18n ，reload代码会有一堆报错，所以每次测试都需要重开 Maya ， 等了我不少的时间啊。&emsp;&emsp;而且花了很多时间之后，还对报错不明不白，不知道为啥引入某个模块报错了。&emsp;&emsp;后来是通过 traceback 之后才发现，原来按个模块是互相引入的，有些变量需要提前声明在 导入 才不会报错。&emsp;&emsp;后面也有遇到过报错没有插件生成，但是 Maya 脚本编辑器完全没有报错信息提示的。&emsp;&emsp;我又用了土办法，注释代码测试到底是那里出错了，后来偶然在 output window 上看到了报错的信息，才知道原来报错的位置去到了那里。&emsp;&emsp;知道错误的话修改总比无头苍蝇地测试要好很多了。 &emsp;&emsp;除了开了上面的坑，多线程主要优化是数据获取的时候可以保持Maya的响应。&emsp;&emsp;然而这次可能是数据比较多，即便用了多线程也还是会卡死 Maya 窗口(:з」∠)(也有可能是我的使用姿势不对)&emsp;&emsp;而且遇到了两个获取数据的坑 &emsp;&emsp;首先就是上面获取工具架的时候需要提前加载工具架才能获取，但是这个加载过程如果放到多线程执行的话就爆炸了。&emsp;&emsp;Maya直接就是运行不正常，还会生成一大堆的窗口，然后脚本编辑器会提示一大堆的错误。&emsp;&emsp;后来是把加载功能提出来，放到主线程加载了。 &emsp;&emsp;另一个问题就是多线程状态下无法通过递归方法来获取到菜单数据。&emsp;&emsp;明明菜单数据是最多的，但是递归方法在多线程下执行之后获取的数据为空，&emsp;&emsp;这个也不知道应该如何解决，于是只好把这个耗时较长的方法放到了主线程去获取了,因此这次多线程的提速并没有达到预期。&emsp;&emsp;写完文章之后还是非常好奇为啥获取的数据为空,于是又进一步研究 RJ 之前写的代码。&emsp;&emsp;后来发现原来 getMenu 里面有有一句 aboutToShow.emit 来触发显示的信号槽。&emsp;&emsp;这个显示操作显然是异步的，因此只要将这个语句搬到主线程里面提前执行就不会有数据为空的问题，而且多线程获取 Menu 数据之后。&emsp;&emsp;加载速度有了不少的提升，只是加载工具架和菜单就要花费5-6秒，后续多线程就有响应了，这个过程也大概只要1-2秒，之前不用多线程总共要10秒 总结 &emsp;&emsp;这个插件虽然拖了很久，不过因为后续有 mpdb 模块开发的经验铺路，因此 i18n 多线程之类的坑都少了很多。&emsp;&emsp;这次没有怎么截图，而是录了一个视频进行讲解。&emsp;&emsp;一直有录制 vlog 之类的想法，但是实在是太多东西要做了，自己的进度总是跟不上(:з」∠)]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 工具开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机效率提升指南（二）]]></title>
    <url>%2Fposts%2F471f7aaa.html</url>
    <content type="text"><![CDATA[前言 安卓手机效率提升指南（一）&emsp;&emsp;上一篇文章介绍了 谷歌商店 里面的一些便捷操作应用。&emsp;&emsp;其实也涵盖了日常最常用的 APP 了，基本上我日常调用 APP 都是通过上文提到的 三大 APP 。&emsp;&emsp;这篇文章则重点着墨在 酷安 - 搞机圣地里面出没的，名声不错的 APP 。&emsp;&emsp;其实我并不是资深搞机佬，也是最近兴致起来才开始研究，因此我拙劣的认识大家莫见怪。 &emsp;&emsp;下面提到的 APP 可以在 酷安应用市场 可以找到 酷安应用市场 太极 黑阈 轻启动 一个木涵 一触即发 太极 &emsp;&emsp;只要是搞机的人都知道，root了手机才算踏入 安卓 的搞机世界。&emsp;&emsp;但是随着各大厂商对于手机的各种保护，root手机的成本越来越高了，轻则无法升级手机系统，重则丢了手机的保修。&emsp;&emsp;而且 root 手机有风险，不仅仅会丢失数据，操作不当还有可能让手机变砖，而且 root 了之后还会被各大银行检测封锁。&emsp;&emsp;虽说上述种种困难，搞机达人都有办法可以应付的，但是大部分人就没有那么多时间来折腾，而且还要冒着各种风险，实在是难受。 &emsp;&emsp;而太极框架的出现，实现了不 root 手机也可以使用 xposed 框架的效果，达到了给应用开发增强性功能的效果。&emsp;&emsp;几乎不会被厂商检测也没有 root 手机的各种风险，实在是我等懒人的福音！~ ↓↓↓注意↓↓↓使用太极需要重装 APP ，需要提前备份 APP 的数据，安装之后 app 无法正常刚更新。并且重装了 微信 之后，在其他 APP 上用不了微信登录，也无法正常分享到微信 ， 需要将其他APP也用太极安装才可以。想要杜绝上面的问题需要解锁 BootLoader ，安装 magisk 开启 太极阳 的大门。 (相当于要 root 手机) 安装 APP 流程 &emsp;&emsp;这里以 微信 安装到太极举例。 &emsp;&emsp;在太极里面选择添加应用。 &emsp;&emsp;然后勾选微信，点击创建。 &emsp;&emsp;太极会创建一个新的微信安装包，然后需要卸载现有的微信，安装太极提供的安装包即可。 &emsp;&emsp;这里拿了网易云音乐来举例，微信的情况也是一样的。&emsp;&emsp;卸载微信之前，可以将手机所有的聊天记录备份到电脑端的微信上。&emsp;&emsp;后续在新装的微信上恢复聊天记录即可，基本不影响到聊天数据。&emsp;&emsp;当然如果担心出问题，还可以用一些备份软件备份一下，一加就有官方的 一加搬家 app 可以备份手机的数据。 &emsp;&emsp;做完上面的流程，就可以根据太极提供的 xposed 模块安装使用了。&emsp;&emsp;我使用太极主要在微信的功能增强上，因此下面介绍到的 xposed 模块都和微信有关。&emsp;&emsp;每次安装完新的模块启用之后，需要强制停止微信重开才有效果。&emsp;&emsp;另外这些 xposed 模块必须在太极安装了微信之后再安装才有效，否则需要重装。 微X助手 &emsp;&emsp;微信辅助功能的绝对神器。&emsp;&emsp;含有非常多微信增强的功能。 消息防撤回 自动抢红包(听说会封号，我就不开启了) 自动电脑端登录 各种批量操作 微信斗图 &emsp;&emsp;长按表情代开按钮可以打开表情搜索面板，输入关键字也可以弹出类似 QQ 的参考表情。 微信网页多页面 &emsp;&emsp;这个功能真的是太棒了，以前看公众号、或者微信打开的网页，有收到别人有消息给我。&emsp;&emsp;以前不懂只能先回复消息，然后找回刚才的链接，后来是将相关的页面弄成浮窗解决。&emsp;&emsp;现在开启这个模块就可以解决问题了。 微信学英语 &emsp;&emsp;微信所有的聊天信息自带翻译功能。&emsp;&emsp;实属学习外语的神器。 &emsp;&emsp;翻译用的源可以自行设置，默认可以白嫖谷歌翻译，但是有时候不稳定。&emsp;&emsp;也可以申请 腾讯 或者 百度 的 API 进行翻译。 黑阈 &emsp;&emsp;黑阈这款软件可以实现在 不 root 状态下对后台常驻的应用进行管理。&emsp;&emsp;使用黑阈可以自定定时杀死某些后台运行的程序，减少耗电量。&emsp;&emsp;缺点就是杀死后台之后就无法收到程序的推送，肯定是各有利弊的。 &emsp;&emsp;使用 黑阈 还是不简单，如果不 root 的话，还需要谷歌的 adb 软件来运行 app 内部的 shell 脚本方可正常使用。 adb下载地址&emsp;&emsp;可以参考这篇百度经验的操作 链接 轻启动 &emsp;&emsp;很多人推荐如果 root 了手机使用 大圣净化，如果不 root 手机就使用 轻启动。&emsp;&emsp;大圣净化听闻要付费使用，我没有用过，毕竟手机没有 root 。&emsp;&emsp;轻启动有付费和免费版本，我觉得免费的已经够用了。 &emsp;&emsp;自动点击 APP 启动时候的广告跳过。&emsp;&emsp;甚至连 youtube 的视频广告也可以自动点跳过。&emsp;&emsp;平日里后台运行，几乎没有任何存在感，应用跳过广告的时候则会提醒我，非常好用。 一个木涵 &emsp;&emsp;这是一个功能全面的工具箱，名声不错。&emsp;&emsp;最近新增了一个打包网页为 APP 的功能，挺不错的。&emsp;&emsp;只是功能挺杂的，我日常使用比较少。 一触即发 &emsp;&emsp;这是一个超强的自动化软件。&emsp;&emsp;感觉内核可能参考了 安卓自动化神器 auto.js&emsp;&emsp;不过里面的链接方式则是类似层级式的，和 automate 的节点式还不一样。&emsp;&emsp;毕竟是国人开发，而且目前还不是很完善，但是未来绝对可期。&emsp;&emsp;官方有提供脚本，可以通过屏幕识色点击来自动玩支付宝的拍小鸡游戏。&emsp;&emsp;不过我也不参与支付宝这些杂七杂八的东西里面(:з」∠) &emsp;&emsp;一触即发的自动化比起 FV悬浮球 的自动化功能要完善复杂很多。&emsp;&emsp;而且一触即发支持代码转译。&emsp;&emsp;但是由于复杂，我反而不太喜欢这种层级式的操作，操作起来很累(:з」∠)&emsp;&emsp;不过由社区有大佬开发了自动刷脚本，可以顺利让我完成很多任务。 总结 &emsp;&emsp;以上就是我两篇关于安卓超好用APP推荐。&emsp;&emsp;还有一些工具APP以及自己很常用的 APP 没有提到。&emsp;&emsp;比如图片扫描使用全能扫描王， OCR图片识别使用 白描。&emsp;&emsp;主要还是分享自己使用手机的一些心得和推荐。&emsp;&emsp;另外我的手机虽然是一加的，但是还没有认真搞过机，root 过权限。&emsp;&emsp;可能等5G成熟换新手机，旧手机转备用的时候再来折腾吧。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>🚀效率</tag>
        <tag>࠱Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机效率提升指南（一）]]></title>
    <url>%2Fposts%2Ffc7c2790.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;其实这篇文章的契机源于 windows 效率的文章&emsp;&emsp;当时写文章就想要把 安卓 相关的内容写出来，不过打算还是再深入研究一番之后再写文章总结。 &emsp;&emsp;我目前使用的手机是 一加 5T ，官方安卓系统。&emsp;&emsp;全面屏手势和谷歌原生系统一样，下边框左右是回退，中键上拉是主页，上拉不松手是多任务。&emsp;&emsp;我的手机装了 200 多个 app ，有常用和不常用的。&emsp;&emsp;有很多 app 不想删除，反正 128G 空间还是够用的。&emsp;&emsp;过去我将 app 统统放到桌面，混乱不堪，找起来也很不方便。&emsp;&emsp;因此我需要用 各种快捷的 app 帮助我快速定位到我想要的应用 &emsp;&emsp;我个人追求手机要干净，也就是这些便捷操作的应用绝对不能阻挡到我的屏幕，因此悬浮按钮无隐藏之类的效果，我是无法接受的。&emsp;&emsp;另外使用上尽可能方便，相互之间的调用上不会互相冲突。 &emsp;&emsp;下面提到的 APP 可以在 谷歌应用商店 可以找到 (谷歌应用市场需要翻墙哦) 谷歌应用商店 微软桌面 Jina抽屉 Pie Control FV悬浮球 (也可以在 酷安应用市场 下载) 老王VPN &emsp;&emsp;当然这些 APP 会涉及到一些用户权限的获取，如果是隐私和权限重度 ptsd 用户不建议使用&emsp;&emsp;另外推荐的这些 app 大多数是后台常驻的，因此耗电量也会有一定的增加，这个也是不可避免的。 微软桌面 &emsp;&emsp;其实我觉得一加系统里面的启动器就已经很棒了。上大二之前用的是华为手机。(是充话费送的荣耀手机)&emsp;&emsp;那个时候也没有刻意专研，但是老安卓似乎是没有上拉查找应用的功能的。&emsp;&emsp;虽然一加一直被人诟病系统功能很少太干净，我觉得还是挺够用的，也不会有全家桶，广告也基本没有，当然一些常用的第三方软件还是自带的。 &emsp;&emsp;不过最后还是决定切换官方的启动器，因为我之前用得很混乱，整个桌面堆满了杂七杂八的 APP。&emsp;&emsp;也懒得删除，说不定还有比官方更好用的启动器，于是我就去 谷歌应用商店 下载了一些去尝试。 &emsp;&emsp;在我眼里的启动器只要能够还原到 原生启动器 的功能就很满意了,如果还有些亮点就锦上添花了。&emsp;&emsp;我希望启动器能够含有两个功能，一个是抽屉寻找应用、还有一个就是左侧能有一个放置卡片下拉滚动的页面。&emsp;&emsp;谷歌原生系统是有的，但是貌似现在流行的启动器都把这个功能给去掉了。 &emsp;&emsp;我安装了 Nova启动器 、poco桌面 、微软桌面&emsp;&emsp;Nova启动器 和 poco桌面都缺少了我想要的额外卡片页面，微软桌面有。&emsp;&emsp;poco的app搜索界面含有分组，还可以通过颜色去快速查询app，我觉得这个功能非常帮你。&emsp;&emsp;而微软桌面快捷栏，可以放 app 以及快速调整亮度的功能，左侧也有卡片页面。&emsp;&emsp;只可惜搜索页面的功能比较普通，我希望能够将 poco 和 微软桌面的功能合并到一起就好了。&emsp;&emsp;最后综合考虑还是喜欢微软桌面多一点，应用分类的问题可以通过 Jina抽屉 帮我解决。 快捷栏 &emsp;&emsp;快捷栏分上下两个地方，横向放 app 的数量和 app 的大小可以在 微软桌面的设置里面调整。&emsp;&emsp;我一般使用 5 个，太多图标太小不习惯。上拉打开快捷栏还可以有 5 个 app 的空间。 &emsp;&emsp;下面可以选择手机小部件或者搜索框，小部件其实我也不太常用，后置指纹下滑就可以打开手机的通知栏了。&emsp;&emsp;不过看着舒服我就留着了。 应用红点 &emsp;&emsp;以前 一加 的官方桌面的 app 只能有红点提示。&emsp;&emsp;微软桌面就可以将红点切换为通知的数量了，虽然我的桌面一个 app 都没有了，我还是觉得这个功能很赞！~ 卡片页 &emsp;&emsp;卡片页可以将手机各种 app 的微件集中放到此处，就不用各个页面找微件去设置了。&emsp;&emsp;我一般将 谷歌 日历放到第一位方便我去设置一些日常的安排。 桌面手势 &emsp;&emsp;另外微软桌面还提供了桌面手势的功能 &emsp;&emsp;我保留了 一加 原本带有的 桌面下拉打开通知栏。&emsp;&emsp;另外就是桌面双击打开 Jina抽屉 快速打开其他应用了。&emsp;&emsp;其他操作用的少了。 Jina抽屉 &emsp;&emsp;上面微软桌面就已经有提到 Jina抽屉了。&emsp;&emsp;Jina抽屉对于拥有众多 app 的我来说简直就是神器。&emsp;&emsp;再也不用为乱糟糟的 app 分类做的文件夹摆到桌面导出都是。&emsp;&emsp;Jina抽屉可以制作应用文件夹给应用加标签归类，最重要的是Jina界面在app内部，就不需要污染到桌面了。(洁癖患者的福音) APP 分类 &emsp;&emsp;这个应用有自动分类的功能，但是通常都不能满足自定义的需求，因此我是自己建文件夹把 app 放进去的。&emsp;&emsp;由于我 app 比较多，当时整理起来的确花了不少时间，但是整理好了之后效果是显而易见的。 &emsp;&emsp;Jina抽屉还可以有不同的排序已经标签分类，也可以定制化显示外观，但是这些功能不都不太常用。&emsp;&emsp;只要能满足帮我快速找到我想要的 app 就够了，什么过滤分类的都是辅助功能，太复杂学起来也头疼。 侧边栏快速启动 &emsp;&emsp;如果app还是需要打开抽屉才能快速打开应用其实我觉得还差点意思的。&emsp;&emsp;但是Jina的强大就在于它提供了悬浮层的多重支持！启动应用超方便！(当然这个功能默认是没有开启的，需要手动开启) &emsp;&emsp;左侧拉动可以打开 Jina侧边栏，左边是所有 app ，可以点击搜索。右边是收藏栏，收藏的 app 显示在右边的侧边栏。&emsp;&emsp;额外吐槽一句，Jina app内部的搜索很卡，反而是侧边栏的搜索是动态的，体验要好很多。(我几乎不打开 Jina抽屉 app 的，因此对我没有影响)&emsp;&emsp;侧边栏的位置和高度是可以设置的，我为了保证不和其他app冲突，因此放到下面触发。 &emsp;&emsp;这个功能在 Jina抽屉 的设置里面有，可以在 抽屉无处不在选项上进行设置。&emsp;&emsp;Jina抽屉的缺点就是无法将 app 拖动到桌面，因此还需要微软桌面的app搜索辅助支持。 文件夹悬浮窗 &emsp;&emsp;最后 Jina抽屉 还提供了 app微件 来快速打开对应的文件夹，甚至可以设置为悬浮层，方便到飞起。 &emsp;&emsp;这个微件启动悬浮窗原本是放在桌面点击才可以，但是可以通过其他的 app 来调用。&emsp;&emsp;桌面上我在微软桌面的手势中添加双击唤起 文件夹悬浮窗 。&emsp;&emsp;而 FV悬浮球 唤出 文件夹悬浮窗，甚至不用回到桌面就可以直接去到其他 app 上。 FV悬浮球 &emsp;&emsp;上面刚好提到了 FV 悬浮球，这个应用简直就是全能神器，功能覆盖到 安卓的所有 模块。&emsp;&emsp;甚至 安卓自动化操作都有 ，这绝对是我最推荐的安卓 app ，功能太强大，吊打所有的悬浮球工具。&emsp;&emsp;如果用我 windows 效率提升指南的文章的软件做比喻&emsp;&emsp;这个 app 相当于 screentogif 、 snipaste 、 Ditto 、 quicker识图 的综合集合体，还自带浏览器功能。&emsp;&emsp;功能之全面和好用，完全刷新了我对 安卓 手机的认知。&emsp;&emsp;而且这个应用是完全免费的，国产无广告，这么良心也是让我叹为观止。 &emsp;&emsp;另外这个悬浮球可以隐藏到手机边缘，不用担心屏幕阻挡和 oled 屏幕烧屏。洁癖赛高~&emsp;&emsp;默认状态下悬浮窗是不开启隐藏的，需要手动设置一下。 &emsp;&emsp;开启了之后就可以将悬浮球隐藏到边缘，并且可以通过拨动悬浮球让悬浮球保持显示状态。 &emsp;&emsp;默认的手势网上拉可以打开 FV悬浮球 APP 主界面 &emsp;&emsp;悬浮球的主界面，默认悬浮球网上拖就可以打开。&emsp;&emsp;这个界面类似于 微软桌面 的 卡片页面，也可以将应用的 微件 放到这里。&emsp;&emsp;还可以通过这个界面找到很多 FV悬浮球的功能 ，不过下面我只介绍一些我常用的好用的功能。&emsp;&emsp;剩下的还需要大家来摸索。 截图 &emsp;&emsp;截图真的非常方便，可以像电脑的 snipaste 随处截图，也可以识别得到当前截图的紫红色区域范围。&emsp;&emsp;如果悬浮球保持不动则可以变成黄色的自定义截图区域。 &emsp;&emsp;截图完成之后也可以对图片进行修改，有马赛克工具也有文字编辑、箭头图标。&emsp;&emsp;截完图可以重新调整截图的区域，或者通过图片编辑功能对截图进行裁剪。&emsp;&emsp;还有撤销功能。 录屏 &emsp;&emsp;自带录屏功能&emsp;&emsp;可以区域录制，录制完成之后可以对录制的视频长度进行修改，也可以像截图一样添加文字信息。 自动识别 &emsp;&emsp;截图自带 OCR 文字识别，可以炸词以及分享。 剪贴板 &emsp;&emsp;自带 剪贴板浮窗 记录复制的信息，&emsp;&emsp;不过百度输入法也有相关的功能，只是 FV悬浮球 更加方便。 滑动手势 &emsp;&emsp;上面是我设置的 滑动手势 参考，我设置往下拉就是打开 应用切换器 应用切换器 &emsp;&emsp;应用启动器可以快速启动一些操作。&emsp;&emsp;比如上面放置的有 切换键盘 、 录屏 、 扫码 等等的操作。&emsp;&emsp;调用起来很方便。 自定义任务 &emsp;&emsp;自定义任务的存在是最让我吃惊的。&emsp;&emsp;没想到小小的悬浮球居然还可以实现 自动化 。&emsp;&emsp;当然要实现这些功能就几乎要把所有的应用权限都开起来才行，不过使用起来是真的好用。 &emsp;&emsp;上面的操作就是我用来到 喜马拉雅 软件上面签到的自定义任务&emsp;&emsp;同样的方法还可以设置 支付宝 、 京东 都可以，它可以模拟安卓的手势操作，完全仿生。&emsp;&emsp;你甚至可以实现开屏通过手势操作来解锁手机，然后进行相应的操作。&emsp;&emsp;支持 定时 、 地点 、 特定应用页面 、 系统特定反馈 的自动化操作任务。&emsp;&emsp;我最初不知道 轻启动 的时候，也是利用 自定义任务 给我自动点击 APP 跳过的按钮。(只不过每一个应用都有加到判断条件里面，还挺累的) Pie Control &emsp;&emsp;这个应用是我最常用的应用，因为启动便捷快速，一步到位，比起 Jina抽屉 和 FV悬浮球 的启动还要快速。&emsp;&emsp;Jina抽屉需要拉出侧边栏再点，FV悬浮球的拖动点击也需要等待时间，而 Pie Control 滑动即可快速启动，速度要快一些。&emsp;&emsp;我刚换手机那会就开始使用这个 App 了，因此很多操作已经习惯了。 &emsp;&emsp;在 Pie Control 的设置里面可以添加 文件夹 、 网页 、 基本的系统操作 以及 app 的相关启动。 &emsp;&emsp;也可以设置侧边触发区域的范围。&emsp;&emsp;还支持边角触发，只是和我的全面屏手势有冲突，而且我以前也不习惯这么用。 老王VPN &emsp;&emsp;最良心的免费 VPN ，从谷歌的好评数即可见一般。&emsp;&emsp;虽然有时候网速不是很给力，但是能稳定科学上网就很不错了。&emsp;&emsp;免费的体验很多时候比 付费的 VPN 体验还好，真的没什么可说的。(没错，吐槽的正是 Nord VPN) &emsp;&emsp;当然翻墙的高端玩法都是使用 国外的 VPS 搭建翻墙服务的。&emsp;&emsp;或者购买被人搭建好的 VPS 服务的。&emsp;&emsp;但是对于懒得折腾的人来说，老王VPN就是很不错的选择。]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>🚀效率</tag>
        <tag>࠱Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya2017 材质面板打开报错空白]]></title>
    <url>%2Fposts%2Ff862fce.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在使用 Maya2017 的时候，偶尔会遇到 材质面板 完全空白并且报错的情况。&emsp;&emsp;过去一般的解决方案就是删除我的文档的 maya 目录，让个人设置回到默认就不会有问题了。 官方链接参考 &emsp;&emsp;只不过这个问题我遇到很多遍了，每次都要清理 个人设置 还是太麻烦了。&emsp;&emsp;于是我就想搞清楚是什么原因导致这个报错的，刚好最近有遇到了这个问题。&emsp;&emsp;于是我将有问题的个人设置保存下来，然后和默认的个人设置进行比对，看看问题再哪里。 文件定位 &emsp;&emsp;我之前的文章里面有详细介绍 Maya 我的文档 里面各个文件夹分别存放的东西。&emsp;&emsp;其实仔细定位可以发现，个人设置都存在 prefs 文件夹里面，删除这个文件夹也可以修复问题。&emsp;&emsp;因此可以进一步定位到底是这个文件夹里面的什么文件导致出错。 &emsp;&emsp;我首先将和文件夹意外的文件用错误的设置文件全部覆盖了一遍。 &emsp;&emsp;结果复现了报错。&emsp;&emsp;因此可以将问题文件锁定在 外部这些零碎的文件上。&emsp;&emsp;这些文件中 userPrefs.mel 文件最大，而且大小差异也很大。&emsp;&emsp;于是也走了一遍替换测试的流程，结果发现就是这个文件导致问题。&emsp;&emsp;于是我打开 userPrefs.mel 查看里面的代码。 &emsp;&emsp;我发现里面全部是 optionVar 的 mel 语言全局变量。&emsp;&emsp;很多设置都直接和首选项里面的设置挂钩。&emsp;&emsp;于是我用 vscode 对比文件差异 &emsp;&emsp;但是两个文件差异实在太多了。&emsp;&emsp;一行一行对比显然是不现实的。&emsp;&emsp;于是我从窗口打开的报错开始进一步的追踪。 报错追踪1// Error: file: C:/Program Files/Autodesk/Maya2017/scripts/others/hyperShadePanel.mel line 10082: windowPref: Object 'hypershadeBrowserPanel' not found. // &emsp;&emsp;打开报错的文件，可以找到报错的语句 1windowPref -q -h hypershadeBrowserPanel &emsp;&emsp;这个是记录窗口设定的命令，于是我也在 prefs 文件夹下搜这个命令。&emsp;&emsp;发现这个命令全部记录在 windowPrefs.mel 文件里面，而且缺失的 hypershadeBrowserPanel 也是有 mel 语句的。 &emsp;&emsp;这就让我懵逼了，于是我在错误的 Maya 下查询这个变量是否存在。 12windowPref -topLeftCorner 250 200 -widthHeight 750 215 -maximized false -parentMain true hypershadeBrowserPanel;windowPref -q -ex hypershadeBrowserPanel &emsp;&emsp;奇怪的情况发生了。&emsp;&emsp;在错误的 Maya 中，即便运行上面的代码也依然返回 hypershadeBrowserPanel 不存在。&emsp;&emsp;但是明明上一行就已经配置了相关的属性了。 &emsp;&emsp;于是到了这里思路就断了，只好再去研究是什么属性导致 windowPref 不起作用了。 userPrefs.mel 追踪 &emsp;&emsp;最开始我是搜索 hypershade 关键字。&emsp;&emsp;逐一排查，发现代码里面有一大段和 hypershade 相关。&emsp;&emsp;于是我将运行正常的代码复制进去运行，然而并没有解决问题。 &emsp;&emsp;然后我又去找 window 关键字(windowPref 找不到东西)&emsp;&emsp;逐一追踪看看语句是否有差别。&emsp;&emsp;然后就追踪到了 saveWindowPos 属性 是有差别的 ， 错误的文件没有开启&emsp;&emsp;这个属性就是首选项中的 记录窗口位置选项。&emsp;&emsp;于是我就将这个选项勾上，奇迹就发生了， hypershade 正常打开了。 &emsp;&emsp;默认情况下这个选项是勾选的，如果不勾选在 Maya2017 就无法打开 材质编辑器 了。 总结 &emsp;&emsp;后续我去测试了 Maya2018 ，发现官方已经将这个 BUG 修复了。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 中文乱码坑]]></title>
    <url>%2Fposts%2F53fbd124.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这次遇到的问题不是我亲自遇到的，不过我也参与了问题的研究。&emsp;&emsp;最后的解决方案已经写在上面了，这里只是记录一下我们填坑的经过。 Maya 中文乱码 &emsp;&emsp;问题如上图，Maya的中文显示全部为乱码。 &emsp;&emsp;我首先联想到了以前弄 Maya 工具架的坑。&emsp;&emsp;Maya 工具架的代码 存在 我的文档的 prefs的 shelves 文件夹里面&emsp;&emsp;通过 mel 代码存储， Maya 默认的存储格式跟随系统，字符为 gbk&emsp;&emsp;我曾经在工具架的图标代码里面写入了一大堆生成界面的代码，后面因为要修改工具架。&emsp;&emsp;又将工具架的 mel 文件通过 vscode 处理保存为了 utf-8&emsp;&emsp;结果 Maya 读取 mel 的中文就全部变成了乱码。&emsp;&emsp;点击工具架生成图标之后生成的界面也是乱码。&emsp;&emsp;因此我一开始是从这个角度去尝试寻找解决方案。 &emsp;&emsp;总之，无论如何也要找到菜单生成界面的代码，看看里面的编码格式是否存在问题。&emsp;&emsp;我就找了一下 prefs 文件夹下面，貌似自定义菜单是没有存储到 mel 的操作。&emsp;&emsp;一般自定义菜单都是开启了 Maya 之后通过 mel 命令添加上去的。 &emsp;&emsp;果不其然，这个问题和我上面遇到的坑是不一样的。&emsp;&emsp;这次是纯粹的中文，而且上面已经定义了这个文件使用 gbk 编码格式，因此这个写法应该没有问题。&emsp;&emsp;于是我再次确认，这个插件显示问题是一台机器的问题还是全部机器的问题。 &emsp;&emsp;回答是只有当前这台机器有问题，因此可以锁定在当前电脑系统环境下的问题。 问题详情 &emsp;&emsp;问题情况也远远比我想象得还要严重得多！ &emsp;&emsp;Maya 运行启动脚本打印输出也是乱码。&emsp;&emsp;我怀疑是不是系统的语言不是 中文 ，但是又使用了 gkb 编码导致乱码。&emsp;&emsp;于是我让她用 python 输出一下当前系统的语言环境。 1234from PySide2 import QtCoreprint QtCore.QLocale.system().name()import localeprint locale.getlocale() &emsp;&emsp;然而输出的系统语言信息很正常。 &emsp;&emsp;结果这个反馈给到我真的是让我惊呆了。&emsp;&emsp;没想到所有的中文打印都是乱码，唯有 gbk 解码才正常 !!!∑(ﾟДﾟノ)ノ 寻找解决方法 &emsp;&emsp;首先我想到的是 Maya 版本的问题。&emsp;&emsp;删除我的文档的 Maya 文件夹，还原 Maya 配置, 然而反馈问题依旧。&emsp;&emsp;而且无论是 Maya 2015 还是 2017 都有同样的问题。 &emsp;&emsp;于是我想到可能这个问题和 Maya 没有关系。&emsp;&emsp;于是我让她检查一下 python 环境下的是否输出乱码。 &emsp;&emsp;Maya无关石锤了，这个原生 python 输出居然也是乱码。&emsp;&emsp;其实到这一步，我的思路已经断了(:з」∠) &emsp;&emsp;好在她发现这个 windows 命令框的字体很小，显示不太对劲。&emsp;&emsp;于是又看了一下系统的字体库。 &emsp;&emsp;这个系统居然只有三个字体，和左边的正常电脑查了那么多。&emsp;&emsp;于是就是安装字体的过程了。&emsp;&emsp;安装完字体还是不行的，重启了电脑之后才解决了问题。 总结 &emsp;&emsp;最后的解决方案其实也不是我的功劳，我当时思路已经没了，好在最后还是解决了。&emsp;&emsp;整个流程下来，感觉 Maya 排错还是可以总结出一套方法论的。&emsp;&emsp;下次遇到类似的问题就有经验了。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 模块安装探讨]]></title>
    <url>%2Fposts%2Fe3ab7e13.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近综合别人写的插件，弄了一个自己的小插件 ———— CommandLauncher&emsp;&emsp;为了实现更好的安装体验，特意对 Maya 安装插件的各种方法逐一进行探讨归纳和总结 &emsp;&emsp;在过去安装 Maya 脚本的体验大都比较难受，比如需要拷贝代码到 Maya脚本编辑器 然后执行代码&emsp;&emsp;这对于大多数没有编程经验的美术人员来说是个可怕的门槛。&emsp;&emsp;因此我这里探讨的安装方案都是永久安装，下次打开 插件 依然存在。 &emsp;&emsp;Maya安装插件有如下几种方法 生成工具架图标 ✪ 添加 Mod 文件调用插件 ✪ Autodesk ApplicationPlugins &emsp;&emsp;带 ✪ 的方法的核心思想都是利用 modules 处理，只是Maya比较灵活，可以通过不同方式实现&emsp;&emsp;因此 ✪ 安装的方法都可以称之为 模块安装&emsp;&emsp;最后再推荐一下 rj 大神的模块安装脚本 github &emsp;&emsp;看本文章之前建议先 预览一下 Maya 文档关于 Maya 自定义的内容 和 插件发布的内容 自定义设置 插件发布&emsp;&emsp;当然也可以看完文章再去看文档，总之文档很重要，希望大家学习的时候多看看官方文档的说明。 Maya 模块机制 &emsp;&emsp;要做到持久化安装，很重要的一点就是需要将数据存储到本地，然后让 Maya 执行的时候可以调用到这些数据。&emsp;&emsp;为了规范化整个流程，Maya 推出了 模块化 插件的概念。&emsp;&emsp;这种方式的安装方法是 Maya 官方更加推崇的，更加值得使用的。 Maya官方文档 多文件模块 &emsp;&emsp;根据文档，一个模块应当包含四个文件夹以 及 模块描述文件 icons 放置模块图标 plug-ins 放置 mll 插件 presets 放置预设参数 scripts 放置 mel &amp; python 脚本 &emsp;&emsp;模块描述文件的后缀为 mod 文件，可以定义 模块 的路径、Maya版本、不同平台等的不同不同行为。 文档&emsp;&emsp;通过模块描述文件就可以让模块的载入更加智能。&emsp;&emsp;文档里面有一个例子 + MAYAVERSION:2016 PLATFORM:win64 LOCALE:ja_JP CustomModule 3.10.5 ..\CustomModule\Modules\win64 Maya版本为2016 在windows平台下 Maya使用日语 模块的名称 版本号 模块的加载路径 (相对路径相对于mod文件的路径) scripts: ..\..\CommonFiles\scripts 定义 scripts 调用的目录 &emsp;&emsp;指定的加载路径就需要有 上面所提的四个文件夹来处理模块中不同的部分。&emsp;&emsp;定义了不同的载入条件之后，就可以通过调整 Maya 环境变量的方式来添加设定了。&emsp;&emsp;你可以在 Maya 的安装目录下的 modules 找到官方插件的 mod 文件。 1234+ LOCALE:en_US MASH 1.0 ..&#x2F;plug-ins&#x2F;MASHPATH+:&#x3D;binMAYA_CONTENT_PATH+:&#x3D;MASH Examples[r] scripts: scripts &emsp;&emsp;上面的 mod 含义就是 当前 Maya 为 en_US 英文版&emsp;&emsp;环境变量 PATH 添加 当前目录的 bin 目录&emsp;&emsp;MAYA_CONTENT_PATH 添加 MASH Examples 目录&emsp;&emsp;[r] 标记是指递归遍历目录的意思，即 scripts 目录下的所有目录，只有含有 .前缀的文件夹会被隐藏 比如 .git .vscode&emsp;&emsp;:= 表示添加模块的相对路径， += 表示添加数组元素而不是覆盖变量数据 123456789101112131415161718getenv "MAYA_SCRIPT_PATH"......D:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/apiclientD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/fluxD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/googleapiclientD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/httplib2D:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/MASHD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/MASHAETD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/MayaToAED:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/oauth2clientD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/uritemplateD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/flux/aeD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/flux/resourcesD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/flux/uiD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts/flux/resources/iconsD:/Program Files/Autodesk/Maya2018/plug-ins/MASH/scripts...... &emsp;&emsp;执行 getenv 命令可以获取到存入的 script 目录，可以看到添加 [r] 标记之后会遍历所有的目录添加到 MAYA_SCRIPT_PATH 环境变量中。 Maya 环境变量Maya 环境变量 官方文档 &emsp;&emsp;Maya 的环境变量类似于 系统的环境变量设置，只不过是针对 Maya 的环境设置的。&emsp;&emsp;可以通过 mel 语句的 getenv 和 putenv 来设置 Maya 的环境变量&emsp;&emsp;也可以将环境变量设置到系统的环境变量当中(非常不推荐这个方案，只是Maya也会一并获取所有的系统变量到自己的环境变量中)&emsp;&emsp;最后还可以通过 Maya.env 文本文件来设置系统变量，Maya.env 在 drive:\Users\username\Documents\maya\version 即 我的文档的 maya 目录里面 &emsp;&emsp;设置方式完全参考当前系统平台的方式，比如 windows 平台 123MAYA_SCRIPT_PATH &#x3D; %MAYA_APP_DIR%\scripts\testMAYA_PLUG_IN_PATH &#x3D; %MAYA_LOCATION%\devkit\plug-ins;%MAYA_LOCATION%\devkit\testTMPDIR &#x3D; D:\tempspace &emsp;&emsp;可以通过 %var% 来获取之前设置的环境变量赋值到其他变量中。&emsp;&emsp;路径分隔符也遵从系统平台的规范。&emsp;&emsp;变量名遵循命名规则，不得含有空格缩进以及特殊符号 / : * “ &lt; &gt; | &emsp;&emsp;在 env 里面设置的变量可以通过 mel 语句的 getenv 获取&emsp;&emsp;= 是赋值 | *= 自动添加一个新的元素 &emsp;&emsp;通过设置环境变量可以对 Maya 很多东西进行自定义，比如说关闭联网登录的 参照我之前转载的文章 加速Maya开启与关闭的方法&emsp;&emsp;还可以开启 Maya 一些过时的功能，比如说打开 viewport 1.0 &emsp;&emsp;另外需要注意环境变量是 PYTHONPATH ，这里添加的目录相当于python的 sys.path.append&emsp;&emsp;我不推荐在环境变量中添加 PYTHONPATH 这个变量设置，用 Python 处理添加会比较好一点，减少环境变量的混乱。 Maya 我的文档 目录官方文档参考 &emsp;&emsp;通过上面介绍的 Maya 模块机制，你会发现 Maya 我的文档 目录 存放了类似的目录也包含了其他的目录。 &emsp;&emsp;这个目录是 Maya 存放用户设置的地方&emsp;&emsp;因此网上有一招万能解决 Maya 启动问题的方法，删除这个文件夹。&emsp;&emsp;一旦Maya启动不了都可以使用这个方法解决问题。&emsp;&emsp;删除这个文件夹之后，Maya再次启动就会重新生成这个文件夹并且生成默认的设置，回到一开始安装的状态。&emsp;&emsp;当然这样的话自己弄的工具架、热键、自定义设置等等的配置全部就没了。&emsp;&emsp;因此删除需谨慎，建议使用改名大法。 官方文档参考 &emsp;&emsp;Maya 目录之下会有不同 Maya 版本数字对应的文件夹，取决于电脑安装了的 Maya 版本&emsp;&emsp;打开数字文件夹如 2017 会有固定的目录层级结构 @ modules 模块文件存放路径 @ * plug-ins 放置 mll 插件 * presets 放置预设参数 * scripts 放置 mel &amp; python 脚本 prefs 首选项设置存储 user.toolclips 自定义工具动画演示 ~ zh_CN 其他语言的选项 Maya.env Maya 环境变量 &emsp;&emsp;如果 Maya 不是英文版的话，只有 Maya.env 和 ~语言文件夹存在&emsp;&emsp;因此需要切换英文版才能看到上面的目录&emsp;&emsp;带 * 号的文件夹和 模块定义的目录是重合的，这里其实也可以看做 Maya 的模块目录&emsp;&emsp;带 @ 号 默认是不存在，但是可以手动创建出来并且起作用。 &emsp;&emsp;下面列举一些常用的文件夹 modules &emsp;&emsp;modules 目录就和 Maya 安装目录下的默认 modules 作用是一样的。&emsp;&emsp;Maya 会读取 modules 目录下的 mod 文件并且让它的设置生效。 plug-ins &emsp;&emsp;这个目录主要存放 mll 文件或者 使用 OpenMaya 编写的插件&emsp;&emsp;Maya会的插件管理器会找寻这些目录，并且生成复选框来勾选反选插件。 scripts官方文档 &emsp;&emsp;Maya 会将这个目录添加到 MAYA_SCRIPT_PATH 环境变量中&emsp;&emsp;如果该目录中含有 userSetup.py 或者 userSetup.mel 命名的文件，开启 Maya 就会自动执行这两种类型的文件。&emsp;&emsp;这就是模块安装的核心步骤，通过 userSetup 文件启动插件！ prefshotkeys 用户自定义的热键 icons 图标文件夹 markingMenus 标记菜单 scriptEditorTemp 脚本编辑器临时文件 shelves 工具架 workspaces 工作区 scripts mainWindowStates &emsp;&emsp;首选项文件存放的目录&emsp;&emsp;里面的 icons 和模块文件夹 icons 一致，添加的图标可以再工具架的图标上直接输入名称获取图标。&emsp;&emsp;其他东西都是用户自定义相关的，如果删除相关文件夹，用户自定义的属性就没了。(比如时候删除 hotkeys 文件夹，那用户自定义的 hotkeys 就没了)&emsp;&emsp;大部分存储的都是 mel 语句，可以查询相关的 mel 命令进行修改。 工具架图标安装 &emsp;&emsp;使用这种方案最具标志性的插件就是 AdvanceSkeleton5 简称 ADV， 有兴趣的同学可以研究一下 ADV 安装脚本 install.mel&emsp;&emsp;安装方法非常简单，将 install.mel 拖到 Maya 的视窗， Maya 就会执行 mel 脚本，通过 mel 脚本在当前工具架上添加了 ADV 的启动图标。&emsp;&emsp;点击启动图标就可以读取到 ADV 安装时的目录，然后调用 ADV 里面的 mel 脚本生成插件界面。&emsp;&emsp;只要 ADV 插件位置没有改变，并且 Maya 之后又是正常关闭的，那每次打开 Maya 都可以通过当时安装的工具架图标开启插件。 图标安装原理 &emsp;&emsp;安装成功之后，可以打开 ADV 的启动图标看看它的启动代码。 1source "D:/Users/xxxxx/Desktop/AdvancedSkeleton5/AdvancedSkeleton5.mel";AdvancedSkeleton5; &emsp;&emsp;其实就是定位到安装时候的目录，然后调用AdvancedSkeleton5.mel 脚本获取到 AdvancedSkeleton5 proc 来执行代码。&emsp;&emsp;因此 install.mel 做的事就是定位到当前脚本的目录位置，然后生成对应的图标，并且将当前的路径输入到图标的执行代码里面。&emsp;&emsp;这里利用 Maya 工具架正常退出是可以保存下来的机制，实现工具持久化存在。&emsp;&emsp;可以再我的文档的 maya 目录 对应版本文件下的 prefs 找到 工具架定义的 mel 文件，正常退出 Maya 会将工具架上的数据覆盖到这里。 mel 获取当前执行脚本路径12345678910111213141516global proc asInstallScriptLocator ()&#123;&#125;global proc string asInstallScriptLocation ()&#123;// NOTE whatIs 命令获取 程序路径 | 返回 Mel procedure found in: D:/xxxx.melstring $whatIs=`whatIs asInstallScriptLocator`;// NOTE 获取 Mel procedure found in: 之后的路径string $fullPath=`substring $whatIs 25 999`;string $buffer[];// NOTE 获取 mel 脚本所在的文件夹int $numTok=`tokenize $fullPath "/" $buffer`;int $numLetters=size($fullPath);int $numLettersLastFolder=size($buffer[$numTok-1]);string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;return $scriptLocation;&#125; &emsp;&emsp;上面这段就是 ADV 安装脚本获取路径的核心代码。&emsp;&emsp;主要还是利用 whatIs 命令获取路径，实在是妙啊~ 添加 Mod 文件调用插件 &emsp;&emsp;其实通过上面模块机制就可以知道 ， 通过设置环境变量 MAYA_MODULE_PATH 可以定义 mod 文件读取的位置&emsp;&emsp;而模块目录下的 scripts 文件夹下的 userSetup.py 或者 userSetup.mel 是可以启动时被执行的。&emsp;&emsp;因此基于这个原理就可以创建一个带 scripts 的文件夹，然后将环境变量指向到该文件夹来初始化插件。 &emsp;&emsp;mod 设置可以区分 Maya 版本 语言，是更好的安装插件方式。&emsp;&emsp;官方最推荐的安装方案就是通过 mod 来安装，毕竟定义不同的模块更加方便文件的区分。&emsp;&emsp;我的文档其实也可以看做一个特殊模块文件夹。&emsp;&emsp;以前我野路子安装统统弄到 我的文档 里面，会把文件搞得十分混乱的。 Autodesk ApplicationPlugins &emsp;&emsp;这个安装方法非常少人知道，我是研究 Command Search 插件的时候才学习到的。 官方下载地址 备用下载地址&emsp;&emsp;不过别后原理其实还是利用了 Maya 的模块规则来做的。 &emsp;&emsp;通过上面的下载地址可以下载一个 msi 安装包，安装完成之后开启 Maya 就会发现 插件自动启动了，方便快捷得一批。&emsp;&emsp;这个安装方式和 Maya 的 bonus 工具箱的安装也是一样的。 &emsp;&emsp;相关的设置说明可以在 Maya 的开发者中心里面找到。 链接&emsp;&emsp;至于怎么打包成 msi 安装包，貌似是需要按照 Autodesk 规范弄好，然后官方会给你打包。&emsp;&emsp;不过官方安装包也只不过是将文件拷贝的 Autodesk 系列软件在系统内的的公用文件夹。&emsp;&emsp;可以通过 command Search 提供的代码来找到这些 python 包在系统的位置。 123import commandSearchprint commandSearch# &lt;module 'commandSearch' from 'C:\ProgramData\Autodesk\ApplicationPlugins\CommandSearch\Contents\scripts\commandSearch\__init__.py'&gt; &emsp;&emsp;可以看到 C:\ProgramData\Autodesk\ApplicationPlugins\ 这个路径就是 Autodesk App 的通用路径。&emsp;&emsp;也可以按照 Autodesk 的规范，写一个 PackageContents.xml 来描述 Maya 插件&emsp;&emsp;这个描述文件可以起到和 mod 类似的作用，判断不同的平台以及添加不同的 Maya 环境变量，并且指定了 Maya 模块的路径。&emsp;&emsp;具体的写法官方也没有详细文档，只是说可以下载一些官方的插件来看写法。 &emsp;&emsp;虽然官方没有提供制作 msi 文件的方法，但是我们自己也可以通过 python 程序将文件复制到对应的目录来实现插件的自动安装。 RJ 大神的 module-installer 方案 &emsp;&emsp;也是非常巧合的，我后来才发现原来 commandSearch 这个插件也是 RJ 大神制作的。 链接 &emsp;&emsp;总之在 RJ 大神的个人网站里面收获匪浅，有通道盒的增强工具，还有增强版的 Maya 减帧工具。&emsp;&emsp;还有今天这里介绍到的 module installer 方案。 github仓库 &emsp;&emsp;其实这个方案就是利用 Maya 的 mod 文件配置的方案，但是通过 mel 文件将整个配置过程自动化了。&emsp;&emsp;核心原理和 ADV 的 mel 脚本方案类似，也需要获取当前 mel 脚本的路径。 首选创建一个 mod 文件，将当前的模块路径命名为 &lt;PATH&gt; mel 脚本复制的时候会自动将路径替换为 mel 脚本的路径。 获取 Maya 的模块路径 和 当前的脚本路径 判断当前的模块是否已经安装，对比 模块文件 的版本信息是否相同 将 mod 文件复制到一个 模块路径下，并且替换 &lt;PATH&gt; 执行模块文件的 userSetup.py 或者 userSetup.mel 来立刻启动插件 输出安装信息 &emsp;&emsp;一套流程已经全部设置好了，自动安装、避免重复安装、以及自启动。 &emsp;&emsp;通过这种方案安装的模块非常方便，而且可以确保 Maya 启动的时候启动插件。&emsp;&emsp;只要启动的时候可以执行脚本就可以将插件安放到 Maya 的任意位置上。&emsp;&emsp;模块越来越多，管理也不好弄， RJ 还针对这种情况制作了一个 模块管理工具 总结 &emsp;&emsp;Maya 安装插件持久化的核心是要解决的是运行指定脚本的问题。&emsp;&emsp;工具架利用的是 Maya 首选项存储的 mel 脚本进行脚本路径指定。&emsp;&emsp;模块化安装则是利用 mod 文件指定启动路径。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 语言切换]]></title>
    <url>%2Fposts%2F6f5d3bd5.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;美术制作人员通常英文水平都不太好，因此不大希望使用软件的英文版本。&emsp;&emsp;但是出于对 Maya 技术支持的考虑，还是使用英文版较为稳定，而且维护起来更加可靠&emsp;&emsp;由于 Python2 对于 Unicode 字符处理的不友好，使用中文很容易导致一些意料之外的问题。 &emsp;&emsp;另外关于 Maya 切换语言的版本其实网上都有相关的文章讲解，这里我总结到一起而已。 方案一 添加环境变量参考链接 &emsp;&emsp;打开 windows 的环境变量编辑器，然后添加 MATA_UI_LANGUAGE 变量&emsp;&emsp;变量可以设置为 en_US (英文版) | zh_CN (中文版) 方案二 修改 Maya 安装目录 l10n 文件夹下的语言名称参考链接 &emsp;&emsp;去到 Maya 的安装目录，可以找到 resources 文件夹&emsp;&emsp;打开 resources\l10n 的目录，就可以知道两种语言的文件夹，将文件夹名称 zh_CN 修改为 en_US 就可以切换为英文版。 两个方案区别 &emsp;&emsp;其实两者实现的效果是一致的，只是如果在系统的环境变量上设置了之后，会影响到所有的 Maya 版本。&emsp;&emsp;如果只是修改文件夹名称则只对安装的 maya 起到修改效果。 &emsp;&emsp;理论上是可以在 Maya.env 文件上添加 MATA_UI_LANGUAGE=en_US 来切换语言，但是我测试并不起作用。&emsp;&emsp;官方文档 官方文档提到 Maya.env 设置语言变量是不起作用的，必须设置系统环境变量。 代码自动切换方案分析 &emsp;&emsp;个人不推荐通过代码修改 windows 下的环境变量，一方面需要管理员权限，而且后续的操作可能会对环境变量造成污染。&emsp;&emsp;系统的环境变量就是个坑，尽量只用来配合 cmd 命令行调用程序，不要将配置放到里面去，否则出错都不知道坑在哪里！~ &emsp;&emsp;当然修改文件夹名字通常不需要系统管理员权限，但是如果 Maya 安装在 默认的 C 盘目录，那恐怕也逃不过这个操作。&emsp;&emsp;其实代码操作非常简单，修改目录名称只需要用到 os.rename 即可，最大的难点就是需要先获取到系统管理员。 系统管理员权限获取 &emsp;&emsp;下面讨论的是围绕 windows 平台，美术制作人员基本不考虑使用其他平台。 通过 runas 手动获取管理员权限 &emsp;&emsp;windows 下可以通过 runas 命令来获取管理员权限，但是这样会有 UAC 弹窗告诉用户。&emsp;&emsp;如果用户是系统管理员会提示是否给程序运行的权限，如果用户不是管理员还会弹出账号密码的输入框。&emsp;&emsp;不过大多数时候有 UAC 窗口也是个好事，至少告诉用户这个操作需要系统权限，用户不爽就不给权限不操作而已。 &emsp;&emsp;其实获取系统权限的方法也是参考网上提供的方案 CSDN&emsp;&emsp;通过网页里面提到的方法可以实现用管理员权限开启 Python 然后用管理员权限跑脚本。&emsp;&emsp;这样就可以另外写一个执行脚本，然后通过管理员权限跑 os.rename 代码来对目录进行更名了。 &emsp;&emsp;不过我觉得这样要多写一个 python 脚本，有点多余，其实可以通过 cmd 命令来修改文件名称的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import osimport sysimport ctypesimport platformtry: from PySide2.QtWidgets import QMessageBox,QApplicationexcept: from PySide.QtGui import QMessageBox,QApplicationdef modifyMayaLanguge(): # NOTE 获取cmd.exe的本地路径 https://stackoverflow.com/questions/49545009 is_wow64 = (platform.architecture()[0] == '32bit' and 'ProgramFiles(x86)' in os.environ) system32 = os.path.join(os.environ['SystemRoot'], 'SysNative' if is_wow64 else 'System32') cmd_exe = os.path.join(system32,"cmd.exe") # NOTE sys.executable 在 maya 里面运行获取到的是 maya.exe 的路径 maya_path = os.path.realpath(sys.executable) bin = os.path.dirname(maya_path) install_dir = os.path.dirname(bin) l10n = os.path.join(install_dir,"resources","l10n") # NOTE 判断当前是否中文版 zh_CN = os.path.join(l10n,"zh_CN") en_US = os.path.join(l10n,"en_US") if os.path.exists(en_US) and not os.path.exists(zh_CN): QMessageBox.information(QApplication.activeWindow(),u'提示',u'当前已经是英文版，无需切换') return # NOTE 执行cmd命令行命令 修改 l10n 文件夹名称 切换Maya为英文版 command = u'rename "&#123;zh_CN&#125;" "en_US" '.format(zh_CN=zh_CN) # NOTE 获取权限改名 result = ctypes.windll.shell32.ShellExecuteW(None, u"runas", unicode(cmd_exe), unicode('/c "%s"' % command), None, 1) # NOTE 返回 5 说明没有提供权限 if result == 5: QMessageBox.information(QApplication.activeWindow(),u'提示',u'没有获取到权限，命令执行不成功') else: # NOTE 修改成功提示框 QMessageBox.information(QApplication.activeWindow(),u'提示',u'Maya 成功切换为 英文版 \n 将自动重启Maya') # NOTE 重启 Maya os.startfile(maya_path) QApplication.quit()if __name__ == "__main__": modifyMayaLanguge() PsExec 静默获取管理员权限PsExec官方文档&amp;下载地址 1234# 基本用法PsExec -u 账户域\账户名称 -p 账户密码 E:/anaconda2/python.exe E:/test/copy_test.py# 示范代码 : 管理员权限打开 cmd 命令行窗口PsExec -u DIGITAL\timmyliang -p 123456 cmd &emsp;&emsp;PsExec 可以通过输入已知的管理员账号密码来获取权限，这样既可以保证美术人员没有权限乱搞也可以让程序带权限运行。&emsp;&emsp;通过 PsExec 调用 Python 也未必有管理员权限，还需要通过上面博客的方式添加到 Python 脚本里面确保获取到了管理员权限。&emsp;&emsp;由于 PsExec 调用的 Python 已经输入过管理员权限密码，因此脚本运行就不会弹出 UAC 权限窗口。 &emsp;&emsp;使用 PsExec 调用共享路径的 Python.exe 会导致错误，有可能不是本地调用的缘故&emsp;&emsp;可以借助 cmd /c 命令来外调 Python 脚本 1PsExec -u DIGITAL\timmyliang -p 123456 cmd /c \\10.99.1.4\ftdy\hq_tool\programs\python\Python2.7.11\python.exe E:/test/copy_test.py 总结 &emsp;&emsp;Maya 设计有个不太好的地方就是语言切换没有使用 Qt 的 i18n 而是弄了 l10n，导致切换语言要重启 Maya 还是挺不方便的。&emsp;&emsp;当然如果不打开Maya的前提下成功执行了脚本，就不需要重启了。&emsp;&emsp;但是 Maya 对应的版本以及本地路径还是需要有的，如果不在一个运行的 Maya 中获取，很容易出问题(:з」∠)]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有云搭建]]></title>
    <url>%2Fposts%2F3c1dd960.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近因为疫情导致远程工作的问题，导致共享目录smb无法远程使用。&emsp;&emsp;因此交换文件非常不方便，最初的确可以通过宝塔面板的文件操作界进行文件共享，但是这样就把服务器裸奔给了其他人。&emsp;&emsp;有没有方法实现个人云盘共享文件呢？&emsp;&emsp;于是经过一番搜索之后，还是找到比较让我满意的方案。 可道云 &emsp;&emsp;可道云算是国内比较不错的私有云构建开源方案了，系统架构是基于 PHP＋Jquery&emsp;&emsp;完全模拟云上操作系统的概念，支持WPS文档打开，还有应用桌面，通过前端模仿了windows的界面。&emsp;&emsp;交互上来说非常友好。&emsp;&emsp;当然也可以类似百度网盘一样设置共享链接来共享文件，特别棒。&emsp;&emsp;缺点就是没有 WebDav 服务，作为个人云盘可以，但是如果作为一些第三方使用的存储媒介就差了点意思。 安装官网参考 &emsp;&emsp;首先在宝塔界面上创建一个网站，宝塔会在指定目录下构建好 php 环境和服务器访问配置文件。&emsp;&emsp;然后去到可道云的官网下载安装包压缩包，解压到宝塔界面指定的目录，然后将权限设置为所有人都可以访问就可以了，宝塔一定要在该目录下允许 php 代码执行。&emsp;&emsp;这个云上空间会将文件保存到自身的data目录下，甚至不需要数据库的支持。 123456# 下载wget http://static.kodcloud.com/update/download/kodexplorer4.40.zip# 解压unzip kodexplorer4.40.zip# 开权限chmod -Rf 777 ./* NextCloud &emsp;&emsp;NextCloud是全球知名的私有云构建开源方案了，和可道云一样采用了 PHP 框架。&emsp;&emsp;另一个有名的是 OwnCloud 听说是同一个作者，只是 OwnCloud 被原作者卖出去了。&emsp;&emsp;NextCloud 对于国人不太友善但是功能比较全面，同样支持网盘类的分享还支持 WebDav ，使用开源软件进行同步的时候都非常方便。&emsp;&emsp;比如说密码专用的 Keepass2Android 和 开源笔记 Joplin 都支持将文件通过 NextCloud 进行同步。&emsp;&emsp;构建方法和可道云大同小异，并且还有更加完善的手机和桌面客户端 安装官网参考 &emsp;&emsp;安装方法几乎和 可道云 没有区别只是多了一个数据库接入，也可以选择使用sqlite自动配置。&emsp;&emsp;第一种方法也是压缩包安装，第二种方法就是通过一个 php 脚本下载压缩包到本地安装(下载速度有点堪忧，不建议使用)&emsp;&emsp;安装完成简单在浏览器上配置即可使用。 WedDav &emsp;&emsp;WebDav默认访问路径就是 remote.php/WebDav/文件目录&emsp;&emsp;通过这个目录即可访问存放在 NextCloud 的文件，可以用管理员账户多设置几个权限账户来分别管理不同的 Apps&emsp;&emsp;避免密码泄露，私有云完全被别人利用了。&emsp;&emsp;另外补充一下 Joplin 云端同步需要安装 NextCloud 的插件，安装方法也是很简单，下载解压到指定目录即可。 公司内网构建私有云踩坑 &emsp;&emsp;内网构建私有云遇到了天坑。&emsp;&emsp;公司的内网推荐使用公司的特制的 tLinux 2.2 版本，&emsp;&emsp;结果配置完成之后发现 PHP 无法执行，执行报错提到一些公共库找不到路径，但是这些公共类似 Windows dll 是个系统都有的。 &emsp;&emsp;经过各种踩坑也无法解决，而且很多库更新也因为无法链接外网进行更新。&emsp;&emsp;尝试下载其他版本的 PHP 却又报错，找不到下载链接。&emsp;&emsp;最后无奈只好选择重装宝塔面板，经过我的一波折腾，总算是成功重装宝塔界面重新配置了下载源下载了其他版本的 PHP&emsp;&emsp;然而运行起来的报错还是没有变。&emsp;&emsp;网上搜索的方法是需要安装特定的包就可以了，但是我安装用的阿里云地址却是无法访问，后来装成 网易的也无法访问。&emsp;&emsp;最后在再折腾腾讯自己的Linux yum源，后来查看共享 yum源，和服务器找不到路径的地址进行对比。&emsp;&emsp;发现服务器莫名其妙访问了 2.2 版本的目录，但是Linux 最低版本也得从 4.4 开始的。&emsp;&emsp;发现这个惊天秘密之后，于是去到源地址记录的文件查找，发现这个地址记录的 2.2 是个变量，读取的是则是当前系统的版本。&emsp;&emsp;然而内网的 Linux 不是标准的 Centos7 而是 2.2 版本，于是我手动修改了地址信息，总算是可以下载包解决问题了(:з」∠) &emsp;&emsp;解决了 Php 无法启动的问题，后续搭建私有云的操作也算是顺畅无阻了，只是内网构建私有云真的没啥用，内网也是有内部网盘的，也可以基于企业微信存文件(:з」∠) 总结 &emsp;&emsp;搭建了私有云之后，我再也不需要付费的App搞各种乱七八糟的同步了。&emsp;&emsp;全部可以使用开源方案实现免费同步(当然服务器本身是要钱的，但是掌握了技术之后就不需要交那么多了)&emsp;&emsp;开源免费，就是宝贝~]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>࠴编程/后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 法线解锁进阶]]></title>
    <url>%2Fposts%2F513460b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;几个月之前，我曾经写了一篇文章，针对蛋疼的 Maya 法线解锁问题。&emsp;&emsp;主要起因是 FBX 可能没有导出平滑组，导致Maya解锁法线会丢失法线数据。 &emsp;&emsp;当时的解决方案可以自动找到软边，然后进行平滑边操作，但是如果模型包含一些特殊修改的法线的话就不奏效了。&emsp;&emsp;为了解决这个问题，我又进行了多方面的努力。 Maya脚本 &emsp;&emsp;将代码拷贝到 Maya 运行即可获得一个解锁法线页面 平滑查找 &emsp;&emsp;这次的解锁法线会自动计算当前模型边是否否和平滑法线的角度，针对边法线的情况发成了两种情况 点平滑 边平滑 &emsp;&emsp;点平滑就是完全 average 平均化的顶点，这种顶点的法线就是完全重合并且取的是这点四个面的法线平均值。&emsp;&emsp;而边平滑的情况则是这个边上的两个点的法线分别是这条边相邻的两个面的法线平均值。&emsp;&emsp;通过上述的两种情况判断，就可以找到所有的平滑边和点。&emsp;&emsp;不符合上述的两种情况就是特殊调整边或者硬边，这里不需要做区分，因为硬边也不会被锁定，所以执行软化边也没问题。&emsp;&emsp;而且特殊锁定的顶点解锁之后其实就是读取了 OpenMaya 的 isSmooth 方法，如果方法返货 false 就自动是硬边了。&emsp;&emsp;因此特殊调整过的就不属于软边的范畴。 &emsp;&emsp;通过上面的方法就可以相对完美解决 3dsMax 软件导入模型到 Maya 之后丢失法线修改信息的问题。&emsp;&emsp;只可惜上述的方法求平均值比较存在较大的误差，因此需要添加一个阈值来锁定判断的范围，这个阈值范围就比较玄学了。&emsp;&emsp;基本原理其实和上一篇文章相差不大，另外就是多了调用 OpenMaya 的 setFaceVertexNormals 方法来批量修改模型法线而已，区别并不是很大。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 效率提升指南]]></title>
    <url>%2Fposts%2Ffcc8e205.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;目前主力用 windows 平台，因此推荐 windows 平台的软件为主。&emsp;&emsp;之前找到一篇文章介绍的工具，这个真的非常受用 少数派 &emsp;&emsp;下面推荐的大部分软件都是这篇文章里面介绍到的。&emsp;&emsp;大家也可以参考一下少数派文章里面的介绍，我这里着重介绍一些我常用的点 &emsp;&emsp;当然这些效率软件有一定的学习成本，属于熟能生巧，工多手熟的范畴，也不一定适合所有人，大家可以按需安装使用。&emsp;&emsp;这一期文章原本是去年（2019年） 11月份就想开写的，最后还是折腾了3个月，完全将这些软件都用熟悉了之后再写。&emsp;&emsp;目前提到的这些工具就是我这三个月主推并一直在使用的工具，我会重点分享自己对这些工具使用感悟。 &emsp;&emsp;这些辅助软件有个缺点就是缺少一个管理软件，如果可以将所有的功能都打包到一起也是挺好的。&emsp;&emsp;安装起来的话就需要大家一个一个去找来下载。 &emsp;&emsp;另外这些辅助插件的确会一定程度的拖慢了电脑的开机速度，而且会导致一大堆后台图标留在电脑下方&emsp;&emsp;使用之前需要自行斟酌。 &emsp;&emsp;最近在 B站上找到了一个专注于提升电脑效率的网站，里面介绍很多东西也非常受用 B站 网站 腾讯桌面管理腾讯桌面管理 官网地址 &emsp;&emsp;可能腾讯系的产品都是有原罪的，只要听到是腾讯出品，必定减分(:з」∠)&emsp;&emsp;但是这次的桌面管理软件属实弄得很好，而且对于全家桶ptsd患者来说还有独立版本安装的福音。&emsp;&emsp;这么良心的产品，希望大家不要带着偏见去用~ (少数派也有相关的推荐文章) &emsp;&emsp;使用也非常简单，只需要安装，就会自动拯救你乱糟糟的桌面。&emsp;&emsp;而且还可以将文件夹目录映射到桌面的格子上，非常方便。 &emsp;&emsp;这个就是经过整理的桌面，配合下面的 listary 启动器，找东西方便太多了。 listarylistary 官网地址 &emsp;&emsp;listary本质上是一个程序启动器，配合腾讯的桌面整理，找东西如有神助。&emsp;&emsp;当然网上也有 Wox 启动器 配合 history 来实现 listary 的效果，我目前还没有体验过，不过我觉得 listary 一个软件相较之下更加简单。 快速搜索 &emsp;&emsp;listary 使用也非常简单，按两下 Ctrl 键即可唤起输入框。&emsp;&emsp;在输入框上输入相应的关键字就可以进行文件搜索，会优先搜索快捷方式桌面相关的目录，而且搜索速度非常快。 &emsp;&emsp;配合上面的桌面整理工具，我可以将软件启动的快捷方式放到快速启动的格子里面，然后通过 listary 来快速打开我想要打开的软件。&emsp;&emsp; 快速执行命令 &emsp;&emsp;Listary 提供了 4 种不同关键字命令，而且完全可以自定义命令，非常高效。 &emsp;&emsp;比如搜索关键字，可以通过 gg 搜索关键字 直接打开网页进行 Google 搜索&emsp;&emsp;也可以加入一些 shell 命令来调用系统批处理操作。 文件夹下快速索引 &emsp;&emsp;过去在一个庞杂的文件加下，我们只能通过 windows 提供的首字母进行跳转。&emsp;&emsp;使用 listary 之后就可以直接输入来在当前目录下进行搜索，而且一些意想不到的地方也支持搜索。 收藏夹支持 &emsp;&emsp;在文件浏览器中的空白区域双击或者单机中键可以打开 listary 菜单&emsp;&emsp;你可以将一些文件路径收藏到 listary 里面，在这里打开。 DittoDitto 官网地址 &emsp;&emsp;其实少数派的文章已经说得很详细了。&emsp;&emsp;不仅仅支持文字、还支持图片数据记录，内置 搜索 也可以用 listary 来搜索记录 &emsp;&emsp;只是内置的唤起快捷键按起来不太方便，我不太喜欢，改为 Ctrl + Shift + d &emsp;&emsp;最近发现 win10 也集成了粘贴板历史的功能，可以通过 win+v 来打开。&emsp;&emsp;可惜还是差了个搜索搜索功能，也无法通过 listary 来搜索。 QtTabbarQtTabbar 官网地址 少数派文章推荐 &emsp;&emsp;最开始我也是使用 clover 了，后来用勒 QtTabbar 之后，还是跳不过真香定律。&emsp;&emsp;经过clover还原了浏览器的体验，但是功能上还是差了点。&emsp;&emsp;最重要的是可以配合下面要介绍的手势切换文件夹标签，之前亲测 clover 无法切换，非常不便。 &emsp;&emsp;详细的使用介绍 少数派的文章介绍已经非常详细。&emsp;&emsp;另外还有一个很不错的地方就是添加文件预览功能，非常方便。 &emsp;&emsp;基于 IE 浏览器实现的，因此有时候工具不正常的时候可以打开 windows 的 IE 来重置原样。 &emsp;&emsp;win10 启动 QtTabbar 可以去到 查看&gt;选项 的下拉菜单开启。 &emsp;&emsp;另外 QtTabbar 也提供相对简单的批量重命名操作。 常用操作 &emsp;&emsp;下面就说说常用的一些快捷操作，前面打 * 号是我很常用很方便的 常用快捷键 * Ctrl + N 新建标签 * Ctrl + Shift + C 复制选中的文件路径 * Ctrl + Shift + Z 打开上一个关闭的标签 Ctrl + Shift + T 新建一个 txt 文档 Shift + F2 重命名当前文件夹 对文件夹 按住 Ctrl 双击左键 - 打开一个新标签并显示 按住 Shift 双击左键 - 打开一个新标签不显示 按住 Alt 双击左键 - 打开文件夹属性 对地址栏上的路径 按住 Ctrl 左键 - 打开一个全新的窗口 * 按住 Shift 左键 - 打开一个新标签并显示 对文件夹关闭按钮 左键 - 关闭当前标签 按住 Ctrl 左键 - 关闭其他标签除了当前 按住 Shift 左键 - 关闭整个窗口 （我用下面的手势操作关闭窗口比较多） 对标签拖拽 * 将文件拖拽到标签上可以移动文件，按住 Ctrl 拖拽可以复制文件 * 将标签拖拽出来可以新建一个全新的窗口 WGesturesWGestures 官网地址 &emsp;&emsp;非常棒的免费手势软件，windows平台专用，用上就爱上了。&emsp;&emsp;安装完成之后，软件会有很详细的使用说明，配合上面的工具使用就非常省心。 &emsp;&emsp;虽然轨迹支持 中键 和 X键，但是因为各种不方便，我就禁用了。&emsp;&emsp;摩擦边和触发角也不太习惯，而且还很容易误触，因此也及禁用掉了。&emsp;&emsp;因此日常操作我就是使用这个软件进行右键滑动~ 快捷键说明 &emsp;&emsp;虽然上面的截图有按键说明，还是总结一份文字版本的在下面 ▲ 上滚轮 ◐●◑ 鼠标按键 ▼ 下滚轮 ↖↑↗ ←※→ 鼠标方向操作 ↙↓↘ 常用操作 &emsp;&emsp;鉴于这里提供的手势操作实在是太多了，提我非常常用的手势 日常操作 ◑↓→ Ctrl + w - 关闭 ◑↓← Alt + F4 - 退出 ◑↗ - 最大化/回复 ◑↙ - 最小化 ◑↘ - 切换到桌面 ◑↑→↑→ - 窗口置顶 ◑→↓→↓ - 目录下打开cmd窗口 浏览器操作 | QtTabbar 大部分适用 ◑←↑ Home 去到顶部 ◑←↓ End 去到低部 ◑▲ Ctrl + Shift + Tab 上一个标签 ◑▼ Ctrl + Tab 下一个标签 ◑↑← Ctrl + Shift + Tab 上一个标签 ◑↑→ Ctrl + Tab 下一个标签 ◑→↓ Ctrl + T 新标签 | 文件浏览器 Ctrl + N 适配 ◑→ Alt + Right 前进 ◑← Alt + Left 后退 QuickerQuicker 官网地址 Quicker 少数派文章 &emsp;&emsp;quicker 非常良心，软件有功能属于付费版本，但是价格非常便宜。&emsp;&emsp;而且提供免费同步服务，简直白送。 常用操作 截图 OCR 杀进程 朗读文本 &emsp;&emsp;因为上面的工具已经提供了大部分日常的应用，因此我使用 quicker 的频率不是很高&emsp;&emsp;不过实际上， quicker 提供用户自己制作功能，整个生态比起上面的工具都要好得多&emsp;&emsp;也可以通过 quicker 给软件指定定制化的操作，只是目前我个人用得还比较少。 &emsp;&emsp;由于 Maya 调试脚本经常需要关闭重启，quicker的杀进程就非常非常好用，quicker 可以获取到程序 id 只需要执行 shell 命令杀进程就可以了。&emsp;&emsp;当然 WGesture 也提供了强制关停程序的操作，只是手势在 Maya 中使用非常不方便， quicker 提供了另一种舒服的方式。 snipastesnipaste 官网地址 少数派文章 &emsp;&emsp;snipaste 可以说是 windows 平台上最棒的截图工具了&emsp;&emsp;以前弄截图不是借助 微信 QQ 就是 借用浏览器的功能。&emsp;&emsp;snipaste 借助 Qt 框架实现全平台 多层截图 - 方便制作说明 &emsp;&emsp;有时候软件的某些操作在不同的窗口上&emsp;&emsp;很难通过一张截图说明打开步骤&emsp;&emsp;这个时候可以借助 snipaste 的 F3 贴图功能&emsp;&emsp;这个功能可以将之前的截图以悬浮图片的形式展示，就可以将多张贴图放到一起，然后再截一张图说明。&emsp;&emsp;步骤不多的情况下，再也不需要用 word 文档制作多图步骤了。 取颜色 &emsp;&emsp;无论是网页开发还是如今的工具人，都需要获取某些地方的色块&emsp;&emsp;snipaste 就提供了全局取色的功能。&emsp;&emsp;F1 键进入截图只有，截图会有提示，点击 c 键可以复制当前坐标下的像素。&emsp;&emsp;按 Tab 键可以切换不同颜色码。 ScreenToGifScreenToGif 官网地址 &emsp;&emsp;ScreenToGif 是个 github 上的开源项目 github网址&emsp;&emsp;作为工具人，经常需要介绍工具的使用，使用动图就可以简单扼要讲解清楚。&emsp;&emsp;过去我都是使用 gifcam 来制作动图的，但是录制 Maya 的时候偶尔会绿屏，而且录制时间不能太长，而且录制出来的动图文件还贼大，试过几十M都有。&emsp;&emsp;自从用上了 ScreenToGif 感觉动图制作再也不是瓶颈。 capslock+capslock 官网地址 &emsp;&emsp;这是我最初认识到 autoHotKey 脚本编写的工具，后面我独自研究才发现了新大陆，原来 autoHotKey 这么强大。&emsp;&emsp;而这个工具实现了花式玩坏无用的大写按键。 &emsp;&emsp;只可惜插件提供的很多功能都和上面的插件重复了，因此我日常使用的情况不会很多。&emsp;&emsp;当然通过大写键将右手边的按键转移到左手是非常棒的思路。 &emsp;&emsp;另外它也提供了 listary 的启动框，还可以借助 IE 引擎，实现快速调用 js。&emsp;&emsp;比如 语言轰炸机 或者 简单的算术 1&quot;test\n&quot;.repeat(10) &emsp;&emsp;输入上面的 JavaScript 代码，然后按 Capslock + Tab 就可以执行了 &emsp;&emsp;可惜使用上存在一些遗憾&emsp;&emsp;最后我决定自己动手，丰衣足食，于是就在原作者的基础上进行了一些修改 github仓库 keycastowkeycastow 官网地址 &emsp;&emsp;这款软件用来显示键盘的输入指令，对于教学之类的讲解非常有帮助。&emsp;&emsp;虽然完全基于windows平台，但是特别小巧，使用方便，而且开源，可以直接查看是否含有恶意代码。 &emsp;&emsp;启动之后右下角会显示键盘输入的所有指令，甚至是鼠标指令也可以显示出来。 &emsp;&emsp;只可惜作者没有将源码编译一个发行版本出来，可以自己编译一个安全的版本，或者下载被人做好的 地址 最后 &emsp;&emsp;这篇文章也算是长时间拖更没有发布了，后续还会考虑发布一个安卓高效率的文章，敬请期待。 福利放送1福利放送2]]></content>
      <categories>
        <category>效率提升指南</category>
      </categories>
      <tags>
        <tag>࠰Windows</tag>
        <tag>🚀效率</tag>
        <tag>💾软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Qt 多线程提升交互体验]]></title>
    <url>%2Fposts%2Faa6ded84.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近开发 mpdb 插件，研究多线程加载插件 UI ，避免 Maya 主界面卡死的问题。&emsp;&emsp;最初测试的时候，不知道是哪里操作不对，我对比测试发现多线程操作和不使用多线程的体验是一样的。 &emsp;&emsp;后来插件顺利发布之后，我打算还是再重新研究一下，看看能否抢救一下。&emsp;&emsp;结果这一次的测试就有了很大的收获。 多线程的意义 &emsp;&emsp;其实 Python 本身是存在 GIL 全局锁，因此性能瓶颈一直是 Python 的坑。&emsp;&emsp;当然GIL锁死了多核调用，面对 CPU 密集型的任务时会显得力不从心。&emsp;&emsp;Maya 也因为自身框架设计问题，很多调用都是非 threadsafe 的，只有一些特殊的计算节点可以完美调用多核来提高性能 具体参照文章&emsp;&emsp;虽然多核调度很麻烦，但是多线程调度则是 Python 的强项，这种特别时候。 &emsp;&emsp;以下是我个人目前的看法，有错之处欢迎大家指正。&emsp;&emsp;Python 可以调用不同的线程使任务并行响应，其实本质上的算力并没有提高，还是只有一个核的运算。&emsp;&emsp;只是多任务交替执行，由于计算机的运算速度够快，给我们的感觉任务是同时执行的。&emsp;&emsp;但是交互体验上则会有巨大的提升。 Python 多线程 Demo &emsp;&emsp;不逼逼，上代码~ 12345678910import timecurr = time.time()while True: elapsed = abs(time.time() - curr) # NOTE 每隔 0.5s 打印输出时间 if elapsed%0.5 &lt; 0.001: print elapsed if elapsed &gt; 3: breakprint "done" &emsp;&emsp;如果直接在 Maya 里面运行上面的代码。&emsp;&emsp;由于 while 死循环的设置， Maya 将会直接卡死 3s 钟并且输出对应的时间。 12345678910111213141516171819202122import sysimport timeimport threadingdef processFunc(runCallback=None): curr = time.time() while True: elapsed = abs(time.time() - curr) if elapsed%0.5 &lt; 0.001: if runCallback: runCallback(elapsed) if elapsed &gt; 3: breakdef porcessPyThread(blocking=False): thread = threading.Thread(target=processFunc,kwargs=&#123;"runCallback":lambda t: sys.stdout.write("PyThread: %s \n" % t)&#125;) thread.start() if blocking: thread.join()porcessPyThread()print "done" &emsp;&emsp;如果将代码改为多线程调用，那么多线程的部分可以看做是异步调用代码&emsp;&emsp;执行上面的代码可以看到 done 会先被执行，和 JavaScript 的异步有异曲同工之妙（可能就是一样的） &emsp;&emsp;因此问题也类似，虽然多线程不会阻塞到主线程，但是如果想获取到多线程返回的数据，就需要等待线程执行完毕了。&emsp;&emsp;因此 python thread 提供了 join 方法，可以让主线程等待其他线程执行完毕获取到数据。 代码参考 &emsp;&emsp;多线程不适合加入 CPU 密集型的操作，会影响到主线程调用。&emsp;&emsp;如果我们调整 while 循环的打印输出条件， print 打印会更急密集，达到一定程度之后会卡到主线程的。 Qt 多线程 &emsp;&emsp;除了 Python 本身实现多线程调度之外，也可以利用 Qt 的多线程来实现UI响应。&emsp;&emsp;而且关于 Qt GUI 相关的部分，网上更加推荐使用 Qt 的模块来做。 &emsp;&emsp;不过我查过，Qt 和 Python 多线程的底层 在windows下 都是调用了 Win32 相关的模块实现的。&emsp;&emsp;除了 Qt 提供了更多函数，对 Qt 组件更加友好之外，其实两者也没有太大的区别。 文件参考 &emsp;&emsp;上面这个脚本就是我测试 Maya 和 Qt 多线程的两个脚本，其实运行体验差不多的。 12345678910111213141516171819202122232425262728293031323334353637import sysimport timeimport threadingfrom PySide2 import QtCorefrom PySide2 import QtWidgetsdef processFunc(runCallback=None): curr = time.time() while True: elapsed = abs(time.time() - curr) if elapsed%0.5 &lt; 0.001: if runCallback: runCallback(elapsed) if elapsed &gt; 3: break class Worker(QtCore.QRunnable): def run(self): ''' Initialise the runner function with passed args, kwargs. ''' processFunc(lambda t: sys.stdout.write("QtThread: %s \n" % t))def processQtThread(blocking=False): thread = QtCore.QThreadPool() thread.start(Worker()) if blocking: thread.waitForDone() return threadif __name__ == "__main__": # NOTE 避免垃圾回收 thread = processQtThread() print "done" &emsp;&emsp;当然 Qt 也麻烦一点，需要避免 Python 对自身的垃圾回收，否则 thread 的执行将不太正常。 多线程提升交互体验 &emsp;&emsp;下面就回归到正题，通过上面 demo 可以看到。&emsp;&emsp;我们可以在 Maya 里面执行一些其他的操作，同时还保持 Maya 主界面的响应。&emsp;&emsp;我在想 UI 创建的过程是否也可以这样，插件界面在后台生成，生成好了之后再返回到Maya的主界面上执行显示操作。&emsp;&emsp;这样就可以不卡主 Maya 的同时生成出插件界面。 &emsp;&emsp;想法是很美好，但是实验过后，现实很骨感。 12345678910111213141516171819202122232425262728293031323334353637383940import sys, timefrom PyQt5 import QtGui from PyQt5 import QtCore from PyQt5 import QtWidgetsapp = QtWidgets.QApplication(sys.argv)class widget(QtWidgets.QWidget): signal = QtCore.pyqtSignal(str) def __init__(self, parent=None): QtWidgets.QWidget.__init__(self) # self.button = QtWidgets.QPushButton(u"clicked",self) def appinit(self): thread = worker(self) thread.start() def testfunc(self): print "clicked"class worker(QtCore.QThread): def __init__(self,widget): QtCore.QThread.__init__(self, parent=app) self.widget = widget def run(self): print "in thread" # NOTE 在另一个线程中创建 UI self.widget.button = QtWidgets.QPushButton(u"clicked",self.widget) self.widget.button.setText("hello") self.widget.button.clicked.connect(self.widget.testfunc)def main(): w = widget() w.show() w.appinit() sys.exit(app.exec_())if __name__ == "__main__": main() &emsp;&emsp;这段代码需要在 Maya 外执行，我是使用 anaconda2 测试的。&emsp;&emsp;在 Maya 里面切换成 PySide2 执行的话，会发现没有报错，但是另一个线程创建 按钮 并没有依附到显示的窗口上。&emsp;&emsp;当我在Maya外部执行的时候，命令行会出现这个警告。 QObject::setParent: Cannot set parent, new parent is in a different thread &emsp;&emsp;经过网上的搜索， Stack Overflow 的回答非常到位 链接&emsp;&emsp;Qt 的 Gui 创建在 __init__ 函数执行的时候会依附到当前的线程上，如果当前的线程不是主线程，那么这个 UI 就无法集中管理了。&emsp;&emsp;尽管 Qt 的 QObject 提供了 moveToThread 方法，但是并不是所有的操作都是 threadsafe ，特别是 Maya 这种古老框架 对多线程支持不太友好。&emsp;&emsp;因此 Gui 创建必须在主线程上，但是一些 Gui 更新、初始化的操作可以放到其他线程执行。 &emsp;&emsp;因此 mpdb 插件基于这样的考量，将大部分 __init__ 函数执行的代码抽到 initialize 函数中去，通过多线程完成 UI 的初始化。&emsp;&emsp;这样的确就解决了 Maya 卡死 2-3s 的问题。 遇到的一些问题 &emsp;&emsp;mpdb 模块修改成多线程之后还是有坑的。 &emsp;&emsp;比如 Maya 的 cmds 模块所有命令 q 标签都出错了，需要改为 query 标签才不会报错，我是在 Maya2017 的版本测试的，原因不明。 &emsp;&emsp;另外就是 partial 函数在多线程模式下不受支持，替代方案需要 Qt 的 Signal 来解决，的确会繁琐一点。 链接 &emsp;&emsp;最后就是如何让 UI 初始化完成之后再生成 UI。&emsp;&emsp;因为不可以使用 waitForDone 或者 join 方法来让主线程等待，这样就失去多线程的意义了。&emsp;&emsp;原本想着非常棘手，好在 Maya 已经提供了 UI 生成的 队列机制。&emsp;&emsp;在线程的函数里面，完成初始化代码之后加入 cmds.evalDeferred 来生成 UI 就可以实现在 Maya 的主线程上实现 UI 的展示了。 总结 &emsp;&emsp;这次多线程的探索又有新的收获，进一步学习了 Qt 框架的一些知识，挺好的。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya插件 - mpdb - Maya Python Debugger]]></title>
    <url>%2Fposts%2F13258e66.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近新冠肺炎全国闹，我春节窝在家里没有什么事情要做&emsp;&emsp;于是就进一步将之前要开发出来的插件做好。 &emsp;&emsp;之前月初的时候，研究一些动画的插件，当时调试代码使用了 VScode 插件 mayapy 来设断点调试。&emsp;&emsp;然而 mayapy 的调试有一些不太友好的点。&emsp;&emsp;比如调试的时候会导致 Maya 完全无法操作，只能观察脚本编辑器查看运行的状况。&emsp;&emsp;具体的一些细节可以参照 av82191243 视频&emsp;&emsp;而且调试的时候也遇到了一些奇奇怪怪的 Bug&emsp;&emsp;于是为了让我可以更加舒服的调试代码，我打算开发一个 Maya native debugger 解决我的问题。 准备 &emsp;&emsp;我计划要开发一个基于 Qt 的调试器，包含断掉调试的图标以及面板。&emsp;&emsp;当然调试这种操作其实没必要自己全部手写，其实 python 就内置了非常强大的库来调试代码&emsp;&emsp;这个库就是官方提供的 pdb 模块&emsp;&emsp;通过这个库已经可以实现流行调试器的大多数功能，而且完全基于命令行，非常适合无键盘的服务器使用。 &emsp;&emsp;pdb 模块也可以在 Maya 当中使用，但是用起来会非常不方便。&emsp;&emsp;pdb 模块会在断点模式下使用 raw_input 方法获取用户输入，由于 Maya 的脚本编辑器无法实现命令行的功能&emsp;&emsp;因此脚本编辑器在这种情况下会弹出输入框来获取用户输入。&emsp;&emsp;但是这种交互方式依然无法解决 Debug 的时候 Maya 被冻结的情况。 &emsp;&emsp;于是我将 raw_input 等待输入的过程修改为 while 死循环，通过点击图标来打破 while 循环&emsp;&emsp;只要循环的过程保持 Maya 的响应就可以解决长久以来悬在头上的响应问题。&emsp;&emsp;因此我特意翻看了 pdb 模块的源码，研究里面的底层逻辑， 可以参照文章 使用方法 &emsp;&emsp;具体使用方法可以参照 github 上的文档。 中文文档 原理分析 &emsp;&emsp;回溯到我最初的想法，其实 VScode 的 Debug 功能已经实现大部分我需要的了，关键是 Maya 的 UI 失去响应。&emsp;&emsp;而这个失去响应的情况其实和 死循环 差不多，因此我可以模拟一个 while True 死循环，然后想办法让 Maya 在死循环中保持响应。 1234567891011121314151617181920212223242526# 注意此代码在 Maya 2017 下执行会崩溃！ 下文有说明！~import timeimport mayatry: from PySide2 import QtCoreexcept: from PySide import QtCoredef main(): curr = time.time() while True: # NOTE 超时跳出循环 elapsed = abs(curr - time.time()) if elapsed &gt; 3: break print elapsed # NOTE Maya2018 需要加入 Qt 事件响应 UI QtCore.QCoreApplication.processEvents() # NOTE cmds.refresh() 实现视窗响应 | 无法让所有 UI 响应 maya.utils.processIdleEvents()if __name__ == "__main__": main() 代码文件路径 &emsp;&emsp;最初我是想通过 cmds.refresh 命令来保持界面刷新的&emsp;&emsp;然而这个方法只会刷新到 Viewport 界面，如果我想要打开大纲列表、曲线编辑器，这些操作统统都有各种问题。&emsp;&emsp;也不是不响应，只是很多状态没有及时同步反馈，比如选择物体 大纲类表没有同步反馈等等的瑕疵。&emsp;&emsp;于是为了让 UI 响应，我想起了之前有遇到的问题， 链接参考 &emsp;&emsp;有时候代码想要让 Maya 的某些 UI 打开了之后再进一步执行，但是如果只是调用 mel 命令是无法立刻获取到相关的 UI 信息。&emsp;&emsp;原因是 mel 命令只是将 UI 构建的事件放入到了 eventLoop 里面， Maya 会确保在 idle 状态（即没有任何其他操作）下再去执行这些事件。&emsp;&emsp;代码执行的过程中就不会触发到这些事件，这样操作可以避免某些操作导致 Maya 崩溃。&emsp;&emsp;这就解释了 evalDeferred 命令存在的意义，在删除 UI 的一些操作需要使用 evalDeferred ，将UI删除事件添加到 idle 状态下执行。&emsp;&emsp;我之前就有遇到过这样的崩溃循环 链接&emsp;&emsp;最后还是参考了 ADV 的代码拯救了我 (哎！都是坑，当时没人指导只能自己摸索了(:з」∠) | 整个周末两天都在Maya的崩溃循环下度过，印象太深刻了) &emsp;&emsp;参考了网上文章之后，就知道可以通过 maya.utils.processIdleEvents() 来强制让 Maya 执行 idle 事件。&emsp;&emsp;文章也提到可以通过 evalDeferred -list 获取当前 idle 事件列表， processIdleEvents 是根据这个列表顺序执行的。 &emsp;&emsp;当我将这个代码放到 Maya 2017 的 while 循环之后，的确解决了 UI 响应问题，但是一旦跳出循环， Maya2017 就立即崩溃！！！&emsp;&emsp;我测试 Maya 2018 就不会有崩溃问题，但是仅仅这样 Qt 很多组件依然没有响应，还和 Maya 2017 的情况不太一样(:з」∠)&emsp;&emsp;后来在Google 论坛的邮件列表里面查到了重要的信息&emsp;&emsp;Justin 大神推荐使用 QtCore.QApplication.processEvents() 来保持 UI 响应。&emsp;&emsp;我试了试，虽然没有解决 Maya 2017 崩溃的问题，不过的确可以实现 Maya 2018 的自由操作。 Maya 2017 执行崩溃分析 &emsp;&emsp;其实当时执行就已经发现了代码运行的一些异常情况，我是持续打印时间的，但是我发现 Maya2017 打印的时间在某个时候会出现重复归零打印。&emsp;&emsp;打断 while 循环就立刻崩溃了。&emsp;&emsp;于是我将时间打印改为 cmds.evalDeferred(list=1) 这一句，然后打印列表就真相大白了。&emsp;&emsp;可以看到 idle事件列表里面一直包含了 当前脚本编辑器运行的代码， processIdleEvents 执行之后再次运行代码，这样会不断变成永动机式运行。&emsp;&emsp;于是重复运行一次之后，跳出循环 Maya 立刻崩溃了(:з」∠)&emsp;&emsp;大概执行按钮触发的代码也用到了 evalDeferred 命令导致永动机吧~ &emsp;&emsp;当时很真就觉得这个问题几乎无解，在网上折腾了好久。&emsp;&emsp;我也不记得怎么就想到了用 shelf 工具架来测试这段代码的，反正我就这么试了。&emsp;&emsp;结果震惊的情况发生了，将上面的代码用 工具架 执行居然没有崩溃！&emsp;&emsp;至少 Maya 还是有办法让代码正确执行的。&emsp;&emsp;于是我就很好奇 脚本编辑器 的执行按钮背后到底执行了什么指令。 追踪 Script Editor 执行代码 &emsp;&emsp;这里依然是使用 whatIs 的 mel 命令追踪大法 具体的最终过程可以参考之前轮廓生成文章 文档链接&emsp;&emsp;这个追踪大法在 大神的博客学来的 链接&emsp;&emsp;注意 whatIs 命令只支持 mel 语言，当然官方也提供了 Python OpenMaya API 的实现方法，可以在 devkit 里面找到，只不过需要加载插件来实现 &emsp;&emsp;我们可以打开 Echo All Commands 通过命令回显追踪。点击 脚本编辑器 图标 12ScriptEditor;if (`scriptedPanel -q -exists scriptEditorPanel1`) &#123; scriptedPanel -e -tor scriptEditorPanel1; showWindow scriptEditorPanel1Window; selectCurrentExecuterControl; &#125;else &#123; CommandWindow; &#125;; &emsp;&emsp;回显 ScriptEditor; 另外下面还有一大坨，这明显是一个 runTimeCommand&emsp;&emsp;这些 Maya 默认的 runTimeCommand 可以在 Maya2017\scripts\startup 目录的 defaultRunTimeCommand.mel 里面查询到 12345runTimeCommand -default true -annotation (uiRes("m_defaultRunTimeCommands.kScriptEditorAnnot")) -category ("Menu items.Common.Windows.General Editors") -command ("if (`scriptedPanel -q -exists scriptEditorPanel1`) &#123; scriptedPanel -e -tor scriptEditorPanel1; showWindow scriptEditorPanel1Window; selectCurrentExecuterControl; &#125;else &#123; CommandWindow; &#125;") ScriptEditor; &emsp;&emsp;当然上面这么找太麻烦，也可以通过 RuntimeCommand 的 mel 命令（这个命令也是 mel 特供 python 不支持） 文档链接 12runTimeCommand -q -command ScriptEditor;// Result: if (`scriptedPanel -q -exists scriptEditorPanel1`) &#123; scriptedPanel -e -tor scriptEditorPanel1; showWindow scriptEditorPanel1Window; selectCurrentExecuterControl; &#125;else &#123; CommandWindow; &#125; // &emsp;&emsp;绕了一圈，其实这行代码一开始就回显了(:з」∠)&emsp;&emsp;代码格式化之后如下显示 12345 if (`scriptedPanel -q -exists scriptEditorPanel1`) &#123; scriptedPanel -e -tor scriptEditorPanel1; showWindow scriptEditorPanel1Window; selectCurrentExecuterControl; &#125; &emsp;&emsp;到这里可以脚本编辑器 通过 scriptedPanel 的 scriptEditorPanel 类型生成出来的。&emsp;&emsp;具体 mel 命令含义可以参考这些命令的文档 特别是 scriptedPanel 命令 官方文档&emsp;&emsp;通过文档的使用例子可以知道，通过这个命令可以定义一种类型的面板， Maya 可以根据里面的回调函数自动调用。 &emsp;&emsp;根据这个线索 我在 Maya 的官方 mel 文件中可以搜索 scriptEditorPanel 关键字（我是用 VScode 进行文件搜索的）&emsp;&emsp;可以找到 scriptEditorPanel.mel 文件&emsp;&emsp;里面包含了 scriptEditorPanel 所有生成相关的回调 mel 函数&emsp;&emsp;其中 global proc addScriptEditorPanel 函数就是脚本编辑器整个界面生成的 mel 函数了&emsp;&emsp;细微到 menu 和 上面的 iconButton 都是 mel 命令生成的。&emsp;&emsp;代码比较长我就不全部弄过来了，只将主要的按钮功能截取出来。 123456789101112iconTextButton -width $iconSize -height $iconSize -annotation (uiRes("m_scriptEditorPanel.kExecuteAll")) -image "executeAll.png" -command "handleScriptEditorAction \"executeAll\"" executeAllButton;iconTextButton -width $iconSize -height $iconSize -annotation (uiRes("m_scriptEditorPanel.kExecute")) -image "execute.png" -command "handleScriptEditorAction \"execute\"" executeButton; &emsp;&emsp;command 标记上接入了 handleScriptEditorAction 函数了&emsp;&emsp;从这个函数里面可以找到 execute 状态执行的代码 1234567891011121314// NOTE switch 函数调用case "execute": &#123; string $filename = getCurrentExecuterFilename(); if (size($filename) &gt; 0) &#123; delegateCommandToFocusedExecuterWindow "-e -executeAll" 1; &#125; else &#123; delegateCommandToFocusedExecuterWindow "-e -execute" 1; &#125; &#125; break;case "executeAll": delegateCommandToFocusedExecuterWindow "-e -executeAll" 1; break; &emsp;&emsp; delegateCommandToFocusedExecuterWindow 函数又可以去追查 1234567891011121314151617global proc delegateCommandToFocusedExecuterWindow( string $cmd, int $deferred) //// Delegates a command to the last focused executer control.// Parameter deferred means use evalDeferred instead of eval, this is important to avoid// instability because the MEL scanner is not reentrant.&#123; global string $gLastFocusedCommandExecuter; if ($gLastFocusedCommandExecuter != "") &#123; string $evalCmd = "cmdScrollFieldExecuter " + $cmd + " " + $gLastFocusedCommandExecuter; if ($deferred == 1) &#123; evalDeferred($evalCmd); &#125; else &#123; eval($evalCmd); &#125; &#125;&#125; &emsp;&emsp;这个函数会找到当前关注的代码编辑标签，通过 cmdScrollFieldExecuter mel 命令调用 -execute 指令执行。 官方文档&emsp;&emsp;其实到这里和我最初的预估还是有出入的，我还以为这里使用 evalDeferred 命令执行，没想到还有这种组件 mel 语句可以执行代码 &emsp;&emsp;追查到这里基本就解开了Maya2017崩溃的重要谜团，主要是 cmdScrollFieldExecuter 的 excute 命令执行有底层的问题，这个问题大概在 Maya2018 已经修复了。&emsp;&emsp;于是我可以复制保留 addScriptEditorPanel 里面的大部分代码，修改一下 执行按钮调用的函数就可以实现对 Maya 脚本编辑器的模型修改。&emsp;&emsp;当然还需要给 scriptEditorPanel 类型的调用时间做函数修改。 github测试文件 &emsp;&emsp;这个文件就是当时测试修改按钮的尝试&emsp;&emsp;当然这个测试其实有瑕疵的， executer = mel.eval(&quot;$temp = $gLastFocusedCommandExecuter&quot;) 这里获取的不一定是当前看到的脚本 executer&emsp;&emsp;不过大体的思路就是这样，修改了 scriptedPanelType 之后再次点开 脚本编辑器 调用的就是自己写的 python 函数了 UI 界面搭建 &emsp;&emsp;UI界面搭建，还是需要从图标开始入手。&emsp;&emsp;我个人还是比较喜欢还原 VScode 的 Debug 图标，于是就去前端图标大全 阿里系的 iconfont 里面找调试图标。&emsp;&emsp;虽然没有调试图标合集，不过我还是找到了所需要的各个调试图标。&emsp;&emsp;当时考虑到图片的清晰度问题，还是下载了 SVG 图标，结果给自己挖坑了(:з」∠)&emsp;&emsp;SVG不带颜色的，后来我还要用 Qt 给 SVG 图标上色，不过弄好了的确更加灵活 &emsp;&emsp;老规矩还是用 designer 来搭建组件 &emsp;&emsp;这里通过qrc文件加载图标，qrc文件需要转为 python 模块进行 import 就可以加载了。&emsp;&emsp;由于是用 SVG 图标， rc 文件还是比较小的。 &emsp;&emsp;开发的过程中，为了区分 设定图标 和 调试图标的区别，特别做了一个 debug_icon 容器通过 disable 做出区分&emsp;&emsp;每一个图标的大小也做了 30*30 的限定。 图标上色 &emsp;&emsp;主要参考 Stack Overflow 里面给 png 上色的方法 链接&emsp;&emsp;获取图标的 pixmap 继而获取到 pixel 来 循环修改颜色 1234567891011121314151617181920212223def setButtonColor(self,button,color=QtGui.QColor("red"),size=25): """setButtonColor set SVG Icon Color # NOTE https://stackoverflow.com/questions/53107173/change-color-png-image-qpushbutton Parameters ---------- button : QPushButton Icon Button color : QColor, optional set the Icon color, by default QtGui.QColor("red") size : int, optional icon size, by default 25 """ icon = button.icon() pixmap = icon.pixmap(size) image = pixmap.toImage() pcolor = image.pixelColor(size,size) for x in range(image.width()): for y in range(image.height()): pcolor = image.pixelColor(x, y) if pcolor.alpha() &gt; 0: color.setAlpha(pcolor.alpha()) image.setPixelColor(x, y, color) button.setIcon(QtGui.QIcon(QtGui.QPixmap.fromImage(image))) workspaceControl Toolbar 接入 &emsp;&emsp;默认情况下生成的 workspaceControl 是以标签的形式嵌入到 Maya 的 Layout 里面的&emsp;&emsp;我希望可以制作一个类似 HelpLine CommandLine 这些组件一样有 workspaceControl Toolbar 的效果&emsp;&emsp;虽然也可以通过 Qt 自己实现这个效果，但是这就太过复杂了。 &emsp;&emsp;最初我是想通过 mel 语言的 toolbar 来实现的 官方文档&emsp;&emsp;但是测试了一下示例代码，结果完全不是我想要的，只能嵌入到 Maya 特定的区域，限制很大。 &emsp;&emsp;于是我就去研究 HelpLine 这些组件是怎么通过 mel 命令生成出来的。 12toggleUIComponentVisibility "Help Line"; updatePrefsMenu;helpLineVisibilityStateChange(`workspaceControl -q -visible HelpLine`, ""); &emsp;&emsp;关键的 mel 语句就是这两行，并且第二行还透露了很重要的信息 HelpLine 就是 workspaceControl 的名称&emsp;&emsp;关于这个切换显示 mel 函数也可以用上面的方法去追踪，不过我查完之后没有什么收获，还是对 workspaceControl 的操作而已&emsp;&emsp;于是我就以 HelpLine 作为切入点进行搜索，可以找到 initHelpLine.mel 脚本&emsp;&emsp;这个脚本就包含了创建 Maya Help Line 组件所有需要的代码&emsp;&emsp;其中有一个关键的代码 getUIComponentToolBar 可以获取到 workspaceControl 的 ToolBar&emsp;&emsp;但是往代码里面查，没有收获，因为 Toolbar 已经提前创建好了， get 函数只是从数组里面获取出来而已。 &emsp;&emsp;辗转周折之后，最后 initMainWindow.mel 里面找到了 createUIComponentToolBar 函数&emsp;&emsp;继续追踪生成代码，还是让我好失望。 123456789101112131415161718192021222324global proc string createUIComponentToolBar(string $name, string $label, string $uiScript, string $area, int $tabbed)&#123; global string $gUIComponentToolBarArray[]; global int $kNameIndex; global int $kControlIndex; // create toolbar string $controlNameArray[] = stringToStringArray($name, " /"); string $controlName = stringArrayToString($controlNameArray, ""); string $createCmd = ("workspaceControl -uiScript \"") + $uiScript + ("\" -loadImmediately true -label \"") + $label + ("\" -dockToMainWindow ") + $area + " " + $tabbed + " " + $controlName; string $toolbar = `eval($createCmd)`; // add entry to array int $count = size($gUIComponentToolBarArray); $gUIComponentToolBarArray[$count + $kNameIndex] = $name; $gUIComponentToolBarArray[$count + $kControlIndex] = $toolbar; return $toolbar;&#125; &emsp;&emsp;其实这个生成就是利用 workspaceControl 实现的，我就纳闷了，为什么 HelpLine 实现的是 ToolBar 形式的 UI&emsp;&emsp;我自己搞的 workspaceControl 就是标签嵌入式的呢？ &emsp;&emsp;于是我将当前的 HelpLine 通过 deleteUI 删除掉，然后自己用 python 代码生成 workspaceControl 命名为 HelpLine&emsp;&emsp;霎时间真相大白了， Maya 的 workspaceControl 还会根据名字不同生成不同的 UI 组件。 123cmds.deleteUI("HelpLine")cmds.workspaceControl("HelpLine",r=1)cmds.workspaceControl("HelpLine2",r=1) &emsp;&emsp;大家可以自个人感受一下 HelpLine 和 HelpLine2 两个 UI 窗口的嵌入 Maya 之后的区别。附注:写文章的时候去测试，发现名称大小写也不受影响，也可以通过大小写的差异来获取的 UIComponentToolBar &emsp;&emsp;但是问题来了，不可能将 Maya 一个ToolBar组件给牺牲了，然后嵌入自己的插件。&emsp;&emsp;但是如果不删除 HelpLine 组件的话，生成就会报错，遇到了这样的矛盾问题。 &emsp;&emsp;后来使用 mayaToQT 将 Maya 的组件转成 Qt 的组件之后，获取组件的 objectName&emsp;&emsp;发现组件的 objectName 其实是和 Maya 的UI名称保持一致的。于是我做了下面的代码测试。 1234567from maya import cmdsfrom PySide2 import QtWidgetsbtn = QtWidgets.QPushButton("myTestButton")btn.setObjectName("myTestButton")btn.clicked.connect(lambda:cmds.deleteUI("myTestButton"))btn.show() &emsp;&emsp;上面这段代码生成了一个 Maya 按钮，并且点击按钮会删除一个名为 “myTestButton” 的 Maya UI&emsp;&emsp;虽然我前面没有任何调用 Maya Cmds 的操作，但是我仍然可以通过点击按钮来将自己删除掉&emsp;&emsp;通过这个原理，我就可以用很 tricky 的方式解决 HelpLine 名称冲突的问题。 123456789101112131415161718192021222324252627def createUIComponentToolBar(ControlName="CustomToolBar"): """createUIComponentToolBar create a Maya Component Tool Bar Widget :param ControlName: str, defaults to "CustomToolBar" :type ControlName: str, optional """ help_line = mayaToQT("HelpLine") help_line.setObjectName("_HelpLine") cmds.workspaceControl("HelpLine", label=ControlName, loadImmediately= 1, initialHeight=20, heightProperty="fixed", ) UIComponentToolBar = mayaToQT("HelpLine") UIComponentToolBar.setObjectName(ControlName) help_line.setObjectName("HelpLine") layout = UIComponentToolBar.layout() # NOTE add spacing layout.setContentsMargins(10,0,0,0) return UIComponentToolBar &emsp;&emsp;通过 setObjectName 可以给 Maya UI 改名&emsp;&emsp;我可以暂时将 HelpLine 的名称改掉，生成出新的 HelpLine 壳也改名，然后将原本的 HelpLine 改回去，就实现无缝获取 ToolBar 的操作了。 调试功能接入 &emsp;&emsp;解决了上面 Maya2017 执行崩溃的问题和界面搭建问题之后，我们终于可以回到正题从设置调试图标接入调试功能开始了&emsp;&emsp;其实我开发的时候并不是按着这样的思路弄下去，不过不妨碍我总结的时候重新整理一下不同模块的内容。 &emsp;&emsp;断点调试的基本原理可以参考 Python pdb 调试模块研究&emsp;&emsp;通过代码最终，我最后找到 cmdloop 函数是导致 等待输入的罪魁祸首&emsp;&emsp;我可以将 cmdloop 里面的核心代码提取出来，然后将 input 命令改为 while 死循环&emsp;&emsp;这样就可以通过花式打断循环来返回 pdb 调试用的命令，我也省心许多，不用一一实现各个调试功能了。 1234567891011121314151617181920212223242526272829303132333435363738394041def breakpoint(self,MPDB,frame): while True: if self.debug_continue_state : self.debug_continue_state = False return "c" elif self.debug_step_over_state : self.debug_step_over_state = False return "n" elif self.debug_step_into_state : self.debug_step_into_state = False return "s" elif self.debug_step_out_state : self.debug_step_out_state = False return "u;;n" elif self.debug_cancel_state : self.debug_cancel_state = False return "q" elif self.debug_cancel_run_state : self.debug_cancel_run_state = False import mpdb mpdb.quitting = True return "disable;;c" elif self.debug_pdb_state : self.debug_pdb_state = False text,ok = QtWidgets.QInputDialog.getText(self,self.pdb_title,self.pdb_msg) if ok and text: return text # NOTE Keep Maya alive QtCore.QCoreApplication.processEvents() maya.utils.processIdleEvents() &emsp;&emsp;给 ToolBar 添加一个 breakpoint 死循环函数&emsp;&emsp;只要点击按钮图标就修改一个状态，返回对应的 pdb 命令就可以实现调试了。&emsp;&emsp;后续就是将 toolbar 引入到 魔改的 MPDB 类里面去调用获取返回的指令实现 点击图标执行对应的调试动作。 调试面板 &emsp;&emsp;仅仅只是实现按钮效果还是不够的，我觉得还得还原 VScode 的调试体验才行。&emsp;&emsp;需要将代码显示出来，并且告诉大家目前调试的行数。&emsp;&emsp;于是我又研究怎么编写一个 CodeEditor 来显示代码。 CodeEditor 编写 &emsp;&emsp;这里要感谢 logcatMaya 插件&emsp;&emsp;里面提到的 cmdReporterHighlighter.py 我也是完全照搬嵌入到我的 CodeEditor 代码里面去了&emsp;&emsp;不过由于这个代码高亮需要读取所有的 melInfo 函数，运行会有一点卡顿。(后续通过多线程解决了卡顿) &emsp;&emsp;另外，这里对我最大的难点就是在对应的行可以给出对应反馈效果。&emsp;&emsp;原本是打算将 cmdScrollFieldExecuter 直接拿来用的，但是考虑到还要进行断点行的的显示，还是手动实现比较靠谱一点。&emsp;&emsp;于是再次借助 Stack Overflow 参考了网上实现的 CodeEditor 方案 &emsp;&emsp;至于对 paintLine 函数 主要通过 Qt 的 paintEvent 来实现自定义绘制&emsp;&emsp;完全参考上面链接里面对左侧行数显示的实现方案，上面的代码实现左侧行高亮当前显示行数。&emsp;&emsp;我也可以根据这个高亮 QPlainTextEdit 里面的一行，基本上依葫芦画瓢而已。 &emsp;&emsp;当时 QPlainTextEdit 里面需要将 painter 设置到 viewport 上才可以绘制。&emsp;&emsp;但是绘制了之后，如果点到其他行，之前绘制的效果会留有奇奇怪怪的残留问题，于是又折腾了好久。&emsp;&emsp;最后我发现 要加上一行 update 代码才可以 self.viewport().update() &emsp;&emsp;默认的字体设置，空格只有半个字符的宽度，于是还需要我修改一个 monospace 的字体来解决问题，网上咨询之后，推荐使用 VScode 也采用的字体 Courier New&emsp;&emsp;采用了新字体之后行数的像素高度还需要 +1 微调 否则点击显示的行数会不一致。 信息面板 &emsp;&emsp;信息面板的 TableView 功能还是相当复杂的&emsp;&emsp;当时在 Stack Overflow 上找到很不错的示例代码，就在它上面进行了魔改 链接&emsp;&emsp;正则过滤的功能上面已经弄得差不多了，我主要是将 ui 文件里面的组件替换&emsp;&emsp;并且添加了可以修改变量数据的功能 &emsp;&emsp;修改变量数据的方法也是参考 pdb 的单行代码执行的方式&emsp;&emsp;核心方式就是 exec code in globals(),locals() ，这个操作将 globals 和 locals 域修改&emsp;&emsp;全局域和局部域就是一个字典，记录了当前域下所有的变量数据，修改字典等同于对变量进行赋值操作。 i18n &emsp;&emsp;i18n 就是 internationalization ，具体可以参照 百度百科&emsp;&emsp;大致就是指代国际化多国语言。 &emsp;&emsp;Qt 其实是配套有 Linguist 语言家来做翻译文本的操作，实现 i18n 非常方便了。&emsp;&emsp;我们在使用 pyside2-uic 编译出 python 的时候，其实就已经使用了 Qt i18n 的功能。&emsp;&emsp;所有和文本相关的操作都会挪动 retranslateUi 函数当中，并且上都使用 QtWidgets.QApplication.translate 来获取文本。 &emsp;&emsp;QtWidgets.QApplication.translate 最少接受两个参数，第一个参数用来分组、第二个参数就是默认文本。&emsp;&emsp;所有的文本设定好之后，可以使用 pylupdate5.exe 来读取 py 文件编译出 ts 文件 （pylupdate5.exe 是 Python PyQt5 库自带的）&emsp;&emsp;ts文件是 Qt 的翻译标记文件，里面的内容也是 xml ，记录了 QtWidgets.QApplication.translate 在 python 文件的位置，以及翻译的数据情况。&emsp;&emsp;所以这里的 ts 并不是 Typescript 文件，默认 VScode 会根据后缀识别成 Typescript 的。 &emsp;&emsp;我们可以通过 Qt Linguist 来打开 ts 文件，这个也是 PyQt5 库自带的。 可以使用 anaconda 的版本，自带 PyQt5 。 &emsp;&emsp;翻译完成之后可以使用 Linguist 发布文件，会自动根据 ts 文件生成一个同名的 qm 文件&emsp;&emsp;qm文件是不可编辑的文件了，Qt可以读取 qm 文件的数据，让 QtWidgets.QApplication.translate 返回当前选择的语言版本的文本。 &emsp;&emsp;具体的使用方法可以参考 Stack Overflow 的使用 Demo 链接&emsp;&emsp;我也是参照着 eyllanesc 的方法，自己依葫芦画瓢实现的。&emsp;&emsp;核心方法也是将 setText 之类的函数全部提取成一个单独的函数，当语言切换的时候，让 changeEvent 调用 retranslateUi 函数。 事件扩展处理 eventFilter &emsp;&emsp;说来感慨，eventFilter 我最初认识这个函数是在弄 Qt 系列教程的时候。&emsp;&emsp;现在看来这个 事件过滤器 真乃 Qt 的神器，他可以安装任意的组件上，可以接受不同类型事件的回调。&emsp;&emsp;真的是嵌入信号槽的绝佳函数！~ &emsp;&emsp;后来在 Stack Overflow 上看到一种更加简洁的用法（忘记保留链接了）。&emsp;&emsp;直接使用 QObject 类来调用 eventFilter 1234567891011121314151617181920class MiddleClickSignal(QtCore.QObject): """addExecuteShortcut 监听鼠标中键事件 """ middleClicked = QtCore.Signal() def __init__(self,parent): super(MiddleClickSignal,self).__init__() # NOTE 确保自己不会被垃圾回收掉 self.setParent(parent) parent.installEventFilter(self) def eventFilter(self,reciever,event): if event.type() == QtCore.QEvent.Type.MouseButtonPress: if event.button() == QtCore.Qt.MidButton: self.middleClicked.emit() return True return False# NOTE 使用例子Setting_signal = MiddleClickSignal(self.debug_setting)Setting_signal.middleClicked.connect(partial(self.setPdb,True)) &emsp;&emsp;这样就可以制作一个鼠标中键触发器的功能，而且这种写法既简洁扩展性还很强。&emsp;&emsp;不过 eventFilter 要响应组件内所有的事件，会有一定的运算浪费。&emsp;&emsp;但我觉得 GUI 从来都不是 CPU 密集型的操作，快速响应 实现功能 才是 GUI 编程的核心，浪费一些算力是值得的。 遇到的问题 &emsp;&emsp;其实在开发的过程中遇到了不少的坑，有些是解决了有些到目前还悬而未决，在这里给大家分享一下。&emsp;&emsp;有不少的坑我已经在上面有所提及，这里就不在复述。&emsp;&emsp;另外下面标题前带 * 号是目前仍然没有解决方案的，因此我可能不去实现或者用了其他方案替代了的。 toolbar 嵌入问题 &emsp;&emsp;由于 toolbar 是通过我自己的特殊手段生成的，有时候关闭了 Maya 之后，Maya 会记录了 UI 的位置。&emsp;&emsp;下次打开 Maya 的时候还给我创建出来了，但是创建出来是空壳。&emsp;&emsp;因此我需要先判断一下 workspaceControl 这个 UI 的名称是否存在，存在需要先关闭再嵌入。 &emsp;&emsp;另外原本是想要一步到位生成 workspaceControl 的时候同时嵌入到右侧的&emsp;&emsp;但是这样会导致 toolbar 整体拉高各种问题，而且怎么调整高度都不奏效。&emsp;&emsp;后来只好使用 workspaceControl -r 标记将嵌入窗口拉出来显示，接入 调试工具 然后再嵌入到 Maya 里面才稍微解决了问题。 调试面板 修改变量 &emsp;&emsp;调试面板上的数据是根据 Qt MVC 基于 QTableView 实现的&emsp;&emsp;这样有个好处就是甚至可以通过 createEditor 函数来管理点击修改生成 gui&emsp;&emsp;当时明显 QTableView 操作的工作量要比 QTableWidget 大很多。 &emsp;&emsp;在修改上，也参考了 pdb 单行修改变量的方法去做的。&emsp;&emsp;为了方便条用函数，还专门写了一个 modify 信号槽了给外部调用修改域。 &emsp;&emsp;最后比较坑爹的是正则过滤导致执行的修改变量错乱。&emsp;&emsp;最后的解决方案是获取当前修改 Table 左侧 Header 的行数才能正确处理 代码执行同步域 | 隐藏 pdb 调试中途跳出产生的报错 &emsp;&emsp;由于执行按钮的功能被我改写了，执行的时候获取的是执行函数的域而不是 Maya 脚本编辑器的域&emsp;&emsp;这会导致一些变量信息打印会报错提示变量不存在的问题。 &emsp;&emsp;后来折腾了好久之后，决定采用 maya.utils.executeInMainThreadWithResult 函数来解决问题。&emsp;&emsp;当然也可以用 evalDeferred 之类的方法来获取到 全局域 但是这会导致之前永动机报错问题。&emsp;&emsp;后来也想到可以利用 mel 调用 python 来执行 python 代码 获取 全局域。 但是这样没法准确抓取到报错的信息， python 代码报错反馈确实 mel 执行出错了。&emsp;&emsp;所以最后发现 maya.utils.executeInMainThreadWithResult 函数可以完美解决域的问题。&emsp;&emsp;而且用这个函数执行代码，如果中途退出 pdb 调试会报错 BdbQuit 来中断代码执行，最后错误也会返回到这个函数上。&emsp;&emsp;我可以通过异常处理来掩盖掉错误提示，如果是 exec 执行的话，报错在 pdb 内部，异常处理会让 pdb 调试继续下去的(:з」∠) &emsp;&emsp;虽然这个方案很好，但是测试的时候还是出问题了。&emsp;&emsp;使用 maya.utils.executeInMainThreadWithResult 进入调试之后， MainThread 已经被这个执行占用等待结果了。&emsp;&emsp;如果在这个情况下再次用脚本编辑器执行代码，会导致Maya直接卡死无响应。 &emsp;&emsp;最后折腾了一大圈，我放弃了 maya.utils.executeInMainThreadWithResult 这个函数，虽然完美模拟了 脚本编辑器运行的函数域。&emsp;&emsp;最后再次参考了 Stack Overflow 上的回答（链接）将 globals() 作为参数传递进来，另外给 mpdb 模块添加 f_locals 和 f_globals 变量来同步函数域。&emsp;&emsp;使用按钮执行调用的是 mel 的 python ，这个 python 语句也是全局域的，因此可以调用 执行函数的时候将 全局域的 globas() 当做参数传递到函数内。&emsp;&emsp;函数内通过 update 同步到 globals() 上。&emsp;&emsp;感觉这种做法有点蠢，不知道大家有没有更好的方案。&emsp;&emsp;目前的确表面上解决找不到变量的问题。 &emsp;&emsp;最后如何隐藏掉 BdbQuit 报错呢？&emsp;&emsp;我发现代码是在 bdb.py 文件的 68 行报错。&emsp;&emsp;使用 decorator 来忽略掉异常会导致代码继续执行。&emsp;&emsp;后来又是查了 Stack Overflow 之后（链接） 可以通过 sys.exit 来中断执行 &emsp;&emsp;上面的确实现了终止运行又隐藏代码报错了，但是我在使用 Ctrl + E 快键键执行调试的时候。&emsp;&emsp;点击终止按钮给我强行退出了 Maya_(:з」∠)_&emsp;&emsp;这个问题我也是摸不着头脑。后来是看 调试面板上 多了个 SystemExit 的异常&emsp;&emsp;只要在 快键键执行的函数上加上 这个异常处理 就不会导致 Maya 强制退出了。 1234567891011121314151617181920212223class AddExecuteShortcut(QtCore.QObject): """AddExecuteShortcut 监听键盘输入事件 """ def __init__(self,editor): super(AddExecuteShortcut,self).__init__() editor.installEventFilter(self) def eventFilter(self,reciever,event): if event.type() == QtCore.QEvent.Type.ShortcutOverride: key = event.key() KeySequence = QtGui.QKeySequence(key+int(event.modifiers())) if KeySequence == QtGui.QKeySequence("Ctrl+E"): # NOTE Ctrl + E 执行代码 from exceptions import SystemExit try: scriptEditorExecute(f_globals=globals(),clear=False) except SystemExit: pass import mpdb mpdb.quitting = False return True return False * 调试红框提示 &emsp;&emsp;进入调试模式的时候需要用比较显眼的方式告诉用户。&emsp;&emsp;我最初其实想给 Maya 包裹一个红框来做提示用的。&emsp;&emsp;后来遇到了一些无法解决的问题作罢了。&emsp;&emsp;现在的方案其实只是给 Maya 嵌入 QSS #MayaWindow{background:red} 这样修改了主窗口的背景颜色为红色。 &emsp;&emsp;Maya2017很难看到效果，在 Maya2018 下切换工作区就看得很明显了。&emsp;&emsp;这个方案其实有个小瑕疵的，时间滚动条的背景颜色受到了这个设置的影响，背景颜色变灰色了，不再是暗黑色了。&emsp;&emsp;这个小瑕疵也是其中一个未解之谜，倒是不影响使用。 &emsp;&emsp;这里还是得重点说说红框的问题，我搞了好久最后给放弃了，这个问题也属实奇怪得很，希望有人能帮忙解惑~ &emsp;&emsp;给程序套上红框，其实我也在 Stack Overflow 上找到了解决方案 添加 Overlay 组件覆盖 绘制红色边界 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# coding:utf-8from PySide2 import QtGuifrom PySide2 import QtWidgetsfrom PySide2 import QtCoreclass OverLay(QtWidgets.QWidget): BorderColor = QtGui.QColor(255, 0, 0, 255) BackgroundColor = QtGui.QColor(0, 255, 0, 125) def __init__(self, parent): super(OverLay,self).__init__() self.setAttribute(QtCore.Qt.WA_NoSystemBackground) self.setAttribute(QtCore.Qt.WA_TransparentForMouseEvents) self.setWindowFlags(QtCore.Qt.WindowTransparentForInput | QtCore.Qt.FramelessWindowHint) self.setFocusPolicy( QtCore.Qt.NoFocus ) self.hide() # self.setEnabled(False) # self.setAutoFillBackground(True) # self.setWindowFlags(QtCore.Qt.FramelessWindowHint) self.setParent(parent) parent.installEventFilter(self) def paintEvent(self, event): # NOTE https://stackoverflow.com/questions/51687692/how-to-paint-roundedrect-border-outline-the-same-width-all-around-in-pyqt-pysi painter = QtGui.QPainter(self) painter.setRenderHint(QtGui.QPainter.Antialiasing) rectPath = QtGui.QPainterPath() height = self.height() - 4 rect = QtCore.QRectF(2, 2, self.width()-4, height) # NOTE 绘制边界颜色 rectPath.addRoundedRect(rect, 15, 15) painter.setPen(QtGui.QPen(self.BorderColor, 2, QtCore.Qt.SolidLine,QtCore.Qt.RoundCap, QtCore.Qt.RoundJoin)) painter.drawPath(rectPath) # # NOTE 绘制背景颜色 # painter.setBrush(self.BackgroundColor) # painter.drawRoundedRect(rect, 15, 15) def eventFilter(self, obj, event): if not obj.isWidgetType(): return False if self.isVisible(): self.setGeometry(obj.rect()) elif event.type() == QtCore.QEvent.Resize: self.setGeometry(obj.rect()) return Falseif __name__ == "__main__": button = QtWidgets.QPushButton("click") frame = OverLay(button) button.clicked.connect(lambda:frame.setVisible(not frame.isVisible())) button.show() &emsp;&emsp;上面的代码经过我的优化，使用更加方便一些。&emsp;&emsp;可以将代码直接在 Maya 上运行（当然也可以在外部运行 参考） &emsp;&emsp;可以看到 OverLay 类可以覆盖在按钮上但是完全不影响到 按钮的点击触发。&emsp;&emsp;只要去掉背景颜色的添加，只红框就是我想要的 Debug 提示效果了。 &emsp;&emsp;下面就需要获取 Maya 的组件然后添加 Overlay 组件测试效果了&emsp;&emsp;上文已经提到过 objectName 就对应 Maya UI 的名称了，如果可以将 Maya 所有的组件打印出来就清晰了。&emsp;&emsp;这里可以利用递归打印的方法来实现，我在 utils.py 里面有具体的代码来循环打印 Maya 所有的 UI 以及 objectName 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from maya import OpenMayaUItry: from Qt import QtWidgets from Qt.QtCompat import wrapInstanceexcept: from PySide2 import QtWidgets from shiboken2 import wrapInstancedef mayaToQT(name,wrapType=QtWidgets.QWidget): """ Maya -&gt; QWidget :param str name: Maya name of an ui object :return: QWidget of parsed Maya name :rtype: QWidget """ ptr = OpenMayaUI.MQtUtil.findControl( name ) if ptr is None: ptr = OpenMayaUI.MQtUtil.findLayout( name ) if ptr is None: ptr = OpenMayaUI.MQtUtil.findMenuItem( name ) if ptr is not None: return wrapInstance( long( ptr ), wrapType )def mayaWindow(): """ Get Maya's main window. :rtype: QMainWindow """ window = OpenMayaUI.MQtUtil.mainWindow() window = wrapInstance(long(window), QtWidgets.QMainWindow) return windowdef traverseChildren(parent,indent="",log=True): """traverseChildren Traverse into the widget children | print the children hierarchy :param parent: traverse widget :type parent: QWidget :param indent: indentation space, defaults to "" :type indent: str, optional :param log: print the data, defaults to True :type log: bool, optional """ if log: print ("%s%s %s" % (indent,parent,parent.objectName())) if not hasattr(parent,"children"): return for child in parent.children(): traverseChildren(child,indent=indent+" ")if __name__ == "__main__": traverseChildren(mayaWindow()) &emsp;&emsp;使用上面的代码就可以将 Maya 所有的 Qt 组件按照树形结果打印出来&emsp;&emsp;打印结果可以参照这个 github 仓库上的 文件&emsp;&emsp;VScode 可以根据文件的缩进进行代码收缩，看起来舒服很多。&emsp;&emsp;从中可以看到 Maya 内部组件的信息以及 相关的 objectName &emsp;&emsp;开始我是直奔主题，直接让 MainWindow 接上 Overlay 类看看红框效果。（我将 Overlay 的绿色背景去掉了） 1234main_win = mayaWindow()frame = OverLay(main_win)frame.show()# frame.setParent(None) &emsp;&emsp;但是我发现我将 WA_TransparentForMouseEvents 之类的属性全部打上还是存在组件覆盖遮挡的问题。&emsp;&emsp;这让我很困惑，不知道到底是哪里导致遮挡产生。 &emsp;&emsp;后来我就根据 上面打印的 组件树 一个一个测试添加效果。&emsp;&emsp;结果发现 脚本编辑器 加上居然没有问题 12345# NOTE 脚本编辑器widget = mayaToQT("scriptEditorPanel1Window")frame = OverLay(widget)frame.show()# frame.setParent(None) &emsp;&emsp;这就让我很是头疼，完全没有头绪。&emsp;&emsp;后面逐一测试了 Maya 内各个主要的组件，还有 视窗窗口 和 主菜单栏 是会受到遮挡影响的。 1234widget = mayaToQT("MainPane")frame = OverLay(widget)frame.show()# frame.setParent(None) &emsp;&emsp;其他的组件都不存在遮挡问题，目前对我来说无解，所以暂时弃用了这个 Debug 提示方案。 2021-4-6 setMask 解决方案 &emsp;&emsp;最近研究 Qt Designer Overlay 的方案也遇到类似的问题。&emsp;&emsp;通过 setMask 应该可以解决 链接 多线程加速加载 &emsp;&emsp;插件加载需要 2 - 3s 的加载时间。&emsp;&emsp;在这个过程中 Maya 处于卡死状态，我希望通过多线程保持 Maya UI 的响应。&emsp;&emsp;一开始我是看了 Qt 多线程 和 python 多线程的对比。&emsp;&emsp;网上提到 Qt Gui 相关的多线程建议用 QThread 而 Python 运算相关的还是建议用 threading 模块。&emsp;&emsp;于是我就是通了 Python 内置 threading 库。 &emsp;&emsp;经过测试，我发现多线程的效果和不使用 threading 完全一样&emsp;&emsp;写文章的时候我重新求证了一下 Qt 多线程加速优化的可能性。 参考 &emsp;&emsp;经过了一轮研究之后，有很多收获，我写了一篇新的文章记录 - Maya Qt 多线程提升交互体验 总结 &emsp;&emsp;经过这个插件开发的锻炼，进一步加深了对 Qt 开发的理解。&emsp;&emsp;趁着这段时间有空，最近还要开发已经很久计划要做的 Maya 工具 CommandLauncher。&emsp;&emsp;并且还要将最近博客上欠下的文章补上。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 工具开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode - Setting Sync 配置同步之坑]]></title>
    <url>%2Fposts%2F614e755e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近公司电脑的 VScode 一直出现一些奇怪的插件更新报错&emsp;&emsp;比如最常见的 C# 和 intellicode 插件，经常下载什么代码包结果无法下载的，我自己也是一头雾水 &emsp;&emsp;直到最近，我打算通过 setting Sync 插件同步一下线上的插件信息，方便我同步到其他电脑上&emsp;&emsp;结果却发现遇到坑了。 问题情况 &emsp;&emsp;由于太久没有同步配置了，而且我希望弄一个新的 gist 来同步当前的插件配置&emsp;&emsp;因此我打开了插件的配置面板，想要将 gist 的数据切换掉 &emsp;&emsp;但是万万没想到，更新的时候翻车了。 &emsp;&emsp;网上查了一番，没有找到报错的原因&emsp;&emsp;从控制台的报错上看貌似是 ssl 证书相关的错误，但是具体不清楚。 &emsp;&emsp;我接着查命令看到有重置的功能，大概是有什么垃圾信息导致错误吧。&emsp;&emsp;手一抖，将数据重置了。 &emsp;&emsp;结果坑爹才刚刚开始。&emsp;&emsp;我在点击一次 update 功能会打开登陆界面的面板 &emsp;&emsp;看到熟悉的 login with github , 我就放心了 &emsp;&emsp;结果我被坑爹了，画面一直白屏打不开。 &emsp;&emsp;这种问题只能自己去搜索一下了，还转么找到 github 的仓库翻 issue&emsp;&emsp;作者提到 3.2.5 版本已经修复了 ssl 无法登陆的问题。&emsp;&emsp;于是我想难道是高版本又出 BUG 了，于是又专门切换到 3.2.5 版本，依旧没有解决问题(:з」∠)。 &emsp;&emsp;而且重置的时候还把之前github上配置好的 token 权限给弄没了&emsp;&emsp;我只好又重新去处理申请新的token 解决方案 &emsp;&emsp;我弄了新的 gist id 然后又弄了 新的 token 验证&emsp;&emsp;还是上传不成功，真的让我很是火大。&emsp;&emsp;考虑到是 ssl 的问题，可能和代理设置有关，我想能否通过 proxifier 工具来实现挂载&emsp;&emsp;结果开启了软件仍然无法解决问题。 &emsp;&emsp;直到最后，我搜索了如何设置 Vscode 代理才发现，原来我已经设置了代理，而且阴沟里翻船了。 &emsp;&emsp;看到自己的设置真的是气不打一处来，浪费我大半天的时间只因为当时配置的时候多加了一个 s&emsp;&emsp;http代理用不了 https 协议&emsp;&emsp;我将设置改了之后，一切都好了，真的是气死我了。]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 轴心移动研究]]></title>
    <url>%2Fposts%2F4120b797.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近翻 RJ 的博客，找到了一个可以K帧轴心的绑定设置 链接&emsp;&emsp;恰巧动画组有人也有相关的轴心K帧的需求，于是我就在 RJ 的基础上进行了进一步研究。 &emsp;&emsp;这篇文章是 2019 年末的研究成果了，因为各种原因拖到了现在才开始写博客做记录。&emsp;&emsp;最近临近春节，年会等事情比较多，暴饮暴食，结果也胖了不少(:з」∠)&emsp;&emsp;说会正题，这次尝试了 Script Job 来实现自动执行代码效果，也算是花了不少心思了。 问题分析 &emsp;&emsp;几个星期前动画人员做动画，遇到了个挪动轴心点K帧的问题。&emsp;&emsp;通过挪动轴心点来实现不同轴心的旋转定义，如此旋转效果才比较合理。 &emsp;&emsp;比如说角色用剑砸到地上，这个时候剑的轴心在手上&emsp;&emsp;砸到地上之后，希望剑来反向控制角色，这个时候轴心应该是剑接触的地面上。 解决方案 - 轴心点控制 &emsp;&emsp;最简单的方法就是控制 transform 节点的 rotatePivot 属性&emsp;&emsp;RJ大佬就是比较经典的绑定制作方案，其实也可以更加简化操作。 &emsp;&emsp;这样连接 Locator 就可以控制到物体的轴心点位置了。 &emsp;&emsp;但是这种搭建方法会有一些问题 &emsp;&emsp;没错，这种方案的轴心点一旦移动旋转了之后，再次移动会给模型带来位置的偏移。&emsp;&emsp;于是下一步的解决方案就是重点解决这个问题。 解决方案 - 事件钩子调用 &emsp;&emsp;首先可以看到，如果是正常的 pivot 模式下是可以任意移动而不会造成模型偏移的。 &emsp;&emsp;因此要实现这个方案需要研究这种 pivot 模式下是如何让模型不产生偏移的。&emsp;&emsp;最初我打算使用 绑定的方式 来实现这种效果，但是始终解决不了问题。&emsp;&emsp;后来我发现 transform 节点下有 rotatePivotTranslate 属性&emsp;&emsp;当我移动轴心点的时候，模型偏移的数值会自动计算赋值到这个属性上。 &emsp;&emsp;因此只要算出这个数值然后赋值到这个属性上就可以了。&emsp;&emsp;然而我折腾了好久，发现如果不通过节点来计算的话，就必须要移动过程中更新这个属性，需要用到 scirptJob&emsp;&emsp;但是这样其实和直接移动轴心操作是没有区别的(:з」∠) &emsp;&emsp;于是最初我是采用了 scirptJob 的生成方案&emsp;&emsp;但是 scirptJob 有一个缺点就是不能保存下来，还需要使用 scriptNode 实现打开加载功能，同时还要避免生成过多的垃圾 scriptNode 节点。&emsp;&emsp;因此整一个实现方法还是有些许复杂，不比开发一个节点简单多少 OpenMaya 事件钩子调用github 代码链接 &emsp;&emsp; scriptJob 解决方案有一些问题，因此代码上面注释掉了。&emsp;&emsp; scirptJob 是有 attributeChange 事件可以捕获物体的移动然后执行相应的脚本&emsp;&emsp;但是这个更新是当物体移动停止之后才开始执行的，没有办法实现类似于节点的操作，一边移动一边更新&emsp;&emsp;因此后面我将代码升级成了 OpenMaya MMessage 的方案。 &emsp;&emsp;调用 OpenMaya.MNodeMessage.addAttributeChangedCallback 函数可以实现节点动态改变动态更新效果。&emsp;&emsp;具体的实现方法参考了autodesk论坛的回答 链接 1234567891011121314def pivotEvent(sel,loc,msg, m_plug, otherMplug, clientData): # msg kIncomingDirection = 2048 # msg kAttributeSet = 8 # 2048 + 8 = 2056 if msg == 2056: if not pm.objExists(sel) or not pm.objExists(loc): return node,attr = m_plug.name().split(".") if str(loc) == node and "translate" in attr and pm.objExists(loc): pm.xform(sel, piv=pm.xform(loc,q=1,ws=1,t=1), ws=1)# 此处省略代码 ...idx = om.MNodeMessage.addAttributeChangedCallback(_node, partial(pivotEvent,sel,loc)) &emsp;&emsp;代码层面上 sel 和 loc 都是我额外传入的参数&emsp;&emsp; msg 后面的参数是这个函数回调传入的参数。 &emsp;&emsp;msg 是类型数字 这里回调涉及到所有的情况，因此需要通过 msg 来过滤属性变化的情况。&emsp;&emsp;后续就是判断传入的参数是否存在，如果存在的话更新 sel 变量的 旋转轴心&emsp;&emsp;相当于一个物体的移动，无时无刻都在同步另一个物体轴心点位置。 scirptJob 删除钩子 &emsp;&emsp;传入的回调事件如果不删除的话会一直循环执行的，如果不及时删除可能会严重影响Maya的性能，甚至导致Maya崩溃。&emsp;&emsp;因此这里通过 scriptJob runOnce 的方案来解决掉 OpenMaya 当中的事件 12345# 此处省略代码 ...idx = om.MNodeMessage.addAttributeChangedCallback(_node, partial(pivotEvent,sel,loc))deleteEvent = lambda:om.MMessage.removeCallback(idx)pm.scriptJob( ro=1,nd= [str(loc),deleteEvent], protected=True)pm.scriptJob( ro=1,e= ["SceneOpened",deleteEvent], protected=True) &emsp;&emsp;因此两个 scirptJob 会分别在 节点删除以及打开新场景的时候删除事件。 ScriptNode 重置效果 &emsp;&emsp;无论是 scriptJob 还是 MMessage 事件都是无法保存到文件里面的&emsp;&emsp;因此需要在打开文件的时候重新创建事件，确保脚本运行正常。&emsp;&emsp;而这里可以通过 ScriptNode 来实现。 &emsp;&emsp;scriptNode 命令提供了几种监听状态来实现 0 Execute on demand. 1 Execute on file load or on node deletion. 2 Execute on file load or on node deletion when not in batch mode. 3 Internal 4 Execute on software render 5 Execute on software frame render 6 Execute on scene configuration 7 Execute on time changed &emsp;&emsp;文档里面有说明，而且命令运行完之后会生成一个 scriptNode 节点 &emsp;&emsp;为了保证文件的干净，这里使用 UUID 来生成全局唯一标识符&emsp;&emsp;通过这个标识符命名 scriptNode 就可以让这个 ScriptNode 几乎在所有的 Maya 场景中是唯一的，&emsp;&emsp;也就可以光明正大删除 ScriptNode 而不会造成误删的情况。（注：最初我是想用序号的方式的，想想就难办） 1234567891011121314151617181920212223242526272829303132from textwrap import dedentimport uuidUUID = str(uuid.uuid4()).replace("-","_")node = 'pivotFollow_%s' % UUIDscript = dedent("""import pymel.core as pmfrom functools import partialdef pivotEvent(sel,loc,msg, m_plug, otherMplug, clientData): if msg == 2056: if not pm.objExists(sel) or not pm.objExists(loc): return node,attr = m_plug.name().split(".") if str(loc) == node and "translate" in attr and pm.objExists(loc): pm.xform(sel, piv=pm.xform(loc,q=1,ws=1,t=1), ws=1)# 判断相关节点是否已经被删除了if pm.objExists("&#123;sel&#125;") and pm.objExists("&#123;loc&#125;"): sel_list = om.MSelectionList() sel_list.add("&#123;loc&#125;") _node = sel_list.getDependNode(0) idx = om.MNodeMessage.addAttributeChangedCallback(_node, partial(pivotEvent,"&#123;sel&#125;","&#123;loc&#125;")) deleteEvent = lambda: om.MMessage.removeCallback(idx) pm.scriptJob( ro=1,nd= ["&#123;loc&#125;",deleteEvent], protected=True) pm.scriptJob( ro=1,e= ["SceneOpened",deleteEvent], protected=True)# 如果已经被删除了则删除自身elif pm.objExists("&#123;node&#125;"): pm.delete("&#123;node&#125;")""".format(sel=sel,loc=loc,node=node))pm.scriptNode( st=1, bs=script, n=node, stp='python') &emsp;&emsp;虽然这样设置可以完美实现移动轴心的效果&emsp;&emsp;但是却会丢失物体原先的位置，K帧可能会导致物体无法归位，还是有很严重的隐患(:з」∠) &emsp;&emsp;这是鱼和熊掌不可兼得，两个方案都各有各自的问题。&emsp;&emsp;相比于隐藏在暗处的方案二，我更加推崇简单的方案一。&emsp;&emsp;毕竟方案二很可能会导致前面的动画毁于一旦的，方案一的问题至少还是肉眼可见的。 总结 &emsp;&emsp;这次又进一步尝试了 Maya 的事件系统，感觉用起来还是有点危险的。&emsp;&emsp;测试 OpenMaya 的时候就忘记了过滤 msg 在输出，结果造成了永动机，被迫强制关闭 Maya 。 &emsp;&emsp;回想起最初接触 scriptJob 还是在 2年前，那个时候看教程，通过 scriptjob 实现 IKFK 自动切换的黑科技&emsp;&emsp;简直是印象深刻，如今发现 Maya API 里面的事件系统更加全面，能实现的 黑科技 可谓是数不胜数呀。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python pdb 调试模块研究]]></title>
    <url>%2Fposts%2F66c5da7.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近录了一个关于 overlapper 插件的讲解视频。&emsp;&emsp;使用 VSCode 调试 Python 代码的时候翻车了，而且使用外部软件调试会冻结 Python&emsp;&emsp;导致 Maya 没有相应，交互非常不友好。&emsp;&emsp;于是我就有了开发一个 Debug 插件的想法。&emsp;&emsp;主要是要解决断点状态下Maya的GUI响应问题，这样可以很直观看到代码对 Maya 进行了哪些操作。 &emsp;&emsp;最开始我是想要在 ptvsd 的模块上调用 API 开发 Debug 工具。&emsp;&emsp;毕竟我自己做的 VScode 扩展就是基于这个原理，可是后来查了一番之后，发现 ptvsd 是基于 PyDev 的&emsp;&emsp;API调用上我挖掘不太深，就是感觉太复杂了，很多杂七杂八的功能都不需要。 &emsp;&emsp;而且我想要更加通用性的解决方案，利用代码来插入断点，进入断点之后开启一个 while 死循环来更新 UI 界面。&emsp;&emsp;断点调试的时候就 break 掉死循环就好了。 &emsp;&emsp;再进一步研究之后，我发现 Python 自带的 pdb 模块就是实现这个功能的。&emsp;&emsp;于是开始研究 pdb 模块有了今天这篇文章。 PDB 模块使用 &emsp;&emsp;PDB 全称是 Python Dubugger，是 python 的内置模块，可以实现命令行来对 python 代码 Debug&emsp;&emsp;具体用法可以参考后端大佬的视频 &emsp;&emsp;特点就是在代码里面输入 pdb 的代码，程序会捕获到插入的 pdb 调试断点然后进入断点调试模式。&emsp;&emsp;缺点就是纯命令行工具，所有的信息显示都需要通过键盘输入来进行调试，真 DOS 时代无鼠标的操作。 &emsp;&emsp;其实 Maya 的官方博客也有提到过 关于 Maya Python Debug 的方案，其中还说到了 利用 pdb 模块debug 的方法 around-corner地址&emsp;&emsp;不过官方并不推荐使用 pdb ，因为 Maya 的脚本编辑器无法进行命令行输入输出，因此input命令将会弹出一个输入窗口&emsp;&emsp;这样的交互方式是在是太过不友好了，连官方都吐槽了。。。 &emsp;&emsp;另外 maya 的官方文档也有提到 Python Debug 的方案 Maya 文档&emsp;&emsp;如何使用 pdb 可以参照 python 的 官方文档&emsp;&emsp;不过官方文档其实也没有什么代码，都是命令解释，所以也不太友好。 &emsp;&emsp;youtube上也有视频专门讲解在 Maya 如何使用 pdb debug pdb 源码探讨set_trace 源码挖掘 &emsp;&emsp;在 pdb 调试中，大多数时候就是在要设置断点的行数前插入一行 pdb 的代码 pdb.set_trace()&emsp;&emsp;那么这一句代码在背后做了什么呢？&emsp;&emsp;我们可以去到 Python 的Lib目录下找到 pdb.py 文件&emsp;&emsp;Maya 的 Python 内置代码封装到了 bin 目录的 python27.zip 压缩包当中&emsp;&emsp;github上也可以查找到源码（代码是Python3的） https://github.com/python/cpython/blob/master/Lib/pdb.py &emsp;&emsp;在代码当中搜索 set_trace 可以找到下面这个函数 12def set_trace(): Pdb().set_trace(sys._getframe().f_back) &emsp;&emsp;Pdb 类里面是找不到 set_trace 函数的&emsp;&emsp;而通过集成关系可以找到Pdb类是继承于 bdb模块的 Bdb 基类&emsp;&emsp;因此我们可以去到 bdb.py 查找 set_trace 的代码 | https://github.com/python/cpython/blob/master/Lib/bdb.py 1234567891011121314def set_trace(self, frame=None): """Start debugging from `frame`. If frame is not specified, debugging starts from caller's frame. """ if frame is None: frame = sys._getframe().f_back self.reset() while frame: frame.f_trace = self.trace_dispatch self.botframe = frame frame = frame.f_back self.set_step() sys.settrace(self.trace_dispatch) &emsp;&emsp;一顿操作猛如虎，一头雾水不清楚。 (:з」∠) frame 类型说明 &emsp;&emsp;首先需要理解参数输入的 frame 是什么&emsp;&emsp;frame 其实 Python 内置的类，用来描述当前函数域相关的信息。&emsp;&emsp;inspect 模块里面也有 currentFrame 函数获取当前代码域信息。&emsp;&emsp;而上面的操作和 sys 模块的私有函数 _getframe 是一样的。 &emsp;&emsp;关于 frame 的类型说明可以参考 python inspect 模块的官方说明&emsp;&emsp;国内还有大佬写了关于 Cpython 里面 frame object 底层的一些生成原理 链接&emsp;&emsp;可惜这个文章太过深奥，我就跳过了。 &emsp;&emsp;下面则是一些其他国内文章，内容通俗易懂，可惜缺乏深度↓↓↓ https://www.jianshu.com/p/4d8a3c919500 https://blog.csdn.net/zhuguiqin1/article/details/79290244 https://blog.csdn.net/qq_29695701/article/details/94196732 &emsp;&emsp;后来在 stack overflow 找到一篇问题&emsp;&emsp;通过文章回答的链接找到了一篇很好的 frame 运行的代码 链接 12345678910111213141516171819202122232425262728293031323334import sysdef one(): two()def two(): three()def three(): for num in range(3): frame = sys._getframe(num) show_frame(num, frame)def show_frame(num, frame): print frame print " frame = sys._getframe(%s)" % num print " function = %s()" % frame.f_code.co_name print " file/line = %s:%s" % (frame.f_code.co_filename, frame.f_lineno)one()# Output # &lt;frame object at 0x606c50&gt;# frame = sys._getframe(0)# function = three()# file/line = stack.py:12# &lt;frame object at 0x180be10&gt;# frame = sys._getframe(1)# function = two()# file/line = stack.py:7# &lt;frame object at 0x608d30&gt;# frame = sys._getframe(2)# function = one()# file/line = stack.py:4 &emsp;&emsp;通过 frame 可以很好查找到当前代码运行的信息，所以在 pdb 和 traceback 模块里面都是非常重要的组成元素 sys.settrace 讲解 &emsp;&emsp;了解了 frame 之后，我们可以继续测试后续的代码 123456789101112131415161718192021222324252627282930313233343536373839404142def set_step(self): """Stop after one line of code.""" # NOTE Issue #13183: pdb skips frames after hitting a breakpoint and running # NOTE step commands. # NOTE Restore the trace function in the caller (that may not have been set # NOTE for performance reasons) when returning from the current frame. if self.frame_returning: caller_frame = self.frame_returning.f_back if caller_frame and not caller_frame.f_trace: caller_frame.f_trace = self.trace_dispatch self._set_stopinfo(None, None)def _set_stopinfo(self, stopframe, returnframe, stoplineno=0): self.stopframe = stopframe self.returnframe = returnframe self.quitting = 0 # NOTE stoplineno &gt;= 0 means: stop at line &gt;= the stoplineno # NOTE stoplineno -1 means: don't stop at all self.stoplineno = stoplinenodef reset(self): import linecache linecache.checkcache() self.botframe = None self._set_stopinfo(None, None) self.lineno = None self.stack = [] self.curindex = 0 self.curframe = Nonedef set_trace(self, frame=None): if frame is None: frame = sys._getframe().f_back self.reset() # NOTE 重置定义一些变量 我将代码父对象的代码都整合到一起 如上面的 reset 函数所示 # 遍历找到最底层 frame | 并且设置 f_trace 函数到 trace_dispatch 上 while frame: frame.f_trace = self.trace_dispatch self.botframe = frame frame = frame.f_back # NOTE 不清楚作用作用 | 注释掉完全不影响程序运行，大概需要 return 触发才可行 self.set_step() sys.settrace(self.trace_dispatch) &emsp;&emsp;上面我将 set_trace 调用掉的一些函数也贴出来了。&emsp;&emsp;我发现最核心的代码其实最后一行 sys.settrace(self.trace_dispatch)&emsp;&emsp;只有这样在才能触发 断点输入 否则 pdb 不起作用了。 &emsp;&emsp;其实我也不太清楚 sys.settrace 函数是怎么运作的&emsp;&emsp;刚好又在 Stack Overflow 上找到了一些参考 链接&emsp;&emsp;根据这个参考可以知道这个函数是一个全局钩子，每个函数调用都会触发到这个函数。&emsp;&emsp;因此通过这个操作可以实现一些 python 黑科技操作。&emsp;&emsp;当然正如回答说的，如果不是为 Debug 的话，使用这个函数会让其他开代码的人非常难受，而且会导致性能下降。&emsp;&emsp;所以我看 pdb 也是看得难受至极了。 1234567891011121314151617181920212223import sysdef trace_func(frame,event,arg): # NOTE 获取局部变量 a 并修改变量 value = frame.f_locals["a"] if value % 2 == 0: value += 1 frame.f_locals["a"] = valuedef f(a): print aif __name__ == "__main__": sys.settrace(trace_func) for i in range(0,5): f(i)# NOTE 输出 ↓↓↓# NOTE 1# NOTE 1# NOTE 3# NOTE 3# NOTE 5 &emsp;&emsp;frame 对象里面的 f_trace 属性就相当于 局部钩子函数 链接 trace_dispatch 分析123456789101112131415161718192021def trace_dispatch(self, frame, event, arg): print "trace_dispatch",frame,event,arg if self.quitting: return # None if event == 'line': return self.dispatch_line(frame) if event == 'call': return self.dispatch_call(frame, arg) if event == 'return': return self.dispatch_return(frame, arg) if event == 'exception': return self.dispatch_exception(frame, arg) if event == 'c_call': return self.trace_dispatch if event == 'c_exception': return self.trace_dispatch if event == 'c_return': return self.trace_dispatch print 'bdb.Bdb.dispatch: unknown debugging event:', repr(event) return self.trace_dispatch &emsp;&emsp;设置了 sys.settrace 之后，无论在 Python 进行任何代码操作都会触发钩子，这就为断点调试做好了准备。&emsp;&emsp;可以看到钩子函数会默认传入当前触发 frame 和 事件。 &emsp;&emsp;为了更好看清楚这个钩子所做的事情，可以继承 Pdb 对象 然后打印出内部的参数。 12345678910111213141516from pdb import Pdbclass TestPdb(Pdb,object): def trace_dispatch(self, frame, event, arg): print "trace_dispatch",frame,event,arg return super(TestPdb,self).trace_dispatch(frame, event, arg)if __name__ == "__main__": def combine(s1,s2): # define subroutine combine, which... s3 = s1 + s2 + s1 # sandwiches s2 between copies of s1, ... s3 = '"' + s3 +'"' # encloses it in double quotes,... return s3 # and returns it. a = "aaa" b = "bbb" TestPdb().set_trace() final = combine(a,b) print final 1234567891011121314151617181920212223242526272829303132333435363738394041424344F:\repo\Pdb_test&gt;"C:/Program Files/Autodesk/Maya2017/bin/mayapy.exe" f:/repo/Pdb_test/frame_test.pytrace_dispatch &lt;frame object at 0x00000222AF1DE048&gt; line None&gt; f:\repo\pdb_test\frame_test.py(16)&lt;module&gt;()-&gt; final = combine(a,b)(Pdb) strace_dispatch &lt;frame object at 0x00000222AF243908&gt; call None--Call--&gt; f:\repo\pdb_test\frame_test.py(9)combine()-&gt; def combine(s1,s2): # define subroutine combine, which...(Pdb) ntrace_dispatch &lt;frame object at 0x00000222AF243908&gt; line None&gt; f:\repo\pdb_test\frame_test.py(10)combine()-&gt; s3 = s1 + s2 + s1 # sandwiches s2 between copies of s1, ...(Pdb) ntrace_dispatch &lt;frame object at 0x00000222AF243908&gt; line None&gt; f:\repo\pdb_test\frame_test.py(11)combine()-&gt; s3 = '"' + s3 +'"' # encloses it in double quotes,...(Pdb) ntrace_dispatch &lt;frame object at 0x00000222AF243908&gt; line None&gt; f:\repo\pdb_test\frame_test.py(12)combine()-&gt; return s3 # and returns it.(Pdb) ntrace_dispatch &lt;frame object at 0x00000222AF243908&gt; return "aaabbbaaa"--Return--&gt; f:\repo\pdb_test\frame_test.py(12)combine()-&gt;'"aaabbbaaa"'-&gt; return s3 # and returns it.(Pdb) l 7 if __name__ == "__main__": 8 9 def combine(s1,s2): # define subroutine combine, which... 10 s3 = s1 + s2 + s1 # sandwiches s2 between copies of s1, ... 11 s3 = '"' + s3 +'"' # encloses it in double quotes,... 12 -&gt; return s3 # and returns it. 13 a = "aaa" 14 b = "bbb" 15 TestPdb().set_trace() 16 final = combine(a,b) 17 print final(Pdb) ntrace_dispatch &lt;frame object at 0x00000222AF1DE048&gt; line None&gt; f:\repo\pdb_test\frame_test.py(17)&lt;module&gt;()-&gt; print final(Pdb) c"aaabbbaaa" &emsp;&emsp;从上面的调试信息可以看到 代码运行的 event 是 line 函数触发的 event 是 call 函数返回的 event 是 return | 并且将返回值 到 arg 上 函数报错的 event 是 exception | 同理可以推断 附注: 测试的时候 super 代码忘记前面添加 return 导致无法 step 进调试函数内部 cmd模块12345678910111213141516171819202122def dispatch_line(self, frame): if self.stop_here(frame) or self.break_here(frame): self.user_line(frame) if self.quitting: raise BdbQuit return self.trace_dispatchdef user_line(self, frame): """This function is called when we stop or break at this line.""" if self._wait_for_mainpyfile: if (self.mainpyfile != self.canonic(frame.f_code.co_filename) or frame.f_lineno&lt;= 0): return self._wait_for_mainpyfile = 0 if self.bp_commands(frame): self.interaction(frame, None)def interaction(self, frame, traceback): self.setup(frame, traceback) self.print_stack_entry(self.stack[self.curindex]) self.cmdloop() self.forget() &emsp;&emsp;那么可以知道一般情况下运行代码会执行 dispatch_line 会调用 user_line&emsp;&emsp;而其中经过我的测试，触发输入调试的代码是 interaction 里面的 cmdloop &emsp;&emsp;这个 cmdloop 可就是大有来头了，这个和 pdb 模块简称的 Cmd 对象有莫大的关系&emsp;&emsp;Cmd 对象来自内置 cmd 库，用于快速构建命令行工具的库。&emsp;&emsp;使用方法可以参考别人研究的 文章&emsp;&emsp;pdb的输入调用操作是完全基于 cmd 库的标准做的，也难怪我也开始找到一些 help 函数之类的信息却完全找不到调用的地方。&emsp;&emsp;因为这个调用逻辑封装在 Cmd 对象里面了。 &emsp;&emsp;因此对应的操作函数其实都在 do_next do_list 这些函数上了。&emsp;&emsp;那么将 cmdloop 替换成函数能否实现 settrace 状态下直接触发想要的调试效果呢？&emsp;&emsp;答案是否定的，直接替换会报错，看了一下上面文章对 Cmd 的运用范例可以知道。&emsp;&emsp;cmd 内部也有相应的执行前和执行后的钩子，pdb模块对执行前做了相应的处理，如果去掉就无法执行了。 1234567891011121314151617181920212223from pdb import Pdbclass TestPdb(Pdb,object): def interaction(self, frame, traceback): self.setup(frame, traceback) self.print_stack_entry(self.stack[self.curindex]) # self.cmdloop() arg = 'c' self.precmd(arg) self.onecmd(arg) self.forget()if __name__ == "__main__": def combine(s1,s2): # define subroutine combine, which... s3 = s1 + s2 + s1 # sandwiches s2 between copies of s1, ... s3 = '"' + s3 +'"' # encloses it in double quotes,... return s3 # and returns it. a = "aaa" b = "bbb" TestPdb().set_trace() final = combine(a,b) print final &emsp;&emsp;只要执行上面的代码就可以无条件跳过所有的断点了。&emsp;&emsp;当然，如果将 c 改为 l 罗列断点的话就会陷入死循环了 (:з」∠) 总结 &emsp;&emsp;以上就是这次 pdb 研究的情况了，其实还有很多pdb相关的东西没有深入探讨&emsp;&emsp;这次研究的目的是为了移除 pdb 模块的输入等待方式，打算在 Maya 中引入 UI 相应实现动态 Debug 的效果。（mpdb 插件）&emsp;&emsp;目前我已经得到了最核心的输入相应代码，因此见好就收了。 &emsp;&emsp;个人觉得 pdb 模块写得非常不友好，注释不太够，太多乱七八糟的参数不明所以，网上讲解的文章也非常少。&emsp;&emsp;还好自己总算是经过重重险阻找到了解决方案。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Overlapper 动画插件研究]]></title>
    <url>%2Fposts%2F83897e45.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近劲爆羊工具盒免费了，因此我怀着高兴的心情去挖掘里面众多工具的功能。&emsp;&emsp;动画师那边刚好需要一个披风动态模拟关键帧的功能，而工具盒里面内置了 动画飘带工具 刚好解决了需求。 链接&emsp;&emsp;这个飘带工具原本需要花费一丢丢的钱的，但是可爱的羊神完全免费了。 &emsp;&emsp;使用了一段时间之后，发现工具的性能有很严重的问题。&emsp;&emsp;一个短小精悍的20-30帧动画都需要处理个几分钟甚至十几分钟。&emsp;&emsp;我翻开源码看了下，原来是个mel脚本，于是就开始着手工具的优化 当前测试 | 动画演示 &emsp;&emsp;制作了一个简单的控制器动画，可以理解为 手臂的 FK 控制器。&emsp;&emsp;就是个简单的举高高动作。 &emsp;&emsp;上面是我将插件最后一步烘焙到控制器的操作去掉。&emsp;&emsp;然后打开debug模式生成中间 locator 效果。&emsp;&emsp;可以看到插件会根据选择的控制器生成层级骨骼，然后再生成辅助的locator将骨架变成柔软过渡的效果。&emsp;&emsp;最后我代码去掉的部分就是骨架动画约束到控制器上然后 烘焙关键帧。 原理分析生成层级骨架 &emsp;&emsp;根据选择的控制器顺序，生成骨架，并且将骨架的朝向调整好. &emsp;&emsp;然后复制最后一个关节。&emsp;&emsp;然后执行 move -r -ls -wd 2 0 0 ; 命令，再整理骨骼的朝向。&emsp;&emsp;这样骨骼就会沿着上一根骨骼的旋转方向的 X 轴进行偏移。&emsp;&emsp;最初我不太理解为什么是拿上一根骨骼的X轴方向偏移。 &emsp;&emsp;执行代码应该沿着红色轴方向移动才是。&emsp;&emsp;结果却出乎意料了。 &emsp;&emsp;原来当我选中 X 通道的时候看到的移动方向才知道原来是继承上一根骨骼的方向。&emsp;&emsp;这样运动就可以确保骨架偏移在正确的朝向上。 约束骨架 | 烘焙关键帧 &emsp;&emsp;将选择控制器约束骨架，并且将约束关系转成关键帧关系 &emsp;&emsp;层级关系如下图 生成辅助 locator &emsp;&emsp;下面进入 for 循环遍历生成运动效果 &emsp;&emsp;生成 offset locator ，位置偏移取决于 scale 属性&emsp;&emsp;生成 IK locator ，位置和控制器保持一致 &emsp;&emsp;后续让控制器保持偏移对locator进行父子约束并将运动烘焙为关键帧。&emsp;&emsp;然后生成一个 wind locator 到 offset_loc 上 关键帧处理 &emsp;&emsp;这里抽出其中一个 offset locator 进行讲解 &emsp;&emsp;上面烘焙玩的关键帧如上图&emsp;&emsp;后续需要对旋转的关键帧进行欧拉过滤 &emsp;&emsp;然后根据 softness 属性对关键帧曲线进行偏移，这里往右偏移了 3 帧。（注意 IK locator 不处理旋转） &emsp;&emsp;然后将偏移之后的初始帧选上，继而将这一帧挪动回初始位置上。 &emsp;&emsp;下面是处理后的动画演示↓↓↓ （注意 IK 的旋转没有处理完全根随控制器旋转角度的） 生成骨架 locator &emsp;&emsp;在骨架层级下生成相关的 locator&emsp;&emsp;由于这里没有关键帧偏移的关系，这些locator会和之前的locator产生3帧的时间差 约束处理 &emsp;&emsp;将 wind locator 和 second locator 添加父子约束，当前两者的位置是完全重合的。&emsp;&emsp;然后将 second locator 添加 目标约束 到 aim_grp 上 ，确保层级里面的 first locator 指向 second locator &emsp;&emsp;透过层级关系可以看到因为 offset locator 可以控制到 first locator 的朝向&emsp;&emsp;后续就是将 second locator 约束 first locator 的 x 旋转轴&emsp;&emsp;然后将 first locator 约束到 result locator 上 &emsp;&emsp;最后输出的 result locator 大概就是指向 second locator 效果的运动&emsp;&emsp;然后将 result locator 的运动烘焙成关键帧 out locator 超神操作 &emsp;&emsp;好了现在要将 result locator 的保持偏移约束到 新生成在原点的 out locator 上 &emsp;&emsp;相信大家看到这里一定会很困惑，我擦这是什么鬼操作，能生成出柔软的关键帧吗？！&emsp;&emsp;我当时也完全不理解。&emsp;&emsp;直到我将最后一行超神代码输进去之后明白其中的奥妙。 &emsp;&emsp;将 out locator 约束到之前的骨骼层级上。 &emsp;&emsp;震惊了吧，这行代码怎么就可以让效果这么好。&emsp;&emsp;其实我上面演示的大部分效果都是错误的，因为我忘记了这个操作是在循环里面。&emsp;&emsp;因此最后一行的操作会影响到后面每次循环生成 locator 的位置的&emsp;&emsp;虽然是错误的结果，但是我自己摸索也是这么摸石头过河过来了(:з」∠) 视频录制 总结教训 &emsp;&emsp;一开始挖掘插件的效率极低，因为不知道mel代码的执行效果，只能注释运行、注释运行重复来查看效果。&emsp;&emsp;后面看懂了一部分之后就开始讲mel语句转换成 python 加深理解，结果还产生了非常多的 BUG 浪费时间。&emsp;&emsp;后来才发现原来工具有 Debug 模式，可以保留生成过程中的中间节点。&emsp;&emsp;研究这些中间节点的作用才逐渐明白这一个工具的运行原理。 &emsp;&emsp;结果搞这个小插件花了 两天时间，实在不值得(:з」∠) 后续 &emsp;&emsp;录制视频的过程中发现了 VScode Debug 其实并不太友好，于是我打算开发一个 Maya Python Debugger 来解决这个问题。&emsp;&emsp;因此这篇文章暂时拖更了，等 Debugger 开发好之后再进一步剖析。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 插件分析</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 代码管理]]></title>
    <url>%2Fposts%2F842747c9.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近动画组频繁出现服务器连接失败导致动画师无法使用工具的情况。&emsp;&emsp;我咨询了导师之后得到了相当让人沮丧的答案，服务器因为安全原因限制了人数登陆限制。&emsp;&emsp;直接导致使用的人多的话就无法连接的问题。 &emsp;&emsp;我最初觉得搞服务器不太可行，否则导师也不用这么窘迫。&emsp;&emsp;于是想着利用 工蜂 git 来同步制作人员本地的代码仓库的。 &emsp;&emsp;后来在找一个后端大佬聊天，了解内部Python的代码管理的时候。&emsp;&emsp;提到内部有 devcloud 开发机可以使用的。&emsp;&emsp;入职的时候我有看到，每个员工都可以申请一台个人的开发机，但是当时看到只有技术族可以申请，我直接无视了。 &emsp;&emsp;后来经过后端大佬的提醒，我尝试了一下，没想到我设计族也可以申请到服务器，真的让我惊诧。&emsp;&emsp;于是我就有了新的想法，通过开发机的个人服务器来给动画组搭建一个全新的服务器。 服务器配置 &emsp;&emsp;幸好之前为了弄网站后台，配置服务器可以通过 宝塔 面板实现可视化处理 O(∩_∩)O哈哈~&emsp;&emsp;瞬间就简单了很多，服务器和腾讯云的服务器相差无几，就是不可以在外网连接而已。&emsp;&emsp;还是常规操作，先去到宝塔面板的主页安装宝塔面板。&emsp;&emsp;然后在宝塔面板上初始化服务器的环境。&emsp;&emsp;下面就可以可视化操作服务器了 &emsp;&emsp;接下来就需要实现服务器的文件共享到 windows 上了&emsp;&emsp;网上搜索了一下，果然是使用 samba ，这个东西我之前在华强有弄过。&emsp;&emsp;但是毕竟不是自己搭建的，因此还是得借助网上文章的帮忙。 &emsp;&emsp;中间过程也看了一些不靠谱的文章，最后还是借助这篇文章搭建好了我想要的 samba 链接 samba共享搭建安装 samba 服务1yum -y install samba samba-client 启动和重启 samba 服务1234# 启动服务systemctl start smb nmb# 重启服务systemctl restart smb nmb &emsp;&emsp;后面修改配置的时候需要重启 samba 服务 开放 139 445 端口 创建 linux 用户 | 配置 samba 访问用户密码1234# 创建 linux 用户useradd -s /sbin/nologin morefun# 配置 samba 用户密码smbpasswd -a morefun 创建共享的文件夹并开放权限 修改 smb.conf 配置 &emsp;&emsp;主要在配置文件的末尾添加共享文件夹的路径和权限即可 1234567891011[Tools] # 共享文件目录描述 comment &#x3D; Shared Directories # 共享文件目录 path &#x3D; &#x2F;data&#x2F;smb&#x2F;Tools&#x2F; # 是否允许guest访问 public &#x3D; yes # 是否浏览权限 browseable &#x3D; yes # 是否可写权限 writable &#x3D; yes windows 上连接服务器 &emsp;&emsp;在windows上文件资源管理器上输入 \\ip地址 即可访问samba共享文件了&emsp;&emsp;访问之后会弹出用户名和密码输入框&emsp;&emsp;可以通过运行 cmd 命令来跳过输入步骤。 1NET USE &lt;\\IP地址&gt; &lt;密码&gt; /USER:&lt;账号&gt; Git 仓库配置 &emsp;&emsp;其实我个人也只是会git常用的命令，复杂操作其实也不懂。 服务器端初始化 git 仓库 &emsp;&emsp;首先要明确 仓库初始化有两种模式 12git initgit --bare init &emsp;&emsp;没有 bare 就是普通的代码仓库，会在创建目录下常见 .git 目录&emsp;&emsp;添加 bare 命令之后会发现 .git 目录下的内容会直接创建到当前目录下。 &emsp;&emsp;添加 bare 命令之后是无法通过文件夹看到仓库的内容的。&emsp;&emsp;这种仓库可以定义为远程仓库，类似于数据中心的概念。 &emsp;&emsp;可以通过 git init 创建一个本地的仓库&emsp;&emsp;然后通过 git remote add 的方式将服务器的远程仓库路径连接上 &emsp;&emsp;其实 remote add 的操作是在 .git/config 文件下添加了新的远程路径配置 &emsp;&emsp;这样本地的 init 仓库就可以类似 github 的操作将代码 同步到 远程的 bare init 仓库上 &emsp;&emsp;我之前都不知道，看到github上可以预览到文件，一直以为 github 上是 git init 的仓库&emsp;&emsp;因此我一直尝试将一个仓库的代码push到另一个仓库上，却始终不成功(:з」∠)&emsp;&emsp;还需要在另一个仓库上对push的文件进行操作处理才行，特别麻烦。&emsp;&emsp;后来看到 Stack Overflow 提到，原来 github 的仓库都是 bare 仓库，才明白我的操作是不对的。&emsp;&emsp;bare init 就不会有问题。 git 钩子配置 &emsp;&emsp;网上大多数的钩子其实都是配置到服务器端的 hooks 文件下的 post-receive 文件下。&emsp;&emsp;这样只要 git push 完成服务端的代码同步之后就会触发 post-receive 钩子的shell代码。&emsp;&emsp;不过因为我这里的一些特殊原因，我还是将钩子配到了客户端的 pre-push 上了。 &emsp;&emsp;钩子里面的代码最初还以为要自己写复制的。&emsp;&emsp;网上查了一下，其实可以通过 checkout 简单实现. 123456# 指定我的代码检出目录DIR= &lt;指定输出路径&gt;# 清理路径上的无关文件git --work-tree=$&#123;DIR&#125; clean -fd# 直接强制检出git --work-tree=$&#123;DIR&#125; checkout --force &emsp;&emsp;通过上面的代码可以将仓库当前分支显示的代码直接复制到制定的目录上，完成代码的发布工作。 总结 &emsp;&emsp;再次温习了一下服务器的使用方法，以及Git的一些内部使用逻辑和方法。&emsp;&emsp;感觉还是多去练习才明白这个东西内部的逻辑结构。 2020-1-2 更新 &emsp;&emsp;使用 –work-tree 的方式 checkout 部署代码的确没问题，但是因为缺少git的追踪，每一次部署等于覆盖一次，仓库复杂的话还是要等挺长时间的。&emsp;&emsp;后来我还是换成了仓库钩子 post-receive 的方式。&emsp;&emsp;为了不对之前的仓库造成影响，我新建了一个新的 bare 仓库在我的服务器上。&emsp;&emsp;然后给本地origin remote 添加多新仓库的url地址&emsp;&emsp;这样 git push 的时候就会分别 push 到两个仓库上。 &emsp;&emsp;后续就是通过 post-receive 的是方式给线上的 –work-tree 仓库执行pull命令即可&emsp;&emsp;这里直接 cd 路径然后 git pull 会报错 参考 &emsp;&emsp;根据第二个回答添加 unset GIT_DIR 即可。 &emsp;&emsp;后面我用 python 写脚本的时候，还发现在windows平台不支持 cd 到 UNC 路径（也就是\\ip地址）&emsp;&emsp;可以使用 –git-dir 来解决 链接 &emsp;&emsp;可以参考我线上的脚本，通过 git 来读取更新的内容]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠑGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya轮廓挤出研究]]></title>
    <url>%2Fposts%2Fddafb500.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近这段时间，场景模型那边给我提需求&emsp;&emsp;希望我可以开发一个工具来简化 Max 工具挤出的问题。&emsp;&emsp;最初这是什么情况我也不太了解。 &emsp;&emsp;于是我去到工位上了解才明白，原来是需要基础场景模型的轮廓。&emsp;&emsp;由于项目是横版格斗类型，用引擎制作背景的轮廓比较消耗资源。&emsp;&emsp;传统制作外轮廓的方案是复制一个新的模型放大，但是这回导致面数翻倍。&emsp;&emsp;而这里恰巧是横版格斗，背景的视角不会有太大的运动，因此人工制作特定视角的轮廓模型是可行的。 &emsp;&emsp;因此制作人员只是想要简化Max在poly模式下挤出会有多余边面产生的问题。&emsp;&emsp;不过考虑到整一个轮廓的效果，我在想Maya貌似有工具是可以直接生产的，未必就需要手工制作轮廓。 &emsp;&emsp;后来翻了一下，找到 Toon 材质里面的确有制作轮廓的 PaintEffect 效果 PaintEffect研究 &emsp;&emsp;通过 Toon 下的 轮廓生成真的非常省心，不用考虑如何根据当前视角获取物体轮廓的问题了。 &emsp;&emsp;只可惜生成的模型是一管道的效果，而制作那边所希望的是面片就够了。 &emsp;&emsp;于是我进行了进一步的研究，如何将 PaintEffect 的效果转换为面片。 &emsp;&emsp;经过我自己简单的研究，我发现可以通过 PaintEffect 转曲线获取到模型的轮廓曲线。&emsp;&emsp;进而通过扩张曲线放样可以生成出想要的面片模型。 轮廓生成 代码探究 &emsp;&emsp;首先需要生成 PaintEffect 的轮廓模型的代码。&emsp;&emsp;这一步可以参照脚本编辑器的代码回显。 1assignNewPfxToon; &emsp;&emsp;执行这个命令有个缺点就是无法返回 PaintEffect 生成的轮廓节点，虽然执行会选中这个节点，可以通过 ls -sl 进一步获取，但是还是想更加优雅一点&emsp;&emsp;通过 whatIs 命令可以查看一下内置脚本的代码 12whatIs assignNewPfxToon;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/paintEffects/assignNewPfxToon.mel // &emsp;&emsp;打开上面路径的脚本 1234global proc assignNewPfxToon()&#123; assignPfxToon "" 0;&#125; &emsp;&emsp;套娃警告!还是需要查询一下 assignPfxToon 代码 12whatIs assignPfxToon;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/paintEffects/assignPfxToon.mel // &emsp;&emsp;继续打开脚本查看源码&emsp;&emsp;我看到里面的代码相当的复杂，判断的情况也比较多，于是放弃再进一步抽丝剥茧了。&emsp;&emsp;还是用 ls -sl 好了 &emsp;&emsp;获取到轮廓模型之后，后面需要将 paintEffects 转换为 曲线。 &emsp;&emsp;这一步操作就非常不友好了，既没有返回曲线也没有选择到曲线，我就没办法获取到转换的曲线了。&emsp;&emsp;于是还是的找到转换曲线的命令去翻一下 mel 里面的代码 1234doPaintEffectsToCurve( 0);// Result: 1 // whatIs doPaintEffectsToCurve;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/paintEffects/doPaintEffectsToCurve.mel // &emsp;&emsp;可以看到执行代码 执行了 doPaintEffectsToCurve 函数&emsp;&emsp;于是去找 doPaintEffectsToCurve 的mel源码 1234567891011global proc int doPaintEffectsToCurve( int $hideStrokes )&#123; int $vertColorMode = 0; int $quadOutput = 0; int $polyLimit = 100000; int $doHistory = `constructionHistory -q -tgl`; int $status = doPaintEffectsToGeom( $doHistory, $vertColorMode, $quadOutput, $hideStrokes, $polyLimit, 2); return $status;&#125; &emsp;&emsp;再次套娃警告！！ 12whatIs doPaintEffectsToGeom;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/paintEffects/doPaintEffectsToGeom.mel // &emsp;&emsp;再次翻源码，这里的代码可就复杂多了。&emsp;&emsp;但是这次没法省事，如果不高清楚这里的曲线生成方式，就没办法获取生成的曲线。&emsp;&emsp;我只好捋一捋这里生成逻辑，将无关的部分屏蔽掉。 &emsp;&emsp;很好下面一步就是查找一下 createPfxOutCurves 的源码 12whatIs createPfxOutCurves;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/paintEffects/createPfxOutCurves.mel // &emsp;&emsp;核心打开抽出来之后其实一切都很清晰了。 &emsp;&emsp; pfxToon 节点会输出 outMainCurves 属性，里面存储了当前轮廓下的曲线形态。&emsp;&emsp;将这个属性连接到 nurbscurve 节点的 create 属性上就可以生成轮廓曲线了。&emsp;&emsp;于是我将这个操作抽离出一个函数 12345678910111213def generateProfileCurve(profile_node): count = profile_node.outMainCurveCount.get() crv_list = [] for i in range(count): attr = profile_node.outMainCurves[i] if pm.connectionInfo(attr,isSource=1): continue crv = pm.createNode("nurbsCurve") pm.connectAttr(attr,"%s.create"%crv,f=1) # NOTE 断开连接 attr.disconnect(crv.create) crv_list.append(crv.getParent()) return crv_list &emsp;&emsp;如此一来总算是可以通过代码获取到生成的对应轮廓曲线，断开连接可以确保生成出当前摄像机轮廓的曲线效果，而不是实时生成。 扩大曲线 &emsp;&emsp;现在已经有了当前轮廓的曲线，怎么才能沿着曲线外围方向挤压出面片呢？&emsp;&emsp;当时首先想到的是使用曲面的挤压命令，然而挤压命令的朝向是固定方向的，无法控制沿着曲线表面的法线方向扩张。&emsp;&emsp;后来搞了好久都没有搞出来，只好用放样（loft）的来做面片了。 &emsp;&emsp;只需要再将轮廓曲线放大一下就可以有两条曲线通过放样生成面片。&emsp;&emsp;然而如何生成扩大的曲线也难倒我了。 &emsp;&emsp;我最初的想法是将模型沿着法线方向扩大，生成新的轮廓，然后再缩小回去。&emsp;&emsp;这样就有了一一对应的轮廓曲线。 1234567891011121314151617181920212223import maya.api.OpenMaya as omdef inflateMesh(mesh,scale=1): sel_list = om.MSelectionList() sel_list.add(str(mesh)) DagPath,Obj = sel_list.getComponent(0) Mesh = om.MFnMesh(DagPath) MeshPoints = Mesh.getPoints(om.MSpace.kWorld) newMeshPoints = om.MFloatPointArray() for i in range(len(MeshPoints)): MeshPointNormal = Mesh.getVertexNormal(i , om.MSpace.kWorld) x = MeshPoints[i].x + MeshPointNormal.x * scale y = MeshPoints[i].y + MeshPointNormal.y * scale z = MeshPoints[i].z + MeshPointNormal.z * scale newMeshPoint = om.MFloatPoint(x,y,z) newMeshPoints.append(newMeshPoint) Mesh.setPoints(newMeshPoints, om.MSpace.kWorld) &emsp;&emsp;上面的代码就可以实现模型沿着法线放大，但是经过我调试之后我发现不对。&emsp;&emsp;模型放到之后的轮廓数量可能和之前是不一样的，导致生成的曲线根本就对不上。 &emsp;&emsp;后来想到应该让曲线沿着法线方向扩大就好了。&emsp;&emsp;于是我通过法线上的 CV 点获取到 CV 点到曲线上的 法线值&emsp;&emsp;通过这个法线值可以利用扩大模型的方法来扩大曲线。&emsp;&emsp;然而我发现这样还是不对，CV获取到的法线运动有时候并不是我所预期的。 &emsp;&emsp;后来我仔细想了一下，法线可以通过 CV 点获取模型上的法线值&emsp;&emsp;这样扩大出来的效果应该是我所预期的法线了。 1234567891011121314151617181920212223242526272829303132333435import maya.api.OpenMaya as omdef inflateCurveOnMesh(crv,mesh,scale=1): newCrv = pm.duplicate(crv)[0] sel_list = om.MSelectionList() sel_list.add(str(crv)) sel_list.add(str(mesh)) sel_list.add(str(newCrv)) DagPath,_ = sel_list.getComponent(0) Curve = om.MFnNurbsCurve(DagPath) CurveCVs = Curve.cvPositions(om.MSpace.kWorld) newCurveCVs = om.MPointArray() DagPath,_ = sel_list.getComponent(1) Mesh = om.MFnMesh(DagPath) DagPath,_ = sel_list.getComponent(2) newCurve = om.MFnNurbsCurve(DagPath) for i in range(len(CurveCVs)): cv = CurveCVs[i] normal,_ = Mesh.getClosestNormal(cv) x = cv.x + normal.x * scale y = cv.y + normal.y * scale z = cv.z + normal.z * scale newCurveCV = om.MPoint(x,y,z) newCurveCVs.append(newCurveCV) newCurve.setCVPositions(newCurveCVs) return newCrv &emsp;&emsp;输入轮廓法线和模型就可以通过API生成一条扩大的曲线。 曲线放样 &emsp;&emsp;下面就需要调整曲面转换成poly的参数，确保生成面数少而简洁的模型效果。 &emsp;&emsp;代码转换如下 123456pm.nurbsToPolygonsPref(polyType = 1)pm.nurbsToPolygonsPref(format = 2)pm.nurbsToPolygonsPref(uType = 3)pm.nurbsToPolygonsPref(uNumber = 1)pm.nurbsToPolygonsPref(vType = 3)pm.nurbsToPolygonsPref(vNumber = 1) &emsp;&emsp;当时也是完全不知道有 nurbsToPolygonsPref 的命令&emsp;&emsp;因此我测试的时候完全没有发现这里设置参数的问题，结果上了制作的电脑之后，发现转换的模型效果不对。&emsp;&emsp;于是我才去研究 loft 窗口下的 polygon 转换是怎么实现的。 1234567891011// loft 窗口打开代码回显LoftOptions;loftToolScript 3;whatIs LoftOptions;// Result: Run Time Command // runTimeCommand -q -c LoftOptions;// Result: loftToolScript 3 // whatIs loftToolScript;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/others/loftToolScript.mel // &emsp;&emsp;runTimeCommand 可以查到命令真实执行的代码是什么，其实就是第二行回显的代码&emsp;&emsp;下面可以去找 loftToolScript.mel 查看模型的代码是怎么实现的。 1234whatIs scriptToolScript;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/others/scriptToolScript.mel // whatIs performLoft;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/others/performLoft.mel // &emsp;&emsp;我发现 scriptToolScript 是执行了传进去的字符串，因此 performLoft 的代码才是重点。 &emsp;&emsp;由此我们可以逐渐找到生成 loft 选项框窗口的代码 loftOptions。 &emsp;&emsp;保持代码追踪最后会发现点击 polygon 窗口的时候回调用到 nurbsToPolyAddOptions 生成 NURBS 转 poly 的选项 1234whatIs nurbsToPolyAddOptions;// Result: Mel procedure found in: C:/Program Files/Autodesk/Maya2018/scripts/others/nurbsToPolyAddOptions.mel // whatIs nurbsToPolygonsPref;// Result: Command // &emsp;&emsp;在里面的代码中我又找到了 nurbsToPolygonsPref 的命令&emsp;&emsp;这个命令就是 Mel 内置用来设置 NURBS转Polygon 的参数命令了&emsp;&emsp;于是我就可以通过开头的代码来实现转换参数的调整。 代码总结 &emsp;&emsp;基本上上述的部分就是这个轮廓挤出的难点所在。&emsp;&emsp;代码可以参照 https://github.com/FXTD-ODYSSEY/MayaScript/blob/430e9194da85d884d0304b141706bae44460dd8a/model/outline/test_outline.py&emsp;&emsp;另外我也写了个带GUI调整的代码 https://github.com/FXTD-ODYSSEY/MayaScript/blob/430e9194da85d884d0304b141706bae44460dd8a/model/outline/outlineExtrude.py &emsp;&emsp;这个东西我测试了几天，结果制作那边其实压根就不需要自动生成的轮廓(:з」∠)&emsp;&emsp;他们需要解决的只是挤出不会产生多余边的问题而已。&emsp;&emsp;我发现这个问题只要 Max 里面改成 mesh 操作就是好的了。&emsp;&emsp;如果是在 poly 下操作挤出再合并点，顶点都无法像Maya一样合并到一起。 &emsp;&emsp;于是我咨询了认识的 3ds Max 大佬，大佬给我做了张图说明了这个问题]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3dsMax FBX导出工具进阶版]]></title>
    <url>%2Fposts%2Fb70d8b0c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近迷之忙碌，因为回学校考试等各种原因，拖更了半个月了&emsp;&emsp;有些东西本来老早打算要写下记录的，奈何就是没有行动起来。 &emsp;&emsp;主要是前段时间花了大量的时间开发 Maya 的 CommandLauncher&emsp;&emsp;然而我开发完了之后其实并没有怎么使用起来，只能说新的使用方式我还是不怎么习惯。&emsp;&emsp;有时间一定要完善一下 github 的仓库，并且记录一下开发过程遇到的坑。 &emsp;&emsp;上次我有提到第一次使用 3ds Max 的 Python Pyside 写了一个工具界面 链接&emsp;&emsp;然而 3ds Max 对python的支持果然非常不友好&emsp;&emsp;制作人员经常向我反馈插件导致 3ds Max 崩溃 (:з」∠)&emsp;&emsp;按照之前的经验，删掉 Max 的用户配置就好了 视频 &emsp;&emsp;但是这样只是治标不治本，没有办法从根本上解决问题，于是还需要我进一步研究到底是哪一个操作导致 Max 的崩溃。 Max 崩溃查找 &emsp;&emsp;这种不稳定的崩溃问题对我来说做难受的就是没有办法复现问题。&emsp;&emsp;的确每次去到制作人员那里发现 插件一打开就导致 Max 崩溃了&emsp;&emsp;为了找到问题，我干脆让制作人员将他电脑的 Max 配置发送给我&emsp;&emsp;然而当我将他的配置拷贝到我自己的电脑上时，却又是一切正常的，真的让我跪了 &emsp;&emsp;因此没办法，我只好占用了制作人员的电脑进行测试。&emsp;&emsp;既然删掉所有配置可以正常使用，我有理由相信应该是有些配置文件有问题。&emsp;&emsp;于是删除的过程中，发现个人文件夹有的文件被 Max 占用了，无法处理。&emsp;&emsp;只好将所有的 Max 程序关闭，然后清理文件。&emsp;&emsp;结果打开 Max 之后，插件就正常了，于是我强烈怀疑是文件夹有什么有问题的配置。 &emsp;&emsp;于是我找回之前发送给我的配置压缩包，看看运行会不会报错。&emsp;&emsp;可是气人的情况出现了，居然还原了配置之后运行时一切正常的(:з」∠) &emsp;&emsp;真的是迷惑行为大赏。&emsp;&emsp;我也不知道自己是怎么的就想到了，刚才的崩溃的时候 Max 是多开的&emsp;&emsp;于是我问了制作人员，制作人员居然反馈只有多开的 Max 才会崩溃！ &emsp;&emsp;纳尼！~&emsp;&emsp;于是我立马多开了个Max，测试运行python，崩溃复现，破案了(:з」∠) &emsp;&emsp;这大概率是 Max 2017 的BUG，我在自己的 Max 2017 上测试也是一样的问题&emsp;&emsp;这就让人难受了，没想到 Max 对 python 的操作有这么多问题，还是 Maya 香啊~！ MaxScript 解决方案 &emsp;&emsp;知道是 Python 的问题就好办了，将插件改写为 MaxScript 就好了&emsp;&emsp;而且 Max 老一点的版本（3dsMax 2014）都不支持 Python 写插件，真的是太落后(:з」∠)&emsp;&emsp;这可能好 Max 的框架不是使用 Qt 有关，官方貌似更加推荐使用 C# 的 .Net 框架来编写插件&emsp;&emsp;不过这方面还不甚了解，基本上依靠官方文档的说明来解决 MaxScript 的问题吧，起码还能凑合着用。 &emsp;&emsp;这次重新翻了官方文档，总算是发现 Max 的索引目录&emsp;&emsp;虽然Max没有mel文档的搜索来得那么方便，不过这个 API 文档还算是清晰了，各个模块分类都很齐全。&emsp;&emsp;基本上有问题就在上面查就对了。 &emsp;&emsp;用 MaxScript 重写 Pyside 界面遇到的问题就是没有办法UI 修改大小。&emsp;&emsp;默认 CreateDialog 连 resize 都没有加上，需要手动添加，而且只能修改窗口大小，UI组件大小不变，真的是上个世纪的组件开发逻辑了，莫名回想起 VB 的时代。 &emsp;&emsp;从上图可以看到我用 MaxScript 改写了之后，Maxscript在界面开发还是不太友好的，而官方的FBX设置窗口却是支持的。&emsp;&emsp;FBX插件的设置窗口我自己没有考证过，但是大概率是基于 .Net 编写的，因此要解决这些零碎的交互问题还是需要进阶的工具支持。&emsp;&emsp;Maxscript 对 .Net 的支持还是比较有好的，甚至可以将 .Net 的库转换为 MaxScript 的对象， 文档 &emsp;&emsp;所以用 max 开发界面需要学习 Windows 的界面开发 WPF 才行。&emsp;&emsp;因为是完全基于 Windows 平台的，导致没法借助 Qt 实现跨平台，Max目前只支持 Windows 平台(:з」∠) 参考1 参考2&emsp;&emsp;当然跨平台技术其实并非做不到，这口锅还是需要 自动桌 去背，我只能表示 Maya 真香！~ &emsp;&emsp;折腾了一番之后，还是回到 MaxScript 的界面编写上。&emsp;&emsp;虽然 Maxscript 的界面写起来各种别扭，但是好歹还是有自己的界面开发工具，比 Mel 写起来要舒服一点。&emsp;&emsp;这个部分还是 Digital Tutors 的教程非常有用，我也是看教程学习的 Digital Tutors - Automating Tasks Using MAXScript in 3ds Max &emsp;&emsp;界面其实基本上就按照上面的 rollout编辑 就可以解决了&emsp;&emsp;Python 转 Maxscript 还遇到了个问题，就是需要实现文件的读写，以及一些字符串的操作 File Dialogs 文件浏览窗口 FileStream 文件IO File Name 文件路径处理 String 字符串处理 &emsp;&emsp;借助上面文档基本上解决了我大部分的开发问题。&emsp;&emsp;文档也和Mel一样比较友好，都有代码示例可以参考，不懂可以运行测试来理解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859MF_FBXEXP_FILE &#x3D; (GetDir #temp) + &quot;&#x2F;MF_FBXEXP.txt&quot;content &#x3D; &quot;&quot;if (doesFileExist MF_FBXEXP_FILE) then( temp_stream &#x3D; openFile MF_FBXEXP_FILE mode:&quot;r&quot; content &#x3D; readLine temp_stream close temp_stream)-- 防止窗口多开try(DestroyDialog FBX_Export)catch()rollout FBX_Export &quot;MoreFun - FBX Export Tool&quot; width:293 height:104( button &#39;Options_BTN&#39; &quot;FBX Output Options&quot; pos:[18,16] width:257 height:21 align:#left edittext &#39;Path_LE&#39; &quot;Output_Path&quot; text:content pos:[18,42] width:203 height:21 align:#left button &#39;Select_BTN&#39; &quot;select&quot; pos:[226,41] width:47 height:21 align:#left button &#39;Export_BTN&#39; &quot;FBX export&quot; pos:[18,67] width:253 height:21 align:#left on Options_BTN pressed do ( OpenFbxSetting() ) on Select_BTN pressed do ( path &#x3D; getSavePath caption:&quot;get Output Folder&quot; Path_LE.text &#x3D; path temp_stream &#x3D; openFile MF_FBXEXP_FILE mode:&quot;w+&quot; format &quot;%&quot; path to:temp_stream close temp_stream ) on Export_BTN pressed do ( path &#x3D; Path_LE.text flag &#x3D; doesFileExist path if flag !&#x3D; true then( messageBox &quot;current directory not exist,please select a new directory&quot; return true ) if selection.count !&#x3D; 0 then( sel_list &#x3D; selection as array deselect sel_list for obj in sel_list do( select obj path_name &#x3D; path + &quot;&#x2F;&quot; + obj.name + &quot;.fbx&quot; exportFile path_name #noPrompt selectedOnly:True using:FBXEXP ) ) else ( file_name &#x3D; getFilenameFile maxfilename if file_name &#x3D;&#x3D; &#39;&#39; then ( messageBox &quot;current scene need to save as file&quot; return true ) path_name &#x3D; path + &quot;&#x2F;&quot; + file_name + &quot;.fbx&quot; exportFile path_name #noPrompt selectedOnly:False using:FBXEXP ) ))createDialog FBX_Export &emsp;&emsp;原本代码就这么简单就可以了。&emsp;&emsp;而且那个时候写代码还不知道 rollout 有 open 事件，可以让代码更加精炼的 参考 &emsp;&emsp;基本上开发到这里也就把 Max BUG 的问题规避了。 后续进阶 &emsp;&emsp;然而制作上的问题总是神出鬼没，制作人员居然换了 Max 2014 使用我的插件&emsp;&emsp;结果插件还是出问题了，只能说我图样图森破了。 &emsp;&emsp;代码出错的地方是 OpenFbxSetting 这一行&emsp;&emsp;我又查了文档，好吧，这东西从 2017 才开始支持，旧版本都用不了(:з」∠) 参考 &emsp;&emsp;为了实现支持，只好自己编写个 UI 界面来解决问题&emsp;&emsp;另外还需要考虑到设置存储的问题，我将他们统统设置到存储路径的文本当中。&emsp;&emsp;具体代码可以参照 github的仓库脚本 rollout 分类 CheckBox 复选框 DropDownList 下来菜单 &emsp;&emsp;基本上参考上面的文档进行操作 总结 &emsp;&emsp;虽然文章标题是进阶版，但是其实用 Maxscript 来写插件不如说是一种倒退吧(:з」∠)&emsp;&emsp;为了稳定和兼容所做出的妥协，不过研究一下还是受益良多。 &emsp;&emsp;今天抽空上传了 3dsMax 的官方教程&emsp;&emsp;不知道自己会不会抽时间去学习。&emsp;&emsp;用了 Max 之后还是觉得 Maya 香，不知道 Houdini 是否会更香。]]></content>
      <categories>
        <category>CG</category>
        <category>3dsMax</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>੃3dsMax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya2017 大纲列表显示 Bug]]></title>
    <url>%2Fposts%2F716eb47e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;今天动画师给我提了个需求&emsp;&emsp;说Maya大纲列表里面有很多乱七八糟的集，希望我可以干掉他们。&emsp;&emsp;阻碍到他选择控制器了。&emsp;&emsp;很神奇的是，只要导入一个文件，这些乱七八糟的集就不再是问题了。 解决方法 &emsp;&emsp;于是我自己打开测试了一下，的确是很奇怪。&emsp;&emsp;最让我不解地是，一旦导入之后，再次打开动画文件就没有显示那些乱七八糟的变形器集了。 &emsp;&emsp;因此我确信这大概是 Maya 的 BUG，但是我却不知道这个问题到底出在哪里，又要怎么解决。 &emsp;&emsp;后来向大佬询问了之后才发现原来这真的是 Maya2017 的BUG，并且已经在 Maya2018 修复了。&emsp;&emsp;通过下面的链接的 Mel 语言可以解决这个问题。 解决方案 1234string $outliners[] = `getPanel -type outlinerPanel`;// Setfor ( $outliner in $outliners )&#123; outlinerEditor -e -setFilter "defaultSetFilter" $outliner; &#125; 1234from maya import cmdsfor outliner in cmds.getPanel(type="outlinerPanel"): cmds.outlinerEditor(outliner,e=1,sf="defaultSetFilter") &emsp;&emsp;网址里面也说了，这个Bug是Maya没有设置过滤器导致的，结果导致一些变形器的set也都显示在大纲列表里面。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 「原力动画」全面开放自研新技术，希望助力中国动画行业发展]]></title>
    <url>%2Fposts%2F53edd78c.html</url>
    <content type="text"><![CDATA[原文链接 时至年末，回顾2019年中国动画市场多次迎来高光时刻。动画作为视觉艺术与现代科技深度融合的行业，技术硬核的标签愈加明显。36氪获悉，原力动画近日公布其自主研发的三项全新动画制作技术OF-USD、Gaffer和 RigX，并决定2020年向全行业免费开放。 OF-USD和基于Gaffer的灯光渲染流程，实现MAYA和灯光渲染的完整USD支持 对于动画制作端而言，皮克斯工作室开源的动画工具Universal Scene Description（USD）具有重要意义，它实现了不同流程和动画软件之间的3D数据无缝传递。但是USD是一个开源的标准，各软件厂商还没有开发相应的原生支持。如果想完整的实现USD落地，更多的只能依靠自研团队来完成匹配度更高的系统定制，而在国内拥有这项能力的动画公司屈指可数。 MAYA是国内使用最多的动画软件，目前尚未原生支持USD，官方的支持还处于实验阶段。原力数字技术研发中心开发团队，结合自身动画生产的需要，自主开发了一系列的流程工具及功能，为MAYA开发了完整的USD支持，实现了USD文件从建模、材质，镜头、绑定、动画、特效、等光渲染整套流程无缝衔接。 同时，原力自研的OF-USD技术，可以实现动画生产的并行编辑。不同制作环节的艺术家，可以同时对同一资产和场景进行改动并予以保存，再更新到其他制作环节，上下游环节可以根据自己的需要和工作内容来对同一个USD生产文件进行编辑。 原力数字技术研发人员表示该项技术实现了USD文件和MAYA场景文件的实时转换，实现了大场景的实时交互。在复杂的场景中，当物体数量过百，mesh面片数量达到千万级，场景打开时间会超过1小时，交互速度延迟成每秒小于1帧左右。而同样的场景在USD流程中打开的平均时间小于10分钟，实时交互速度每秒10帧以上。这样的巨型场景，在影视动画项目中并不少见，基于USD流程的工具大大提升了此类文件的读入和交互速度, 便于艺术家们的快捷处理。 此外，原力还在MAYA中开发嵌入了基于USDview的视窗，将MAYA材质网络和USD实时材质网络进行转换，使得用户可以在MAYA视窗中实时快速预览材质、切换数字资产各种变体，并且支持对USD文件资产的实时改动以及发布。同时，原力数字技术研发中心结合最新的Materialx材质定义技术，开发了在不同渲染器以及UE引擎中的实时转换功能，真正做到无缝对接。 原力也进一步完善了高性能的开源渲染平台Gaffer对USD的支持，让Gaffer可以更原生的理解USD文件概念结构，并能够在Gaffer视窗中切换数字资产变体。基于MaterialX材质定义技术，MAYA材质网络和Gaffer材质网络进行转换，让携带MaterialX材质文件的USD资产能够在Gaffer直接渲染。 自研新技术RigX，希望实现高效绑定加速系统在动画制作中，绑定是给模型加上灵魂的一步，因为每一个模型都需要经过绑定才能进入动画的环节。随着制作技术的不断发展，角色绑定的性能问题已经受到业内普遍关注。虽然影视制作的最终产品是固定的离线渲染结果，但在制作过程中，能否达到实时水平直接影响着生产效率。 据了解，针对角色绑定性能严重退化的问题，业内不少公司已经开始着手研发了新的计算平台，试图取代如今的主流动画制作软件。这些以新兴的计算平台以高性能为设计目标，即使能够达到实时水平，但仍然存在一个普遍的问题，那就是由于缺少很多重要功能，且使用方式与传统软件大相径庭，导致了制作公司想要把文件迁移到新的平台上变得非常困难。此外，CG生产中，在保证艺术效果的前提下，再提高绑定性能，有的制作公司会采用完成绑定后重写关键节点的方式来解决。这种方法虽然满足了艺术效果及性能要求，但需要高昂的人力成本，无法大规模使用。 针对以上痛点，原力自研了新技术RigX。据了解，RIgX可以将绑定文件自动转化为C++代码，而不需要技术人员或艺术家的介入。在加速效果上，由于自动转化可以一视同仁地处理整个绑定文件，而不需要像手动转化一样选择非常小的一部分加速，所以最终的加速效果往往比手写代码的方式更好。原力数字技术研发人员分享了一组数据，“以一个MAYA绑定文件为例，原来每秒帧率2，转化之后提高超过24，是原来MAYA原生系统的10倍以上。这样可以让动画师更加实时的进行动画调整，大大加快动画生产速度。” MAYA目前是绑定制作的主流软件之一，RigX自主研发了一个和MAYA有着相同功能但又完全独立的计算后端，它可以完全自动化的将MAYA文件转化为新的高性能形式，不需要人工干涉。同时，新的计算后端可以让任意的MAYA绑定文件快捷简单的移植到Unreal Engine等其它软件中，这对于动画制作而言是个很大的突破。 “硬核”一直是原力的重要标签，原力也始终坚持文化+科技的深度融合。原力动画CEO赵锐表示，“在大部分人的观念里，动画公司是做艺术品，但是为什么好莱坞很多公司能做出厉害的作品，因为它不仅限于艺术，而是一个真正的高科技公司，运用了更多科技的方法来实现艺术品。” 原力动画 Original Force 成立于 1999 年，主要从事高科技数字娱乐内容创制，擅长角色动画数字内容的研发。原力也是国内最大的 3D 计算机动画公司，国内已知的在科技领域投入最多的动画公司之一。其原创代表作有《妈妈咪鸭》， 制作的影视、游戏作品包括《爵迹》《驯龙高手》《GTA》《战神》《神秘海域》《全职高手》等多部作品。 原力总部位于南京，在中、美、泰等国家设有分公司，业务覆盖了影视相关的 IP 开发、项目投资、内容创制、技术研发、衍生授权、人才培养等领域。原力于2016年获得了腾讯的过亿元融资，现有员工1500 人，其中包含全球近千名 3D 动画艺术家、工程师。 p{ text-indent:2em; }]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>✒博客/©转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 法线解锁]]></title>
    <url>%2Fposts%2F4cc5c02.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;昨天做建模的美术给我提了个需求&emsp;&emsp;3ds Max 导入的模型一旦没有办法修改软硬化边。&emsp;&emsp;主要原因是导入的模型锁定了，一旦解锁，所有的法线就会重置成硬边。&emsp;&emsp;虽然对于制作人员来说建模工具都无所谓了，哪个顺手用哪个。&emsp;&emsp;不过目前还是朝着Maya的方向进行切换，如果可以更顺手那么 Maya 流程推进也能更顺利。 &emsp;&emsp;而且这个法线问题也的确是个较为让人头疼的问题。&emsp;&emsp;我原本以为非常简单就可以解决，不仅是 API ， Mel 也有相关获取顶点法线数据的命令。&emsp;&emsp;理论上只要解锁之前读取数据，解锁之后重新设置法线就可以了。&emsp;&emsp;然而我大意了，重新设置法线之后，法线就会处于锁定状态，这个和软硬化边的操作不完全一样。&emsp;&emsp;为此我花了一整天的时间探索怎么解决这个问题。 &emsp;&emsp;在Maya里面黄色表示法线锁定，绿色表示没有锁定。 &emsp;&emsp;关于软硬边可以参照这个教程&emsp;&emsp;3、4 集都有很详尽的描述，非常有用。 前期探索 &emsp;&emsp;最初其实我怀疑是 FBX 导入导出的设置问题。&emsp;&emsp;后来结合 Obj 流程进行测试，我发现Maya导入的模型都是锁定状态的，除非设置了解锁之类的操作。&emsp;&emsp;因此导入进来的法线信息是正确的，但是一旦解锁就会重置。 &emsp;&emsp;3ds Max 的导出就是如此。&emsp;&emsp;然后我去看 Maya 导出的FBX是什么情况。&emsp;&emsp;如果 Maya 导出 FBX 在不锁定法线的情况下导出，那么导回Maya是可以正确解锁的。&emsp;&emsp;但是如果导出的时候锁定了法线，导回来解锁就变成了硬边状态了。 &emsp;&emsp;最让人无语的就是混合导出，也就是软硬边都有的常见状态，这种也是一解锁就丢失所有软硬边信息。&emsp;&emsp;这对美术的制作人员来说实在是太痛苦了。 &emsp;&emsp;开始我还是坚信是 FBX 的设置有问题，毕竟导出的时候的确有 法线信息 导出相关的选项。&emsp;&emsp;可是经过测试并不管用。&emsp;&emsp;于是我网上搜索了相关的链接。&emsp;&emsp;我发现有不少的解决方案，但是没有一个是我想要的。 通过 Mel 脚本修改顶点法线 通过 transfer Attribute 传递模型的法线信息 &emsp;&emsp;上述的两个方案我都测试过了，问题都是修改之后法线就被锁定了。&emsp;&emsp;即便是手动设置法线角度的各种操作都会锁定法线。&emsp;&emsp;因此照抄模型数据的方案是不可行的。 踩坑尝试 &emsp;&emsp;最后发现只有软硬化边的节点是不锁定法线。&emsp;&emsp;因此只需要找到模型软化的边，然后解锁，然后对这些边进行软化操作就可以了。 &emsp;&emsp;因此需要解决的问题就是如何从导入的模型上找到硬化的边和软化的边。 github脚本地址 &emsp;&emsp;我最初是通过 pymel 来获取模型上的点，然后通过点的 getNormals 方法获取相邻面的法线信息。&emsp;&emsp;这里获取到的法线有很严重的缺点，就是不知道法线的向量对应的面是哪一个。&emsp;&emsp;也就无法判断哪些向量需要考虑的。&emsp;&emsp;唯一明确的是软化边所有向量都重合的，硬化边则相反。&emsp;&emsp;因此我认为可以通过比对每一个向量的是否相等来确定这个顶点是否含有硬化边。 &emsp;&emsp;由于 pymel 的执行效率很慢，我还做了个测试。&emsp;&emsp;后续将脚本转为 OpenMaya 来实现，中间在获取顶点法线数据的时候还卡了好一会。&emsp;&emsp;后面是法线可以通过迭代器来获取法线数据 &emsp;&emsp;这个思路应对大量平滑的四边面检测是可行的，但是一旦涉及单一的硬化变就无法判断了。&emsp;&emsp;特别是将模型三角化之后暴露了很多检测错误的问题。&emsp;&emsp;然而Maya没有向量对应面的信息，也是让我头疼不已。 &emsp;&emsp;后面沿着这个思路走了很多弯路。失败示范1失败示范2 &emsp;&emsp;当时还想到将向量数组转成字符 然后计算出 md5 的值&emsp;&emsp;后面解锁之后，法线的数据就被改变了，重新算一遍 md5 的值，就可以找到哪些顶点的法线发生了改变。&emsp;&emsp;那么顶点相关的法线就可以硬化了。 &emsp;&emsp;然而这个方案就还是不行，因为顶点周围的边无法判断哪一个才是软化边。&emsp;&emsp;然而并不是所有顶点相邻的边需要软化的，结果就会出现瑕疵。 &emsp;&emsp;后面还想到既然 软化边 这个节点是通过角度计算过滤的。&emsp;&emsp;那 Maya 能否过滤出特定角度法线的边呢？&emsp;&emsp;网上一查也的确有方案，可以通过 polySelectConstraint 命令来实现。&emsp;&emsp;然而真实情况是硬化边可能是人工加上去的，才不管他的这是角度是多少。&emsp;&emsp;因此这个方案也行不通了。 最终解决方案最终解决方案 &emsp;&emsp;后面我看到可以通过 MItMeshFaceVertex 来遍历面上的点，并且通过这个点来获取到对应的法线&emsp;&emsp;这样就可以构建出面对应顶点的法线数据字典。&emsp;&emsp;我遍历边的时候可以找到对应的顶点和面。&emsp;&emsp;接着通过上面获取的字典就可以找到对应面的法线信息，这样一比较就能顺利找出边是否为硬边了。 &emsp;&emsp;结果还是因为之前嫌这个方法有点绕，也没有深入思考是否可以构建出数据对应的字典，而且这个遍历两次效率也有点低。&emsp;&emsp;结果就一直没有尝试，没想到最后还是通过这个方法解决选边的问题。 &emsp;&emsp;这个脚本可以选择出模型软化的边，当然如果模型的法线是经过人工修改的，那我的脚本是直接当成硬边处理了。&emsp;&emsp;毕竟一般美术也不会手动修改顶点法线这种操作的，再说这种操作必然锁定法线了的。 &emsp;&emsp;脚本的逻辑再捋一遍 导入模型 遍历模型获取面对应点法线的数据 遍历模型上的边，找到边上顶点对应相邻面的法线数据 对比数据找到软化的边 法线解锁 对软化的边重新进行软化边操作 总结 &emsp;&emsp;虽然这个东西我折腾了一天，最后还是顺利弄好了，满满的成就感。&emsp;&emsp;而且貌似网上也没有这样操作的解决方案，能够解决制作人员的痛点，我还是很开心的。&emsp;&emsp;最后其实脚本还有一些可优化的地方，比如添加进度条以及选择部分的线进行单独的解锁。&emsp;&emsp;不过目前脚本其实已经够用了，以后再看需求吧。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3dsMax FBX导出工具]]></title>
    <url>%2Fposts%2Ff4dcd89b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;因为有 Maya 技术积累的自信，对于做 3dsMax 的二次开发其实我是充满了自信的。&emsp;&emsp;虽然我之前不怎么用 3dsMax 但是，我知道 3dsMax 按照自动桌的尿性，帮助文档可以解君愁。 &emsp;&emsp;因此之前我被介绍的时候，大家以为我是搞 3dsMax 我也没有去否认了，反正大不了就看看文档写就好了。 &emsp;&emsp;果不其然昨晚就收到了相关的开发需求，而且需求还是相对简单的。&emsp;&emsp;因此我就看了半套教程配合自动桌的文档解决了问题。 需求说明 &emsp;&emsp;首先明确一下这次开发的需求。&emsp;&emsp;3dsMax 导出 FBX 的时候每次都会弹出一个导出选项的窗口。&emsp;&emsp;而且每一次都是默认的设置，尽管这里的设置可以保存预设切换读取，但是对于制作人员来说还是非常不友好。&emsp;&emsp;因此需求很简单，就是导出的时候可以使用上次的设置，简单清晰就给你导出了。 前期准备 &emsp;&emsp;毕竟自己还是没有接触过 maxscript ，相应的教程准备还是要看的。&emsp;&emsp;在B站搜罗了一轮之后，发现 DigitalTutors 有教程，非常棒。 Digital Tutors - Automating Tasks Using MAXScript in 3ds Max &emsp;&emsp;另外看到教程的 13 集导出的方法，其实就和需求想要的效果差不多&emsp;&emsp;另外我可以通过 PySide 制作界面，剩下我去搞 maxscript 图形编程的问题。 &emsp;&emsp;剩下的解决方案基本上是通过 Autodesk 官方文档找了，Stack Overflow里面也没有多少有价值的提问。&emsp;&emsp;网上的教程也不多(:з」∠) 开发填坑 &emsp;&emsp;首先测试的时候，我发现 max 居然还不能通过拖拽执行 python 脚本&emsp;&emsp;因此只好通过 maxscript 调用 python 间接实现调用。 &emsp;&emsp;毕竟是要搞 FBX 的导出，因此我在 3dsMax 的官方帮助里面搜索 FBX export&emsp;&emsp;可以找到这个页面 &emsp;&emsp;而且上面教程里也有用到这个命令。&emsp;&emsp;最重要的是 页面 里面提示了我可以通过 OpenFbxSetting() 打开设定面板。 &emsp;&emsp;测试了之后，这里打开的 设定面板 ， 并且这里做的所有操作都是可记录，就没有原本 FBX 导出那么蛋疼了。 &emsp;&emsp;于是我花了一些时间绘制了一个 ui ，然后转换成 py 文件，在 3dsMax 里面测试能否实现 Qt 的编程&emsp;&emsp;一切都很顺利，并没有太棘手的问题。 &emsp;&emsp;后续就到了关键的输出步骤了 ，我在官方文档上找到了相关的页面 12theClasses &#x3D; exporterPlugin.classesexportFile (GetDir #scene + &quot;&#x2F;exportTest&quot; ) using:theClasses[1] &emsp;&emsp;我看到输出的类型还需要找到对应的插件去 using 才可以，巨麻烦。&emsp;&emsp;而且 GetDir 的 #scene 也不知道怎么通过 pymxs 获取 ， #noPrompt 标记也不知道如何启用。&emsp;&emsp;幸好教程也有同样的写法，Using 可以直接写 FBXEXP 插件名称即可&emsp;&emsp;默认加载插件就可以识别得到这个变量，省去了过滤的步骤。 &emsp;&emsp;不过 GetDir 还是不知道怎么才能正确使用起来。 12from pymxs import runtime as rtrt.GetDir("#scene") &emsp;&emsp;原以为是这样子调用，但是这样会报错，而且错得莫名其妙。&emsp;&emsp;我也参照了 GetDir 的文档，但是对于 #scene 这些类型的变量依然一无所获&emsp;&emsp;后来一直没有解决，因此我就通过 python 调 maxscript 来解决这个问题&emsp;&emsp;具体的操作可以参照 文档 &emsp;&emsp;当然这样的解决方案不太让我满意，于是我写文章之际做了进一步的研究。&emsp;&emsp;最后我按照教程的说法，用 classof 函数测一下带 # 这个符号的变量类型&emsp;&emsp;结果发现这些变量并不是 string 而是 name，于是又查了一下 name 这种类型的变量。 文档&emsp;&emsp;现在好了，这是一个独特的类型，那应该是可以通过 Name 来进行类型转换的。&emsp;&emsp;于是我 dir(rt) 罗列出所有的属性，果然有 name 的函数可以用来进行类型转换。&emsp;&emsp;因此上面要起作用需要转化成下面的写法。 12from pymxs import runtime as rtprint rt.GetDir(rt.name("scene")) &emsp;&emsp;解决了这个棘手的类型转换问题之后，也就顺理成章可以解决掉 #noPrompt 标记的问题 12from pymxs import runtime as rtrt.exportFile(r"C:\Users\timmyliang\Desktop\test\a.fbx",rt.name("NOPROMPT"),using=rt.FBXEXP) &emsp;&emsp;另外 maxscript 有个神奇的地方就是变量不严格区分大小写。&emsp;&emsp;因此 noprompt 大小写都无所谓的，但是和 python 相关的部分就要好好区分清楚。 数据记录 &emsp;&emsp;由于美术那边希望可以记录到上次脚本调用的路径，因此还需要做一个存储功能。&emsp;&emsp;我最初的想法就是通过json文件进行记录，但是这样脚本就会很臃肿。&emsp;&emsp;于是我打算将路径记录到脚本自身。&emsp;&emsp;因此我要在 maxscript 里面的开头两行做路径记录的注释，然后通过 python.Execute 来执行 PySide Qt 的界面。&emsp;&emsp;然后这个 python 调用里面有集成了 maxscript 的调用，真的是够绕的。&emsp;&emsp;因为 maxscript 是不支持 单引号 的，因此调用的时候还要对 python 的双引号做转义处理。&emsp;&emsp;又因为这里的python内部调用了 maxscript ，所以这里的双引号无法用单引号避开，尤为需要注意。 &emsp;&emsp;于是继续到存储的操作上。&emsp;&emsp;由于 python 文件是通过 maxscript 调用的，因此就无法通过 __file__ 内置变量来获取脚本路径 &emsp;&emsp;好在 maxscript 还是集成了获取脚本路径的函数 getSourceFileName() 文档&emsp;&emsp;获取了脚本路径之后需要获取脚本的目录 虽然可以通过字符串处理来获取，但是希望找到更加简洁的方式。&emsp;&emsp;于是找了一下发现了 getFilenamePath 函数 文档 &emsp;&emsp;于是后续的操作就是将这个字符串拼接到 python 脚本内部就可以了。 &emsp;&emsp;下面就是代码，获取路径之后 会修改第二行的路径 ，因此不能修改脚本的内容，否则就乱套了。 12345678910111213141516-- NOTE 下面这一行注释会通过 python 进行读取设置到工具的路径上-- C:\Users\timmyliang\Desktop\test-- https:&#x2F;&#x2F;help.autodesk.com&#x2F;view&#x2F;3DSMAX&#x2F;2016&#x2F;ENU&#x2F;?guid&#x3D;__files_GUID_9588A886_A811_4C05_9A07_B6A68C969050_htm-- NOTE 获取当前脚本的路径SCRIPT_PATH &#x3D; getSourceFileName()-- http:&#x2F;&#x2F;help.autodesk.com&#x2F;view&#x2F;3DSMAX&#x2F;2015&#x2F;ENU&#x2F;?guid&#x3D;__files_GUID_0EE531B2_6FF8_4D0B_ACA1_5400E0B9D604_htm-- NOTE 获取当前脚本的文件夹-- script_folder &#x3D; getFilenamePath(script_path)code &#x3D; &quot;__author__ &#x3D; &#39;timmyliang&#39;\n__email__ &#x3D; &#39;820472580@qq.com&#39;\n__date__ &#x3D; &#39;2019-11-26 14:52:34&#39;\n\nu&#39;&#39;&#39;\nMoreFun - FBX导出工具\n简化 3dsMax FBX 导出流程\n&#39;&#39;&#39;\n\nimport os\nimport sys\ntry:\n from PySide.QtCore import *\n from PySide.QtGui import *\nexcept:\n from PySide2.QtWidgets import *\n from PySide2.QtCore import *\n from PySide2.QtGui import *\n\nimport MaxPlus\nimport pymxs\nimport json\nfrom pymxs import runtime as rt\n\nSCRIPT_PATH &#x3D; r&#39;&quot;+SCRIPT_PATH+&quot;&#39;\n\nclass Ui_Form(object):\n def setupUi(self, Form):\n Form.setObjectName(&#39;Form&#39;)\n Form.resize(349, 184)\n Form.setWhatsThis(&#39;&#39;)\n self.verticalLayout &#x3D; QVBoxLayout(Form)\n self.verticalLayout.setObjectName(&#39;verticalLayout&#39;)\n self.Options_BTN &#x3D; QPushButton(Form)\n self.Options_BTN.setObjectName(&#39;Options_BTN&#39;)\n self.verticalLayout.addWidget(self.Options_BTN)\n self.horizontalLayout &#x3D; QHBoxLayout()\n self.horizontalLayout.setObjectName(&#39;horizontalLayout&#39;)\n self.label &#x3D; QLabel(Form)\n self.label.setObjectName(&#39;label&#39;)\n self.horizontalLayout.addWidget(self.label)\n self.Path_LE &#x3D; QLineEdit(Form)\n self.Path_LE.setObjectName(&#39;Path_LE&#39;)\n self.horizontalLayout.addWidget(self.Path_LE)\n self.Path_BTN &#x3D; QPushButton(Form)\n self.Path_BTN.setObjectName(&#39;Path_BTN&#39;)\n self.horizontalLayout.addWidget(self.Path_BTN)\n self.verticalLayout.addLayout(self.horizontalLayout)\n self.Export_BTN &#x3D; QPushButton(Form)\n self.Export_BTN.setObjectName(&#39;Export_BTN&#39;)\n self.verticalLayout.addWidget(self.Export_BTN)\n spacerItem &#x3D; QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)\n self.verticalLayout.addItem(spacerItem)\n\n self.retranslateUi(Form)\n QMetaObject.connectSlotsByName(Form)\n\n def retranslateUi(self, Form):\n Form.setWindowTitle(u&#39;MoreFun - FBX导出工具&#39;)\n self.Options_BTN.setText(u&#39;FBX导出选项&#39;)\n self.label.setText(u&#39;输出路径&#39;)\n self.Path_BTN.setText(u&#39;选择路径&#39;)\n self.Export_BTN.setText(u&#39;FBX导出&#39;)\n\nclass MF_FBXEXP_UI(QWidget,Ui_Form):\n def __init__(self):\n super(MF_FBXEXP_UI,self).__init__(MaxPlus.GetQMaxWindow())\n\n self.setupUi(self)\n self.Options_BTN.clicked.connect(self.openOptions)\n self.Path_BTN.clicked.connect(self.selectPath)\n self.Export_BTN.clicked.connect(self.exportFBX)\n \n # NOTE 防止窗口多开\n for child in MaxPlus.GetQMaxWindow().children():\n if &#39;MF_FBXEXP_UI&#39; in str(type(child)):\n child.close()\n\n self.show()\n\n # NOTE 读取 maxscript 第一行的注释获取\n self.initPath()\n\n def initPath(self):\n\n if not os.path.exists(SCRIPT_PATH):\n return\n\n with open(SCRIPT_PATH,&#39;r&#39;) as f:\n self.script_data &#x3D; f.readlines()\n first_line &#x3D; self.script_data[1].strip()\n \n self.Path_LE.setText(first_line[3:])\n\n def openOptions(self):\n rt.OpenFbxSetting()\n\n def selectPath(self):\n\n # NOTE 根据现有的路径打开路径选择\n directory &#x3D; os.path.dirname(self.Path_LE.text())\n if not os.path.exists(directory):\n directory &#x3D; &#39;&#39;\n\n output_path &#x3D; QFileDialog.getExistingDirectory(self,dir&#x3D;directory,caption&#x3D;u&#39;导出FBX文件目录&#39;) \n \n # NOTE 如果关闭窗口或者取消\n if not output_path :\n return\n \n self.Path_LE.setText(output_path)\n\n if not os.path.exists(SCRIPT_PATH):\n return\n\n self.script_data[1] &#x3D; &#39;-- %s\\n&#39; % output_path\n with open(SCRIPT_PATH,&#39;w&#39;) as f:\n f.writelines(self.script_data)\n\n def exportFBX(self):\n \n output_path &#x3D; os.path.normpath(self.Path_LE.text()).replace(&#39;\\\\&#39;,&#39;&#x2F;&#39;)\n\n if output_path &#x3D;&#x3D; &#39;&#39;:\n QMessageBox.warning(self,u&#39;警告&#39;,u&#39;路径不能为空&#39;)\n return\n \n folder &#x3D; os.path.dirname(output_path)\n if not os.path.exists(folder):\n QMessageBox.warning(self,u&#39;警告&#39;,u&#39;当前给定目录不存在，请重新选择路径&#39;)\n return\n\n # NOTE 无窗口导出FBX\n MaxPlus.Core.EvalMAXScript(&#39;&#39;&#39;\n if selection.count !&#x3D; 0 then(\n sel_list &#x3D; selection as array\n deselect sel_list\n for obj in sel_list do(\n select obj\n path_name &#x3D; \&quot;&#123;0&#125;&#x2F;\&quot; + obj.name + \&quot;.fbx\&quot;\n exportFile path_name #noPrompt selectedOnly:True using:FBXEXP\n )\n ) else (\n file_name &#x3D; getFilenameFile maxfilename\n path_name &#x3D; \&quot;&#123;0&#125;&#x2F;\&quot; + file_name + \&quot;.fbx\&quot;\n exportFile path_name #noPrompt selectedOnly:False using:FBXEXP\n )\n &#39;&#39;&#39;.format(output_path))\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n FBXEXP &#x3D; MF_FBXEXP_UI()\n \n&quot;-- NOTE 运行 Python 代码-- print codepython.Execute code 菜单集成 &emsp;&emsp;其实到这一步就基本已经完成了 美术 想要的需求了。&emsp;&emsp;只是后面还有一个优化方案，就是希望可以开启 3dsMax 的时候可以自动显示出插件。 &emsp;&emsp;考虑到 Maya 颇为复杂的配置，我还是咨询了我的导师看看 TA 组内是否有现成的配置方案。 &emsp;&emsp;于是 导师 就给我发了以前项目用的脚本。&emsp;&emsp;用起来也非常方便，只需要将脚本拖拽到 Max 就会生成相应的下拉菜单，而且这个菜单生成是永久记录的。&emsp;&emsp;一次运行解君愁。 &emsp;&emsp;我模仿导师发给我的脚本也做了一个下拉菜单。&emsp;&emsp;菜单需要用到 MacroScript 来进行触发调用。&emsp;&emsp;然后通过 menuMan.getMainMenuBar() 来获取 Max 的主菜单进行添加操作。&emsp;&emsp;我看了一下文档，也有相关的代码案例可以参考。 &emsp;&emsp;最后顺利将自己的脚本集成到了上面的下拉菜单上。&emsp;&emsp;然后当我关了 3dsMax 重开之后，我发现我输入的中文字符全部变成了 ? (:з」∠) &emsp;&emsp;后来又在网上查了不少的文档，这个Character Encoding 文章说得很透彻&emsp;&emsp;详细阐述了 脚本编辑器 如果不按照正确的方式存储， ascii 以外的字符统统变成问号。&emsp;&emsp;我突然明白上面的菜单调用肯定也是调用了 用户设置 的文件，然后通过这些文件在开启 Max 的时候生成菜单的。&emsp;&emsp;于是我又突然想起昨天看到的 B站 上解决Max的方法，操作其实就和删除 Maya 我的文档的文件是一样的。&emsp;&emsp;想不 Max 也和 Maya 一样有记录用户设置的文件夹，只是和 Maya 放的 位置不一样而已。 &emsp;&emsp;于是翻了视频看 找到了目标路径 C:\Program Files\Autodesk\3ds Max &lt;ReleaseNumber&gt;\&emsp;&emsp;删除这个文件夹之后， Max 就会恢复到默认的设置上了。 &emsp;&emsp;于是我用 VScode 在这个目录下寻找我生成的 文件。&emsp;&emsp;果不其然可以找到 \ENU\usermacros 可以找到菜单调用的代码，然后这里的代码就是全部 ? 号来的&emsp;&emsp;主要原因就是保存的时候没有按照上面 Character Encoding 文章 配置的问题导致的。&emsp;&emsp;我看到文章中有提到 Preference : Files 里面的设置。&emsp;&emsp;我试着把 save strings in legacy non-scene files using UTF8 这个选项勾选之后，奇迹就出现了。&emsp;&emsp;这样保存的 msc 文件就是正常的，而且关了重开也没有任何问题。 &emsp;&emsp;那么下面的问题就是如何通过代码来勾选这个选项。&emsp;&emsp;最初我想到的就是 Macro Recorder 录制这个操作，类似 Mel 看回显可以发现很多细节。&emsp;&emsp;然而 Max 到这里并没有这么智能，Maya 的撤销大法也不管用。 &emsp;&emsp;于是我就卡住了，还是得去官网查找文档 Files Preference 官方说明然而看来看去似乎并没有什么卵用。 &emsp;&emsp;后来偶然搜索到了这个文章&emsp;&emsp;这里提到可以通过 修改 max.ini 来解决这个问题。&emsp;&emsp;而且的确 max.ini 里面是有 LegacyFilesCanBeStoredUsingUTF8 这个属性&emsp;&emsp;当我修改了 Preference 之后这个文件就会随之更新。&emsp;&emsp;但是我手动修改这个属性，打开 Preference 似乎也并没有读取这里的 设置。 &emsp;&emsp;于是就在僵持的时候，我突然发现还可以通过 C++ SDK 来解决这个问题。&emsp;&emsp;于是搜了一下 MaxPlus 的相关函数，还真的让我找到了我想要的东西 123import MaxPlus as msif not ms.PreferencesFileEncoding.LegacyFilesCanBeStoredUsingUTF8(): ms.PreferencesFileEncoding.SetLegacyFilesCanBeStoredUsingUTF8(True) &emsp;&emsp;执行脚本之前可以先勾选这个设置就万无一失了。 &emsp;&emsp;最后还要处理路径存储的问题，因为现在切换为菜单创建&emsp;&emsp;因此存储不能通过脚本写入来实现。&emsp;&emsp;这里我借助 Python tempfile 库来获取系统的临时文件夹&emsp;&emsp;在临时文件夹里面创建一个存储路径的 txt 文档。&emsp;&emsp;变相解决了这个存储的问题。 总结 &emsp;&emsp;另外我发现 maxscript 是支持多行字符串的，这点比 Mel 要好很多。&emsp;&emsp;这样就可以保留 Python 的样式了，只是不能有额外的缩进而已。&emsp;&emsp;下面就是最终版本的代码 ↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193-- https:&#x2F;&#x2F;help.autodesk.com&#x2F;view&#x2F;3DSMAX&#x2F;2016&#x2F;ENU&#x2F;?guid&#x3D;__files_GUID_9588A886_A811_4C05_9A07_B6A68C969050_htm-- NOTE 获取当前脚本的路径-- SCRIPT_PATH &#x3D; getSourceFileName()-- http:&#x2F;&#x2F;help.autodesk.com&#x2F;view&#x2F;3DSMAX&#x2F;2015&#x2F;ENU&#x2F;?guid&#x3D;__files_GUID_0EE531B2_6FF8_4D0B_ACA1_5400E0B9D604_htm-- NOTE 获取当前脚本的文件夹-- script_folder &#x3D; getFilenamePath(script_path)-- NOTE 设置 utf-8 保存 | 避免中文显示乱码python.Execute &quot;import MaxPlus as msif not ms.PreferencesFileEncoding.LegacyFilesCanBeStoredUsingUTF8(): ms.PreferencesFileEncoding.SetLegacyFilesCanBeStoredUsingUTF8(True)&quot;macroScript OPcategory: &quot;OP FBX Export&quot;tooltip: &quot;批量导出FBX工具&quot;( -- NOTE 运行 Python 代码 python.Execute &quot;__author__ &#x3D; &#39;timmyliang&#39;__email__ &#x3D; &#39;820472580@qq.com&#39;__date__ &#x3D; &#39;2019-11-26 14:52:34&#39;u&#39;&#39;&#39;MoreFun - FBX导出工具简化 3dsMax FBX 导出流程&#39;&#39;&#39;import osimport sysimport tempfiletry: from PySide.QtCore import * from PySide.QtGui import *except: from PySide2.QtWidgets import * from PySide2.QtCore import * from PySide2.QtGui import *import MaxPlusimport pymxsimport jsonfrom pymxs import runtime as rt# NOTE 临时文件记录选择的路径SCRIPT_PATH &#x3D; os.path.join(tempfile.gettempdir(),\&quot;MF_FBXEXP_PATH.txt\&quot;)class Ui_Form(object): def setupUi(self, Form): Form.setObjectName(&#39;Form&#39;) Form.resize(349, 184) Form.setWhatsThis(&#39;&#39;) self.verticalLayout &#x3D; QVBoxLayout(Form) self.verticalLayout.setObjectName(&#39;verticalLayout&#39;) self.Options_BTN &#x3D; QPushButton(Form) self.Options_BTN.setObjectName(&#39;Options_BTN&#39;) self.verticalLayout.addWidget(self.Options_BTN) self.horizontalLayout &#x3D; QHBoxLayout() self.horizontalLayout.setObjectName(&#39;horizontalLayout&#39;) self.label &#x3D; QLabel(Form) self.label.setObjectName(&#39;label&#39;) self.horizontalLayout.addWidget(self.label) self.Path_LE &#x3D; QLineEdit(Form) self.Path_LE.setObjectName(&#39;Path_LE&#39;) self.horizontalLayout.addWidget(self.Path_LE) self.Path_BTN &#x3D; QPushButton(Form) self.Path_BTN.setObjectName(&#39;Path_BTN&#39;) self.horizontalLayout.addWidget(self.Path_BTN) self.verticalLayout.addLayout(self.horizontalLayout) self.Export_BTN &#x3D; QPushButton(Form) self.Export_BTN.setObjectName(&#39;Export_BTN&#39;) self.verticalLayout.addWidget(self.Export_BTN) spacerItem &#x3D; QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding) self.verticalLayout.addItem(spacerItem) self.retranslateUi(Form) QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): Form.setWindowTitle(u&#39;MoreFun - FBX导出工具&#39;) self.Options_BTN.setText(u&#39;FBX导出选项&#39;) self.label.setText(u&#39;输出路径&#39;) self.Path_BTN.setText(u&#39;选择路径&#39;) self.Export_BTN.setText(u&#39;FBX导出&#39;)class MF_FBXEXP_UI(QWidget,Ui_Form): def __init__(self): super(MF_FBXEXP_UI,self).__init__(MaxPlus.GetQMaxWindow()) self.setupUi(self) self.Options_BTN.clicked.connect(self.openOptions) self.Path_BTN.clicked.connect(self.selectPath) self.Export_BTN.clicked.connect(self.exportFBX) # NOTE 防止窗口多开 for child in MaxPlus.GetQMaxWindow().children(): if &#39;MF_FBXEXP_UI&#39; in str(type(child)): child.close() self.show() # NOTE 读取路径 self.initPath() def initPath(self): if not os.path.exists(SCRIPT_PATH): return with open(SCRIPT_PATH,&#39;r&#39;) as f: path &#x3D; f.read() self.Path_LE.setText(path) def openOptions(self): rt.OpenFbxSetting() def selectPath(self): # NOTE 根据现有的路径打开路径选择 directory &#x3D; os.path.dirname(self.Path_LE.text()) if not os.path.exists(directory): directory &#x3D; &#39;&#39; output_path &#x3D; QFileDialog.getExistingDirectory(self,dir&#x3D;directory,caption&#x3D;u&#39;导出FBX文件目录&#39;) # NOTE 如果关闭窗口或者取消 if not output_path : return self.Path_LE.setText(output_path) with open(SCRIPT_PATH,&#39;w&#39;) as f: f.write(output_path) def exportFBX(self): output_path &#x3D; os.path.normpath(self.Path_LE.text()) output_path &#x3D; output_path.replace(\&quot;\\\\\&quot;,\&quot;&#x2F;\&quot;) if output_path &#x3D;&#x3D; &#39;&#39;: QMessageBox.warning(self,u&#39;警告&#39;,u&#39;路径不能为空&#39;) return folder &#x3D; os.path.dirname(output_path) if not os.path.exists(folder): QMessageBox.warning(self,u&#39;警告&#39;,u&#39;当前给定目录不存在，请重新选择路径&#39;) return # NOTE 无窗口批量导出FBX MaxPlus.Core.EvalMAXScript(&#39;&#39;&#39; if selection.count !&#x3D; 0 then( sel_list &#x3D; selection as array deselect sel_list for obj in sel_list do( select obj path_name &#x3D; \&quot;&#123;0&#125;&#x2F;\&quot; + obj.name + \&quot;.fbx\&quot; exportFile path_name #noPrompt selectedOnly:True using:FBXEXP ) ) else ( file_name &#x3D; getFilenameFile maxfilename path_name &#x3D; \&quot;&#123;0&#125;&#x2F;\&quot; + file_name + \&quot;.fbx\&quot; exportFile path_name #noPrompt selectedOnly:False using:FBXEXP ) &#39;&#39;&#39;.format(output_path))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: FBXEXP &#x3D; MF_FBXEXP_UI() &quot;)------------------------------ NOTE 创建面板----------------------------mainMenuBar &#x3D; menuMan.getMainMenuBar()ori_OP_menu &#x3D; menuMan.findMenu(&quot;OP&quot;)if (not ori_OP_menu &#x3D;&#x3D; undefined) do( menuMan.unRegisterMenu ori_OP_menu)subMenu &#x3D; menuMan.createMenu &quot;OP&quot;FBXExportItem &#x3D; menuMan.createActionItem &quot;OP&quot; &quot;OP FBX Export&quot;subMenu.addItem FBXExportItem -1subMenuItem &#x3D; menuMan.createSubMenuItem &quot;FBX批量导出工具&quot; subMenusubMenuIndex &#x3D; mainMenuBar.numItems() - 1mainMenuBar.addItem subMenuItem subMenuIndexmenuMan.updateMenuBar()]]></content>
      <categories>
        <category>CG</category>
        <category>3dsMax</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>੃3dsMax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya 次级控制器跟随方案]]></title>
    <url>%2Fposts%2Ffc4346ec.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近手头上有了新的工作，需要我去做角色的表情绑定。&emsp;&emsp;虽然之前在华强做了半年的表情。&emsp;&emsp;不过我做的事情是驱动开发，其实和绑定没有太大的关系。&emsp;&emsp;虽然理解了华强那一套绑定的精髓，但是没有亲手去实现过。 &emsp;&emsp;最近自己又要成为一个 Rigger 绑定师来做绑定了&emsp;&emsp;就打算好好研究一下以前学习欠下来的东西。 &emsp;&emsp;我找了不少绑定文件，打算参透不同的绑定系统，结合有用的放到绑定上 &emsp;&emsp;其中我发现有一套的绑定的次级跟随特别牛逼，叫做 Lou Rig &emsp;&emsp;可以看到这套绑定的强大之处在于次级控制器完美跟随模型的运动&emsp;&emsp;而且次级控制器的控制依然完全跟手。 &emsp;&emsp;以前研究IKFK切换的时候，就是遇到了这个难点没有办法解决，因此才必须使用脚本进行切换，因为如果通过 父子约束 的话，会产生约束循环的问题，直接导致变换叠加。&emsp;&emsp;如果不明白什么是约束循环，可以试下在一个父子对象的物体下用子物体对父物体进行父子约束。 &emsp;&emsp;其实仔细想想就知道，父物体会带动子物体，但是子物体约束了父物体之后，也可以带动父物体，这就变成永动机了(:з」∠)&emsp;&emsp;因此Maya会发出警告，并且将这个死循环终止。 &emsp;&emsp;但是回过头来看 Lou Rig ，它解决了这个蛋疼的问题。&emsp;&emsp;而且还不知道用什么方法实现了轴心点持续跟手。 &emsp;&emsp;于是抱着巨大的好奇，我研究了一下整套跟随系统的设置原理。 跟随基本原理 &emsp;&emsp;要实现跟随首先需要完成模型运动位置的追踪。&emsp;&emsp;在 lou_rig 的绑定文件中是通过曲线包裹变形器实现位置信息的跟踪。 &emsp;&emsp;这里我采用的方法是使用 毛囊 来实现模型运动的跟随。&emsp;&emsp;其实都为了追踪到 Mesh 节点的变形效果而已，目的是一样的。&emsp;&emsp;同理也可以使用 rivet 脚本（肌肉系统其实是附带的） &emsp;&emsp;有了这个运动信息之后就可以通过这里的位置移动来“约束”到控制器上。&emsp;&emsp;当然直接约束就是典型的永动机了，因此需要耍一些花招。&emsp;&emsp;我先做一套简单的绑定来测试效果。 我的绑定测试 &emsp;&emsp;我自己做了一个简单的绑定将整个跟随系统简化成一个小球的绑定情况。 &emsp;&emsp;下面简单阐述一下这里要做的效果。&emsp;&emsp;首先是一套蒙皮的绑定效果。&emsp;&emsp;六根骨骼可以控制这个球体。&emsp;&emsp;这个被绑定的模型称之为 Skin &emsp;&emsp;接着复制蒙皮的模型，这个模型作为 毛囊 模型用来约束蒙皮模型的骨骼。&emsp;&emsp;然后通过脚本，根据骨骼的位置计算UV数值，并生成在对应位置生成毛囊。 &emsp;&emsp;如此一来毛囊模型就实现将一切的变形效果转换为骨骼驱动附加到蒙皮模型上。&emsp;&emsp;我们可以给毛囊模型添加 Blendshape 来实现多层次的驱动。&emsp;&emsp;因为 Blendshape 是叠加 Transformation 的，因此可以将大量的绑定系统集成到一起，而不需要担心变形互相覆盖等等的问题，而且一套不可行也可以利用同样的方法拆成多个来实现。是非常有想象力的绑定方案。 &emsp;&emsp;下面就可以通过添加 Blendshape 来驱动 Fol_Mesh ，Fol_Mesh 则通过骨骼蒙皮驱动 Skin 模型。&emsp;&emsp;于是我简单弄了两套骨骼的绑定，然后通过 Blendshape 加到 Fol_Mesh 上。 &emsp;&emsp;这样做的好处就是通过少量的骨骼可以控制更大范围的骨骼运动。换言之就是次级控制器。 &emsp;&emsp;以上就是整套精简绑定的效果。 &emsp;&emsp;下面可以简单添加两个控制器来控制上面和侧面的次级骨骼。 &emsp;&emsp;我想要实现的是侧面的次级骨骼运动的时候，上面的骨骼也可以跟随运动，并且依然可以正确进行次级驱动。 &emsp;&emsp;如果我们什么也不做，控制器只能留在原位，但是控制效果的确是我们所想要的。 跟随效果实现 &emsp;&emsp;首先断开上层控制器对骨骼的约束，然后用毛囊对控制的父组约束 &emsp;&emsp;这样实现的确可以让控制跟着毛囊进行运动。 &emsp;&emsp;下面重点来了, Low_Rig 是通过表达式来进行输出控制，我这里是通过连接通道的方式。 &emsp;&emsp;根据驱动的层级关系常见一个层级组。&emsp;&emsp;轴心位置需要和控制器保持一致，并且冻结变化。&emsp;&emsp;原本这个组应该放到 follow 组之外的，不过可以通过不继承变换放到 follow 组里面，方便管理（如果勾选继承的话，由于follow约束的原因仍然会导致约束循环） &emsp;&emsp;同理 driver 组也是这么操作，只是这里不需要去掉 继承 的勾选了。 &emsp;&emsp;如此就将父子的关系通过通道连接去掉了。&emsp;&emsp;用 driver 组进行父子约束就不会有约束循环了。 &emsp;&emsp;仅仅这样还是不够的，通过上面动图可以看到，这样移动控制器会导致 Double Transformation&emsp;&emsp;也就是控制器的运动以及上层组的约束驱动两层变换叠加了。&emsp;&emsp;因此这里需要去掉控制器的位移实现控制跟手效果。&emsp;&emsp;另外需要注意的是，正常情况下父层级的轴心点也无法跟随子层级，这也是需要解决的问题。 跟手处理 &emsp;&emsp;只需要多加两个组与控制器进行相反位置运动，就可以抵消多出的位移效果。 &emsp;&emsp;同样父层级也需要进行同样的操作。&emsp;&emsp;这样次级就是完全跟手的，而且父层级也完全没有问题。 &emsp;&emsp;由于父层级控制和控制器之间隔了一个抵消组，于是我尝试修改一下他们之间的层级结构。&emsp;&emsp;结果这样处理父层级的轴心点就不跟随了(:з」∠) &emsp;&emsp;最终效果如下↓↓↓ 总结 &emsp;&emsp;总算是整理完成了这种次级跟随了&emsp;&emsp;感觉非常受用，不知道能否通过类似的手段来解决 IKFK 切换的问题。&emsp;&emsp;这个问题在 功夫熊猫 教程中有详细的阐述 av12415659&emsp;&emsp;只是当时看完教程不大喜欢教程的解决方案。 2022-7-14 梳理补充 &emsp;&emsp;后面翻看自己的文章居然卡壳了(:з」∠)，所以重新整理了一下。 现将 follicle 和 控制器同步到一个位置 然后弄一个 driver 同步到 控制器的位置并归零 follicle 约束控制 控制器 的上层 (driver 则不能受 follicle 的影响) 控制器的数值直接连接到 driver driver 再约束到骨骼上 这里重点是 骨骼 不受 follicle 的跟随影响，只受控制器的位移旋转影响，但是控制器不能直接约束骨骼，因为会受到上层的跟随影响。所以这里取巧地弄了一个外部的 driver 控制，将属性控制连接到 driver 上绕过 follicle 的影响。在通过 driver 来约束到骨骼上。 这样做的结果就是:follicle 因为其他控制器的运动而运动带动了 控制器，但是控制器自身的数值没有发生变化(上层的父层级变化了)，所以没有影响到 driver 和 骨骼 的位置当直接操控控制器的时候才会让它的数值变化从而驱动到骨骼。不过这里运动骨骼也会影响到 follicle 让控制器也跟着偏移，导致控制器的偏移 double 了抵消掉控制器数值带来的偏移即可解决问题。 &emsp;&emsp;另外这只是其中一种 次级 跟随的方案，还有使用 wrap 变形器的方案 或者 follicle 驱动曲线顶点的方案。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Rigging</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠀMaya/Rigging</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 加速Maya开启与关闭的方法 | Adu Blog]]></title>
    <url>%2Fposts%2F5486e619.html</url>
    <content type="text"><![CDATA[原文链接 本内容转自http://www.animator.idv.tw的indigo Maya在2016版本后增加了Cloud登入的方法，这个方法会造成Maya在启动的时候，开启多个连线到网际网路获取登入资讯，造成启动时间变长。 新的Cloud登入功能使用了一个新的QmayaIPMWidget UI，称为CLIC IPM (In Product Messaging) Button，该功能会在Maya启动时启动5个外部的chromium browser程式acwebbrowser.exe供连线讯息使用，但是如果是使用Node Lock或Floating的License的使用者会用不到这个登入方法，但是必须等候外部程式启动连线后，Maya才会开启。启动时间在可能长达30~40秒，关闭Maya时间为15~20秒，如果在没有网际网路连线的网域中，启动时间可能还会变成几分钟或者更长。 Maya在关闭或Shutdown时会透过TCP连线来启动CIP(Customer Involvement Program)，连线到Amazon的伺服器。如果Maya里有执行错误的话，还会使用CER(Customer Error Reporting)来Report Error到伺服器。 解决方法关闭CLIC_IPM UI在Maya.env里或电脑加入环境变数，MAYA_DISABLE_CLIC_IPM用来关闭CLIC IPM登入功能，可以大幅提升启动Maya的效率。 MAYA_DISABLE_CLIC_IPM=1 关闭Customer Involvement Program (CIP)也可以加入MAYA_DISABLE_CIP，关闭CIP的功能，可以加速关闭Maya时间 MAYA_DISABLE_CIP=1 关闭Customer Error Reporting (CER)加入MAYA_DISABLE_CER关闭CER，可以加速Maya错误时的需要回报的关闭时间。 MAYA_DISABLE_CER=1 结果 Default startup time: 38s shutdown time: 15sDisabled IPM UI startup time: 14s shutdown time: 5s 当然了，还是会有很多人还是不满意这样的关闭Maya的效率，这时可以透过硬处理的方式 taskkill /IM maya.exe /F 相关链接Maya 2016.5 slow start-up Reducing Maya shutdown time by disabling Autodesk CIP]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>✒博客/©转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode - 全面使用攻略（三）]]></title>
    <url>%2Fposts%2F7cc09d5d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;开篇的时候挖了一个坑 &emsp;&emsp;这里的操作是怎么在 VScode 实现的呢？ 我在这里解惑&emsp;&emsp;其实复制行可以在不选择任何代码的时候 ctrl+c ，这样会复制一整行。&emsp;&emsp;然后就疯狂敲 ctrl + v 就可以了， 在不选择的情况下，这样粘贴是直接粘贴到下一行。&emsp;&emsp;然后按住鼠标中键可以拖拽选择文本，选中末尾的数字。&emsp;&emsp;然后使用我上次介绍的 Insert Number 插件， ctrl + alt + n 就可以插入递增的数字。 交互式演练场 &emsp;&emsp;在开篇的时候也挖了一个坑&emsp;&emsp;我有提到 其实 交互式演练场（Interactive Playground） 其实已经包含了很多 VScode 的骚操作 ctrl+alt+上下键 多重鼠标添加 alt+上下键 移动行 alt+shift+上下键 复制行 ctrl+d 可以选择当前光标下的单词 类似双击效果 ctrl+shift+L 可以找到当前选中类似的单词 ctrl+shift+k 可以删除一行，不过我一般是在不选择字符情况下用 ctrl+x 来删除（离左手近） alt+shift+f 可以自动排布文档（formating） F2 重命名变量 VScode 的 骚操作代码注释 ctrl+/ 可以切换代码注释 ctrl+k ctrl+c 可以继续注释代码 ctrl+k ctrl+u 可以取消注释代码 自动保存 开启了自动保存之后，我写代码再也不用担心断电、崩溃等问题导致写的内容没有了。再加上 localhistory 双重保险，无论什么情况，代码都与你同在。 鼠标中键拖拽 鼠标中键实现多行拖拽（比 ctrl+alt+上下键 更好用） ScreenCast 模式 ScreenCast 模式可以让VScode回显所有的操作指令以及鼠标点击红色标记 用户代码片段 snippet 用户可以插入自定义的代码片段，提高编程的效率。 搜索 ctrl + f 可以打开搜索框 ctrl + h 可以打开替换框 普通的匹配模式进行替换 大小写匹配 全字匹配 正则表达式 完全基于 JavaScript 的正则表达式可以通过 $数字 来实现匹配的获取和替换 注：(“apple.*)” 括号的部分将会获取到替换标记 \$1、\$2 这些变量中，根据括号的数量赋值。. 代表任意字符* 代表匹配0个或者多个“apple.*” 表示匹配 “apple任意字符” 这个模式通过括号则可以进一步把匹配到的内容获取出来进行扩充。 禅模式 （Zen Mode） 开启之后屏幕所有的区域就只剩下代码区域，让你脱离一切干扰。让我想起了 一加7pro 的禅定模式， 一键单身(:з」∠)这个模式太过佛系简洁，我个人用不惯 总结 &emsp;&emsp;熟练掌握这些技巧可以大大提高 代码编写 的效率&emsp;&emsp;特别是正则表达式，你可以通过它插入多行代码。&emsp;&emsp;不过正则也不是万能的，之前遇到个需求就是匹配到的数字需要进行数学计算。 仓库&emsp;&emsp;貌似正则就无法处理这种复杂的情况，这个时候就需要自己写代码来处理了， python 和 js 都原生支持正则表达式匹配处理。 &emsp;&emsp;以上是我个人使用 VScode 一年多来的经验汇总，如果大家还有什么骚操作愿意分享可以留言给我^_^]]></content>
      <categories>
        <category>VScode</category>
        <category>VScode - 全面使用攻略</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode - 全面使用攻略（二）]]></title>
    <url>%2Fposts%2F31de3e0f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这里浓缩了我目前使用中的大部分插件，其中推挤标题前面加上 * 号的是我强烈推荐的插件。下面推荐中夹带了私货 - (￣▽￣)认真脸 通用插件推荐中文补丁Chinese (Simplified) Language Pack for Visual Studio Code &emsp;&emsp;提供VScode界面的全汉化。 * Settings SyncSettings Sync &emsp;&emsp;这个工具将当前插件配置直接放到 github 的 gist&emsp;&emsp;可以在别的软件上一键获取之前配置好的插件配置，一键完成所有插件的安装&emsp;&emsp;方便到难以想象（前提是得能联网） BookmarksBookmarks &emsp;&emsp;通过这个工具可以给当前代码行设定一个标记。&emsp;&emsp;代码比较长和复杂的时候，可以通过这个标记来回跳转。 &emsp;&emsp;缺点是这个标记只记录行，如果上面的代码更新了，标记的位置还是在之前的那一行。 AlignmentAlignment &emsp;&emsp;这个工具可以对齐等号冒号等符号，让代码更加清晰。&emsp;&emsp;当然这也要看语言的规范要求，有些代码规范是禁止等号前后有多余的空格。&emsp;&emsp;我个人是觉得使用这个工具可以让变量定义更加清晰。 Live ServerLive Server &emsp;&emsp;快速高效地在当前工作区搭建本地服务器。&emsp;&emsp;安装之后右下的状态栏有 Go Live 按钮快速启动。&emsp;&emsp;这个工具最棒的地方在于可以通过 http 协议共享自己的文件，通过 Ip 地址加端口，可以实现局域网互联互通（前提是网络没有限制） Auto Rename TagAuto Rename Tag &emsp;&emsp;通过这个工具重命名 XML 或者 HTML 就很方便，一步到位 PolacodePolacode &emsp;&emsp;分享代码截图非常方便，样式各方面都照顾得很到位。 * Better CommentsBetter Comments &emsp;&emsp;通过这个工具可以通过不同的颜色将代码注释区分出来，这样哪些是注释不用的代码、哪些是说明就一目了然了。 * Todo+Todo+ &emsp;&emsp;配合better comment 的标记，可以实现不同注释代码的追踪，还挺好的。 Insert NumbersInsert Numbers &emsp;&emsp;可以快速在光标位置插入序列数字，变量命名之类的非常有用。 Bracket Pair ColorizerBracket Pair Colorizer &emsp;&emsp;括号用不同颜色区分，让代码一目了然。 * Local HistoryLocal History &emsp;&emsp;这款插件可以实时对文件修改进行记录备份。&emsp;&emsp;记录每一次修改保存的时间，有时候出问题，可以通过这个插件还原旧版本，比 git 还要方便。&emsp;&emsp;git 只能将 commit 的部分作为存档点，没有这个工具存得多。&emsp;&emsp;缺点是会在工作区里创建一个 .history 的文件夹，各种操作务必忽略这个文件夹的内容。 &emsp;&emsp;另外开启了 VScode 的自动保存之后，有时候会备份太多，可以修改下面这个参数，超过3秒的文件才去备份。123&#123; "local-history.saveDelay": 3000,&#125; macrosmacros &emsp;&emsp;这个插件可以将 VScode 的命令组合成一个新的命令，通过快捷键设置进行触发。&emsp;&emsp;我通过这个插件，实现 ctrl+shift+; 直接将 : 拆入到行末并且切换到下一行，编写python时尤其方便。 &emsp;&emsp;通过快捷键可以直接从括号的位置插入 : 并且跳到下一行。 设置方法如下↓↓↓ 在 setting.json 配置一个 macros 的自定义命令 123456789&#123; "macros": &#123; "addColon": [ "cursorEnd", // 跳转到行尾 &#123;"command": "type", "args": &#123;"text": ":"&#125;&#125;, // 打上 : 号 "editor.action.insertLineAfter" // 跳转到下一行 ] &#125;&#125; 在 keybindings.json 配置 addColon 的快捷键 12345[&#123; "key": "ctrl+shift+oem_1", "command": "macros.addColon", "when": "editorTextFocus"&#125;] &emsp;&emsp;自定义命令可以通过 shortcuts 面板查看相关的命令是什么 Project ManagerProject Manager &emsp;&emsp;这个插件可以将不同的项目记录起来，可以快速点击来进入到相应的工作区 Visual Studio IntelliCodeVisual Studio IntelliCode &emsp;&emsp;微软爸爸的牛逼插件，基于 AI 驱动，优化自动提示的效果。&emsp;&emsp;可惜这个插件需要联网才能使用 Zoom BarZoom Bar &emsp;&emsp;通过这个工具可以方便放大缩小 VScode 的显示界面,类似浏览器的放大缩小。 Python 相关* PythonPython &emsp;&emsp;微软爸爸维护的当家 Python 插件&emsp;&emsp;VScode Python 开发必备插件，通过它实现代码自动提示 以及 代码Debug&emsp;&emsp;默认情况下会自动获取系统安装的 Python ，如果Python没有配置到环境变量中，插件左下角没有选择 Python 程序的话，插件是不起作用的。&emsp;&emsp;有时候为了测试方便，可以将 Maya 的 bin 目录下的 mayapy.exe 配置到左下角&emsp;&emsp;在 setting.json 配置相应的路径即可 123&#123; "python.pythonPath": "C:\\Program Files\\Autodesk\\Maya2017\\bin\\mayapy.exe"&#125; autoDocstringautoDocstring &emsp;&emsp;通过这个工具可以快速生成 Python 的说明文档&emsp;&emsp;默认文档风格不喜欢，可以通过配置修改。 123&#123; "autoDocstring.docstringFormat": "Numpy"&#125; Python Paste And IndentPython Paste And Indent &emsp;&emsp;粘贴Pytho代码自动缩进，抄代码的时候非常方便 Python postfix completionPython postfix completion &emsp;&emsp;写 Python3 的时候 print加括号还是挺麻烦的，用这个就方便很多。 CG 语言 相关* MayaPyMayaPy &emsp;&emsp;这是我自己开发的插件，疯狂安利…φ(๑˃∀˂๑)♪ 文章&emsp;&emsp;插件依赖于 MayaCode 和 Python 两个插件的功能进一步开发&emsp;&emsp;支持 Maya Python 断点 Debug 以及 Maya 代码库的自动提示。&emsp;&emsp;一键安装，无需任何手动配置。 MayaCodeMayaCode &emsp;&emsp;支持 Mel 语言，并且提供 Mel 的自动提示&emsp;&emsp;集成代码发送到 MayaPort 的功能，非常方便。 VEXVEX &emsp;&emsp;Houdini 开发者的福音 unity3d-packunity3d-pack C# C# FixFormat C# Snippets C# XML Documentation Comments Debugger for Unity Shader languages support Unity Code Snippets Unity Tools ShaderlabVSCode(Free) Code Outline &emsp;&emsp;自动安装上述 Unity 开发相关的插件，各种需求一应俱全。 Shader languages support for VS CodeShader languages support for VS Code HLSL - High-Level Shading Language GLSL - OpenGL Shading Language Cg - C for Graphics &emsp;&emsp;主流游戏用的 shader 语言支持 OSL SupportOpenShadingLanguage &emsp;&emsp; Open Shading Language(OSL) 是高级 Shader 开发语言，主要用于影视行业的Shader编写，由索尼提供维护支持，可以参照此项目 Markdown 相关Markdown All in OneMarkdown All in One &emsp;&emsp;VScode 其实是原生支持 Markdown 的。&emsp;&emsp;通过这个插件可以扩充更多 Markdown 的快捷键和模板的自动生成 * Markdown Preview EnhancedMarkdown Preview Enhanced &emsp;&emsp;虽然VScode本身就内置了 Markdown 文件预览的功能 &emsp;&emsp;样式虽然不同，呈现方式和 github 是完全一样的。&emsp;&emsp;但是显示效果我不是很喜欢，没有自动换行，而且无法将 markdown 转换成 HTML 文件&emsp;&emsp;这个插件就可以解决我这些问题。 &emsp;&emsp;最重要的是右键可以输出不同的格式，可以直接输出 HTML 文件到本地。 &emsp;&emsp;这个功能很重要，别人未必懂得 markdown 的编写效果，但是html就可以通过浏览器预览到效果。 总结 &emsp;&emsp;以上推荐是我比较中意的插件搭配方式。&emsp;&emsp;还有一些前端开发的以及杂七杂八的插件就不在这里详细介绍了，我觉得有意思的在下面罗列出来吧 transformer 实现大量数据的对齐和去重 jumpy 可以通过键盘跳转到任意的代码位置 (我用得不太习惯，用得少。) Kanban 实现需求的追踪管理 Dashboard 类似于 Project Manager，实现可视化窗口管理，功能比较单一。 XML Tools 处理XML的就很方便 Power Mode 自带特效的装逼神器 Comment Anchors 可以实现代码注释的标记和跟踪，但是对中文支持不好，全中文注释无法正常显示。 Commands 状态栏添加按钮来执行相应操作（取代快捷键） Browser Preview 内置浏览器预览 Shader Toy glsl代码预览 glsl-canvas glsl代码预览 vscode-journal 方便做日常的记录 WakaTime 代码编写统计，需要联网使用 Clipboard History 可以提供粘贴的历史记录 GitLens — Git supercharged 扩展了 Git 在 VScode 上的功能，支持修改标签等 &emsp;&emsp;另外还有各种让人意想不到的鼓励师插件（大家可以自行挖掘）&emsp;&emsp;除此之外还有很多主题和图标插件，这些也不再讲解，我个人偏向默认风格。&emsp;&emsp;VScode 的插件市场真的无比丰富，如果大家有什么神奇有用的插件也欢迎大家推荐给我。]]></content>
      <categories>
        <category>VScode</category>
        <category>VScode - 全面使用攻略</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode - 全面使用攻略（一）]]></title>
    <url>%2Fposts%2F1947fed4.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;其实一年多前就写了一篇文章专门来安利 VScode 链接&emsp;&emsp;那个时候还说 VScode 是个小众编辑器，其实得益于前端开发刚猛的势头，这个编辑器也越来越流行了。&emsp;&emsp;结合了最近一年多的使用经验积累,我打算将自己使用 VScode 的经验总结归纳一下。&emsp;&emsp;希望大家受用 |ू･ω･` ) &emsp;&emsp;B站也有别人录下推荐的视频(偏PHP后端方向的) av56583362 什么是 VScode &emsp;&emsp;VScode 全称为 Visual Studio Code ,是微软公司开发的文本编辑器，由于名字过长，下面统统简称为 VScode。 百度百科 为什么推荐 VScode &emsp;&emsp;其实这个问题已经不需要我回答，网上也有大量推荐 比如 Visual Studio Code（VS code）你们都在用吗？或许你们需要看一下这篇博文 为什么我选择使用 VS Code进行前端开发? &emsp;&emsp;他们给出的理由都很充分，有些东西也不需要我多加赘述。 &emsp;&emsp;不过作为写给小白的教程，有些东西我还是需要明确一下。&emsp;&emsp;在编程开发工具中，常用的代码编写工具有以下两种分类: 集成开发环境(Integrated Development Environment) 脚本编辑器(Text Editor) &emsp;&emsp;可能会有人对这两个名词很陌生,不过只要指出一些编程开发的工具相信大家就明白了。 集成开发环境(Integrated Development Environment) Visual Studio Android Studio Eclipse Xcode Netbeans JetBrains 全家桶 PyCharm WebStorm Intellij IDEA … 脚本编辑器(Text Editor) VisaulStudioCode Atom Sublime NotePad ++ Vim Emacs HBuilder &emsp;&emsp;关于这两者的区别可以参照我初学编程的时候翻译的教程 av15609748&emsp;&emsp;因为当时初学所以翻译质量不太好，请见谅(:з」∠) &emsp;&emsp;在 3m50s 的地方 Simon 指出了 IDE 和 脚本编辑器 的区别。&emsp;&emsp;脚本编辑器其实就是纯文本编辑工具，它只是让代码更好地显示，但是涉及到一些专门的测试环境就需要使用 IDE 这种复杂的开发环境。&emsp;&emsp;用通俗的话来讲就是 文本编辑器 是 导弹， 而 集成开发环境 是 核弹。&emsp;&emsp;那更加强大的集成开发环境理应是最佳选择，那我们为什么还会选择导弹呢？&emsp;&emsp;其实主要是因为杀鸡焉用牛刀的原理。&emsp;&emsp;集成开发环境通常集成过多的东西导致很臃肿，然而普通程序员又有多少人会用到全部的工具呢？&emsp;&emsp;因此文件体积更小，启动速度更快的脚本编辑器越来越受到程序员们的追捧。 &emsp;&emsp;我们可以参照 VisualStudio 的大小 和 VisaulStudioCode 的文件大小比较就可以知道。&emsp;&emsp;VisualStudio如果将所有语言的开发包都安装上需要几十个G&emsp;&emsp;而VScode的安装包大小只有不到 100M &emsp;&emsp;由于集成开发环境的庞大臃肿，很多集成开发环境都是有自己的针对领域的，比如说 JetBrains 的全家桶IDE&emsp;&emsp;每一个软件都针对特定的开发环境需求进行优化，比如说 PyCharm 是针对 Python 而 Intellij IDEA 是针对 Java 的&emsp;&emsp;而在这方面脚本编辑器因为其轻量化的特点通常还可以支持多种语言的编辑。 &emsp;&emsp;但是话说回来，即便是杀鸡焉用牛刀，随着开发越来越复杂，导弹的威力很可能并不能满足我们的开发需求的。&emsp;&emsp;因此随着时代的发展 Atom 和 Sublime 这种带插件扩展的编辑器相继出现，而其他编辑器也紧跟其后。&emsp;&emsp;我们可以通过编辑器的插件获取类似 IDE 的各种功能体验，而且插件相当于扩展模块，我们可以很轻松地开启和关闭无关的功能，也满足轻量化的需求。&emsp;&emsp;如今 VScode 的插件的强大已经完全不输于专业IDE，比如Google的新技术Flutter 就钦定了 VScode 和 Android Studio 两个开发平台。&emsp;&emsp;通过插件扩展的 VScode 开发 Flutter App 的体验几乎不输于 Android Studio 这种专业 IDE 。 &emsp;&emsp;当然由于这种高度定制化的插件功能扩展，如何搭配这些插件加快开发效率就得花很多时间去研究，不像 IDE 那样一整套功能提供好了。 &emsp;&emsp;这里我总结一下 IDE 我不喜欢的点： 按钮太多，功能太复杂，让人劝退，对新手不友好 针对特定开发环境，无法兼容不同语言，不灵活 插件较少，一些自定义开发需求难以满足 启动缓慢，占用系统资源多 &emsp;&emsp;纵然 IDE 有些不便的地方，我们也没必要全盘否定它，毕竟使用环境是不一样的。&emsp;&emsp;IDE适合大型开发，特别是需要编译运行还要依赖各种环境的 C++ 或者 Java ，IDE的配套环境真的可以省去很多麻烦，调试使用 IDE 的工具也很省心。&emsp;&emsp;脚本编辑器更加适合敏捷开发，比如 js python 这类的脚本语言。&emsp;&emsp;而且现在很多IDE也支持插件开发进行功能扩展，并不是脚本编辑器特有的功能了。&emsp;&emsp;以上就是我个人对 IDE 和 脚本编辑器 的看法，个人还是偏好 脚本编辑器 多一点 &emsp;&emsp;另外必须强调 无论是 IDE 还是 脚本编辑器 都只是编程工具，编程最重要的是写程序的人，因此没有必要争自己使用的工具来秀优越感，适合自己才是最好的。 &emsp;&emsp;最后在众多脚本编辑器中 为什么 就选了 VScode呢？&emsp;&emsp;其实几年前还是 Sublime 和 atom 称霸天下的时候。&emsp;&emsp;不过后来 VScode 的插件生态建立起来之后，实现了弯道超车。&emsp;&emsp;由于 atom 我没用过，Sublime 我也只是用了很短一段时间，所以我自己也不好做出评价。&emsp;&emsp;我总结一下目前对VScode积极的认识： 微软爸爸的财大气粗做后盾，维护很积极 图形化图标，交互比较友好 集成 Git 和 Cmd 以及 Debug 工具，我以前用 Sublime 的时候这些东西都没有内置 安装插件有图形化界面，可以不敲命令行，对新手很舒服 插件超级丰富，社区极度活跃，有问题基本都可以在 Github Issue 以及 Stack Overflow 上查到答案 &emsp;&emsp;最重要一点是我自己也算是半个前端工程师，以前一直用 学校 教的 Dreamweaver ，自从接触了 Sublime 之后就爱不释手，后来另一个学前端的同学给我推荐了VScode真的就成了我编程开发的主力工具，大多数的开发都可以通过插件扩展实现在 VScode 上开发。&emsp;&emsp;我印象最深刻的就是 VRML 语言，当时学校要求我们学习这个被淘汰的语言，而且还要用 VRML Pad 这种不知道是多少年前的开发工具，颜色高亮各种不清晰，操作各种不顺手。&emsp;&emsp;最后还是通过 VScode 的插件来完美解决这些的问题。 VScode 安装 &emsp;&emsp;安装VScode 特别是简单，去百度搜索 VScode 点开第一个微软的官方链接，点击下载即可。 &emsp;&emsp;双击安装包 点击 安装，基本上点击下一步就可以了，几个要点可以重点说一下 我接受协议 必须勾选的 路径可以自定义，不过一般默认就可以了 添加到资源管理器上下文目录 这个操作可以添加右键 Code 打开当前目录，非常方便。 将 Code 注册为受支持的文件类型的编辑器 这个操作会让 VScode 支持的代码文件全部编程变成 VScode 默认打开，文件图标也会随之更改，很好辨认。 &emsp;&emsp;安装完成的界面如下图 VScode 使用 &emsp;&emsp;通过上面的步骤，我们已经顺利进入了软件的启动界面。 &emsp;&emsp;然而看到的全部是英文，可能有些人会觉得很难受，有没有办法转换成中文界面呢？&emsp;&emsp;当然是可以的，我们只需要安装一个中文补丁就没问题了。 &emsp;&emsp;那就可以好好讲解一下 VScode 的界面的情况了 VScode 新手讲解 注：经过更新之后，新版本UI有点不同，请见谅。 &emsp;&emsp;在欢迎使用的界面上，新手需要注意红色框的区域&emsp;&emsp;特别是下划线的部分的 入门视频 和 提示与技巧 都是官方提供的说明讲解。&emsp;&emsp;当然里面都是英文的，有点遗憾。 &emsp;&emsp;另外右边的 界面概览 可以清晰显示出 VScode 各个区域的说明 &emsp;&emsp;交互式演练场 英文叫做 Interactive Playground 也是非常好的体验文档。&emsp;&emsp;只可惜同样没有汉化。&emsp;&emsp;关于交互式演练场的操作我将留到 VScode 的骚操作进行讲解。 文件资源管理器 &emsp;&emsp;默认情况下 文件资源管理器 是空的，可以打开一个文件夹作为工作区。&emsp;&emsp;点击 打开文件夹 或者 拖拽文件夹进来都可以实现。 &emsp;&emsp;通过工作区可以管理当前文件夹里面的内容。&emsp;&emsp;工作区上方的四个按钮可以帮助你创建文件和文件夹。&emsp;&emsp;对文件右键还有更多的删除命令等等，也可以通过拖拽改变文件的位置。 跨文件搜索 &emsp;&emsp;通过跨文件搜索可以搜索当前工作区下的所有文件的内容。 &emsp;&emsp;通过这里找到的信息直接跳转到相应文件的相关行。 源代码管理 &emsp;&emsp;原代码管理提供了简单的 git 处理&emsp;&emsp;基础的功能诸如 push pull commit 都封装好了&emsp;&emsp;只需要点击按钮即可使用 启动和测试 &emsp;&emsp;启动和测试集成了 Debug 的模块&emsp;&emsp;和浏览器的 Debug 模块基本相同。&emsp;&emsp;这里可以通过 node.js 进行脚本测试 &emsp;&emsp;点击 F5 就可以启动 Debug 模式。&emsp;&emsp;遇到设置红色的断点，代码执行就会暂停。 终端集成 &emsp;&emsp;通过快捷键 ctrl+` 可以呼叫出来&emsp;&emsp;默认是 windows 的 cmd 窗口，也可以切换 &emsp;&emsp;也可以切换成其他的终端启动 总结 &emsp;&emsp;VScode的生态真的越来越强，各种语言开发的支持都很全面了。&emsp;&emsp;当然还是如上文说的，一般还是前端用它比较多，萝卜青菜各有所爱。&emsp;&emsp;上面最后一张gif图稍微显示了一些 VScode 的便捷操作，关于这些骚操作以及插件运用我留到后面两篇文章进行介绍 VScode 插件推荐 VSCode 使用骚操作]]></content>
      <categories>
        <category>VScode</category>
        <category>VScode - 全面使用攻略</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - AboutCG - Maya API 编程教学 for TD]]></title>
    <url>%2Fposts%2F26180f28.html</url>
    <content type="text"><![CDATA[AboutCG教程地址 前言 &emsp;&emsp;说来惭愧，以前自己是学生党。&emsp;&emsp;因此所有的教程都是白嫖而来。&emsp;&emsp;我庆幸自己通过各种途径能够想方设法搞到自己想要的资源，从来不花一分钱。 &emsp;&emsp;经历了一年的吃土实习，总算是上岸了&emsp;&emsp;趁着双十一这波降价，自己就剁手了，双十一折扣加新人优惠券只花了66元。&emsp;&emsp;虽然 Maya API 已经比较熟悉了，猫大的教程大概也没有太多有用的知识点了，而且教程是14年的了。&emsp;&emsp;不过，Maya API 其实也没有什么太大的更新。&emsp;&emsp;而且我对教程里面的加密算法非常好奇，领略过 2进制 的加密，只是不知道怎么实现的。 &emsp;&emsp;由于这个是个付费教程，所以我不会那么详细讲解这个教程的细节，就大概提一提我觉得有意思的点吧。 加密方案 &emsp;&emsp;教程一开始演示了最简单的加密方法&emsp;&emsp;就是通过字符偏移实现加密效果，其实我之前也研究过这种加密的方法 文章链接 &emsp;&emsp;后面猫大结合 C++ 的 zlib 库，将文本转成 二进制 压缩的形式。&emsp;&emsp;进一步实现加密&emsp;&emsp;到这里，其实我是有一丢丢的失望，因为 zlib 的加密原理并没有被提及。&emsp;&emsp;虽然我也明白，大多数时候我们只管实现，而不会探究背后的原理。&emsp;&emsp;即便我使用 python 也不会探究 os 库的函数是在底层如何实现的(:з」∠) &emsp;&emsp;当然虽然加密算法用的是别人弄好的&emsp;&emsp;但是要通过 C++ 接入还是需要点技术操作的，毕竟C++的代码比较透明，处理起来也比较麻烦。&emsp;&emsp;首先需要将 zlib 的源代码通过 VS 编译成 lib 文件，提供给代码调用&emsp;&emsp;而且我们并不需要 zlib 的所有功能，还要有选择地进行编译减少大小&emsp;&emsp;后续还需要一些在工程的配置当中加上 lib 的调用路径。 &emsp;&emsp;另外口令的处理上，其实是获取口令的字符长度，然后通过字符偏移对 2进制的压缩文件 进一步加密。&emsp;&emsp;我觉得这类获取字符长度是有BUG的，如果用户输入同样长度的不同口令，岂不是也同样解密了。 &emsp;&emsp;带着这个疑问，我自己通过源码，重新编译出了 2017 版本的插件&emsp;&emsp;测试的时候，我发现输入空的口令会导致Maya崩溃，而且参数不足的时候也没有有效的报错提示，代码健壮性不足呀(:з」∠) &emsp;&emsp;回归到我要测试的问题，我发现仅仅是字符的数量相同时无法通过口令的&emsp;&emsp;我看了源码，是通过 C++ 的 strlen 获取口令的长度进行偏移的&emsp;&emsp;我总觉得这一步要用 md5 才能减少同样的不同的口令可以解密的问题。 &emsp;&emsp;后来再仔细看了一下后面的源码，发现自己粗心了。&emsp;&emsp;原来解密是根据 token 的数组求模取出字符来进行偏移，的确是要知道正确口令才能解密。&emsp;&emsp;猫大强无敌。 C++ 学习 &emsp;&emsp;虽然我自己有捣鼓过Maya C++ 的插件开发，而且学校也有 C++ 的课程。&emsp;&emsp;但是猫大的教程还是让我在 C++ 领域上受益匪浅。&emsp;&emsp;毕竟我之前写 C++ 基本上参考 Maya API C++ 文档里面的 example 为主&emsp;&emsp;并没有正统地学习过 C++ 的编写规范，算是野路子典型。&emsp;&emsp;幸好之前开发C++也比较简单，代码不超过 500 行，也不需要拆分文件了。&emsp;&emsp;这次看了猫大的骚操作以及指针的巧妙运用还是很有用的。 &emsp;&emsp;当然这当中也涉及到了 C++ 蛋疼的地方。&emsp;&emsp;头文件 include 会互相影响的，这也很好解释了为什么 python import 之后要 reload 来重加载。&emsp;&emsp;这样可以避免文件多次 import 不断受到影响的问题。&emsp;&emsp;因此下次写脚本的时候，发布版本一定要将 python 的 reload 代码清掉。 &emsp;&emsp;C++ 解决这个问题需要使用 宏&emsp;&emsp;通过 宏 的定义，判断宏是否存在来进行只有一次的初始化。 &emsp;&emsp;头文件可以通过 extern 来进行外部定义&emsp;&emsp;从而实现 C++ 代码公共调用的目的 &emsp;&emsp;另外教程中，猫大多次强调 warning 和 error 一样严重&emsp;&emsp;程序员对待 warning 要以 error 的标准进行逐一处理。&emsp;&emsp;这个idea我以前听过，没理解，这次看 C++ 懂了。 &emsp;&emsp;其实 python 是基本不会报 warning 的。&emsp;&emsp;因为 python 没有变量类型声明，也就没有 C++ 这种静态类型的检测。&emsp;&emsp;要运行的时候才知道代码出错了。&emsp;&emsp;C++的检测可以有助于代码运行之前就排除大量的错误，这些优势和 typescript 的优势是一样的。&emsp;&emsp;在企业级开发中，庞大的代码维护通过这种方式就可以很好地减少 BUG 的出现。 总结 &emsp;&emsp;这一次比较遗憾的地方是自己并没有怎么动手写代码。&emsp;&emsp;就只是拿着猫大的源码重新编译了一下而已。&emsp;&emsp;不过教程大体也就这些内容，基础的地方我都已经OK了。&emsp;&emsp;那些我觉得很亮点的东西已经卸载上面的文章里面。 &emsp;&emsp;整体来说还是非常不错的，特别是对于有编程开发经验，但是 C++ 不太懂的新人。&emsp;&emsp;可惜指针的地方猫大讲得也比较少，当然这不是教程的重点，我理解。&emsp;&emsp;教程的文件里面也提供了说明文档，里面推荐了一下 C++ 的书籍来进行入门学习。 &emsp;&emsp;另外教程也详细讲解了如何通过 C++ 来写一个 Mel 命令&emsp;&emsp;有这方面开发需求的同学可以学一学，当然 玩具蛇 前辈的视频教程也有讲。 链接&emsp;&emsp;另外还有一套非常经典的外国教程 链接 &emsp;&emsp;说来惭愧，上面两套教程都很棒，可惜我都是只看了开头前面几集的部分，并没有完整看完。&emsp;&emsp;以后有机会补上，并且记录观看笔记的。&emsp;&emsp;外国那一套印象很深刻，记录了 CMake 文件的使用方法，强烈推荐。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（十） - 置顶文章 | 代码注释颜色区分 | 评论自动初始化]]></title>
    <url>%2Fposts%2F4c52085.html</url>
    <content type="text"><![CDATA[置顶文章 &emsp;&emsp;最近想要做一篇博客置顶给所有的人看&emsp;&emsp;本来还以为只要不添加时间就可以自动置顶了，结果发现不可行 &emsp;&emsp;随后网上搜了一下解决方案，其实Hexo还有人开发了插件来解决这个问题，真的贴心。 文章 1npm install hexo-generator-index-pin-top --save &emsp;&emsp;安装这个插件，并且在文章的信息里面添加 top: true&emsp;&emsp;真是方便得很。 代码注释颜色区分 &emsp;&emsp;自从用上了 vscode 的 Better Comments 插件之后&emsp;&emsp;我写代码都喜欢加上 NOTE 标记来区分代码注释和说明注释&emsp;&emsp;Better Comments 添加了颜色加以区分，也让我写代码贼喜欢加说明 &emsp;&emsp;但是目前博客上使用的代码块还缺少这一功能，要如何才能实现呢？ 1234# test# NOTE test# TODO test# ! test 1234// test// NOTE test// TODO test// ! test &emsp;&emsp;在 main.js 里面添加下属代码就可以了 123456789101112131415161718192021222324252627// Note 添加 comment 特殊样式$(".comment").each(function()&#123; let py_long_comment = $(this).text().slice(0,6).toLowerCase() let c_long_comment = $(this).text().slice(0,7).toLowerCase() let py_short_comment = $(this).text().slice(0,3).toLowerCase() let c_short_comment = $(this).text().slice(0,4).toLowerCase() if (py_long_comment == "# note" || c_long_comment == "// note")&#123; $(this).css(&#123; "color":"#FFD700", "font-style": "normal" &#125;) &#125; else if (py_long_comment == "# todo" || c_long_comment == "// todo")&#123; $(this).css(&#123; "color":"#FF8C00", "font-style": "normal" &#125;) &#125; if (py_short_comment == "# !" || c_short_comment == "// !")&#123; $(this).css(&#123; "color":"#FF2D00", "font-style": "normal" &#125;) &#125;&#125;) 评论自动初始化 &emsp;&emsp;参考了这一篇博客文章 &emsp;&emsp;由于公司访问外网需要通过代理实现。&emsp;&emsp;还需要在请求上加上 proxy 代理参数 文章参考 &emsp;&emsp;经过我自己的测试，我发现我的博客评论是通过抓取 github Issue 的标签实现的。&emsp;&emsp;而 gittalk 的设置上设置了标签是通过对 window.location.pathname 变量 MD5 来实现的&emsp;&emsp;还好之前抄代码留的注释还是解释得挺好的， md5 就是为了让标记小于50个字节 1234567891011121314151617181920212223&lt;section id="comments"&gt; &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.css" rel="stylesheet"&gt; &lt;div class="gitalk" style="width:90%;margin:auto;"&gt; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; require(["https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.js","https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js"], function (Gitalk,md5) &#123; const gitalk = new Gitalk(&#123; clientID: '&lt;%= client_id%&gt;', clientSecret: '&lt;%= client_secret%&gt;', repo: '&lt;%= repo%&gt;', owner: '&lt;%= githubID%&gt;', admin: ['&lt;%= githubID%&gt;'], id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode &#125;) gitalk.render('gitalk-container') &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/section&gt; &emsp;&emsp;因此同理自动生成的标签也需要添加这个 id 号才能抓取到数据。&emsp;&emsp;下面就是我经过修改的 自动生成 评论的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// 参考 https://blog.csdn.net/daihaoxin/article/details/84958369const request = require("request");const fs = require("fs");const path = require("path");const url = require("url");const xmlParser = require("xml-parser");const YAML = require("yamljs");const cheerio = require("cheerio");const md5 = require("md5")// 根据自己的情况进行配置const config = &#123; username: "FXTD-ODYSSEY", // GitHub 用户名 token: "GitHub Token", // GitHub Token repo: "FXTD-odyssey.github.io", // 存放 issues的git仓库 // sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理 sitemapUrl: path.resolve(__dirname, "./public/sitemap.xml"), kind: "Gitalk", // "Gitalk" or "Gitment" client_id: "client_id", client_secret: "client_secret"&#125;;let issuesUrl = `https://api.github.com/repos/$&#123;config.username&#125;/$&#123;config.repo&#125;/issues?access_token=$&#123;config.token&#125;&amp;client_id=$&#123;config.client_id&#125;&amp;client_secret=$&#123;config.client_secret&#125;`;let requestGetOpt = &#123; proxy: "http://127.0.0.1:12639", // 公司网络需要代理进行访问 url: `$&#123;issuesUrl&#125;&amp;page=1&amp;per_page=100`, json: true, headers: &#123; "User-Agent": "github-user" &#125;&#125;;let requestPostOpt = &#123; ...requestGetOpt, url: issuesUrl, method: "POST", form: ""&#125;;console.log("开始初始化评论...");(async function () &#123; console.log("开始检索链接，请稍等..."); try &#123; let websiteConfig = YAML.parse(fs.readFileSync(path.resolve(__dirname, "./_config.yml"), "utf8")); let urls = sitemapXmlReader(config.sitemapUrl); console.log(`共检索到$&#123;urls.length&#125;个链接`); console.log("开始获取已经初始化的issues:"); let num = 1; let issues = []; let data = await send(requestGetOpt); issues = issues.concat(data); while (data.length == 100) &#123; num++; data = await send(&#123; ...requestGetOpt, url: `$&#123;issuesUrl&#125;&amp;page=$&#123;num&#125;&amp;per_page=100` &#125;); issues = issues.concat(data); &#125; console.log(`已经存在$&#123;issues.length&#125;个issues`); // NOTE 过滤出 gittalk 的 issue issues = issues.filter(issue =&gt; &#123; // NOTE 检测是否带有 gittalk 标签 let gittalk = issue.labels.filter(label =&gt; &#123; return label.name == "Gitalk" &#125;) // NOTE 检测是否带有以前带三个日期的评论 let match = issue.body.search(/\d+\/\d+\/\d+/i); let match2 = issue.body.search("/posts/"); return gittalk.length &gt; 0 &amp;&amp; match == -1 &amp;&amp; match2 != -1; &#125;) // NOTE 过滤掉非文章的链接 urls = urls.filter(url =&gt; &#123; return url.search("/posts/") != -1; &#125;) let notInitIssueLinks = urls.filter((link) =&gt; &#123; link = link.split("/"); html = link[link.length - 1] return !issues.find((issue) =&gt; &#123; return issue.body.includes(html); &#125;); &#125;); if (notInitIssueLinks.length &gt; 0) &#123; console.log(`本次有$&#123;notInitIssueLinks.length&#125;个链接需要初始化issue：`); console.log(notInitIssueLinks); let initRet = await notInitIssueLinks.map(async (item) =&gt; &#123; // console.log(item) item = item.replace("blog.l0v0.com", "fxtd-odyssey.github.io"); let html = await send(&#123; ...requestGetOpt, url: item &#125;); let $ = cheerio.load(html); let title = $("title").text(); let description = $(".article-entry h1").text(); let pathLabel = url.parse(item).path; let body = `$&#123;item&#125;&lt;br&gt;&lt;br&gt;$&#123;description&#125;`; let form = JSON.stringify(&#123; body, labels: [config.kind, md5(pathLabel)], title &#125;); return send(&#123; ...requestPostOpt, form &#125;); &#125;); console.log(`已完成$&#123;initRet.length&#125;个！`); console.log("可以愉快的发表评论了！"); &#125; else &#123; console.log("本次发布无新增页面，无需初始化issue!!"); &#125; &#125; catch (e) &#123; console.log(`初始化issue出错，错误如下：`); console.log(e); &#125; finally &#123; &#125;&#125;)();function sitemapXmlReader(file) &#123; let data = fs.readFileSync(file, "utf8"); let sitemap = xmlParser(data); return sitemap.root.children.map(function (url) &#123; let loc = url.children.filter(function (item) &#123; return item.name === "loc"; &#125;)[0]; return loc.content; &#125;);&#125;function send(options) &#123; return new Promise(function (resolve, reject) &#123; request(options, function (error, response, body) &#123; if (!error) &#123; resolve(body); &#125; else &#123; reject(error); &#125; &#125;); &#125;);&#125; &emsp;&emsp;原理也很简单，借助 Github 提供的 Restful API , 通过用户设置的权限token进行验证就可以通过代码自动处理了。 总结 &emsp;&emsp;进一步完善了博客的一些配套设置。&emsp;&emsp;如果大家有什么东西想要添加的，可以在下面评论区一起探讨。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Arnold 渲染设置崩溃]]></title>
    <url>%2Fposts%2F8bb6468c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;数天前，在公司干活的时候发现，Maya的渲染设置界面会出BUG。&emsp;&emsp;在 Maya2017 下会是如下报错。&emsp;&emsp;并且所有的渲染设置都无法切换了。 &emsp;&emsp;在 Maya2018 和 Maya2019 的错误会好一点。 ma文件对比 &emsp;&emsp;幸好出问题的文件很小，还可以保存成ma文件研究问题的出处。&emsp;&emsp;于是不停地用 vscode 注释 ma 里面的代码。&emsp;&emsp;最后发现初始化的摄像机是导致这个问题的罪魁祸首。 &emsp;&emsp;我发现当初始化的四个摄像机如果都勾选 renderable 之后就会出现这个错误，而且在 Maya2017 一旦出错就得重开才可以。&emsp;&emsp;更高版本的Maya就不需要重开。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 疑难杂症</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>🏢公司/Autodesk</tag>
        <tag>🇨🇬CG/Arnold</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Autodesk Genuine Service 破解无效解决方案]]></title>
    <url>%2Fposts%2Fefd57a69.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;今天在电脑里使用Maya的时候，突然直接弹出自动桌的线上验证。&emsp;&emsp;然后验证出我的Maya序列号无效，要求我重新进行输入验证操作。&emsp;&emsp;我以为只是以前的小问题，重新输入一遍破解序列就可以解决问题了。&emsp;&emsp;然而我还是图样图森破。 &emsp;&emsp;当我重新输入序列号之后，Maya无法正常启动了！！~&emsp;&emsp;可惜我已经解决了问题，没办法复原之前的效果。 &emsp;&emsp;一开始还不清楚是什么情况。&emsp;&emsp;我其他 Maya 版本也尝试了，估计是我已经过了试用期的使用时间。&emsp;&emsp;然后 Maya 验证就发现我输入的序列号是有问题的，直接将我的 Maya 锁定了。 尝试解决 &emsp;&emsp;遇到这种倒霉的问题，没有什么好想法，于是就尝试全部Maya卸载重装吧。&emsp;&emsp;然后就在那里等待这个操作好长一段时间。&emsp;&emsp;卸载的时候法线卸载工具里面有一个 Autodesk Genuine Service 的软件。&emsp;&emsp;我也尝试将它卸载了，结果发现无法正常卸载 ！！ &emsp;&emsp;只要点卸载就是这个界面，点击这个界面会弹出网页，告诉我电脑含有非法软件。&emsp;&emsp;然后这个窗口就会自动关闭，然后卸载操作就没了。 &emsp;&emsp;后来没办法，打算先重装看看情况怎样？&emsp;&emsp;结果等了好长一段时间重装了之后，发现无法点击输入序列号的按钮，一点击就会退出界面。&emsp;&emsp;于是还是得想办法。 微软的卸载工具 &emsp;&emsp;鉴于这个软件无法正常卸载了，所以需要额外的工具进行卸载。&emsp;&emsp;后面我在网上自动桌的官网上找到了完全清理的文章&emsp;&emsp;又通过文章找到了 微软官方 提供的卸载工具 &emsp;&emsp;通过这个工具，我成功卸载了软件，至少是把注册表相关的信息清理了。&emsp;&emsp;后面用 腾讯的电脑管家 清理只需要将安装目录的文件删除即可。 &emsp;&emsp;然而当我兴高采烈地想打开Maya运行时。&emsp;&emsp;却发现打开 Output Window 之后就闪退了，也不知道原因是什么。 最终解决 &emsp;&emsp;后面还是看自动桌官方的文章清理 C 盘相关的目录 &emsp;&emsp;清除了 FLEXnet 目录之后，就可以了，甚至 Maya 重新获取到了试用30天的机会。]]></content>
      <categories>
        <category>CG</category>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>🏢公司/Autodesk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校招之路]]></title>
    <url>%2Fposts%2F216efd3e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;近几年的市场环境其实不太好，特别是最近贸易战打得厉害，中国各行各业都陷入了寒冬。&emsp;&emsp;企业对人才愈加谨慎，招聘流程越来越长，考核越来越多，进大厂也越来越难。&emsp;&emsp;我自己很清楚市场的大环境，因此我对今年的校招其实很悲观。&emsp;&emsp;没想到居然能够顺利拿到网易和腾讯的offer，实属在我的意料之外(:з」∠) &emsp;&emsp;这篇文章会比较文绉绉，请见谅。&emsp;&emsp;考虑到这只是我自己的经验总结，并不一定适合所有人。&emsp;&emsp;我会重新介绍一下自己的高中到大学的经历，希望能够对大家有所帮助。&emsp;&emsp;当然也可以翻我以前写过的一些文章对比，不同时间写的，我的心得感悟也可能不大一样。 自己的情况 &emsp;&emsp;最近为了准备这篇文章，分别写了从高中到大学三年的回忆录，至少也写了3万字了。&emsp;&emsp;如果有兴趣可以去看看，只不过写的文绉绉的，我这里也会凝练总结一下。 【回忆录】 - 我的高中 【回忆录】 - 我的大一 【回忆录】 - 我的大二 【回忆录】 - 我的大三 &emsp;&emsp;我的高中生活很佛系，不过也因为这样的佛系生活培养了自己的爱好，为我走上CG相关的道路奠定了基础。&emsp;&emsp;后来到了大学之后，我终于可以放飞自我了，又因为高中的积累顺利进入了工作室，并且在工作室的帮助下收住了贪玩的心。&emsp;&emsp;潜心在工作室学习了两年的时间，因为自己是技术宅，基本上空闲的时间都跑工作室了。&emsp;&emsp;以前典型的说法就是宿舍-课室-工作室三点一线了，周末也不放过自己。&emsp;&emsp;通过工作室进一步的技术积累，我有了很大的成长。&emsp;&emsp;同样，在学习过程中也充满了迷茫和困惑，即便有师兄带我，但很多弯路也是必须自己走过才会懂得。&emsp;&emsp;大一还是按照这我高中时候的目标进发的，可是到了大二的时候，因为师兄转向网页制作的原因，我也跟着学了1年的前端。&emsp;&emsp;虽然我学前端主攻 three.js 的三维网页技术，并没有摒弃之前自己学到的CG技术，但是隔行如隔山了。&emsp;&emsp;当然前端的技术积累也不是完全无用的，毕竟TD或者TA都是涉猎面非常广的岗位，只要核心技术掌握了，会更多东西都是加分项，等于技多不压身。 &emsp;&emsp;后来因为自己的机遇，认识了做特效的仲予师兄，通过他的推荐，我得以华强方特实习。&emsp;&emsp;我当时虽然还是大三，家里人也反对我过早出来实习，毕竟我要去深圳，学校在广州，家里人很担心我能否完成学业。&emsp;&emsp;不过经过两年的大学生活，我已经对大学的教育看得很透，要学习更多东西，增强自己的竞争力，就必须要出去找大厂实习。&emsp;&emsp;而且机会难得，如果我推迟过去华强，我不知道下次还有没有像这一次一样那么顺利的推荐机会。&emsp;&emsp;当然还有一方面就是实习之后就有收入了，自己还是不想要太过依赖父母。&emsp;&emsp;因此我力排众议，大三上学期就全职入职华强实习。&emsp;&emsp;华强的实习工资并不高，只有3000元，在深圳省着用还算凑合的，不过我当时的心态是过去学习的，即便没有工钱我也愿意去的。&emsp;&emsp;现在回过头来看，我觉得这是我做的最正确的决定。 &emsp;&emsp;如果已经确定自己不往考研之类的方向发展，那么尽早步入社会实习是百利而无一害的。&emsp;&emsp;脱离学校的环境可以摆脱学校萎靡的学习氛围（抱歉，我们的学校就是这样(:з」∠)），而且生活的压力可以促使自己快速成长。&emsp;&emsp;最重要的是，在公司的工作和在学校自学遇到的挑战和困难是完全不一样的。&emsp;&emsp;我以前在学校总是很天真地想象公司工作的情形，认为很多问题可以这样或那样地解决。&emsp;&emsp;实际上，公司里面遇到的问题和挑战比想象来的复杂得多，不过这也是实习锻炼人的地方。 &emsp;&emsp;最近看了曹大的一篇文章，我觉得特别有道理。文章链接&emsp;&emsp;文章简直就是开幕雷击，里面明确提到了腾讯1万薪酬是侮辱性的，嗯，好像看到了自己。只是我不矫情，已经知足了^_^ &emsp;&emsp;人生除了要做好选择题，还有更重要的证明题，证明题做不好，选择题都没法做。证明题做好了，即便选择题做错了，还有源源不断的选择题可以做。&emsp;&emsp;如何才能做好证明题，考研、实习、比赛这些都可以成为能力的证明。&emsp;&emsp;我自己作为双非的学生，也自知自己不适合考研，自己并不喜欢填鸭式的教育以及应试的考试，而比赛我接触的也比较少，我们校区的氛围严重欠缺。&emsp;&emsp;所以我只好抓住实习这根稻草，拼命往上爬。&emsp;&emsp;华强方特的实习经历，的确给我镀金了，后面对我校招帮助非常非常大。 校招经历 &emsp;&emsp;原本去了华强方特的时候，我自认为已经进入了大厂，也没有考虑过要跳槽的。&emsp;&emsp;只是华强的氛围以及对员工的剥削愈发得让我感到了不满，看了知乎上的一些评论，感觉说得很对。&emsp;&emsp;当然我们只是员工思维去看待这些问题，从公司层面上看就是开源节流，反正大厂又不怕招不到人，那些不愿吃苦的走呗，留下来的才是公司想要的精英。&emsp;&emsp;我自己的话，如果有更好的平台肯定会走的，华强方特属于我保底的公司，如果校招不顺利，起码可以留在那里也不亏。 &emsp;&emsp;我大概是到了大三临近暑假的时候，才开始萌生要准备简历，准备校招的想法。&emsp;&emsp;因为我看了一些关于校招的5视频，很多up主的分享都说到，校招是人生仅有的一次优惠券（当然如果有打算考研等等的还有机会）&emsp;&emsp;企业会因为校招大大降低招聘门槛，校招的标准是看重应届毕业生的潜力，而非能够立刻给公司干活创造价值，这和社招是完全不同的。&emsp;&emsp;而且企业会更加青睐校招进来的员工，比起后面社招进来的，在同样的工作年限下更加有优势，算是企业内部的员工保护吧。&emsp;&emsp;当然上面这些信息也是我听闻的，目前自己并不是特别清楚。 &emsp;&emsp;6月份的时候，我咨询了师兄关于广东省内有没有比华强更好的CG类型公司，得到的答案是否定的。&emsp;&emsp;CG行业很多大厂都集中在北京上海，华强算是广东最强了。&emsp;&emsp;因此作为TD要留在广东发展，其实也没有多少好的去处了。&emsp;&emsp;但是如果转行到 TA，广东就很有优势，毕竟腾讯网易都在广东，这些游戏大厂都十分需要技术美术的人才。&emsp;&emsp;不过很遗憾，TD虽然有TA重叠的部分，但是终究还是隔行如隔山，工作的标准也有很大的差异。&emsp;&emsp;我看到很多大厂都有要求技术美术懂shader开发等等的，我自己其实并不太擅长，所以非常悲观。 &emsp;&emsp;7月份的时候，为了准备新的数字媒体技术网站，又在不断爆肝学习前端技术，进一步把shader和引擎的学习给拖慢了。&emsp;&emsp;到了8月份的时候才感到严重的危机感，听了在腾讯暑假实习同学的建议，开始爆肝学习 Unreal 引擎。&emsp;&emsp;8月1日的时候是今年腾讯开发校招的时候，我当时第一时间就把自己的简历投了上去。&emsp;&emsp;但是当时没有多少游戏引擎和shader开发的东西，因此只好把TD的简历当成TA去投，只是尽量扯了一些学校实训时候做的游戏引擎效果。&emsp;&emsp;这些工作都很浅，其实没有什么亮点。&emsp;&emsp;于是我拼命学习 Unreal ，打算做出个Demo ，然后更新到简历上。 &emsp;&emsp;另外7月末的时候，我也联系到了在网易实习的同学，帮我内推网易的技术美术。&emsp;&emsp;很早就联系他了，不过后面也是拖到内推快要截止的时候，才顺利走上了内推的通道。 &emsp;&emsp;后来8月17号，我当时还在华强工作，突然就收到了腾讯那边打来的电话。&emsp;&emsp;直接就开始了电话面试，面试官说自己是魔方工作室（我当时可能听错了，一直以为是光子）的，然后就对着我的简历跟我聊。&emsp;&emsp;好在Maya我很在行，在华强工作的内容都是实打实的，没有任何水分。&emsp;&emsp;因此和面试官聊得挺投机的~&emsp;&emsp;这个面试非常突然，不过也没有超出我的知识范畴，如果他问些引擎相关的问题，我就凉了。。。 &emsp;&emsp;面试结束之后，面试官加加了我的微信，然后在微信上临时给了我一道Maya测试题。&emsp;&emsp;显然这道题是临时加的，题目也非常粗糙，不过要扩展还是有很多工作可以做，而且这道题目我在华强也做过类似的东西。&emsp;&emsp;真的非常愕然，于是我用了三天（包含周末两天）把这个工具开发好了。 github &emsp;&emsp;做好了自己的证明题之后，后续的流程就非常顺利了。&emsp;&emsp;过了三天之后，面试官就回复我可以让我过去当面面试了。&emsp;&emsp;然后大概是8月27日，刚好是距离电话面试10天左右，就去到腾讯的科兴科学院面试了。&emsp;&emsp;大体的过程还是非常顺利，我正好是他们需要的那种人才，他们的流程也正好是国内比较少见的 Maya 流程，我进去刚好可以给他们的Maya流程做优化。&emsp;&emsp;当时也临场考了我不少Maya的内容，好在我Maya全流程都做过，没有问倒我。&emsp;&emsp;当然也提到了一些游戏优化的问题，这方面我的确是不在行，好在这些问题，他们都可以接受（还是赚了校招的便宜）&emsp;&emsp;当时面试结束的时候，面试官都明确说了等 HR 的消息，所以基本上稳得不行。 &emsp;&emsp;只是后来 HR 面试等了好长一段时间，听说是校招弄流程，我提前批比较快，所以 HR 那边流程疏漏了。&emsp;&emsp;我是到了 9月中旬中秋节前才收到 HR 面试，基本上也没有什么难点，很顺利就通过了。 &emsp;&emsp;网易的情况就不太一样，我是8月下旬收到测试题，然后5题选2题制作，可以用 Unity 或者 Unreal 引擎制作效果。&emsp;&emsp;我当时选了一个 GIL 图片处理的 Python 题 以及另一个是 Unreal 对骨骼的做水特效的题。&emsp;&emsp;后来也顺利通过了测试，进入了面试环节。 &emsp;&emsp;网易的面试和腾讯的 HR 面试刚好是同一天。&emsp;&emsp;早上去网易的珠江新城的办公楼去面试。&emsp;&emsp;面试氛围完全和腾讯不一样，所有的大佬一次过面试，有程序的、美术的、TA的还有 HR 的&emsp;&emsp;问的东西也比腾讯复杂很多，毕竟腾讯都是引导到 Maya 去说的，但是网易的流程都不怎么用 Maya&emsp;&emsp;中间有些问题完全没法回答出来，印象最深刻的就是被程序员大佬问到我寻路系统的 迪杰斯特拉算法。&emsp;&emsp;的确我在 C++ 里面用了这个寻路算法，当时也有深入研究过。&emsp;&emsp;但是网易面试的时候还没有做好这方面的准备，结果卡壳了，非常尴尬，我只好说时间太久我给忘了。&emsp;&emsp;这是我准备不充足的重大疏忽，没办法，好在我通过在华强开发 C++ 插件做的相关算法开发补救印象。&emsp;&emsp;他们问的问题大都很庞杂，也有问到shader优化相关的问题，我也没有办法给出很好地答案。&emsp;&emsp;最后没有办法只能说自己不会了。 &emsp;&emsp;不过整体的感觉还好，我还算是能够处之泰然。&emsp;&emsp;面试的时候不慌张，自信一点，给人的印象也会好一点的。 &emsp;&emsp;于是9月底就陆续收到了 腾讯和网易的 offer 了 就业环境 &emsp;&emsp;其实就今年的经济情况来看，已经比起去年有所好转。&emsp;&emsp;去年恰逢中美贸易战的动荡时期，CG行业的很多公司都倒闭或者转型，颇有种人人自危的感觉。&emsp;&emsp;今年虽然依旧有些阴霾，但是大环境还是趋向缓和的。 &emsp;&emsp;就我投递的岗位而言，恰巧碰上了行业的红利期，竞争不大，算是入职大厂比较好的方向。&emsp;&emsp;从今年腾讯的校招官网可以看到，技术美术的竞争比例只有 9 ： 1，而且其他岗位普遍都到了 20：1 以上，甚至有 50 ： 1 上千的都有。&emsp;&emsp;今年刚好是腾讯第一年开始校招，技术美术的考核标准还没有形成套路，就业标准也比较低，最重要的是竞争不大。 &emsp;&emsp;我很喜欢将人工智能行业和技术美术行业进行互相对比。&emsp;&emsp;因为两个领域都属于技术支持范畴，两个岗位都属于对应行业的核心技术人员。&emsp;&emsp;公司如果没有这些人才不会导致产品卖不出去或者出现很严重的问题，而且对这方面的人才需求也不会有很大规模。&emsp;&emsp;因此中小公司基本不会招这类岗位，大公司的岗位也是往精专方向去招。 &emsp;&emsp;因为人工智能领域近几年别培训机构炒热了，所以竞争非常激烈，尤其以低端岗位更甚。&emsp;&emsp;很多人培训出来之后就失业，原因就在这里，因此高端岗位一直缺人，没点顶会文章，大厂都不会考虑招进来。&emsp;&emsp;而技术美术以及TD目前的就业情况还比较好，竞争也没有那么激烈。&emsp;&emsp;毕竟TA和TD在过去主要是由在业内工作了一段时间的人转型而来的，需要有丰富的实际操作的经验。&emsp;&emsp;过去大都是以社招为主，近几年腾讯、网易大厂才逐渐开放校招通道。 &emsp;&emsp;除了和技术支持类的岗位进行对比之外，我也喜欢拿技术美术和前端进行对比。&emsp;&emsp;毕竟我也是学过前端的人，见证过前端的快速发展。&emsp;&emsp;在我入学那年（2016年），其实是前端也包括人工智能领域发展的红利期。&emsp;&emsp;两个行业都属于发展初期，考核标准各方面都比较松。&emsp;&emsp;人工智能和前端都只需要会一些前沿的框架调用，就可以顺利在大厂站稳脚跟，拿到offer。&emsp;&emsp;但是随着技术的发展和普及，前端发展之迅猛远远超出了我的想象。&emsp;&emsp;如今前端的招聘也基本上和大部分的编程岗位一样，需要考察各种计算机底层原理，考算法和数据结构。&emsp;&emsp;各个大厂都爱用算法进行人才的筛选，考核也逐渐套路化。&emsp;&emsp;可以说每一年都是有史以来最难找工作的一年呀。 &emsp;&emsp;目前因为技术美术岗位还属于初期，甚至连HR都不太清楚这个岗位是干什么的。&emsp;&emsp;也算是自己恰好抓住了这个特定时期的机遇吧。&emsp;&emsp;毕竟这一次校招我也没有做刷题的操作，也没有搞海投战术，只投了两家大厂。 简历准备 &emsp;&emsp;这一次我使用的是 知页简历 来准备自己简历。&emsp;&emsp;简历不需要设计得太高大上，最重要是布局清晰，信息全面。 &emsp;&emsp;另外，千万不可以用一份简历投所有公司、投所有岗位。&emsp;&emsp;每一个公司最好写上有针对性的内容，简历是招聘最开始的地方，如果这里没有做好，那就不用指望后续的机会了。 &emsp;&emsp;另外简历也不要太长，不要造假。&emsp;&emsp;我的简历一般只有 1 到 2 页就够了。&emsp;&emsp;太长的话，面试官可能没有心情全部去看的。&emsp;&emsp;另外，写在简历上的东西一定要做好准备，大多数时候，面试官都希望拿着简历写的东西去询问。&emsp;&emsp;我在网易面试的时候就吃了大亏。 面试 &emsp;&emsp;面试的时候服装首先不要太粗糙。&emsp;&emsp;当然我们技术方向的面试也不需要太正式、太拘谨。&emsp;&emsp;面试的时候不要跳过紧张、正常心态就好。&emsp;&emsp;我就是实事求是的那种，被问到不懂的也很直白。 &emsp;&emsp;面试的时候尽量引导面试官问自己擅长方向的东西，比如问到不懂的直接跳过。&emsp;&emsp;主要谈自己懂的东西，不断往外延伸扩展。&emsp;&emsp;当然这样也有利有弊，但是至少比不懂装懂，最后显得虚伪要好得多。 总结 &emsp;&emsp;我校招实在不能算有充足的经验，我只投了两家公司，&emsp;&emsp;我自己也分析了我投的岗位的特殊性，因此面经也没有太大的参考价值。&emsp;&emsp;我校招还是延续了自己佛系地风格，并没有投入太多的时间。 &emsp;&emsp;我个人还是建议，可以海投，广撒网，这样机会更多（当然也需要花大量的时间准备，而且如果通不过也是对自信心的打击）&emsp;&emsp;最好大三就开始做准备，特别是互联网看重实战经验，最好能尽快找到大厂的实习，这对校招是巨大的加分点。&emsp;&emsp;如果是技术类岗位，那么相应的技术基础也很重要，特别是编程岗位需要大量的刷题训练。]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一灯问卷小程序 开发]]></title>
    <url>%2Fposts%2Fc8c0ddca.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个小程序原本开发是打算用于问卷报名的。&emsp;&emsp;差不多在一个月前，也就是9月底，仲予师兄问我可不可以实现这个问卷填写的统计。&emsp;&emsp;我原本打算是做一个网页进行跳转记录的。&emsp;&emsp;但是考虑到要识别访问的用户唯一性，还是的用微信登录才可以识别。&emsp;&emsp;那既然如此，使用小程序来做应该是最为方便的解决方案。 &emsp;&emsp;原本打算国庆的时候就在家里完成这个小程序开发。&emsp;&emsp;然而因为自己懒惰，特别是校招顺利的消息出来了之后，感觉自己就没有以前那么刻苦了。&emsp;&emsp;哎，自己有时候还是需要一些外部环境的压力才可以让自己更进一步。&emsp;&emsp;就像 《death by chocolate》 里说的 sometimes you need extra push. &emsp;&emsp;不管怎样，拖了到十月中旬，我总算是把这个东西给完成了。&emsp;&emsp;主要是最近搞华强的表情开发，感觉自己陷入了泥潭，非常不好受吧。。。&emsp;&emsp;这么急于参加校招摆脱这个环境，这里也有很深的缘由，这几个月感觉自己都在原地踏步，没有比这更难受的了。&emsp;&emsp;也因此才有了9月份开发 MayaPy 的情况，在华强真的有点喘不过气来了，还是想做自己喜欢的东西。 小程序准备 &emsp;&emsp;其实在这之前我还没有怎么接触过小程序开发。&emsp;&emsp;不过因为自己7月份有努力学习 Vue 和 node.js ，理解小程序的代码结构丝毫没有压力。&emsp;&emsp;小程序的架构真的很像 React , 这种生命周期的架构简直有异曲同工之妙。&emsp;&emsp;虽然我玩 react native 也是很短的时间，但是开发小程序真的很有相似的地方。 &emsp;&emsp;小程序开发和 react native 一样是没有 DOM 操作的，因此需要通过js的模板替换 wxml 里面的样式来实现组件更新。&emsp;&emsp;对我来说这些都不算很困难。&emsp;&emsp;简单看了一个小程序的教程，基本就上手了。 小程序云开发 &emsp;&emsp;当时对我来说最大的坑就是小程序云开发。&emsp;&emsp;通过云开发功能，腾讯已经提供了最基础的数据库+服务器，而且还有很充足的免费流量使用。&emsp;&emsp;基本上个人的小作品是完全用不完的流量。 &emsp;&emsp;在这里主要要学会如何利用小程序的云开发的功能来将读取和保存数据。&emsp;&emsp;好在官方提供的小程序案例里面就有了我所需要的功能代码。&emsp;&emsp;于是我也是在官方的基础上进行适量的修改而已，大体也没有太难的地方。 遇到的难点wx.login 获取 openid 的问题 &emsp;&emsp;为了识别用户，我需要通过小程序获取微信用户的 openid ，通过 openid 我可以知道用户是唯一的。&emsp;&emsp;最初我以为需要通过 wx.login 函数来获取 openid 。&emsp;&emsp;但是运行 wx.login 函数会顺带获取用户的头像和昵称，需要用户确认提供这方面的隐私数据。&emsp;&emsp;而腾讯的最新公告禁止在用户不清楚小程序的用途前提下，让用户点击确认按钮。&emsp;&emsp;于是我又折腾了好一会，发现原来即便不用 wx.login 也可以通过线上的云开发函数获取到 openid 下拉菜单 &emsp;&emsp;师兄要求我获取用户的基本信息&emsp;&emsp;这个可以通过表单来实现&emsp;&emsp;然而有一个问题，在选择用户的年级的时候，我需要提供一个下拉菜单。&emsp;&emsp;在 wxml 里面并没有提供这样的一个组件。&emsp;&emsp;于是我网上搜了一个 下来菜单 的实现代码，通过复制粘贴的方式实现了效果。 样式控制 &emsp;&emsp;由于没有 DOM 操作，这里控制样式是通过在 wxml 传入样式控制的变量&emsp;&emsp;然后再页面的js中修改这个变量实现样式的控制。&emsp;&emsp;因为用惯了jQuery ，最初遇到这个问题还让我难倒了好一阵子。 &emsp;&emsp;另外在样式的控制上，我在最外层 wxss 上写了很多类似于 bootstrap 调用的颜色类&emsp;&emsp;整个样式风格的颜色搭配也花了我一天的时间进行调试。 小程序跳转 &emsp;&emsp;在用户完成了数据输入之后，我需要让用户跳转到问卷星的问卷上&emsp;&emsp;原本我是想要跳转到网页链接上的，然而这个操作需要企业版的小程序才可以做到。&emsp;&emsp;于是我只好退而求其次实现跳转问卷星的小程序上，好在问卷星的小程序支持这种问卷跳转。&emsp;&emsp;只是跳转完了无法跳转回来了，跳转回自己的小程序需要开通会员才能操作。 &emsp;&emsp;因此按照目前的情况，录入的数据会有很大的问题，就是不知道访问者到底有没有填写问卷。&emsp;&emsp;好在问卷星填写完成之后是可以显示信息的，我可以做一个跳转页面。&emsp;&emsp;如果用户访问这个单独的跳转页面，就会记录用户已经完成问卷，当然如果用户完全没有录入信息则会跳转到信息录入的页面上。&emsp;&emsp;只要用户回答完问卷之后扫描这个二维码或者跳转到小程序页面的跳转链接即可。 小程序扫码跳转 &emsp;&emsp;一开始不知道怎么才能让小程序正确扫码跳转到对应的页面。&emsp;&emsp;后来网上查了之后发现草料二维码可以自动生成出这个二维码。&emsp;&emsp;但是测试版本不可用。 &emsp;&emsp;后来在师兄的帮助下让小程序成功上线了。&emsp;&emsp;经过简单的测试是可行的，那么只要问卷完成留下二维码图片就可以了。 问卷星的限制 &emsp;&emsp;原本我的想法很美好，既然指定跳转路径需要花钱。&emsp;&emsp;那我回答完问卷之后直接弹出图片扫码跳转就好了。&emsp;&emsp;没错，在网页页面是完全可以实现的。&emsp;&emsp;问题就在于我跳转到的是问卷星的小程序，小程序里显示的图片就很有毒。&emsp;&emsp;不仅没有识别图中二维码的功能，甚至连保存图片也会显示保存失败(:з」∠)&emsp;&emsp;这可把我难倒了。&emsp;&emsp;如果可以让小程序跳转到问卷星的网页就好了，然而腾讯限制了小程序跳转H5的功能&emsp;&emsp;所以要实现我的自己设计的逻辑，就只有让用户截屏，然后再识别图中二维码了。 &emsp;&emsp;最后师兄嫌这个操作太麻烦了，于是干脆就把第二个二维码也公布出来，直接告诉大家，要完成报名需要扫第二个二维码。&emsp;&emsp;但这样是会有漏洞的，如果用户录入了信息，回退了问卷，直接扫码，那就被用户转了空子了。&emsp;&emsp;不过也没办法了，因为没有更好的解决方案了，除非花钱。 总结 &emsp;&emsp;小程序开发比我预计的要简单一些。&emsp;&emsp;但是数据库开发我还是很生疏，花了一点时间来写 crud 功能。&emsp;&emsp;另外在华强的工作也浪费了我太多时间，到职后面开发进度太慢。&emsp;&emsp;我被迫无奈，只好将小程序开发的东西弄到上网机上弄，才最后在10月中旬做完(:з」∠)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠴编程/前端/小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【回忆录】 - 我的大三]]></title>
    <url>%2Fposts%2F21ad06c1.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;大三这一年对我来说是相当重要。&emsp;&emsp;也为我后来校招打下了坚实的基础。 花城汇三维网页 &emsp;&emsp;9月中旬，我总算是把专业网站差不多地弄完了。&emsp;&emsp;就在这个时候聪哥给我们三维扫描小组拉来了花城汇项目。 &emsp;&emsp;基本的工作就是在网页里面重建整个花城汇广场的模型。&emsp;&emsp;然后需要我们点击相应的模型显示出数据库里对应的数据。&emsp;&emsp;甲方给我们提供了 CAD 图纸，我们尝试将CAD图纸转成模型转到 Maya 里面&emsp;&emsp;由于CAD的DWG格式无法直接在 Maya 加载（加载会卡死）&emsp;&emsp;我们先通过 Max 加载 DWG ，然后通过 MAX 的命令挤压出模型。&emsp;&emsp;但是曲线挤压的模型有各种问题，当时做模型的人不够又另外找了三个大一的同学过来帮忙。 &emsp;&emsp;我感觉这样工作效率太低了，而且也完全学不到东西，对大家都不好。&emsp;&emsp;于是我潜心研究 Houdini 的解决方案，当时也问过仲予师兄的解决方案，然而并没有可用的方案给我。 &emsp;&emsp;所以很多时候是需要自力更生的。 Houdini VDB 将CAD图纸转成实体模型 &emsp;&emsp;经过自己不懈的努力，最终自己摸索出了通过 VDB 转换模型的解决方案。&emsp;&emsp;因为我们自己不懂，需要将模型转换为 VDB ，然后再转模型，这个过程非常吃内存。&emsp;&emsp;所以最后只好交给台式电脑处理，不过也的确极大加快了制作的效率。 Houdini - 计算模型体积 过滤问题模型 &emsp;&emsp;后来又发现有些模型挤出没有体积的，需要额外删除&emsp;&emsp;然后又研究了Houdini的解决方案给解决了。 &emsp;&emsp;后续花城汇项目也出了很多问题，断断续续，一直走到10月份。&emsp;&emsp;当时我开始尝试通过 Maya python 来写代码。&emsp;&emsp;python我是到了 18年6月份才开始学习 , 也就是暑假前比较空闲的时候 。&emsp;&emsp;一方面是自己对新事物有点抗拒心理，另一方面主要是因为之前聪哥在，不敢明目张胆地学习。 &emsp;&emsp;后来到这个项目的时候，我已经开始尝试用 cmds 来写些东西简化整个制作过程了。&emsp;&emsp;最典型代表就是下面的博客文章的需求。 Maya Python - 自动生成序号插件 &emsp;&emsp;因为每个方块盒子需要对接数据库的数据，那数据库需要存储每个方块的编号记录。&emsp;&emsp;所以，我们在模型上命名需要给一个特定的编号进去，之前因为不知道怎么标识数字，所以只好让大一的同学在 PS 上填数字。 &emsp;&emsp;后来经过我对Maya API 的研究，我发现可以通过代码来实现自动序号的生成。&emsp;&emsp;我以及通过命名的工具给所有的方块给定了一个数字编号。&emsp;&emsp;后续是获取这个名称的数字，然后通过 Maya2018 新版本的 Text 工具实现模型文字的生成。 &emsp;&emsp;面片贴合工具、自动成盒工具都是那个时候应付这个项目做出来的小工具。 MEL 随机大小插件 MEL - 面片自动匹配插件（一） MEL - 面片自动匹配插件（二） MEL - 选点成盒插件 &emsp;&emsp;当然这些都还是用 MEL 写的。 &emsp;&emsp;因为那个时候正在联系仲予师兄将我内推到 华强方特 ，所以边学边做这些 Maya 开发，特别有动力。&emsp;&emsp;后来这个项目只收到尾款就烂尾了。。。 国庆前后爆肝学PyQt | 龙门镇三维旅游网页 &emsp;&emsp;后来到了国庆，有点让我回想起一年前做魔兽不快的时间。&emsp;&emsp;为了确保自己进入华强之后不会丢了师兄的面子，我扛着巨大的压力，拼命爆肝学习 Maya Python 编程。&emsp;&emsp;也就是当时挺着风寒写了三篇关于Qt的文章 Pluralsight - Python for Maya Fundamentals Python For Maya Artist Friendly Programming PyQt &amp; Qt Designer 三套教程 &emsp;&emsp;最后看完教程之后还顺带将学习到的东西做了实践。&emsp;&emsp;于是就有了利用 Python 写爬虫，爬取青年之声接口上的数据。 Python爬虫 - 抓取 青年之声 数据 Python - 用 PyQt 写爬虫界面 &emsp;&emsp;以及后来利用 Python 读取 Pluralsight 和 Lynda 字幕的操作 Python - 用 PyQt 写 Pluralsight 下载器 python - PLB downloader 开发完成 &emsp;&emsp;当然下载器那个其实写得很失败，是个单线程的超不友好的下载器。&emsp;&emsp;而且估计现在已经不奏效了吧，接口以及验证不可能一直不变的。 &emsp;&emsp;差不多也是这个时候，聪哥先是弄了一个什么桌球游戏的外包。&emsp;&emsp;需要我们做一下桌球的贴图，我也协助帮大一的给模型建出来了。（其实主要是教他们映射贴图）&emsp;&emsp;后来这个项目也不知道怎样，不了了之了&emsp;&emsp;另外一个就是 龙门镇三维旅游网页 这个项目了。&emsp;&emsp;当时聪哥很自信，甚至说我做做辅助就好，因为我那个时候已经告知了他，我有师兄帮我内推进了华强方特。 &emsp;&emsp;然而结果证明没有我，这个网页就要变成烂尾工程了。&emsp;&emsp;于是我没办法，只好去配合力挽狂澜。&emsp;&emsp;模型聪哥本来打算让大一或者之前的两个动画去配合完成的。&emsp;&emsp;结果首先是我要去实习了，然后其他人聪哥调动不起来。&emsp;&emsp;两个做动画的因为花城汇项目，聪哥给的报酬和承诺的严重不符，结果也闹翻了（聪哥画饼说有1万元，结果他们只有1千多）&emsp;&emsp;我都忘记当时花城汇拿到了多少报酬，印象中是听说我要去深圳，给了我5000元。（后面听聪哥说这个项目只付了首款2-3万元，后面烂尾了）&emsp;&emsp;后来聪哥没办法，他自己也基本把 Maya 的操作给忘光了，于是只好请了外包公司（也是广工的师兄开的）去处理。 &emsp;&emsp;而我那个时候还是主要围绕着 Three.js 做交互的逻辑。&emsp;&emsp;最后还是开发还是挺顺利的。&emsp;&emsp;只是有一会印象特别深刻，忘记是什么事情回了学校，然后那个外包的公司有一个师兄叫梓伟，是大一那会沙龙的会长。&emsp;&emsp;我在沙龙待了两年，还是认识他的。&emsp;&emsp;他那个时候说网页遇到了严重的问题，要我过去通宵解决。&emsp;&emsp;于是我就不管三七二十一，抓起书包就赶了过去。&emsp;&emsp;在路上告诉聪哥，聪哥还各种惊愕，劝我不要过去什么的。 &emsp;&emsp;去到了才明白，我被聪哥包装成了工资过万的技术大佬了(:з」∠)&emsp;&emsp;然后也提到大佬去了深圳，然后我刚好实习也去了深圳，还好我才大三，只要我不认，他们绝逼不知道大佬就是我。&emsp;&emsp;然后我就帮着聪哥圆谎。（我也知道出来混，不包装一下自己的实力，项目都接不到的）&emsp;&emsp;说我在大神的带领下，学到了技术的精髓，然后又说大神封装了特牛叉的js脚本，还弄了 API 文档，超级厉害。&emsp;&emsp;背地里其实这些都是我自己亲手弄的，在真实的世界里体验了一把扮猪吃老虎的感觉，贼TM爽。 &emsp;&emsp;其实以前封装的东西真的不咋的，是做花城汇项目的时候，为了更好的给甲方交接这个工具，我就利用 docsify 工具，直接做好了 API 文档。&emsp;&emsp;脚本其实使用 ES5 参考 Three.js 的一些内核封装的，其实特别粗糙，可以看成只是一个类附着了大量乱七八糟的调用函数而已。&emsp;&emsp;不过无论如何也算是写了 API 文档，也实现了过年自学那段时间聪哥吐槽的要 new 一个东西去用的想法。 &emsp;&emsp;好在外包公司都是做美术的，他们压根就看不懂程序，我使劲吹大牛，其实是在夸自己，简直有毒O(∩∩)O哈哈~&emsp;&emsp;不过当时过去的问题也的确棘手，需要在 Three.js 里实现 AO 效果。&emsp;&emsp;他们说只有加上 AO 才有那种层次感，否则目前的美术效果太平了，后来我搞了一个通宵才做了出来，中间还遇到了丢失了模型阴影等等各种问题。&emsp;&emsp;中途他们的老板还请了我们吃了一顿烧烤。&emsp;&emsp;这个老板也是我的大大大大大大师兄了，出来创业陪我们通宵。&emsp;&emsp;然而他陪我们通宵居然是在通宵打 LOL 你敢信(:з」∠)_，一边吐槽项目，一边打游戏也是没谁了。 &emsp;&emsp;记得后来又因为性能问题，摒弃了动态AO的方案，主要是那会好像搞错了一些东西，导致模型都没阴影，效果才这么糟糕。&emsp;&emsp;后来经过我的排查，解决了这个问题了。 &emsp;&emsp;这个项目虽然是政府的，但是聪哥接的时候已经经过了多手的外包，钱也不多，再加上外包公司做模型也分去了大部分的成本。&emsp;&emsp;后来我想着自己实习也有点小钱了，就让聪哥把我的薪酬留着，好好创业吧~ 华强方特内推和就职 &emsp;&emsp;关于华强方特的内推，多亏了在里面做特效的 仲予师兄。&emsp;&emsp;我能顺利去深圳就职，师兄的助力可谓是功不可没。&emsp;&emsp;我入职的时候还刚好他那边有人要转租，我就顺利得连住房问题也解决了。 &emsp;&emsp;其实我9月份的时候整理了自己大学两年来的作品集。&emsp;&emsp;回头看了一下自己这些年跟着工作室努力的成果，其实关于 TD 开发的内容并不多。&emsp;&emsp;而且很多都是使用 MEL 开发的，属于非常没有竞争力的阶段。&emsp;&emsp;我当时还挺担心能否通过内推的。不过后面倒是挺稳的。&emsp;&emsp;当然仲予师兄也多番强调要赶紧看 PyQt 开发相关的教程，他以前也做过这方面的开发，算是个特效TD，很强！&emsp;&emsp;也就因为这样，我国庆之后就不断爆肝学习 PyQt &emsp;&emsp;其实关于华强就职，我入职的第一周还写了文章~ 华强方特 实习 第一周 &emsp;&emsp;想到最近我离职了，总算是可以对老东家进行全方位的吐槽了。 &emsp;&emsp;刚来华强方特的时候，恰巧这边技术部门遭遇了TD集体离职的重创。&emsp;&emsp;本来行业上的TD就不多，招人异常困难。&emsp;&emsp;因此部长愿意让我这种实习生进来学TD，那会基本上有点基础的都可以进去。 &emsp;&emsp;开始的工作，包括环境都让我感觉很新鲜。&emsp;&emsp;但是经过了一段时间之后还是有不少让人失望的地方。&emsp;&emsp;我刚入职的时候，发现会 Qt Designer 就已经很强了，那会除了部长，似乎也没多少人会这个开发。&emsp;&emsp;我的顶头上司也不懂，所以很多时候只能自己摸着石头过河。&emsp;&emsp;别人靠不住，就学会使用搜索引擎来解决自己的问题。 &emsp;&emsp;我记得刚进去开发的第一个工具是给师兄他们特效部门做的，当时刚进去，属于熟悉环境的阶段。&emsp;&emsp;因此可以放心地帮师兄完成这个开发。 Maya Python - ALembic导入导出助手 藤蔓生长快速绑定工具 &emsp;&emsp;虽然没有牛逼的人带我，以前在工作室养成的习惯还是很有帮助。&emsp;&emsp;我基本上可以保持每天工作到10点之后，周末也不停地状态来自学。&emsp;&emsp;大概是因为脱离了学校的环境，加上刚入职的新人压力，那个时候真的干劲十足。 &emsp;&emsp;后来，公司方面安排给我的一个工作就是给绑定部门开发一个快速绑定藤蔓的工具。&emsp;&emsp;其实当时也不是刚需的插件，绑定部长丸子说以前绑定这个东西遇到了很多问题，希望我可以开发这个插件来实现快速绑定。&emsp;&emsp;说实在当时已经一年多没有接触过绑定了，好在绑定的基础原理还是记得的。&emsp;&emsp;于是拿着丸子提供的文件进行了深入的研究。 &emsp;&emsp;因为那个时候接触 Qt 的时间也不长，丸子也没有给插件提出更加具体详细的需求。&emsp;&emsp;所以那个时候都是自己给插件提需求，自己做产品经理，把插件体验做到最好。&emsp;&emsp;当时开发遇到的困难可以参考我的博客文章 Maya Python - 藤蔓生长快速绑定工具 TSM镜像工具 &emsp;&emsp;后来经过了藤蔓工具大概半个月的开发之后 &emsp;&emsp;绑定那边突然加急要我完成TSM绑定系统的镜像功能，现在动画组那边急需这样的功能。 Maya Python - TSM镜像工具 &emsp;&emsp;当时因为没有人指导我，遇到问题都是自己闭门研究解决的。&emsp;&emsp;当时想要类似 ADV5 的不同窗口切换功能，当时不知道 evalDeffered 命令&emsp;&emsp;结果将这个功能集成到菜单里面就会不停导致Maya崩溃，当时连代码哪里出错了都不清楚&emsp;&emsp;还是看了 ADV5 源码才解决的。 &emsp;&emsp;再后面绑定那边给我安排辅助开发龙的绑定切换功能，那边龙的绑定功能还是有点复杂的&emsp;&emsp;需要飞天和落地形态的切换&emsp;&emsp;也就是蛇形绑定和两组绑定的快速切换。&emsp;&emsp;最后我没能给他们搞定，是后来张峥前辈给了解决方案。 &emsp;&emsp;在我工作了快一个月的时候，终于来了一位大神————张峥，他是从追光动画过来的。&emsp;&emsp;大我10岁，过来以流程TD的身份统筹整个流程。&emsp;&emsp;刚好他刚进来就是一批入职培训，我就和他一起参加入职培训的。&emsp;&emsp;当时和他聊了不少东西，的确是个牛人。 &emsp;&emsp;果不其然，他就慢慢接替了业哥的位置，做了TD组的组长。&emsp;&emsp;我那个时候搞不定 龙绑定 切换，还是多亏大佬帮忙让我从中解脱了。 外包检查工具 &amp; 文本加密工具 &emsp;&emsp;当时大神刚进来，并没有太多的任务从他手上安排给我。&emsp;&emsp;技术部部长苏老板给我安排了开发对接外包工具的工作。&emsp;&emsp;也就是将我们内部使用的检查工具封装成 pyd 文件交给外包公司使用，避免了源码泄漏。 Maya Python - 外包检查工具开发 &emsp;&emsp;当时为了做得更好，还开发基于字符编码加密的工具。 Python - CHR_Encrypter CHR文件加密器 &emsp;&emsp;我当时开发 PLB下载工具的时候有弄过类似的操作，这一次算是结合 Qt 的界面复习了一遍。 Ziva研究 &emsp;&emsp;18年年末的时候，苏老板安排了我和智博研究 Ziva 插件，希望可以在年前给出一套方案。 &emsp;&emsp;当时听说 Ziva肌肉插件 已经在楼下的动漫公司投入使用了。&emsp;&emsp;虽然楼下是集团的分公司，但貌似技术的壁垒还是有的，我起初还是白手起家。&emsp;&emsp;后来智博通过绑定部门那边拿到了楼下的 Ziva 资料，然后我们就开始了相互的研究。 &emsp;&emsp;那会我还没有升级电脑，Ziva这套流程和做特效差不多，需要大量的电脑资源进行解算。&emsp;&emsp;当时做测试特别浪费时间，于是苏老板给我安排了一台高配机，配合我的测试工作。 &emsp;&emsp;越做其实就越知道测试过程的乏味与无趣，前期和智博定的方案还是可以执行的，但是我做测试不太行。&emsp;&emsp;有时候因为错误操作解算不对，然后半天就白搞了，也没有产线制作人员的耐心。&emsp;&emsp;于是我给自己的定位还是以编程插件辅助为主，所以我帮直播看官方的教学，指导使用流程。&emsp;&emsp;关于这套东西的参数设置，解算就交给他来弄了。&emsp;&emsp;而我就去做辅助工具的开发，简化出一个使用流程。 Maya Ziva 初步探索 &emsp;&emsp;也是那个时候，智博教会了我使用Maya的HumanIK&emsp;&emsp;我也是那个时候为了达到我们最初方案的一些需求，开始研究Maya更加底层的模块 OpenMaya &emsp;&emsp;最初我是不知道 OpenMaya 模块，还是多亏了绑定部那边突然开会加需求。&emsp;&emsp;他们想要实现龙绑定碰撞地面的效果，希望我们 TD组能够给与技术支持，那时候张峥还没有进来。&emsp;&emsp;没有人知道应该如何做，不过绑定那边是找到了一个国外大佬做的 Demo ，并且还将源码给到了我们。&emsp;&emsp;那个时候是我第一次接触OpenMaya，国外的大佬用 OpenmMaya 写了一个碰撞器节点，牛逼得很。&emsp;&emsp;我当时很努力研究吃透他的代码，但是对于节点开发当时还没有什么概念，也不知道原来和 C++ 是一样的。&emsp;&emsp;当时也还没有学习 C++ 代码开发，所以踩了特别多的坑。 &emsp;&emsp;还好当时是记得有一套教程的讲这个的，我很早很早之前就发布到 B 站了，于是我就趁着那段时间看。 &emsp;&emsp;我还记得当时凑巧有事情回学校，大概是有考试之类的吧，然后我就趁着学校的时间爆肝将Ziva需要的插件给做出来的&emsp;&emsp;其实这个功能也还好，并没有那么复杂，而且就我目前看来还有很多可以优化的地方。 OpenMaya - VertexConstraint插件开发 &emsp;&emsp;关于Ziva流程的推进我和智博做了很多努力，中间一些疑惑也和张峥交流过&emsp;&emsp;得出的结论就是目前我们很难将这套复杂的东西运用到我们的实际项目之中。&emsp;&emsp;首先是这套解算需要做实体的骨骼和肌肉，需要大量的人力物力去做辅助。&emsp;&emsp;骨骼模型要用Maya骨骼进行绑定，肌肉需要用 Ziva 提供的肌肉进行动力学解算。&emsp;&emsp;然后还需要添加一层筋膜，我接地气地翻译为了紧身衣，让肌肉对这一层筋膜进行碰撞。&emsp;&emsp;最后计算出的筋膜还要连接皮肤层，皮肤层也需要添加Ziva的皮肤来计算真实的抖动。 &emsp;&emsp;整一套流程下来非常非常消耗内存，因此官方是通过缓存一层一层解算的。&emsp;&emsp;而且计算效率贼低，因为 Maya对多核优化不好，我后面也有专门做过测试，Ziva的解算效率很低。&emsp;&emsp;而且解算的过程还偶尔会产生崩溃的情况，真的是让人头大。 &emsp;&emsp;因此整一套下来的成本是可想而知的。&emsp;&emsp;不过后面智博也提了一个非常棒的方案，就是给官方的骨骼肌肉做绑定，就可以通过控制器来匹配肌肉骨骼&emsp;&emsp;大大减少模型部的工作量，当然如果有更高精度的要求，估计这种方案也不太行。 &emsp;&emsp;这里是当时的一些流程测试之类留下来的记录 Maya Ziva 设置参考 &emsp;&emsp;后面忘了过年前还是过年后了，楼下动漫公司又给我们开了一场交流会。&emsp;&emsp;交流才发现他们的研究造诣还没有我们做得深，我们的测试以及辅助的插件做得比他们要全面的多。&emsp;&emsp;难以相信他们号称已经研究了半年，并且已经投入到了实际的生产之中。 &emsp;&emsp;最后经过张峥的判断，这个流程算是胎死腹中了，我后面没有怎么对接，主要是智博交接了后面的流程。&emsp;&emsp;大概毕竟我还是个实习生吧。 2019春节 &emsp;&emsp;过年前几天，参加了公司的年会。&emsp;&emsp;实习生可惜点，无法参与年会的抽奖，但是只要出戏就有安慰奖 800 元，我也是很高兴的。 &emsp;&emsp;然后华强的春节放得挺长的，印象中有13、14天，不过听说是把年假也一并放了，我实习生就赚到了。&emsp;&emsp;回家之后，今年没有去年学习 Houdini 那么有干劲了。&emsp;&emsp;刚好那个时候还有每个月做计划的习惯，因此翻了一下，是可以看到当时的一些记录的。&emsp;&emsp;我那段时间去学 Flutter 了，主要就是想开发一个时间管理的 APP ，满足我不同的需求吧。&emsp;&emsp;不过拖到现在也没有完成这个工作，还是不免让我有点唏嘘。 【总结】 2019年1月回顾 | 2月学习计划 【总结】 2019年2月回顾 | 3月学习计划 镜头路线管工具 &emsp;&emsp;经过Ziva的开发之后，基本就进入3月份了。 &emsp;&emsp;那个时候相机TD那边因为小车轨道的问题，苏老板让我开发插件辅助他们解决。&emsp;&emsp;我对接之后才发现，他们虽然叫做TD，不过也算是方特特有的岗位，也和传统TD掌握的东西不一样。&emsp;&emsp;他们负责对接乐园轨道小车的相机，调节小车的关键帧适配到乐园的小车上，还需要掌握CAD和一些摄像机角度和与运动的计算公式&emsp;&emsp;不过工作内容反而和编程没什么关系。 Maya Python - 镜头路线管理器 &emsp;&emsp;其实上面这个工具是自己想要做的 Qt 开发尝试&emsp;&emsp;虽然是按照这苏老板的要求做的，但是功能过于复杂，后面沟通之后，他们的实际需求简化了很多。&emsp;&emsp;我又额外开发了一个简单的界面给他们用。&emsp;&emsp;所以这个插件就没有了用武之地，有点可惜，不过也算是积累了不少的经验。 Publish 工具开发 &emsp;&emsp;终于，经过漫长的磨合之后，苏老板算是完全将TD的工作交接给了张峥。&emsp;&emsp;所以这个东西算是我第一次和张峥合作进行开发。 &emsp;&emsp;张峥能力贼强，作为TD居然连 mysql 数据库都会。&emsp;&emsp;更别说懂绑定、懂流程了，不愧是10年工作经验的大佬。 &emsp;&emsp;在那个时候华强迫切需要重新梳理出一套完整可用的全新规范，并且需要开发对应的Publish发布工具来约束产线制作。&emsp;&emsp;那时候华强产线的规范真的形同虚设，导致后期组装的时候出现一大堆的问题。&emsp;&emsp;张峥在这几个一直对接处理这些问题，并且研究如何让产线弄得刚好。 &emsp;&emsp;苏老板这边一直希望能够为公司打造一个自研的shotgun，公司内部称之为花木马。&emsp;&emsp;不过张峥看过之后，发现这个网站平台徒有表面，设计上依然有很多问题。&emsp;&emsp;TD想要接入到花木马的数据库上有产生了很多张峥意想不到的状况。 &emsp;&emsp;后来我听后面入职的同事说，张峥在华强搭建的规范其实和追光的差不多，不过那会我也不知道。&emsp;&emsp;但是追光的技术规范和管理的确是很优秀的。 &emsp;&emsp;当时张峥给我的需求其实并没有那么复杂。&emsp;&emsp;只是希望通过 xml 配置，可以生成出对应的插件面板。&emsp;&emsp;按照张峥原本的想法，其实 xml 也可以， json 也可以，目的是让界面调用更加灵活。 &emsp;&emsp;因为我过年的时候学习过 react ，我就想把组件化的思想融入到界面上。&emsp;&emsp;换句话说就是实现我们自己定义的 Qml 效果，或者说是类似 Html 的效果。&emsp;&emsp;我当时还想得很多，甚至想将 HTML 有的东西标签，全部封装出不同的组件进行调用。&emsp;&emsp;这样就可以通过 XML 的组合实现很复杂的应用。&emsp;&emsp;不过张峥把我拉了回来，让我实现组件扩展就可以了。&emsp;&emsp;如果功能太碎，反而会框架做得很复杂，其实不好的。 &emsp;&emsp;于是我又花了很大的精力来编写整个Publish界面框架 Maya Python - Publish工具开发 &emsp;&emsp;借助以前开发 Three.js 的文档开发经验，我利用自己的前端知识进一步又花了 Docsify 的文档&emsp;&emsp;开发完整一个框架调用之后，有需要开发一些功能来完善 Publish 功能 Maya Python Publish 检查功能开发 &emsp;&emsp;这一个开发也非常有意义，第一次解除了 ffmpeg 工具的使用，也为我后面腾讯测试题提供了准备 C++ 插件开发 &emsp;&emsp;经过这些努力之后，检查工具的开发更进一步需要开发一个重叠面以及面穿插检查工具。&emsp;&emsp;我当时和张峥讨论了之后，定出了一套空间切分算法。&emsp;&emsp;毕竟如果不停遍历模型上所有的面，算法复杂度可是 O(n²)&emsp;&emsp;于是我们先遍历所有的面，将面分组到空间魔方一样的区域上，然后再对每个小区域进行重合计算&emsp;&emsp;极大减少了计算量。 &emsp;&emsp;不过这样子的计算效率还是比较低。&emsp;&emsp;于是我就尝试将 Python 代码转换到 C++ 来加快进行效率。 Maya C++ MEL语句 性能测试 &amp; 插件开发 &emsp;&emsp;当时还想解决面面穿插的问题，奈何需要遍历所有的边，计算效率太低了，还不如ziva工具的计算速度。&emsp;&emsp;所以我的方案解决了重叠计算问题，却解决不了模型自穿插检查的问题。 RBF工具研究 &emsp;&emsp;大概是4、5月份的时候，我的同学也过来实习了。&emsp;&emsp;后面差不多5月份的时候，张峥动用了他的人脉，给我们找来了 渲染TD 何欣。&emsp;&emsp;这个时候TD小组不断壮大。 &emsp;&emsp;从4月末开始，我完成了 Publish 工具框架的搭建。&emsp;&emsp;张峥就让我接手更加复杂的 表情工具开发。&emsp;&emsp;希望我可以研究一下网上的 RBF 插件，实现更加符合公司要求的工具 Maya Python RBF工具开发研究 Maya C++ 多核性能测试 &emsp;&emsp;国外大神写的开源的 RBF 插件地址 仓库&emsp;&emsp;为了研究清楚Maya的多核功能，我还自己通过 RBF 工具的源码进行了测试。&emsp;&emsp;结果结论还是 Maya 底层的内核太久了，对于多核优化比较糟糕。 &emsp;&emsp;前期是在研究这个插件的计算原理，但是过于复杂，我自己完全没有搞懂。&emsp;&emsp;张峥希望插件可以实现线性过渡的效果，因为目前插件的过渡是非线性的，越接近输出的数值越近视。&emsp;&emsp;我在文章中也提到，可以通过函数进行修正，但是这样也剥夺了单一样本的独立性。 &emsp;&emsp;后来张峥说，如果我们吃不透这个插件的代码，我们可以自己去开发一个。&emsp;&emsp;于是他给说了很多他计算相似的方法，比如不同表情的曲线边长比值。&emsp;&emsp;划分区域，减少计算的数量。&emsp;&emsp;不过我研究到后面，颇有种心不在焉的感觉。。。 &emsp;&emsp;经过几个版本的全面推倒之后，我想不到的是这个开发会一直延续到我离职才勉强交接完成。 视锥可视工具 &emsp;&emsp;这个工具是苏老板计划用来删减模型，减少渲染内存用的&emsp;&emsp;不过在开发之初，张峥就断定这个方案是派不上用场的，但是苏老板执意要做，就让我把坑给踩了。&emsp;&emsp;虽然明知不可为而为之，但是也可以进一步锻炼 OpenMaya 的使用，我还是挺尽心的。 Maya Python 视锥可视工具 暑假前后 &emsp;&emsp;四、五月份的时候，因为我自己的出色表现。&emsp;&emsp;加上我和师兄的争取，成功争取到了三个实习名额给还在学校的同学。&emsp;&emsp;其中有位女同学和我一样去做TD的工作。&emsp;&emsp;我知道她的基础还差不少，因此特意为她做了 Python Qt 系列教程给她。 Python-QT-开发教程 &emsp;&emsp;6月份的时候，刚好是大三学期末有考试和大作业。&emsp;&emsp;那个时候的大作业是用 Unity 引擎做一个游戏，游戏的前期策划已经被我的组员做完了。&emsp;&emsp;因此我的工作就是把游戏程序开发完成。 Unity - 场景漫游课程设计 &emsp;&emsp;完成了上面的课程设计之后，自己对游戏制作的信心增强了不少。&emsp;&emsp;但也很清楚自己所掌握的能力范畴，如果是以程序员的身份进入行业是很困难的。&emsp;&emsp;作为TD，最佳的转行选择就是成为 TA 。&emsp;&emsp;为此，当时还咨询过不少人，我记得当时有优秀学生的演讲。&emsp;&emsp;由于大二的时候参加了创青春省赛，我也参加了，因此作为学院的创业代表参加了学校的创业之星演讲。&emsp;&emsp;那个时候创业之星参选的人很少，只要表现的印象深刻一点就顺利评选上了。&emsp;&emsp;因此我后来也有幸出席优秀学生的演讲。&emsp;&emsp;当时我和大我一届的优秀毕业生云龙师兄了解了一下游戏的情况，表达我想要去腾讯的意愿。&emsp;&emsp;云龙师兄是37互娱的大佬，大学还拿了很多游戏比赛的奖。 &emsp;&emsp;咨询是咨询了，只是后面也没有什么好的建议给我。&emsp;&emsp;毕竟我是跨行业而来，而且他也不是做技术美术的，因此真的没办法。&emsp;&emsp;所以这也加重了我自己的焦虑 &emsp;&emsp;后来我回深圳之后，也有和我哥哥同通话，说了我内心的苦楚。&emsp;&emsp;那个时候研究 RBF 已经2个月了，张峥只是给我提方向，后续研究全靠自己。&emsp;&emsp;而且很多时候都没有任何人可以交流，只能自己闭门造车单干，这种状态其实我并不喜欢。&emsp;&emsp;加上张峥还很忙，经常不在，也没法和我一起研究，在我自己内心有种代沟在里头。&emsp;&emsp;如果想要打破这种环境，我估计在华强没戏了，只能选择跳槽。&emsp;&emsp;况且华强的各种规章制度的死板也让我很无奈，有种大公司的体量却没有大公司的胸怀和福利的感受&emsp;&emsp;但是作为 TD 在广东省内跳槽，估计就没有比华强更好的公司了。&emsp;&emsp;因此对我来说更好的选择就是跳槽到 腾讯、网易 这些互联网大厂上。&emsp;&emsp;当时就像我和云龙师兄讨论的时候提到的一样，游戏行业和影视行业是不一样的。&emsp;&emsp;而且作为TA基本的 shader 能力我也不是特别强，只是在以前 Three.js 接触过，复杂的都不会。 &emsp;&emsp;因此6月份时候的焦虑就演变成的动力，在那个时候我就开始了 Shader 的学习之路 Shader学习之路 &emsp;&emsp;那会刚好有个认识的同学争取到了去腾讯暑假实习的机会。&emsp;&emsp;我们就聊了不少。&emsp;&emsp;那个时候，真的感觉自己错过了很重要的东西，因为3、4月份的时候，完全没有考虑到这么快就有提前实习的机会。&emsp;&emsp;他进的是天美的技术美术，给了我很多具有建设性的意见，真的非常感谢。&emsp;&emsp;我也是在他的建议下开始了Shader的学习。 &emsp;&emsp;后面7月份的时候，考虑大四还有数据库的大作业，而且那个时候非常想跟进树莓技小程序开发的进度&emsp;&emsp;所以那个时候我任性地改了方向，开始学习 Vue 框架，只可惜专业网站的后续似乎是不了了之了。&emsp;&emsp;Vue 学习之路 和 Node.js 学习之路 都是那个时间段更新的。 Vue学习之路 &emsp;&emsp;后来，8月份的时候，我投了腾讯的校招，想要离开华强。&emsp;&emsp;因此游戏引擎的压力就不断压在自己的身上，我那个时候榨干了自己的自由时间，拼命学习 Unreal&emsp;&emsp;在腾讯实习的同学就是主要用 Unreal 的，他推荐我使用 Unreal 学习Shader开发 Unreal &emsp;&emsp;其实8月份的时候我也不看好自己能过的，反正那个时候还有华强可以打底。&emsp;&emsp;不过无论怎样，还是按照官方说的，先把简历投递上去，后续的优化可以慢慢来。&emsp;&emsp;因此我疯狂学 Unreal 就是希望后面加上一些 Unreal 相关的 Demo&emsp;&emsp;只是没想到 华强实习的经历给我镀了金，让我在提前批里面脱颖而出 校招之路 &emsp;&emsp;后来8月末的时候，经历了最后一轮技术面试之后，我知道腾讯已经稳了&emsp;&emsp;然后我的大三也就洋溢在这种意料之外的幸福下落幕了。]]></content>
      <categories>
        <category>回忆录</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【回忆录】 - 我的大二]]></title>
    <url>%2Fposts%2F63f190cc.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;进入大二之后，遇到了更多的挫折，但是在我面前的机会也更多了。 开学外包接单 &emsp;&emsp;对了，暑假的时候还出现了很严重的问题，网页组宿舍暴雷了，他们全组集体离开工作室。&emsp;&emsp;我们动画组是不知道当中发生了什么的，但是他们的离开对我们多少也是有影响的。&emsp;&emsp;当时聪哥也没说什么，只是很无奈地默许了他们的离开而已，往后聪哥就更忙了，没多少时间管我们。&emsp;&emsp;当时动画组的管理也越来越松，我都在搞自己感兴趣的开发，可以说当时大家都有点迷茫而不知所措了。&emsp;&emsp;聪哥当时是找到了愿意投我们的投资人，然而我们需要做出一定的成果，投资才有信心。&emsp;&emsp;然而加杭师兄得过且过的态度明显让聪哥很不爽，最后我们一直交不出拿得出手的好作品，投资也就黄了。&emsp;&emsp;其实那个时候就有各奔东西的预兆，加杭师兄说出去找工作，看看别的公司的制作经验，后面就再也没有回来了。&emsp;&emsp;动画组要干的事情也没有了，聪哥开始给我们做一些外包的工作。 &emsp;&emsp;那个时候暑假已经接近尾声，聪哥给了我们一个展览会场景渲染的活，做好了大家都有钱分。&emsp;&emsp;后面聪哥又借助小瑞的关系，又拉了一个大三中印动画的同学进工作室，我们叫他小烨。&emsp;&emsp;做展览项目的时候我们第一次对接甲方，当时是立明师兄给我做对接，我负责完成甲方的需求。&emsp;&emsp;当时要做一个泰姬陵的展台，我们还到网上下了模型。&emsp;&emsp;结果聪哥和我们说不要下载网上的模型，自己模仿着做，布线各方面都比较好控制一点。&emsp;&emsp;网上下载高模非常不好修改，不过这和我想偷懒的想法是冲突了，于是我就硬着头皮做。&emsp;&emsp;没想到后面坑爹的居然是甲方，聪哥已经按照甲方最初的要求给我们搭好了建模比例，我也按照这个比例一点点细化。&emsp;&emsp;后面我们渲染一些图给甲方，甲方就慢慢开始大规模修改。&emsp;&emsp;嗯，就是那种不太懂，然后不停逼逼的甲方，而且甲方的用词有时候我和立明都理解不了，又怕问甲方冒犯了他们。&emsp;&emsp;于是最后我们互相猜甲方的真是意图，真的无奈得很。&emsp;&emsp;这个项目做了好几天，最后聪哥说甲方不满意，于是就不了了之，不知道聪哥收到钱没有，反正我是没有钱_(:з」∠)_233&emsp;&emsp;不过聪哥也不是那么地坑爹，暑假我们留在工作室学习的同学都得到了聪哥私人发放的暑假津贴，忘记多少钱了，大概是一两百吧，我也不太在意。 &emsp;&emsp;当时渲染的时候还发生了一个小插曲，记忆犹新。&emsp;&emsp;我就是在等待的时候脚不小心撞了我的神机，然后神机就挂了，这TM上万元的东西，当时可怕我吓坏了。&emsp;&emsp;因为电脑是服务器主板，和常用的家用主板效果是不一样的，开机会有自检环节。&emsp;&emsp;我当时尝试开电脑，服务器主板一直卡在自检的环节，所有的灯是亮的、风扇也在转，但是主板一直没有响应。&emsp;&emsp;考虑到磕碰可能只是零件松了，接触不良，于是我就将重要的硬件全部拔插了一遍。&emsp;&emsp;最后估计是显卡或者硬盘接触不良吧，插回去之后好了。&emsp;&emsp;当时真的吓死宝宝了。 &emsp;&emsp;这一单结束之后，聪哥又给我们找了南沙政府的项目，聪哥给我画大饼，说这个项目很大，会和其他公司合作开发&emsp;&emsp;而我主要负责建模，重现南沙政务大厅的这个模型，这个东西是要放进 Unity 进行开发的。&emsp;&emsp;于是我当时和小烨一起做地铁去南沙的政府大厅踩点，拍了很多相关的照片。&emsp;&emsp;回来之后，拿到了南沙政府提供的 CAD 图纸，当时由于不知道怎么将图纸的线条转成模型，只好人工去建模&emsp;&emsp;当时大概花了两周的时间，又是在网上找素材又是对图纸拉模型建墙壁的。&emsp;&emsp;当时开学了，我荣升为大二，还是动画的班助，忙里忙外的，真的是累死我了。&emsp;&emsp;幸好当时动画专业缩招了，两个班助对一个班，我还是可以踹口气的。 &emsp;&emsp;视频参考 7m32 - 7m50s&emsp;&emsp;视频是项目的最终效果，后面其实还有很多修改，后面再说。&emsp;&emsp;当时基本上做出来的大型就是这个样子的。&emsp;&emsp;对于这么庞大的模型量，我还是推崇网上下载模型而不是自己建模。&emsp;&emsp;但是网上下载的模型面数通常都很大，需要调整，于是我那个时候结合刷鼠标的操作拼命给模型减线。&emsp;&emsp;也有利用Maya自带的 Reduce 功能区减面。 &emsp;&emsp;我记得当时汤院长还请求我们帮她做一个宣传片。&emsp;&emsp;什么乱七八糟的东西统统都集中到那个时候来了，然后那个时候就特别特别忙。&emsp;&emsp;记得当时汤院长的片子也需要我们网上找素材，搭场景。&emsp;&emsp;基本都是靠我和立明合力完成的，那个时候我对Maya的造诣已经不错了，小瑞和小烨都有请教于我。 魔兽项目外包 &emsp;&emsp;这个项目对我们工作室来说都影响深远，必须单独开一个专题讲这个项目。&emsp;&emsp;虽然项目说是魔兽，其实和游戏关系不大，是一个乐园场景的渲染项目，应该是要我们渲染出一个海报吧。&emsp;&emsp;当时20号开始接手这个项目，预计一个星期就可以完成了。&emsp;&emsp;我们都没在意，甲方给我们发来预定的素材。&emsp;&emsp;但是素材太大了，而且甲方要求的东西很多都没有，于是还得我们去网上找素材去拼凑。 &emsp;&emsp;记得项目刚开始的时候，我们都很开心，还在畅谈国庆回家的安排，我记得当时国庆家里安排好了要回妈妈的老家梅州的，我也好久没回去了。&emsp;&emsp;甲方爸爸是聪哥认识的人，虽然不知道他们到底是什么关系，总归是比院长和展览项目的外人要好沟通一点。 &emsp;&emsp;然而这只是噩梦的开始，我们根本就不清楚有关系可能意味着肆无忌惮的修改(:з」∠)&emsp;&emsp;刚开始对接是要做一个乐园入口的效果，那个时候看到Arnold日渐成熟了，我开始看Arnold的教程，尝试使用当时最新的 Maya2017 制作这个项目。&emsp;&emsp;回想起来，这真的是第一次使用 Arnold 进行渲染，很多东西都是边学习边做项目这样子。 &emsp;&emsp;当时搬砖的无用功也做了不少，就是下载模型，摆模型这种毫无用处的工作，然而没人想干，总得有人把活给干了。&emsp;&emsp;所以我也不计较那么多，做项目总比之前自学来得明确，压力也更大。&emsp;&emsp;这回是真的体验到了什么叫每一版本都是密密麻麻的修改意见，当时也的确做得火气都上来，感觉这活就是无底洞。&emsp;&emsp;每天工作到晚上11点被保安催促着回宿舍，然后还有很多东西没有改完。&emsp;&emsp;现在看来就像程序员改Bug一样╮(╯▽╰)╭，真的越改越多，越改越烦。 &emsp;&emsp;当时聪哥一直没有直接对接，都是我和立明在微信群里面对接需求。&emsp;&emsp;甲方爸爸也很任性，有很多地方都属于大改的部分，真的体验到了工具人的感觉。&emsp;&emsp;很快一个星期的工作时间就到了，但是我们加班加点还没有改完，整个工作室的氛围就越来越糟糕。。。 &emsp;&emsp;当时也要怪我，Arnold的经验不足，包括做项目的经验也十分单薄，所以这个项目也犯了很多错误~&emsp;&emsp;最智障的错误就是网上下载了一个4w多面的草，然后根据甲方的要求需要将草铺满半边的屏幕。&emsp;&emsp;于是我没有怎么考虑这个面数的问题就直接对这个模型批量复制。&emsp;&emsp;结果这个草居然占了几千万个面，打开卡、渲染也卡，我们也不知道问题的根源，反而就越来越烦躁了。&emsp;&emsp;然后最坑爹的事情就发生了，因为这个草的问题，直接导致了小烨的电脑显卡报废了（可能这显卡本身的品质也不行）。&emsp;&emsp;所以当时搞得大家都很不开心，我也吸取了很大的教训。 &emsp;&emsp;当时甲方爸爸也知道自己理亏，还给我们工作室免费请了一顿寿司。&emsp;&emsp;然而后面依旧于事无补，特别是有人提出国庆假期加班干完这个项目（忘了是不是聪哥了），当时所有人都炸了。&emsp;&emsp;我当时在吃饭也很不客气地数落了聪哥，当时聪哥女朋友也在，我没有意识到这意味着什么，反正最后立明给我们打圆场过去了。&emsp;&emsp;哎，年少轻狂，不过聪哥也算是惹起了大家的愤慨吧。 &emsp;&emsp;后面小瑞也有给我们做思想工作，毕竟好不容易一起奋斗了一个暑假，大家还是希望以和为贵。&emsp;&emsp;不过我国庆的安排是早就在计划上了，是绝对雷打不动的。&emsp;&emsp;经过一番争执之后，聪哥还是把这个外包单子压了下去。&emsp;&emsp;当然报酬也不可能有了。 &emsp;&emsp;当时真的太年轻了，完全不知道这种接单毁约很可能是要赔偿的，都是聪哥后来给我时候才明白。&emsp;&emsp;因为这件事之后，其实工作室内部已经产生了剧烈的分歧，小瑞和小烨还闹僵了，这都为后来的发展埋下了伏笔。 国庆 | 工作室解散 &emsp;&emsp;国庆前，由于项目的事情闹得不欢。&emsp;&emsp;国庆的时候也算是堵着一股气吧，回去老家那边也过得萧然无味，于是也在看教程。&emsp;&emsp;基本还是围绕着 Arnold 的教程，也看了一些 绑定 的教程。&emsp;&emsp;由于那边没有电脑，也仅仅停留在看的阶段，不过因为自己打牢了基础，发现即便不实际操作也能学习到不少东西了。&emsp;&emsp;有时候看教程留个印象，下次用到的时候再去翻再去看也是帮助很大的，至少以后要用的时候自己还知道切入点在哪里。 &emsp;&emsp;国庆的时候我终于忍不住向家里要钱买了一部笔记本电脑。&emsp;&emsp;其实开学的时候就已经有很多师兄推荐台式+笔记本的搭配，的确这样才是最方便的。&emsp;&emsp;然而当时我台式就花了上万元，实在不好意思再向家里要钱配笔记本电脑，于是就一直拖着拖着。&emsp;&emsp;大一也因为这个原因到处蹭别人的电脑用╮(╯▽╰)╭ &emsp;&emsp;当时还是以学习的心态去配的，于是有了一直用到现在笔记本电脑。&emsp;&emsp;最开始预算是 3000 元以内，并且需要时 i7 CPU 8G 内存 以及 固态硬盘。&emsp;&emsp;显卡就无所谓了，反正不打算打游戏，渲染都是吃 CPU 的（当时还不认识GPU渲染）&emsp;&emsp;但是这个价位的确也没有什么选择了，当时还看中了 麦本本 。&emsp;&emsp;但是 CPU 是低压型的轻薄本，最后还是不要了。 &emsp;&emsp;后来不得已预算提升到 4000 之后 上了神船。&emsp;&emsp;神舟总算是 i7 的移动性 CPU 了，然而是 4代老U&emsp;&emsp;没办法，当时急着想要用起来，于是就剁手了 &emsp;&emsp;这电脑一直用到现在，除了屏幕坏了一次，换个屏幕花了 700 多&emsp;&emsp;还有就是加装了一个固体硬盘，目前为止都用得挺好的。 &emsp;&emsp;国庆之后，工作室重新调整了方向开始渐渐筹备动画比赛的一些东西&emsp;&emsp;当时立明给了我一个故事构思，当时是涉及到一些烟雾效果之类的特效。&emsp;&emsp;于是那段时间上传了很多 Maya 特效相关的教程，原本打算按制作需求去看的（结果并没有） &emsp;&emsp;由于小烨闹僵了，虽然人在工作室，但是他基本在做作业之类的东西，有时候有问题我也给他一些指导。&emsp;&emsp;当时比赛是《创维杯》，要结合创维电视这个品牌去做，我们就看了很多国外动画片广告。&emsp;&emsp;希望从中获取一些制作的灵感。 &emsp;&emsp;这段时间工作室的气氛缓和了不少，但是也沧桑了很多，聪哥也是经常不露脸，整个工作室也就剩下我们几个骨干了。&emsp;&emsp;有种风萧萧兮易水寒的萧条之感。 &emsp;&emsp;那个时候聪哥已经毕业了，工作室的归属表面上立明负责的。&emsp;&emsp;大概国庆之后一周吧，立明就给我们传达了工作室的噩耗，我们要解散了(ಥ_ಥ) &emsp;&emsp;当时没有人问为什么要解散，可能大家都心知肚明吧，聪哥手下的人这么多，终究还是散的散。。。&emsp;&emsp;我当时猜测是去年的比赛的成绩不理想，毕竟工作室的场地必须有相应的奖项撑场面才可以。&emsp;&emsp;后来听创业老师的说法，似乎是聪哥主动解散了，不过当时工作室都弄成这样，也是令人唏嘘的。 &emsp;&emsp;知道这个消息之后，大家就再也没有动力去做什么比赛相关的事情了，工作室也经常没人来，空荡荡的。&emsp;&emsp;也是那个时候开始我开始将注意力转移到了专业的学习上。&emsp;&emsp;现在回想起来，仿佛都是那么凑巧，我总能在这种不知所措的时候找到新的方向。 Flash 学习 | 寻找新工作室 &emsp;&emsp;当时我们的课程是学习 Flash （现在 Adobe 改名为 Animate 了），利用 ActionScript 去开发 Flash 小游戏。&emsp;&emsp;是的大学的教育就是这么落后， Flash 播放器都快要被 H5 替代了，然而我们依然还是学这个。&emsp;&emsp;所以当时很多同学都很抵触，我也不例外，但是我高中也的确玩过 Flash ，对 Flash 还是有一点感情的。 &emsp;&emsp;制作游戏终究还是绕不开编程的，当时暑假就应经体验过 Mel 编程的魅力，说实话 ActionScript 反而让我更加期待。&emsp;&emsp;于是那会我又开始找 Flash 的教程，也看了很多教程。 &emsp;&emsp;当时首当其冲的教程果然还是入门教程，而且上面的是入门教程重新学习了 Flash&emsp;&emsp;我高中的时候也是看翼虎网上面的教程，我记得那个是 Lynda 出品的教程，这一次则是 Pluralsight 出品&emsp;&emsp;至于 ActionScript 还真的找不到新的教程，都是一些很老的教程，为了能够应付学校布置的作业，硬骨头还是要啃的。 &emsp;&emsp;这套教程是 入门教程 ，的确很过时了，不过应付作业还是绰绰有余了，而且比老师讲得好多了(￣ェ￣;)&emsp;&emsp;虽然教我们 Flash 的老师也不差，就是上课讲解这种都效率很低而已，看教程还可以加个速，上课就想睡觉(:з」∠) &emsp;&emsp;后面进阶的部分就是依靠这个教程的的几个案例，当时我通过这个教程帮舍友完成了大作业呢~&emsp;&emsp;而且我当时开发 Flash 也算是上头了，就像 Mel 一样开发起劲了之后，就一直想要做得更好。&emsp;&emsp;当时给自己设立要做一个塔防游戏的目标，本来想依靠坦克炮塔案例去研究可以可以自己实现的，后来时间不够就去 youtube 上找了一个 Flash 的塔防制作的教程做大作业了。&emsp;&emsp;当时大作业其实并没有做完，可惜，这些坑估计永远也不会去填了。 &emsp;&emsp;可以参照视频 1m03s - 2m33s &emsp;&emsp;当时我做的第一个游戏是算术跑酷，我当时只是想着练练手，越做越复杂，总是自己给自己提了很多需求。&emsp;&emsp;其实最后的效果完全可以当做是大作业去交了，但是自己还是想完成塔防游戏，于是给自己挖了的个大坑（最后还填不上(:з」∠)） &emsp;&emsp;当时学习的时候还不知道怎么地接触到梦日记这款猎奇游戏，当时是看了一些游戏实况，感觉非常非常有意思，就是结局有点过分了。&emsp;&emsp;然后那个时候找到了这首梦日记的配乐 subconscious 非常好听洗脑&emsp;&emsp;当时算术跑酷的游戏配乐就用了这首曲子，那个时候独自一人在工作室开发Flash的时光也藏在这首曲子里面了。 &emsp;&emsp;总体而言，学习 ActionScript 并不是没有用的，一方面它进一步锻炼了编程语言的，而且也为我后面学习 JavaScript 做好了准备。&emsp;&emsp;有时候学习真的不应该过于功利，重要的是务实肯干，所有的付出不可能都是无用的，只不过在未来有可能体现的作用不大而已。 &emsp;&emsp;在知道工作室要撤场之后，我就开始寻找自己的新东家了，反正回宿舍是不可能回宿舍的了，只有找到新东家安家才能维持得了学习劲头这样子。&emsp;&emsp;其实我们东风路校区剩下的选择不多了，毕竟地方小，工作室也少。&emsp;&emsp;当时我知道我们专业的就是韦老师旗下的 iseven 工作室，我当时国庆之后差不多一周才去找师兄，他们国庆前就已经发招新通知了。&emsp;&emsp;好在我还是上了最后的末班车，还有机会做测试题。&emsp;&emsp;我记得当时工作室的测试题有两道，一个是用任意语言做一个石头剪刀布的程序，另一个是做一个游戏的策划。&emsp;&emsp;当时我觉得游戏策划这个没啥难度，反正天马行空就可以了(:з」∠)&emsp;&emsp;至于石头剪刀布，我那个时候刚好学 Flash ，就顺手用 Flash 做了这个程序，当时演示的时候好像还有 BUG 的说(/ω＼)&emsp;&emsp;总而言之，自己的竞争力还算是很强的，毕竟经过了 1 年的工作室历练。 &emsp;&emsp;最后 iseven 工作室的大佬云龙师兄单独留下我，和我聊，希望我可以去 浩宏 的工作室，当时他们工作室比较缺人。&emsp;&emsp;浩宏也是我们专业同一届的同学，我当时就震惊了，大二就居然可以组建自己的的工作室，毕竟这里可是东风路不像大学城那么容易。&emsp;&emsp;于是就去浩宏的工作室找他聊，去到之后发现他们也很不容易的，硕大的工作室只剩下两台电脑。 &emsp;&emsp;跟他们聊过之后才知道他们也很坎坷。&emsp;&emsp;大一的时候有一个 覃大佬 是开新媒体艺术效果公司的。&emsp;&emsp;他来学校希望和院长合作开一个新媒体艺术的工作坊，当时开了讲座，只是我们专业没有被邀请参加。&emsp;&emsp;当时是数字媒体艺术专业很多人去了，至于浩宏怎么进去的，那就多亏了云龙师兄的通风报信了。&emsp;&emsp;当时他们工作坊找了10几个人，然后大佬教他们学习 vvvv 图形化编程语言 做新媒体效果。&emsp;&emsp;他们的工作很杂，不仅要会编程还要搞 arduino 这种嵌入式开发，搞电机。这东西在大学城才好搞吧-_-||&emsp;&emsp;工作坊中 培国 和 浩宏 就脱颖而出了。&emsp;&emsp;但是这种性质的工作室都有一个很严重的通病，学生都是目光短浅且逐利的，仅仅提供学习的场地根本就不够。&emsp;&emsp;最起码也得像社团一样可以解决一些东西才行的，比如说实践时数、综测加分、拉赞助有钱分。&emsp;&emsp;当时暑假的时候，覃大佬只能提供两个实习的机会，所以 培国 和 另一个女生上车了，其他人就什么都没有。&emsp;&emsp;所以最后他们工作坊也和我们工作室一样分崩离析了。&emsp;&emsp;一个暑假过去之后，很多人都搬走了，于是培国和浩宏就希望可以将这个场地用起来，组件成工作室开发游戏。 &emsp;&emsp;所以他们当时的确很缺人，我也义不容辞加入了。&emsp;&emsp;后来快到11月份的时候，聪哥的工作室才正式撤场，于是我也是那个时候入驻了浩宏的工作室。 新工作室 | CG交流会 &emsp;&emsp;浩宏的工作室不在机电厂而在5号楼，这一点的好处就是晚上没有保安来赶人。&emsp;&emsp;缺点就是弄得太晚了有可能保安把楼下的门给关了，出不去(:з」∠)。&emsp;&emsp;后来我们还真的遇上了一次，还想着在工作室通宵(^o^)/~，结果培国的舍友过于担心通知了保安给我们解围了。 &emsp;&emsp;当时培国游说了他们专业很多人进了工作室。&emsp;&emsp;新的工作室和以前聪哥的工作室最大的不同就在于成员都是同一届的人。&emsp;&emsp;大家都比较平等，但是管理起其实是很费力的，如果有人不干活我们要不就得罪人要不就只能放任不管。&emsp;&emsp;而我们的情况更多的是偏向于后者，管理的松散，以至于晚上经常组队打王者荣耀。&emsp;&emsp;我是游离在他们之外的存在(:з」∠) &emsp;&emsp;晚上有时候还吵吵闹闹的，甚至会外放音乐，整个工作室充满了快活的气氛。 &emsp;&emsp;那会大概11份有多的时候，忽然在群里收到有扎根在影视行业的仲予师兄回来开CG交流会。&emsp;&emsp;我真的是太激动了，感觉工作室虽然散了，但是放下之后反而有更加广阔的机会。&emsp;&emsp;当时做了师兄安排的调查问卷，终于可以接触业内人士了，太兴奋太激动。 &emsp;&emsp;当时交流会上我又对自己高中的作品进行鞭尸(•̀ω•́),然后依旧收到热烈的追捧(:з」∠)&emsp;&emsp;那个时候我自己是挺尴尬的，感觉大学努力了一年反而没有能拿得出手的作品(ಥ_ಥ) &emsp;&emsp;那会交流会之后，仲予师兄也打算组建一个工作室。&emsp;&emsp;但是奈何东风路真的很无奈，无法申请到场地，因此就只能弄一个空壳工作室。&emsp;&emsp;同样这种学习性质的工作室也踩了留不住人的雷，没有办法，万事开头难。&emsp;&emsp;这些问题我当时的确也帮不上什么忙。 &emsp;&emsp;当时有个师弟叫做嘉杰，因为我们两个是老乡，因此刚开学的时候就和我套近乎，我也安排了Maya相关的东西让他学习。&emsp;&emsp;不过后面我忙成狗了，所以接触也少了，我知道他对CG相关的东西也挺感兴趣的，于是就一起参加了CG交流会。&emsp;&emsp;现在也是这个CG工作室的骨干了。 &emsp;&emsp;仲予师兄是特效师，使用 Houdini 软件为主，那个时候我还没有使用这个软件，所有的认识都很模糊。&emsp;&emsp;但是在认识仲予之前，我已经打算往特效的方向靠拢，我当时还不知道有 TD 这种岗位，但是所以是以 Maya 特效的方向进军的。&emsp;&emsp;为什么往特效模块发展，因为除了特效之外，我其他的模块都切切实实接触过了(σﾟ∀ﾟ)σ &emsp;&emsp;好在我在最对的时间认识了最对的人，通过仲予我了解到行业上特效已经逐渐被 Houdini 制霸了。&emsp;&emsp;因为 Houdini 节点式操作做特效真的效率贼高，就连曾经的王者 Max 也经不起 Houdini 的吊打。&emsp;&emsp;后面进了 仲予的线上工作室之后 所有人都开始来学 Houdini 了。 &emsp;&emsp;我那个时候其实还没有正式开始学，因为还有很多其他的事情干扰着我，但是这个东西就像种下了种子，不是不做，只是时候未到。&emsp;&emsp;其实主要原因还是和聪哥有关，但是不想让他知道我有学Houdini，因此一直拖着不学。 南沙项目 &emsp;&emsp;经过交流会之后，聪哥还是迫不得已联系上了我。&emsp;&emsp;因为拖了近一个月之后，9月份做的 南沙模型 出问题了。&emsp;&emsp;要我去对接解决问题。&emsp;&emsp;可能很多人会觉得这TM不是坑爹吗▄█▀█●&emsp;&emsp;不过我还是希望善始善终吧，说不定最后做完还能分点项目报酬。&emsp;&emsp;就这样我毅然决然地踏上自己的不归路(இдஇ`) &emsp;&emsp;因为要将整个模型放到Unity引擎上面，加上和我们合作开发的公司垃圾得一批。&emsp;&emsp;经常向我们模型这边反馈各种性能问题，聪哥让我将所有的模型都烘焙出贴图。&emsp;&emsp;于是我当时就去研究 Arnold 的烘焙了，当时要将 AO 贴图、光线贴图什么的统统烘焙出来。&emsp;&emsp;也看了不少教程来解决这个问题。 &emsp;&emsp;最后还是第二个教程使用 turtle 插件的方法烘焙AO比较管用。&emsp;&emsp;另外我发现 Arnold 可以烘焙渲染效果的贴图，只要UV不重叠，都可以解决，反正有万能的自动拆分 UV 功能&emsp;&emsp;虽然拆分UV之后会很碎，但是只要不重叠就可以满足了。&emsp;&emsp;于是当时给很多个模型进行贴图烘焙的操作，虽然后面几乎就是重复劳动，我还是尽了我最大的努力来完善模型的显示效果。 &emsp;&emsp;所以一开始的模型效果是很简单，后面做烘焙耗费了大量的时间。&emsp;&emsp;做完这些操作之后还要在PS上给颜色贴图贴上 AO 图层。&emsp;&emsp;这个我给他们弄得差不多了之后，那边的Unity程序员又说不会做地板的反光效果。&emsp;&emsp;然后我TM这个Unity门外汉，自己摸索Unity自带材质库，将自带的水材质反射效果给到了地板上，调节一些参数就做出来了。&emsp;&emsp;好吧，可能他们就是个 C# 程序员，总之能解决就好。&emsp;&emsp;后面到政府那边上机测试的时候也遇到了很多问题，真的不知道他们的程序怎么写，之前群聊上经常发什么数据库接口的对接问题，幸好我不是对接这个项目的▄█▀█● &emsp;&emsp;再到后面场景需要添加一个服务生，于是又到网上下载模型，然后对模型进行各种魔改。&emsp;&emsp;好在服务生只需要一个鞠躬的动画，否则这个魔改的模型真的做不出复杂的动作(⊙o⊙)…&emsp;&emsp;这个东西折腾了我一两天之后，上机测试反馈说模型太暗了(:з」∠)&emsp;&emsp;然后我们这边怎么调整都没用，因为主要原因是 Unity 场景上缺少相关的灯光补充。&emsp;&emsp;后面不得已，只好我们直接去到他们公司上门解决问题。&emsp;&emsp;但是加了灯光之后，性能就不行了，这TM不是冲突矛盾的吗？&emsp;&emsp;好在我想到 Maya 有 flat shade 模式，就是可以忽略灯光影响，直接反映贴图的颜色。 &emsp;&emsp;后面果真是用了Unity不接受灯光的材质解决问题的。&emsp;&emsp;也算是在这种特定的需求场景下学到了不少东西吧。 &emsp;&emsp;这个项目我大概12月之后就不需要我怎么弄了，但是后续的程序问题一直改，直到过年了才草草完结。&emsp;&emsp;当时做完项目快过年了，收到了800元的报酬 (ง •_•)ง 前端学习 | WebGL &emsp;&emsp;在搬到浩宏的工作室之后逐渐就开始有网页制作的课程。&emsp;&emsp;教我们的老师是真的不行，一直照本宣科，还说js很难选学，然后用 Dreamweaver CS5 教我们写网页&emsp;&emsp;不用任何框架以及额外的脚本，写出来的东西基本上就是20年前的网页，我的天(:з」∠)&emsp;&emsp;而且老师本人对前端的发展一无所知，操作还各种慢吞吞的，绵羊音简直是安眠曲一样。&emsp;&emsp;后面我还是看 Lynda 的教程的来学习前端了。 &emsp;&emsp;额外插入这个教程，考虑到自己要更加全面地学习和了解编程这个东西，于是我还靠晚上的时间翻译了这一套的 Simon 的编程入门教程 &emsp;&emsp;这个教程对我学习编程帮助极大，因为我们专业是没有计算机原理之类的课程的，毕竟不是计算机领域的专业。&emsp;&emsp;而且这个教程是完全基于对任何语言零基础的讲解，是非常好的讲解教程，也帮助我认识了很多术语。 &emsp;&emsp;后面聪哥也有指导我前端网页的开发，差不多是那个时候第一次认识了 JQuery 插件吧。&emsp;&emsp;当时大作业，聪哥是给我一手操办了的，但是我还是碍于影响不好，自己又开发了一个额外的。&emsp;&emsp;真的当时做的效果贼差，简直难以想象这也会这个时代前端程序员做出来的东西(:з」∠) &emsp;&emsp;考虑到我有课程学习前端，聪哥想要让我学习网页相关的知识，给他研究WebGL技术。&emsp;&emsp;还安排了一些极客学院的课程让我循序渐进地学习。 &emsp;&emsp;当时聪哥还在创业，公司地点在羊城创意园那边，我周末有空就过去拜访。&emsp;&emsp;其实说是公司地点，倒不如说寄居篱下，别的公司提供创业场地类似创业孵化器一样的地方。&emsp;&emsp;不过有落脚地也不算太差，就是离学校有点远。 &emsp;&emsp;当时有手提电脑就是方便，经常就是去到聪哥那边学习，用 Dreamweaver CC 2017 开发网页。&emsp;&emsp;后来在接近12月份，聪哥似乎接触到了什么，让我去研究 WebGL 技术。&emsp;&emsp;我当时去搜索了 Pluralsight 和 Lynda 上的教程，发现教程真的不多。&emsp;&emsp;而且两个教程都指向了一个JS框架 Three.js WebGL and Three.js FundamentalsLearning 3D Graphics on the Web with Three.js &emsp;&emsp;当时因为搞到了 Pluralsight 和 Lynda 线上免费看教程的方法，因此没有把教程搬运到B站&emsp;&emsp;Pluralsight的教程有点老了，Lynda在当时还是刚出不就的，于是我就照着两个教程学着玩 Three.js&emsp;&emsp;因为当时学过 ActionScript 两者其实都是在 ECAMscript 规范之下的，所以很多写法都是高度相似的&emsp;&emsp;当时前端三大框架已经有了，但是还没有全面向市场铺开，我当时学的JS还是以 ES5 规范为主。&emsp;&emsp;包括后面我去研究 Three.js 下面的很多脚本都是 ES5 规范下的类实现的而不是使用 class 关键字。 &emsp;&emsp;当时聪哥吐槽我，要我像百度编辑器一样 new 一个实例，封装出一个自己的脚本。&emsp;&emsp;那个时候有种神奇的逆反心理，觉得聪哥的技术也不咋地，既然吐槽我做不到，我偏要做出来的心情。&emsp;&emsp;于是我那个时候就一直为这个目标努力，研究 Three.js 很多不同的脚本（Three.js 很多东西就是 new 实例出来的）&emsp;&emsp;最开始我写的封装还是以 function 的形式面向过程去调用的。&emsp;&emsp;后面在进入寒假还没到春节的时间里，我听从聪哥的安排，直接住到他家里学习 Three.js 去了。&emsp;&emsp;当时它给我提供就是包吃包住包学习而已，当时虽然没给我什么压力，也的确在那样的环境下铆足了劲去学习。 &emsp;&emsp;当时开始学习 JQuery 学习自己封装 Three.js ，简化模型导入、生成控制器等等的操作。&emsp;&emsp;聪哥当时还给我介绍了极客学院的一些课程，从上面学习到了一些 设计模式(design pattern) 的知识。&emsp;&emsp;后面也去看了 Pluralsight 上一些关于设计模式的教程，不过这东西当时还不是特别懂。&emsp;&emsp;最后我的确做好了 Three.js 的封装，而且还基于 docsify.js 将自己的封装脚本写成了一个 mini 的 API 文档。&emsp;&emsp;当时的一些劳动成果可以参考我 Three.js 学习之路相关的博客文章 &emsp;&emsp;当时工作室解散之后还和聪哥联系的就只有我、立明和小瑞了。&emsp;&emsp;立明在春节前的时间里也一起住到了聪哥家里，开始的时候还每天早上早起然后徒步从三溪走到羊城创意园，晚上也是徒步回家。&emsp;&emsp;那个时候走一趟大概要1个小时。 &emsp;&emsp;那会聪哥也没有给我安排外包项目，给足了时间让我去学习，立明则负责了一些设计类的工作还有文案。&emsp;&emsp;因为这段时间的积累，也为后面大二下学期打比赛最好了充足的技术积累。 聪哥经历回顾 &emsp;&emsp;后来我跟回聪哥学习之后，才逐渐了解到当时工作室解散的一些情况。&emsp;&emsp;其实从工作室这么长久的人员流动情况来看，就知道聪哥是有很大的责任的，但有些时候又是无可奈何的，创业从来就不是那么简单的。&emsp;&emsp;没有利益，只有理想是很难持久的。&emsp;&emsp;我也算是比较呆的人了，大学只想要一个安静的学习环境学习自己热爱的东西，因此跟着聪哥能学到东西我也不在意没有利益。&emsp;&emsp;但是真的有太多人坚持不下去了，知识如果无法变现，在大多数眼中就是无用的，甚至连学习的动力都没有。&emsp;&emsp;因此精明的人都会离开我们，加上聪哥经常给我们画大饼（创业者惯用伎俩(:з」∠)），然后又无法兑现，的确会让人不爽。 &emsp;&emsp;后来我跟聪哥走得近，他也和我说了不少当时网页组的事情，那段时间估计算是聪哥的人生低谷了。&emsp;&emsp;17年3、4月份的时候，网页组宿舍已经学习网站制作快半年了，当时聪哥安排好了前后端分工学习的，因此制作一个网站不成问题。&emsp;&emsp;然后就接了单去做，只是个小项目，报酬大概也就三、四千元，做之前聪哥肯定会和他们高谈阔论，做完有钱分云云。&emsp;&emsp;结果项目有坑，一直做不好吧，具体我也没有去找网页组那边打听，不太清楚。&emsp;&emsp;结果坑坑洼洼到了5月份才弄好，弄好之后可能甲方也不满意什么的，当初承诺的利益分配兑现不了。&emsp;&emsp;这个情况和我9、10月份做外包的时候差不多，那个时候的怒气也是挺盛的。 &emsp;&emsp;所以后来网页组就集体离开了，然而大坑来了，当时聪哥对网页组的矛盾完全不知情的。&emsp;&emsp;为此还给他们准备下一个项目，当时他借了国际的外包，做英文网站。&emsp;&emsp;当时分工是加上网页组和他7个人完成的，然而签完合同之后，网页组就集体离开了。&emsp;&emsp;聪哥当时也没有挽留，可能他也知道自己又不对的地方，加上我们都还是大一，也不能强人所难。&emsp;&emsp;于是聪哥就默默啃了这个项目，一个人干了7个人的活。&emsp;&emsp;结果可想而知，从6、7月份一直做到10月份。&emsp;&emsp;他给我们接外包做的时候，他自己也头大得不行，因为工作量太大，甲方要求的修改迟迟不能兑现。&emsp;&emsp;最后聪哥是无法在预定的工期完成合同构成违约了，甲方直接把律师函都寄到他家里来，他女朋友看到都哭了。&emsp;&emsp;那个时候刚好是我们外包搞不定，不断闹事的时候，哎，这些聪哥当时也没有和我们说，只是默默承受了。&emsp;&emsp;创业的艰辛，人员的流动，真的是不容易的。 &emsp;&emsp;后来聪哥是直接跑到上海去，托了一些关系摆平了官司，钱没赚到反而赔了。&emsp;&emsp;当然这些情况都是后来聪哥告诉我的，也算是一面之词，可能并不客观。 &emsp;&emsp;也算是创业必须经历的一些磨难吧，不过聪哥一直有自己的目标，有着自己的希望。&emsp;&emsp;给我们画了很多大饼，尽管最后都因为各种原因没有实现，但是在这个世道下创业，能坚持下来就很不容易了。&emsp;&emsp;后来我也帮助他很多，也算是对他栽培的一种报答吧。 18年春节 &amp; 开学 &emsp;&emsp;当时一直想好好学习 Houdini ，已经通过多个渠道知道 Houdini 的强悍之处。&emsp;&emsp;然而当时在聪哥家里，不敢去学，怕遇到做翻译时候的情况被他打压。&emsp;&emsp;所以我春节回家了，才终于感觉自己解放了出来(:з」∠)，（其实住在他家也没有那么不堪） &emsp;&emsp;那个时候我看到师弟的 Houdini 也已经小有成就了，自己感觉落后了很多。&emsp;&emsp;于是回家之后就开始奋起直追。 &emsp;&emsp;于是那个时候又在B站上传了一堆的Houdini教程。&emsp;&emsp;当时做特效的仲予师兄也提供了网盘给我们，并且还给我们安排了学习路线，让我们少走很多弯路。&emsp;&emsp;然而前人走的路并不是所有人都能接受的，我自己还是更加倾向于自己找教程，自己去学习。&emsp;&emsp;有时候感觉自己也是带着叛逆心理的，别人走的路有点不信邪，偏要给自己安排自己认可的方向，&emsp;&emsp;于是那个时候我上传Lynda的教程，Pluralsight的Houdini学习路线，资格开辟了一个学习的方向。 &emsp;&emsp;不过到后来看到师弟的一些进步和成果，还是按照师兄给的老教程看了一遍，跟着做出来。&emsp;&emsp;这些成果也在博客的 Houdini学习之路上有记录。&emsp;&emsp;那个时候虽然是春节，但是自己特别有干劲，进度赶上了不少。 &emsp;&emsp;我还记得的那个时候三维网页已经有了一点点的成果。&emsp;&emsp;过年的时候还拿着这个东西拜年的时候给亲戚看效果。&emsp;&emsp;当然其实我也没有懂行的亲戚，也就变成了自我满足而已╮(╯▽╰)╭ &emsp;&emsp;后来就开学了，开学之后，聪哥开始弄创业比赛的事情，没有给太多的活给我干。&emsp;&emsp;这段时间我主要给自己安排工作，而且那时候仲予师兄开始给我们开直播，讲解 Houdini 了&emsp;&emsp;然而他的直播都是讲最前沿的，当时我进度落了很多，根本就听不懂。。。&emsp;&emsp;没办法，我看着自己有空，于是就开始疯狂肝Houdini教程。&emsp;&emsp;那个时候天天去 704工作坊 学习，也和认识了不少数媒艺术的同学。 &emsp;&emsp;也恰好是那段时间，704工作坊要搞游戏，学院要他们承办一个新媒体艺术展。&emsp;&emsp;于是我就努力帮忙了，我主要就是基于之前使用 ADV的经验给他们做角色的绑定和一些简单的动画。&emsp;&emsp;他们艺术生出模型、出原画，然后浩宏负责整一个游戏程序。&emsp;&emsp;我当时有帮忙，不过最多也是打杂，帮他们通宵布置了一下艺术展。&emsp;&emsp;那个时候我的重心全部在 Houdini 的破碎教程上。 &emsp;&emsp;当时之所以拼命学习破碎，主要是因为仲予师兄在公司主要干破碎的特效。&emsp;&emsp;精通于破碎效果的制作，可以给我们给出很有用的建议。&emsp;&emsp;当时我也的确做出了一点小成果，等到了师兄的夸赞。 挑战杯比赛 &emsp;&emsp;开学没多久之后，聪哥又一次组件团队开始打创业比赛。&emsp;&emsp;这一次我们带着三维网页的技术而来，作为一个尚未完全开发的领域，还存在很多可能性。&emsp;&emsp;这种东西非常有利于我们去打比赛。&emsp;&emsp;创业的老师也非常支持我们，看到我们没有足够的打杂人手，于是直接将创协的小干安排给我们打比赛。&emsp;&emsp;整个东西由立明和小瑞负责统筹，而我只是负责技术的部分。 &emsp;&emsp;打比赛前期，我作为技术的负责人其实是非常闲的，这也是为什么我可以抽出这么多时间去学习 Houdini&emsp;&emsp;前期的工作很多，准备策划书、搜集资料，路演ppt，上台演讲等等。&emsp;&emsp;聪哥可能也知道我不太适合做这些东西，所以也就没有怎么安排我的工作。 &emsp;&emsp;就这样我们又重新组建了一个小团队开始备战挑战杯。&emsp;&emsp;挑战杯非常重要的一站就是校赛共创杯，基本上只有在这个舞台上充分得到肯定，才有机会推送到省赛。&emsp;&emsp;然而到了三月份的校赛的时候，立明却炸了。 &emsp;&emsp;那个时候，立明已经大三快要大四了。&emsp;&emsp;创协的小干大都是大一的同学，他们很多都不会，于是立明一个人承担了很多资料准备以及修改的工作。&emsp;&emsp;那个时候创协的明霞老师也非常负责，每周都会给我们开会，跟进我们的各个资料的进度。&emsp;&emsp;我经常就是过去开会旁听，其实也没有出多少力。 &emsp;&emsp;后来立明开始不对劲的时候就发现，很多上周提到的问题，压根就没有任何改进。&emsp;&emsp;直到到了共创杯的比赛上，立明也没有将我们的项目讲好，校赛只得到了优胜奖~ &emsp;&emsp;每天都累死累活，干着自己不喜欢的事情，最后还没有好成绩，我猜测这是压垮立明最后的力量。&emsp;&emsp;校赛之后，立明就不断逃避这个事情，不接聪哥的电话，比赛也是毫无进度。&emsp;&emsp;那时真的是实在没办法，我虽然是做技术的，但是我也的确参与到了比赛里面，所以我就挺身而出，担当了我该做的东西。&emsp;&emsp;因为演讲不行，创业老师又给我们找来了外援，大三的伟淇师兄和志华师姐。&emsp;&emsp;志华师姐的演讲能力是真的牛逼，而且思维特别清晰，非常敏锐地抓住老师的需求，通过5w分析项目，真的是无敌的救援投手。&emsp;&emsp;伟淇师兄就能力稍弱一些，但是在那个时候也是很不错的人选了。&emsp;&emsp;于是我们和大一的师弟师妹一起，开始改ppt，搜集资料，准备演讲。 &emsp;&emsp;原本校赛不过，我们就没有希望参加省赛了。&emsp;&emsp;但是我们学院就我们一支团队（艺设学院不受重视，常年都没有人有打创业比赛的热情），老师和聪哥尽了最大的努力&emsp;&emsp;成功将我们团队报送到省赛上去，省赛的初选只是过滤策划书，我们的策划书立明弄了几十页，内容还是相当充实的。&emsp;&emsp;因此最后我们还是轻松通过了省赛的预赛环节。 &emsp;&emsp;立明的退出对于我们所有人都是一个打击，那个时候小瑞师姐也大四了，也无暇顾及太多工作。&emsp;&emsp;我那个时候刚好也差不多解决了艺术展的事情，浩宏的704工作室逐渐变得形同散沙，我就全身心地投入到比赛的准备中来。&emsp;&emsp;我觉得主要还是立明的退出刺激到我了吧，我不想又让辛辛苦苦搞出来的东西给弄没了。&emsp;&emsp;于是我给大家讲解 WebGL 技术，做ppt动画剖析我们比赛所说的三维展示平台是怎样的一个东西。 &emsp;&emsp;后来聪哥有找我做相关的三维网页项目，才发现聪哥所有的认识都来自以为元老级的嘉恒师兄那里了解到的。&emsp;&emsp;这个师兄是做三维扫描的，也是处于创业阶段，的确网上也有了一些三维的展示平台，他们就是通过那些平台将扫描的模型放到网上的。&emsp;&emsp;而聪哥因为有制作网站的能力，于是嘉恒就给聪哥发了个外包，给他们公司做了简单的官网。&emsp;&emsp;后来嘉恒也有安排让我辅助开发一个三维网页编辑器，当时还谈妥做完有5000元。&emsp;&emsp;后来我就魔改了开源的 Three.js 的编辑器，结合聪哥的后端只能保存出可以外部浏览的网页页面。&emsp;&emsp;可惜最后不知道聪哥怎么交接的，就不了了之了。 &emsp;&emsp;于是经过这些琐琐碎碎的事情之后，我开始全力投入到比赛的准备中来。&emsp;&emsp;当时我们是艺设学院的唯一代表队，广工也非常重视这些创业比赛。&emsp;&emsp;在大学城有开很多相关的培训和讲座，我们只好屁颠屁颠地坐车赶往大学城参加。&emsp;&emsp;说实话那个时候还挺累的，好在课程没有大一那么多，自由的时间还是挺多的。&emsp;&emsp;志华师姐真的在那会帮了我很大的忙，很多东西都是她给我们做好总结归纳，凝练优化我们的问题。 &emsp;&emsp;本来我只是负责技术，大体也就是做ppt、做后勤辅助的。&emsp;&emsp;但是大学城请来的创业大佬希望我们能更加生动地讲讲我们创业的故事。&emsp;&emsp;而熟悉这个故事的就只有我和聪哥，其他曾经的元老都因为各种原因离开了。&emsp;&emsp;志华和伟淇也都不太熟悉我们当年在学校工作室里的情况。&emsp;&emsp;于是我就主动承担起了这一责任，我也的确跟着聪哥有过矛盾也有过合作。&emsp;&emsp;当时我们内部试了试让我上台演讲，最后下来效果还是可以的，因此我也就成了上台演讲的人选之一。 &emsp;&emsp;说实在的，作为技术宅，其实我不太擅长上台演讲的，初中的时候就特别特别害怕上台。&emsp;&emsp;知道高中为了鼓起勇气参加科技节，我才开始不断尝试上台。&emsp;&emsp;大一的时候参加思修课、做团支书这些都是我锻炼上台经验的地方，不过最后我上台演讲的能力也就一般般~&emsp;&emsp;不过好在省赛我们准备的时间很长，学院给了充足的时间让我们一遍又一遍的演练。&emsp;&emsp;而且还临时给我们提供了场地专门用于比赛的准备。 &emsp;&emsp;那个时候我们小组的人待在5号楼的206，一起点奶茶喝，一起准备演讲。&emsp;&emsp;我那个时候准备的西装和志华、伟淇的都有些不一样，这个问题拖了一段时间，最后创业的老师给我们公费报销买服装，人生第一次买了上千元的西装(:з」∠)&emsp;&emsp;为了打好比赛，学校还专门安排了礼仪老师培训我们上台的仪容，这其中的花销也由学院承担了。&emsp;&emsp;可以说那会学校对我们额外的照顾，因为我们是近几年来最有希望冲击国赛的院队了。 &emsp;&emsp;我还清楚的记得比赛前一天要去华工参加彩排，当天早上刚好我又考试。&emsp;&emsp;为了节省时间，我直接穿着正装去考试了，变成了全场瞩目的焦点(:з」∠) &emsp;&emsp;比赛当天，我们上台的时候很惊讶遇到的两个评委是我们认识的。&emsp;&emsp;我们的发挥也不错，并没有给人留下什么坏毛病。&emsp;&emsp;然而后来颁奖的时候，我们却只得到了省赛银奖，与国赛失之交臂。。。 &emsp;&emsp;这对我们来说是一个巨大的打击。&emsp;&emsp;后来我自己复盘这次比赛的演讲，我发现自己作为技术大佬犯了最致命的错误。&emsp;&emsp;当时评委问我们的技术是怎么来的，我当时直白的说是借助了谷歌大厂的开源技术，基于 WebGL 开发的。&emsp;&emsp;我真的是太耿直了，我们核心竞争力就是技术层面，然而直接说开源，也就把我们技术上的成绩全部抹杀了。&emsp;&emsp;我觉得最后没有通过这个占了主要的原因，这个锅我要承担很大的一部分。&emsp;&emsp;评委都是不懂技术的，所以这种比赛要会吹，我TM老实被欺负了。。。 &emsp;&emsp;有时候人生就是这样，差之毫厘，失之千里。&emsp;&emsp;那个时候对我来说机会已经出现在眼前了，只可惜我没有抓住而已。 工作室新场地 | 数据结构寻路系统 &emsp;&emsp;比赛结束之后，学校重新给我们工作室安排了场地，场地刚好是以前工作室的隔。&emsp;&emsp;于是我就成了拥有两个工作室场地的奇葩存在了。（加上仲予师兄的特效工作室，我那个时候有三个工作室！）&emsp;&emsp;比赛结束之后，团队就又开始散了，只留下一地鸡毛。&emsp;&emsp;场地有了，之前参加比赛的一些骨干成员可以入驻到工作室，工作、学习了。&emsp;&emsp;然而那个时候场地刚下来，又临近期末了，没有什么人来工作室。 &emsp;&emsp;我那个时候也要肝两个课程的大作业，一个是数据结构、一个是动画技术&emsp;&emsp;我想着自己闲下来，就打算用心把大作业做了。&emsp;&emsp;其实我当时是打算敷衍数据结构，用心把动画技术的动画做好的。&emsp;&emsp;但是我又不甘心，只是做出一个命令行的寻路系统。 &emsp;&emsp;考虑到老师是用 C++ 做的，于是我就上Lynda找了个自认为靠谱的教程学习图形化界面做系统。&emsp;&emsp;当时找到的教程就是基于 C++ 的SFML框架做游戏。 C++ Game Programming &emsp;&emsp;当时看教程感觉和 Flash 有共同之处，还挺有意思的，SFML其实只是基于 OpenGL 的封装。&emsp;&emsp;只可惜当时很傻，没有想到用 Qt 框架，结果就花了大量的时间去研究 SFML 框架去了。&emsp;&emsp;当时的一些心路历程后来我也写到了博客上。 数据结构-导航系统 &emsp;&emsp;当时类的认识还很浅，主要懂事通过一大堆的function将功能堆叠出来的。&emsp;&emsp;毕竟当时完全靠自己摸索，也是那个时候逐渐养成了Bing搜索的习惯，因为 SFML 框架在百度根本搜不出有用的东西。&emsp;&emsp;我也深刻知道这个框架到底有多小众。&emsp;&emsp;原本也没打算将老师安排的功能都尝试一一实现，当时还是认为只要实现图形化界面加寻路就够了。&emsp;&emsp;而且我当时还没有组队，完全一个人单干，没必要这么拼。 &emsp;&emsp;不过编程真的好似有一种魔力，随着一个又一个需求的解决，我自己又不断蹦出新的需求，想要实现和完成。&emsp;&emsp;因此包括仿数据库的读取的表格界面，输入框等等SFML都没有的组件，我通过自己的尝试，写了一堆奇奇怪怪的function实现了。&emsp;&emsp;当时我做输入框的时候差点就要放弃了，自己手动实现还要去弄全选功能、游标闪烁功能，我完全都不知道 Qt 框架这些都内置了。&emsp;&emsp;我也觉得这个异常复杂，当时还想着网上下载一个 C++ 组件库解决这个问题，但是结合SFML弄的库是没有的。&emsp;&emsp;自己也花了点时间想去弄个框架试试，结果那个框架搞了好一会都没有跑起来。&emsp;&emsp;于是我就放弃，还是踏踏实实地手写输入框去了。 &emsp;&emsp;这也就是为什么最后我写了几乎 4千行代码，中间还做了一些函数的封装来简化代码量。&emsp;&emsp;当然我必须承认，这些代码都写得很烂。。。 &emsp;&emsp;当时真的很自由，没有什么限制，完全按照自己的喜好去开发。&emsp;&emsp;包括一些额外的功能也添加进去了，什么VIP扫码支付、音乐控制等等的东西。&emsp;&emsp;那两个星期真的很投入,真的很痴迷于这种编程的状态。&emsp;&emsp;晚上想着无法解决的问题入睡，第二天早早地感到工作室，然后就是独自一人肝程序的日子。&emsp;&emsp;感觉经过这次的锻炼，更加坚定了我往编程方向走的意志。 Hexo 博客搭建 &emsp;&emsp;其实在这段时间有有个插曲，我特效的师兄说写博客对找工作非常有帮助。&emsp;&emsp;这个东西我在过年的时候就记在心上，但是一直没有怎么弄起来，后来不知道在哪里了解到了 Hexo 这个静态博客。&emsp;&emsp;感觉比起 CSDN 博客园 等等更加极客，当时也没想着要有多大流量。&emsp;&emsp;只是想着自己可以发一些东西上去就满足了，Hexo 这种静态博客可以自定义网站的所有部分。&emsp;&emsp;这个功能正是我想要的，不需要广告，可以使用 gittalk 添加评论功能等等。&emsp;&emsp;我当时3月份的时候搭建了一个 hexo 博客。后来因为没有坚持写，被我自己弃用了。&emsp;&emsp;知道5、6月份的时候，我还是觉得应该坚持把博客做起来。&emsp;&emsp;于是我又重新折腾了一个全新的 Hexo 博客。 &emsp;&emsp;这个新博客就是大家目前所看到的博客了。&emsp;&emsp;整一个博客的搭建过程以及一些自己添加的小功能都可以从 Hexo博客搭建历程 找到相关的文章。 &emsp;&emsp;自从搭建了博客之后，我后续做的事情其实都变得有迹可循了，透过博客完全可以看到那些时日我在做些什么东西。 三维扫描 | 暑假招新 &emsp;&emsp;快到暑假的时候，我已经空闲了许多。&emsp;&emsp;感觉我们专业的确是课少，考试也少，后面应付了大作业之后其实不存在什么问题了。&emsp;&emsp;于是聪哥给我安排了研究三维扫描相关的东西，这个就是嘉恒师兄做的东西。&emsp;&emsp;聪哥的意思其实就是希望我们另起炉灶，甚至超越之前的师兄，因为我们手上掌握了编程的核心技术。&emsp;&emsp;不过嘉恒师兄也不是盖的，它在aboutcg发过三维扫描的教程，在扫描领域也算是数一数二的大佬了。 &emsp;&emsp;于是我那段时间开始研究三维扫描的技术。师兄先是推荐了他在人人素材网上搜到的软件 3DF Zephyr&emsp;&emsp;不过经过我研究，我发现 photoscan 软件在业内用得比较多（听说最近改名为 metashape 了），教程也是做多的，最重要是有破解版(:з」∠)&emsp;&emsp;而另外还有著名的 reality capture ，以及 Autodesk 的 recap &emsp;&emsp;自动桌的操作是线上的，其他的软件也是教程太少了。所以我自己总结之后还是 photoscan 管用&emsp;&emsp;于是我看了 youtube 以及一些国外的教程，总结了这个软件的用法 &emsp;&emsp;后面经过我自己的一些亲身实践，最终完成了 Photogrammetry-学习之路 系列的文章 &emsp;&emsp;打完比赛之后，我们还准备了 互联网+ 的比赛。&emsp;&emsp;当时老师还给我们拉来了龙洞校区的演讲高手，只可惜后面我们的准备不了了之了&emsp;&emsp;因为有了新的场地，我和聪哥都希望能够招些人来帮忙做东西。&emsp;&emsp;我当时带着自己极大的私心，找了我们专业同届的一些同学进来。&emsp;&emsp;关于这档事，其实聪哥也没有什么意见，我也是出于好意，希望大家能够明确自己的目标和方向，进而一起学习。 &emsp;&emsp;另外为了配合我的三维扫描对模型的修复工作，聪哥又在动画专业里找了两个人帮忙。&emsp;&emsp;其中有一个人还挺强，踏实肯学，我挺喜欢和他一起学习的。 &emsp;&emsp;暑假那会，我们就在工作室附近找了很多小部件去测试三维扫描&emsp;&emsp;聪哥当时还花了大价钱给我们准备摄影棚以及转盘，当时我们认为将小物品放在转盘上，通过小型摄影棚的打光拍照是不错但又廉价的解决方案。&emsp;&emsp;我们看到国外一些大厂（后来我在华强看到的就是这样），他们是用铁笼上放满了摄像机，只需按一下快门，所有的摄像机都能拍照到需要的全方位图片。&emsp;&emsp;这个方案对于我们来说实在是太过昂贵了。。。 &emsp;&emsp;然而即便是这样的光照环境，我们实现三维扫描成功的案例并不多。&emsp;&emsp;真的非常好奇嘉恒师兄是怎么做到环境扫描的，我们连小物品的拍照都经常失败。&emsp;&emsp;失败的原因主要是图片的定位问题，不能拍太多的图片，信息冗余会让软件混乱，最后识别不出拍照的位置。&emsp;&emsp;当然拍太少也是绝对不行的，总之当时我们用了大量的电脑进行测试，最后的效果都不太尽人意。 雅塘村扶贫 数字博物馆 | 数字媒体技术网站 &emsp;&emsp;后来因为互联网+比赛的分赛，我们作为红色科技小分队被安排去雅塘村协助学校扶贫工作。&emsp;&emsp;聪哥最初的方案就是利用我们研究了一个月的三维扫描给博物馆做三维重现的工作。&emsp;&emsp;然而去到当地才发现各种意外频发，而且学校给的经费也严重不足。学校只有1千元经费。&emsp;&emsp;我们住宿+吃饭，只用了三天经费就透支了，所以我们取材的时间非常紧迫。&emsp;&emsp;然而博物馆那边有规定所有的文物都是不可以取出来的，根本就完成不了扫描的工作。 &emsp;&emsp;幸好我依稀记得高中的信息科技书本上有讲到过类似的图片拼接软件，至少我们可以做成全景类型的博物馆。&emsp;&emsp;拿着效果就和各种地图软件的全景效果差不多。&emsp;&emsp;至于技术方案，也多亏了丝绸之路实训的时候看到一个家荣同学的作品，通过他的作品我才能完成这个全景博物馆的搭建。 &emsp;&emsp;关于这次遇到的各种情况，其实我也全部写在了博客里面，可以参考 渔村苏维埃政府旧址-数字博物馆 &emsp;&emsp;经过一段时间的折腾之后，我们大概7月份末的时候就把整个网站做完了。&emsp;&emsp;我记得很清楚，当时还是用 Dreamweaver 写的，js代码大部分都嵌在 html 文件里面&emsp;&emsp;代码质量只能用可怕来形容 。。。 &emsp;&emsp;对了，当时取材的时候我和聪哥摊牌了。&emsp;&emsp;因为和聪哥共事，我一直隐藏了自己想要往特效方向发展的想法。&emsp;&emsp;我没有和他商量，而是主观臆测了他会认为这个不适合我。&emsp;&emsp;但是因为认识了仲予师兄，我还是希望自己能够好好学习特效，争取去华强方特大厂。&emsp;&emsp;但是在取材的那段时间里，我真的心情不太好，很多东西都是我一个人扛了。&emsp;&emsp;于是憋着憋着就和他说了，我说我不想再弄前端的东西了，我想要学习Houdini，学习特效的。&emsp;&emsp;不过结果是他还挺支持我的，他说后面会争取给我找项目来锻炼我的能力，还很担心我自学能否跟上学习进度。&emsp;&emsp;我也不敢透露自己还有仲予师兄这种后盾，只好敷衍了过去。&emsp;&emsp;毕竟聪哥是创业的，让他知道我一心二用，我害怕还是会出问题。 &emsp;&emsp;结果就让这种遮遮掩掩的心态一直延续到了我的大三(:з」∠) &emsp;&emsp;后来快到8月份的时候，我看到新生都进群了。&emsp;&emsp;我自己作为老人还是希望能够贡献出一些经验来指引他们，于是我就想写一篇博客。&emsp;&emsp;然而写着写着，感觉篇幅有点大，有想要加一些稍微酷炫的效果，比如滑动ppt。&emsp;&emsp;这种复杂程度结合我的博客会有点别扭，于是我打算做一个单页html吧。&emsp;&emsp;至少样式可以脱离我的博客，做得酷炫一点。 &emsp;&emsp;然而当我接着往下面做下去之后，我发现越来越复杂了。&emsp;&emsp;于是就萌生了不如做一个网站的想法。&emsp;&emsp;这种不断给自己提需求优化的感觉，像极了我之前开发数据结构的大作业时的感受。 &emsp;&emsp;当时也算是闲着，有足够的时间来让我搞，于是我敷衍着聪哥，自己另起炉灶搞网站。&emsp;&emsp;当时我找了很多网站模板，还是用着 ES5 + JQuery 的方式，逐渐将网站搭起来。 &emsp;&emsp;当时也找了很多酷炫吊炸天的特效效果，看了API文档之后就各种调用。&emsp;&emsp;完全没有 require 的概念，也没有三大框架的组件化思想。&emsp;&emsp;我当时其实还没有意识到这么搭建网站已经完全落后了，还乐此不疲的加功能。 &emsp;&emsp;当时就是怎么酷炫怎么来，不仅有 弹幕、视频背景、三维分享、各种乱七八糟的库嵌套到一起。 数字媒体技术网站 &emsp;&emsp;当时的开发历程可以在这里找到 数字媒体技术专业网站 - 搭建感想 &emsp;&emsp;这个网站在新生入学了之后还有很多东西没有弄完，后来实在没办法，就安排了工作室的同学帮忙弄。&emsp;&emsp;其实也就是做一些简单的内容填充，复杂的js部分都让我给弄了，没办法，那样写的js只有我自己清楚怎么搞了。&emsp;&emsp;后面就到了大三的日子里了。]]></content>
      <categories>
        <category>回忆录</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【回忆录】 - 我的大一]]></title>
    <url>%2Fposts%2F5871be65.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;初中和高中的状态我基本可以将自己的状态总结为佛系。&emsp;&emsp;但是到了大学之后，我真的可以毫不掩饰地说自己是在努力奋斗了。 入学 &emsp;&emsp;上大学给我的感觉就是新鲜，虽然我去了东风路校区，和我预想的大学完全不一样。&emsp;&emsp;记得那个时候父母给我带着大包小包的行李去到天河客运站，车站有广工大的摊位有专车接送我们去校区。&emsp;&emsp;结果等了半个小时回复是没车了，我们只好搭地铁去区庄站了。&emsp;&emsp;入学当天是那么新鲜和陌生，很多细节莫名地有印象，记得当天早上安顿好宿舍之后，父母就回去了。&emsp;&emsp;当时还因为床位和座位和老妈起了争执，最后还是服从学校的安排了。&emsp;&emsp;随后还有舍友入住，听他们的口音就像老妈那边的客家话，还因为是客家人，结果后来才知道他们是潮汕人，说的是完全不一样的潮汕话，世界观被刷新。&emsp;&emsp;下午我就去找在广州规培的哥哥去了。&emsp;&emsp;入学第一天晚上，这是我们宿舍第一次也是最后一次这么早睡觉了，全宿舍居然10点就关灯了，仿佛还活在高中 (:з」∠)&emsp;&emsp;以后都是熬夜成性了。 &emsp;&emsp;关于东风路这个校区有太多想吐槽的地方，但是吐槽归吐槽，它也确实让我抓住了我想要的东西。&emsp;&emsp;东风路一直有东风破的昵称，校区极小，大概就是一个高中那么大，但是在越秀区的中心地带，交通方便四通八达。&emsp;&emsp;而且宿舍楼和教学区很近，基本5-10分钟就可以从宿舍到教学楼。&emsp;&emsp;对我来说最最重要的是，我们专业被划分到了艺术与设计学院了，这既是挑战也是机遇。&emsp;&emsp;艺设的确不是广工的强势学院，重视程度有所欠缺。&emsp;&emsp;但是这正是我想靠近 Maya 的地方，估计广东省再也找不到另一个理科生可以距离艺术生这么近的地方。&emsp;&emsp;这也为我后面认识很多游戏、影视相关的艺术生打下了基础。 &emsp;&emsp;不过我们之所以这么关注大学城也是有历史原因在里面的，我们专业以前是在大学城的。&emsp;&emsp;直到我们的上一届才正式搬迁过来艺术与设计学院，我觉得学校的出发点还是合理，堂堂数字媒体技术分配到机电学院，成何体统。&emsp;&emsp;但是机电学院可是广工的强势学院呀，我们脱离了之后，其实是感觉自己专业的地位一落千丈的。&emsp;&emsp;不过开学之后不久，上一届的学长学姐就给我们这帮入学的萌新打气，鼓励我们。&emsp;&emsp;当时2班班长的话让我印象深刻 - 大学大学，大不了自学 ，不管这是梦幻开局还是悲惨起跑，我们已经无法左右了。&emsp;&emsp;但是我们还可以左右我们自己，我们可以靠自己努力往自己所期待的方向前进。 &emsp;&emsp;入学的时候 建院(城市规划和建筑学院) 有组织了一个活动，给未来的自己的寄一封信。&emsp;&emsp;我一年后真的收到了这封信。&emsp;&emsp;信的内容真的很感性，逻辑都有点错乱，完全是写给自己看的。大家就将就一下。&emsp;&emsp;不过真的万万没想到，当年很多期盼都实现了呢！ 班干部有感 &emsp;&emsp;大学受到父母辈思想的影响，另外我哥入党了，我也不想落下，于是我就义不容辞的竞选了班干部，当时我们宿舍有人想当班长（大一的时候真的当上了）&emsp;&emsp;于是我就退而求其次的选了团支书。&emsp;&emsp;说来惭愧，这团支书我当了两年，但我都疲于应对，ε=(´ο｀*)))，终究不是做班干部的料，也没有为班级争取荣耀的那种强而有力的信念。&emsp;&emsp;什么团日活动都没有组织好，我自己给自己的评价就是胡诌过去的，好几次班级活动都是抱了隔壁班的大腿，一起组织。&emsp;&emsp;团日活动答辩什么的也没有重视答辩，准备极度不充分，两年共计四次团日活动，在我看来我就是团灭活动，隔壁班的团支书就牛逼了。&emsp;&emsp;活动出色，答辩出色，还能选送到校赛拿个1、2等奖，给班级加班费。&emsp;&emsp;我的确是一个不合格的团支书，我也必须承认我成功入党也或多或少有班干部的加分在里面，本来大二就想不干了。&emsp;&emsp;经历了大一一年的洗礼，完全明白团支书的工作就是吃力不讨好的苦力活，为班级争荣誉，实际上大多数时候出力的还是团支书自己。&emsp;&emsp;因此到大二的时候就没有人想当团支书了，如果没有人想当我就自动连任了，隔壁班的团支书就是找了继任者顺利完成交接。&emsp;&emsp;我自己出于对大一一年工作的愧疚，也想着自己已经积累了一年的经验，所以我参选了，毫无疑问地我连任了第二年的团支书。&emsp;&emsp;然而愧疚说得倒是冠冕堂皇，结果大二还是保持大一的作风，佛系组织，佛系答辩。(/ω＼)&emsp;&emsp;虽然表面上组织得有模有样，班里的人还是挺热衷响应的，可能还是没有对比就没有伤害吧，也清楚知道自己只出了多少的力，所以我对这份工作评价很低，很对不起班里的同学。&emsp;&emsp;中间还发生了一些情况，比如班级有人实践本丢失、团员补办的程序交接出问题，这些都是我团支书工作的失职。&emsp;&emsp;最后我大三在没有找接任人的情况宣布不当了，当然如果没有人接手的话，我还是继续上任。&emsp;&emsp;不过大三的团支书其实就很轻松了，很多活动都不再强制举办。好在还是有人接过了我的重担，这为我后面大三能够长期实行做好了准备呀o(￣▽￣)ｄ &emsp;&emsp;大三虽然辞掉了团支书，却又被内定成了党支委，真的是万万没想到，好在我们这边的支部都比较水，因为大家都没有入党的热情。&emsp;&emsp;上级下来名额，还得找差不多可以的人去凑数，我哥真的羡慕死了。他当年医学院人人争做党员的激烈竞争简直不堪入目。&emsp;&emsp;所以我大三实习不在校，很多工作都由另一个支委承担了，而且老师也很体谅我们，给我们扛了很多很多的工作。 &emsp;&emsp;现在回想起大学班干部的经历，我觉得没有走错，走入社会之前能试着够担当更多东西，这种锻炼也是挺好的。&emsp;&emsp;反正大学的东西搞砸了也不会很影响自己的未来，基本谦卑一点，道个歉就可以了。&emsp;&emsp;在这个过程会有很多无用的东西手续、档案流程要搞清楚、要帮同学解决，我觉得这些都是一种很好的能力平衡。&emsp;&emsp;可能从技术层面上这些都是无用的，但是我觉得人不太能太技术，不能只有技术的角度。&emsp;&emsp;尽管我自己是的确不太适合做班委这种组织活动的活，但是我还是逼迫着自己去试着适应了，也是非常不错的试错体验。 &emsp;&emsp;虽然我是一个失职的团支书，不过我觉得自己还是算是扛起了作为团支书的责任担当，也对得起和我交接团支书的女生了。&emsp;&emsp;做团支书过程中的佛系状态让我想起了高中的学习状态，果然自己还是一个比较技术向的人(:з」∠)&emsp;&emsp;不过到了大三之后，自己技术长进了，我还是有试着将自己所掌握的东西来帮助团支书的手头工作的。&emsp;&emsp;记得大二开始就已经有了 青年之声 回答通知活动，同学们回复青年之声平台的问题可以换取校内实践时数。&emsp;&emsp;我当时也算是尽力将这个活动做好了，所有的问题都是班委自行组织发出来，然后自行组织同学们参与的。&emsp;&emsp;当时做统计真的是很统计，需要点开每一链接查找都有谁回复了，还是需要将问题链接贴到 Excel 文档上。&emsp;&emsp;到大三的时候这个活动还是有的，想到这个痛苦的统计过程，我甚至花了一个下午的时间去弄，真的很蛋疼。&emsp;&emsp;于是我写了一个 Python 脚本自动抓青年之声平台的接口数据，实现自动化统计生成 Excel 表格，这也是我做技术最自豪的地方。&emsp;&emsp;这件事可以参照我以前写的博客 文章 入选工作室 | 军训 | 社团 &emsp;&emsp;我入学的时候真的很幸运，那个时候还是工作室遍地开花的时候，不过相比大学城的工作室数量也完全不是一个数量级。&emsp;&emsp;现在我们校区这边都不肯批场地给我们学生使用了o(╥﹏╥)o，真的苦了我的后辈了。&emsp;&emsp;入学的时候辅导员安排我们去蚂蚁工作室参观，那个时候认识了影响深远的师兄 聪哥 。&emsp;&emsp;蚂蚁工作室就是聪哥一手搭建的，是一个彻头彻尾的动画工作室，以开发三维动画为己任，他们当时就演示了 Maya 软件，让我大为振奋。&emsp;&emsp;随后我在参观的过程中主动亮出了高中的作品，我原以为高中的敷衍之作也不算什么，没想到却让他们大为震惊！！&emsp;&emsp;后来聪哥给我的评价就是，高中就做出了他们毕设的水平╮(╯▽╰)╭ ！&emsp;&emsp;其实真实的情况就是敷衍的，当时没有接触过绑定，也不会制作贴图。当时角色一套全部是借了 DT 教程的素材以及一些网上的资源。&emsp;&emsp;我只是把动画K好了，说实在的动画也做得不咋地，所以说第二部特敷衍，第一部才是良心之作，我是真的用了一个寒假的时间把巡洋舰飞船给做出来了。 &emsp;&emsp;虽然大学入学就成功了进了工作室，但是高三一年的荒废其实也忘记得差不多了，很多东西都是从头开始学起。&emsp;&emsp;随后就开始面临社团招新和军训。 &emsp;&emsp;工作室那边聪哥要求我只能在社团 和 工作室之间二选一。&emsp;&emsp;聪哥真的算是经历过社团活动，知道社团的真是斤两，但是那个时候我还是懵懂的大一新生，对社团充满了憧憬和期待。&emsp;&emsp;于是我还是想去一个能够学习精进技术的社团去试试。&emsp;&emsp;那个时候我看见校学生会的宣传片很牛逼，过长动画，各种效果横飞，我在想哇，原来现在的学生也可以做出这么高端大气的宣传片了。&emsp;&emsp;实在是太牛逼了，一定要进社团了解清楚。&emsp;&emsp;当时校学生会负责这个部门叫做 信息技术部，负责学生会公众号推文以及宣传片制作，现在想来还挺新媒体的呢!~&emsp;&emsp;那会儿宿舍招新，很多师兄师姐来新生宿舍串门，宣传各种社团，宣传纸都堆满了宿舍桌面。&emsp;&emsp;有的同学还很受欢迎，说实话自己压力还挺大的，总觉得自己也不能落下吧。&emsp;&emsp;参加社团无非就是为了凑学校要求的实践时数，当时也是犯难了，没有社团的支持貌似还很难凑齐呢&emsp;&emsp;尽管工作室说可以给足我50个小时，比社团还牛逼，但是毕竟没有先例，当时也怕被忽悠了呀(:з」∠)&emsp;&emsp;当时班助还带他的同学给我们逐个串门，聊聊大学生活，那个时候也推荐了一个低调的 信息中心 的社团兼职。&emsp;&emsp;不仅有50个小时实践时数，还有钱下发，女生宿舍电脑出问题了，还可以进去帮忙修电脑 (✪ω✪)&emsp;&emsp;当时就决定进这两个社团。 &emsp;&emsp;我首先面试了校学生会，因为高中有做过视频剪辑的基础，所以我是相当自信的。&emsp;&emsp;当时有初试和复试，现在经历了校招之后，感觉那个时候还挺正规的。&emsp;&emsp;初始就是正常的部长面试，基本问题不大。&emsp;&emsp;复试的面试题是策划校学生会篮球赛的宣传视频，然后就是分组竞赛，相当于群面了呢！&emsp;&emsp;我当时主导了整个团队的规划，还分好了故事版，反正策划也是天马星空的，我还结合了3D技术做出篮球动画的片头。&emsp;&emsp;可惜那会还没有鸡你太美，否则绝逼用上了 ๑乛◡乛๑&emsp;&emsp;所以学生会的面试还是很轻松的，结束的时候还分享高中做的短片，装了一波逼 (:з」∠) &emsp;&emsp;至于信息中心的就有点遗憾了，当时初始是去了，不过表现得挺紧张的。&emsp;&emsp;后来复试的时候，不知道怎么忘记时间了，当时当电话过去就已经结束了，然后就与这个好差事失之交臂。 &emsp;&emsp;经过社团招新不久之后，军训的日子就来了。&emsp;&emsp;我们艺术与设计学院的标准是真的轻松，早上8点到操场，而且教官大都很贴心让我们避免晒太阳。&emsp;&emsp;然后晚上就是开各种 party 活动 土嗨，当时教官叫我们跳社会摇，简直有毒。&emsp;&emsp;也是那个时候重学了 团结就是力量 认识了 强军战歌 ,还在社会摇中发现了 电音教主 Alan Walker (￣▽￣*) &emsp;&emsp;那个时候我还没有配电脑，晚上有空经常去操场旁边的机电厂，蹭工作室的电脑学习。&emsp;&emsp;工作室也有些师兄会给我指导一二，给我建模的教程开始看生肉学习~ &emsp;&emsp;我记得那会还找到了一套 DT 的教程种子，当时开始试着收集资源，将 DT 的手机游戏开发系列全部整理了出来。&emsp;&emsp;那会其实对未来是有了影视游戏的大方向，但是其实还没有明确的细分方向的，大概就是游戏影视两开花吧~&emsp;&emsp;特别是军训和同学交流多了之后，还是挺多人冲着游戏方向进这个专业的，当时也想着自己不能落下呢~&emsp;&emsp;后来我就开始将找到的教程开始逐渐上传到B站，最开始的就是从这套 Unity 游戏开发系列开始的。结果是我现在也压根没看过 _(:з」∠)_233 &emsp;&emsp;那个时候因为还没有配电脑，自己没有将电脑搬到工作室就不算正式成员。&emsp;&emsp;军训结束之后，也就快国庆了，那个时候校园十大歌手的活动已经开始筹备了。&emsp;&emsp;信息技术部要开始出片给校园十大歌手做宣传，那会部门还开了会。&emsp;&emsp;信息技术部也是有定期的培训的，我印象很深刻，那个时候我们专业的学长（当时的部长）还教我们PS怎么抠图。&emsp;&emsp;视频剪辑就分了几个会剪辑的去做，不会的人趁机去学习。&emsp;&emsp;也是那会，部长推荐了 人人素材网 和 新CGer网 ，那是我第一次认识这些教程素材网站，对我后面的教程收集帮助还真大。&emsp;&emsp;不过后面也的确让我大失所望，了解了这些素材网站之后才找到原来有 AE 模板这种东西，因为我高中是学习过AE剪辑的，有模板之后做宣传片就很简单了。 av6583634av6588230av6620943 &emsp;&emsp;又是黑历史，大家不要介意。&emsp;&emsp;那个时候还忘记是什么原因提前回校了，估计待在家里太过无聊了吧，就和哥哥一起回广州了。&emsp;&emsp;那个时候我的电脑还没到学校，都是借用舍友的电脑去做的，渲染花的时间贼长。&emsp;&emsp;当时部长们很看好短片，但是对于成片质量还是意见不少，于是我们在微信交流。&emsp;&emsp;因为自己用微信少，或者不擅长加些颜文字辅助表达，部长觉得我的语气很激烈，然后就约我出来面谈了。&emsp;&emsp;忘记那个时候是怎么赶工期了吧，反正就是弄得很赶，然后这里要改亮度、那里要改饱和度的，也着实是把我改出了内伤。&emsp;&emsp;有种感觉就是她在瞎逼逼，你就只能按着他们的新要求来，没修改一次又是重头来一遍的渲染时间，再加上舍友的垃圾电脑，真的是蓝瘦香菇。&emsp;&emsp;所以也是那个时候下定决心要离开社团进工作室了，社团的东西太过流于表面，并不是我想要的。&emsp;&emsp;于是后面就给所有的部长写了诚恳的道歉信就退出了社团。 大一配电脑 &emsp;&emsp;高中的时候渲染都是用 垃圾 i3 CPU 去渲染的，当时渲染都是通宵才能弄出来，还真的不容易。&emsp;&emsp;因此当时暑假我哥还给我查了很多配电脑相关的资料。&emsp;&emsp;基本就是按着三维设计的方向去给我配，显卡要配专业显卡（其实现在看来 游戏显卡就足够了，专业显卡性价比很亏），CPU要志强系列。&emsp;&emsp;不过暑假的时候只是确定了要配台式电脑的方向，却没有定下具体的配置。&emsp;&emsp;当时也想着靠工作室给我配一部，老爸其实没有给我设预算上限，但是我觉得预算 1 万元已经很奢侈了。&emsp;&emsp;当时工作室的聪哥 给我配都是往京东上查具体的型号给我组装起来，我的感觉贼亏。（因为我当时已经认识到了洋垃圾的便宜）&emsp;&emsp;后来国庆的时候就我和我哥讨论配一套洋垃圾版的双至强方案。&emsp;&emsp;但是讨论了很久也没有很好的落地方案，当时即使洋垃圾 E5 CPU也有3000多元一块，还得找到合适的主板以及的 ECC 内存。&emsp;&emsp;所有的东西都要配好还是挺费劲的。&emsp;&emsp;最后我查了一下淘宝整机工作站，没错就是被吐槽了千万遍的坑爹淘宝整机。&emsp;&emsp;当时感觉看了一家销量和综合评级最好的店，由于国内有这种需求的电脑极少，卖出去也不过20多部，看了评价觉得可以，虽然是北京的店没法现场验收了。&emsp;&emsp;价格是 8499 整机不带显卡， E5 2683 双至强， 16G ECC内存 加 服务器主板，三星250G固态硬盘，全塔巨型机箱。&emsp;&emsp;当时感觉性价比还过得去，毕竟两个 CPU 就 6000 多了，我们又不敢踩服务器主板的坑，怕后面出问题，于是就把钱花出去了。&emsp;&emsp;当时还顺带在那家店买了显卡，专业显卡 P2200 ，中端专业显卡要 3000 多元，现在回想起来亏大了(:з」∠) &emsp;&emsp;于是我第一台上万工作站就来了，花了最贵的钱，然而是台玩不起游戏的机器(ΦωΦ)&emsp;&emsp;毕竟是低频的专业显卡搭配主频只有2G的 2683 CPU，玩大型游戏不知道有多蛋疼。&emsp;&emsp;不过这些都是我最好心理准备的，花这么多钱配这样的配置就是为了让自己好好学习嘛~ 大一上学期 工作室 &emsp;&emsp;电脑快递到了之后，我就直接把电脑搬到工作室了，当时工作室的人还对这样的工作站啧啧称奇。&emsp;&emsp;不过也是，买 i7 不好，非得买个多线程的洋垃圾。&emsp;&emsp;然而 E5 2683 的正品可是上万元一块，真的买不起(:з」∠)&emsp;&emsp;后来还听说 2683 可以通过修改主板的黑科技可以超频到 3G 主频，见过洋垃圾的价格也水涨船高。&emsp;&emsp;不过想必大家也清楚，我是买整机的人，怎么会操这种极限超频的心嘛~ &emsp;&emsp;我刚进去工作室的时候，他们安排我学习建模为主，那个时候看教程，学习布线，背模型布线云云。&emsp;&emsp;那个时候其实已经很流行 ZBrush 雕刻之流，不过师兄他们也在学习中，所以我就学习 Maya 的建模制作。&emsp;&emsp;那会也是结合翼虎网的DT教程一并学习。&emsp;&emsp;然而学习过程并不那么理想，主要问题在于我并没有艺术生的美术积累，造型、比例都把握不准。&emsp;&emsp;最后建出来的东西不好看或者不像，对我的打击还是挺大的。&emsp;&emsp;那会工作室也很萧条，很多师兄都不在，有问题我也是通过高中养成的习惯自己解决的。&emsp;&emsp;其实那会就已经开始初见工作室问题的端倪了，后来才知道 聪哥 和他的舍友闹翻了，刚入学那会的师兄就慢慢一个一个地退出了工作室。&emsp;&emsp;最初是聪哥将我们专业三个学习网页师兄师姐赶出了工作室，因为他们经常不来工作室，强调多次之后聪哥心一横就把他们干掉了。&emsp;&emsp;然后就是聪哥和舍友之间的矛盾扩大，逐渐离开。 &emsp;&emsp;聪哥后来想着另立门户，又从大一的数字媒体艺术那边招了一个宿舍进行管理，刚好我和他们宿舍就是神奇对照组。&emsp;&emsp;聪哥是希望组织一个团队搞网站的，那会前端网页开发很火，基本会点皮毛就可以找到能够糊口的众包，他招一个宿舍进来就是规划用来做网页的。&emsp;&emsp;一个宿舍招进来也方便培养团队感情以及强化团队的凝聚力，的确也是一个不错的尝试。&emsp;&emsp;而我就是最特立独行的散养模式了。&emsp;&emsp;我和他们宿舍交流较少，不知道他们艺术生到底喜不喜欢做网页这种东西，不过大学反正都是迷茫为主的，如果暂时有个方向，我觉得也挺好的。 &emsp;&emsp;后面还招了一个动画专业的新生 小焯，当时聪哥的舍友看上的人才，那会我和他之间交流还挺多的，军训的时候也一起来工作室。&emsp;&emsp;所以即便聪哥和舍友闹翻了，我还是联系上他带到工作室进来。&emsp;&emsp;就这样刚开学，工作室就经过一大波换血。 &emsp;&emsp;虽然聪哥（当时大四）大四的学长全部走了，还有两个打我们一届的动画专业的师兄带我们。&emsp;&emsp;现在回想起来，怎么都是男生的说ヽ(ー_ー)ノ&emsp;&emsp;他们两个分别是 立明 和 李広。&emsp;&emsp;基本这就是换血之后的最终人马。 &emsp;&emsp;其实工作室的安排也非常明晰。&emsp;&emsp;聪哥大学自学了编程同时也会动画专业的课程，属于全才，主要负责带数媒艺术宿舍去学习和制作网站。&emsp;&emsp;我和小焯加上两个学长负责动画模块。 &emsp;&emsp;即便是现在回想起来，也还是觉得聪哥很牛逼，虽然英语不行，但是那个年头艺术生居然自学 PHP 和 JS 成了一个全栈工程师。&emsp;&emsp;我后面大二学前端可以说是直接受到了他的影响，现在来看他的技术可能有些落后了，但是作为艺术生能达到通才，背后的努力和汗水是可想而知。 &emsp;&emsp;那会艺术生都是搞二维绘画为主，他们对三维熟悉程度甚至还不如我，因此整个Maya的三维全流程全部就给我来处理了。&emsp;&emsp;特别是聪哥的舍友离去，我们曾经的三维主力军都离开了，所以说那会还真的是前途多难，出问题基本靠自己来解决，算是一种很好地锻炼吧。 &emsp;&emsp;那个时候我就养成了成天泡工作室的习惯，因为回到宿舍就没有电脑了，所以从另一个角度也算是不得已而为之吧。&emsp;&emsp;在工作室的好处就在于可以避开宿舍的玩耍氛围，可以专心致志地学习，对我日后的成长来说可谓至关重要啊！~&emsp;&emsp;现在每当听到 Ryan Farish 的 Stars Collide 以及 Life in Stereo 音乐，就可以回想起当时8点多吃完早餐独自一人呆在工作室学习的日子。 &emsp;&emsp;一方面自己要对得起这花出去的上万元电脑，另一方面自己的确对这一行充满了兴趣。 &emsp;&emsp;我记得大一上学期聪哥很忙，不过还是给我布置了一个汽车建模的练习任务。&emsp;&emsp;当时还是他给我在百度上好了 老爷车 的图，让我按照这些参考图，大致地坐一辆老爷车出来。&emsp;&emsp;也教了我至关重要的建模方法，就是先用方块将超简模搭建出来，这和画画的时候画大型是一样的，用来把握整体的比例和镜头位置。&emsp;&emsp;后面再慢慢细化模型，我觉得这些思想到现在来说还是很有用的，甚至是开发也可以参考这样的思维。&emsp;&emsp;所以那会我拼命练建模，甚至会拿一些工作室上的小物品进行建模测试，比如奖杯、塑料盒都是我那时的小目标。&emsp;&emsp;也得益于我暑假看了关于建模规范的教程，比起高中的建模，模型的布线更加规范了。&emsp;&emsp;也是那个时候不知道怎么认识到了 技术范 Kevin，从他那里我第一次认识到Maya刷鼠标的厉害之处。&emsp;&emsp;后面建模的效率更是更上一层楼，记得那时候晚上去蹭老师的公开课，公开课其实就是给交了钱的同学评讲作业，听课的人都是交钱的人。&emsp;&emsp;所以我这个外人就在直播间里面偷师学艺了(:з」∠)&emsp;&emsp;当时学到了很多布线思维对我影响极其深远，特别是 Kevin 老师的各种建模骚操作。 &emsp;&emsp;记得那个时候搞了两个月，毕竟大一的课程和作业都不少，大概是圣诞节左右才完成这个老爷车的制作。&emsp;&emsp;当时还学着用 Maya 表达式完成方向盘转轮胎以及移动汽车转轮胎的简单绑定效果。&emsp;&emsp;感觉还是收获满满的。 &emsp;&emsp;然而后续的人头建模就成了我的噩梦了，当时聪哥基本将我放养了。&emsp;&emsp;建模建出来的效果都是给大二的师兄评价的，可是怎么建效果都不尽人意，这个结果真的一言难尽。&emsp;&emsp;当时弄到快寒假了，还是没有满意的效果，于是聪哥认为我缺少美术的基础，让我去学习绑定了。 资源搜索 | 教程翻译 &emsp;&emsp;在工作室学习的日子里是相当充实的，不过也不单单只是这样而已。&emsp;&emsp;那会对我来说除了学习最喜欢做的事情就是找教程资源，收藏起来以后有机会再看。&emsp;&emsp;人人素材网这些网站都是通过慢慢签到去获取密码，也有一些 素材资源网 一站资源网 其他网站签到可以更快获取到密码。&emsp;&emsp;当时也有找一些其他的方式找资源，我当时的目标就是不花一分钱获取想要的资源，也建立了 QQ 群进行交流（现在荒废了(:з」∠)）&emsp;&emsp;所以慢慢的手头上的资源也就越来越多，但是在网盘上看又不方便，自己的电脑只有 250 G，后面空间是肯定不够的。&emsp;&emsp;于是慢慢就有了将教程放到网上的想法，这样随时都可以去看，然而各大视频网站都有烦人的广告，所以就只剩下良心的B站是最佳的选择。&emsp;&emsp;其实到后面更多像是养成了收藏的癖好了~ &emsp;&emsp;当时收集了大量的教程，然而绝大多数都是生肉教程，于是自己也想将一些有用的教程翻译成中文。&emsp;&emsp;毕竟暑假那会就有很强烈的愿望，于是很快自己就行动起来了。&emsp;&emsp;不过聪哥其实并不看好我做这个东西，也确实是没什么前途的工作。&emsp;&emsp;为了可以避开他的视线，我就借用隔壁宿舍的电脑，晚上11点回去宿舍之后自己做起了翻译工作。 &emsp;&emsp;那个时候我的作息是和隔壁宿舍同步的，他们打游戏到什么时候，我就翻译到相同的时间，基本上是 一两点 吧&emsp;&emsp;更好隔壁宿舍有个同学经常玩手机游戏电脑是闲置的，我在宿舍没有电脑可用，就给我用了。&emsp;&emsp;那会偶尔也会受到他们打游戏的影响，不过终究还是没有入坑，可能是我之前高中就玩过相关的三A大作，感觉也就那样。&emsp;&emsp;那时候盛行 LOL 和 守望先锋，吃鸡还不存在呢~！ &emsp;&emsp;上面就是我第一次翻译出来的教程，做翻译真的很锻炼自己的英文水平。&emsp;&emsp;因为有当时的不懈努力，才让我熟悉大量的三维相关的术语，给我后面自学生肉奠定了基础。&emsp;&emsp;不过整体而言做翻译的确很累，而且很花时间，基本上翻译视频一个小时自己就得画上十个小时进行翻译、调整时间轴。&emsp;&emsp;当时我还是使用 arctime 去制作的，算是比较早一批的 arctime 用户的，自动时间轴是真的方便，只是还需要慢慢的调整。 &emsp;&emsp;那个时候还想着可以组件一个翻译组来义务翻译教程，帮助大家共同学习的。&emsp;&emsp;不过终究还是没有搭建起来，自己并不擅长这种团队的管理，虽然中间也的确有得到群友的协助，但是整体还是以个人翻译为主。&emsp;&emsp;后来加入了商业翻译之后才真正体会到专业翻译的考究严苛之甚，耗费时间之多。 &emsp;&emsp;因为自己也需要看教程学习的，没有那么多时间来做翻译的工作，所以我后面翻译的定位都是一些入门、初学者级别的教程做翻译。&emsp;&emsp;再到后来收到商业教程字幕组的邀请，然后做了一些教程的商业翻译之后我就彻底死心了，终究翻译只是对自己的锻炼而已，并不是长期糊口的目标。&emsp;&emsp;商业翻译是按教程时间算人工的，翻译的效率就很重要，但是显然自己的翻译速度和精确度还远不如在外面做兼职，因此后面就没有再做了。&emsp;&emsp;并且商业翻译的教程是固定的，发布任务制的，很多时候并没有自己感兴趣的教程可以翻译，确实翻译起来还挺痛苦的，只能说这行不适合我。 &emsp;&emsp;另外上面这个教程还没有翻译完成，╮(╯▽╰)╭ 挖坑不想填的典型例子。&emsp;&emsp;总结起来，刚开始翻译的时候还比较理想主义，经过商业翻译的现实摧残之后就失去理想了。&emsp;&emsp;其实从某种意义上来讲，那个时候做翻译也是自己为了锻炼英语能力的定位吻合的，到后面做翻译就变成苦力，而且当我看到人工智能未来对翻译行业的冲击之后。&emsp;&emsp;我真的对翻译没有什么兴致了，除非是某些特别棒的教程让我觉得很值得翻译，比如 CG101 系列，灰猩猩 系列 链接 &emsp;&emsp;现在回想起来，那会似乎就没有什么娱乐活动了，的确那时候还不知道B站关注其他 Up主 的功能。&emsp;&emsp;接触B站也还不到1年，也的确没有消遣时间的地方。&emsp;&emsp;除了翻译之外，我晚上在工作室最多研究的就是寻找资源的方法，对我来说就是一种放松。&emsp;&emsp;为了免费获取到资源，除了人人素材网之外，我还研究可以大量获取该网站资源密码的方法，当时也搜集了不少，基本17年以前的资源都有密码了。&emsp;&emsp;只可惜老资源作用也不大了，只能说时代变了，技术更迭太快了。&emsp;&emsp;再到后来，我就找到终究找老资源的方法，那就是磁力链接。 av12125582av11945156 &emsp;&emsp;在百度搜索磁力链接可以搜索到很多类似的网站，那个时候还能找到一些上古老物教程，参考上面的链接。&emsp;&emsp;大家都知道，这么老的教程用处不大了，不过也算满足了我收藏的癖好吧！~ 入坑绑定 &emsp;&emsp;寒假的时候，因为家里没有神机，我一直待到接近春节的日子才回家。&emsp;&emsp;那个时候聪哥告诉我让我往绑定的方向走。&emsp;&emsp;因为工作室要做动画，的确需要会绑定的人，而他事实上是不会的，只能让我自己去摸索。&emsp;&emsp;其实聪哥的舍友是会的，原本这些工作也是让他们来弄的，不过总归是闹僵了，没办法。&emsp;&emsp;而且我那个时候比较倔，基本就是自学惯了崇洋媚外得很(:з」∠)，绝不找中文教程学习，唯英文教程马首是瞻。&emsp;&emsp;所以这也是为什么我会这么热衷找教程，因为没有人整理提供给我，也不想花额外的钱去淘宝买。&emsp;&emsp;现在想起来，看英文教程的确会比较累，特别是要慢慢适应一些专业名词，不过算是先苦后甜的学习路线。&emsp;&emsp;可以追踪我B站发的视频时间，那会我整理了大量潜在可能要看的绑定教程，统统都发到B站上了。&emsp;&emsp;虽然没有全部看了，但是也看了不少的教程吧，大部分都是看 DT delano 的教程，老师的名字都记得清清楚楚。 &emsp;&emsp;我学习的时候也和大部分的人一样的心态，要找最新的、最权威的教程，就怕学完过时了、没用了。&emsp;&emsp;所以当时看的第一部绑定入门教程是 Pluralsight 最新的绑定入门教程 (Pluralsight 后来收购了 Digital Tutors) &emsp;&emsp;当时是在家里看这套教程，家里的电脑还非常不凑巧坏了。&emsp;&emsp;我当时拿着16G空间的华为老手机，蹭着奶奶家的wifi，在B站上看这教程。&emsp;&emsp;看不懂还没法打开Maya去研究教程的操作，只能反复看视频参悟教程的操作。&emsp;&emsp;当时第一次接触约束，看得我一愣一愣的。（以前高中的时候只接触过骨骼，后来绑定想过的部分因为下载绑定好的模型所以忽略了）&emsp;&emsp;再加上这个老师有些部分讲得的确不好，后面看还是 delano 讲得好一点。&emsp;&emsp;不过终究是自己踩的坑，跪着也给填了。&emsp;&emsp;当时在家里磨了一个星期，总算是把这个教程给搞定了，当时还学习了很多人体结构的单词，真的万万没想到!!!∑(ﾟДﾟノ)ノ&emsp;&emsp;也通过这个教程接触了一些 mel 语言的代码，也算是对我走 TD 路线的铺垫。 &emsp;&emsp;后来接触上面的教程，发现了表情动画原来还有 Blendshape 这种混合变形的过渡神器。&emsp;&emsp;当时在我看来，没有什么是雕刻解决不了的（当时没人带就是那么 图样图森破） &emsp;&emsp;终究在家里没有电脑的情况下，学习效率是很低的，所以后面还是提前回学校了。&emsp;&emsp;那会回学校之后7点多起床，看着空荡荡的宿舍，然后兴致一起，就一个人听着音乐在广州老城区乱逛。 &emsp;&emsp;当时还有张专辑叫奶牛至牛奶，歌曲名叫做《黄昏》，可惜后来歌手将专辑删掉了，不过还是在老专辑里找到这首曲子。&emsp;&emsp;名字反而叫做《黎明》，这些曲子能让我想起那个时候的经历。 &emsp;&emsp;后来开学之后，进一步开始抓紧时间学习绑定的知识，那个时候聪哥的舍友给我推荐了主流的绑定插件 advance skeleton5 简称 ADV&emsp;&emsp;的确有了绑定插件之后，绑定效率快了很多，再也不用手动做绑定了，也深刻体会到了代码自动化处理的好处。&emsp;&emsp;后面做绑定就非常依赖插件了，毕竟效率提升很多，难怪聪哥强调不许我学习插件，要先把基础打牢，否则就没有动力去学基础了(:з」∠)&emsp;&emsp;有了强大的插件之后，绑定的工作只剩下优化权重而已，所以的绑定系统 ADV 会自动生成处理好。 &emsp;&emsp;不过我当时使用 ADV 的面部绑定总是代码报错出问题，没办法只好自己去学角色面部绑定。&emsp;&emsp;当时看了很多教程，面部绑定起码有三种方案，有一套教程统统都总结起来了，奈何我是没有看完的。 &emsp;&emsp;脸部主要有 面板控制方案 控制器控制方案 两种方案。&emsp;&emsp;印象中教程都有分析并且讲出了优劣，最后还是比较推崇控制器的方案，比较直观，面板调整表情不太方便。&emsp;&emsp;不过总体而言还是得看制作流程吧，大多数时候都是采用混合方案，比如ADV的表情就是。&emsp;&emsp;当时我们工作室采纳了控制器方案，其实控制器而言还有模型控制器的方案的。 &emsp;&emsp;通过多重BS的传递，可以让控制效果更好，不过当时实现难度太大，没有采纳。&emsp;&emsp;我们那会没有人会雕刻，我只会些雕刻的皮毛，而且造型能力不行，所以最后做角色都没有用 Blendshape ， 都是用骨骼权重驱动的。 &emsp;&emsp;上图就是当时做动画的主要角色之一的绑定。&emsp;&emsp;基础绑定基于 ADV 完成，脸部的一些控制器设置则是骨骼加刷权重完成，并没有什么黑科技。 快乐的喏比 | 创业比赛 &emsp;&emsp;其实说来惭愧，聪哥虽然有要做动画大电影的梦想，但是我们那个时候维系工作室的场地都拼尽了全力。&emsp;&emsp;学校不可能毫无条件地给我们提供场地，必须要参加比赛并且拿出成绩才配拥有场地的。&emsp;&emsp;再加上我们校区不在大学城，场地不足，工作室稀缺，竞争尤为激烈。&emsp;&emsp;在我还没入学的时候，聪哥就带领团队拿到了不错的创业奖项，而且他至今也一直在创业的路上奋斗，很让我尊敬！~&emsp;&emsp;为了实现制作动画大电影的梦想，他才带头创建了工作室，因此我们也必须参加学校举办的创业比赛以及省赛校赛。&emsp;&emsp;那个时候聪哥已经大四了，而且因为网页那边需要做项目赚钱糊口（我们动画组是毫无产出的倒贴(:з」∠)）&emsp;&emsp;对于用动画打创业比赛的态度还是比较敷衍的，而且动画行业的行情并不好，创业实属困难得很&emsp;&emsp;不过既然学校要求要做的东西，我们也可以当是作为近半年的努力的成果。&emsp;&emsp;然而，对于打比赛的问题我们真的准备不充足，聪哥也是临上台还有一到两周的时候才通知我们要做出来。&emsp;&emsp;因此这个作品无论从哪个角度来说都是无比地赶工期╮(╯▽╰)╭ &emsp;&emsp;关于这个作品，其实我们很早之前就开始策划了，最主要靠大二两位师兄进行构思，我不是艺术生，也画不出什么概念设计。&emsp;&emsp;但是对于作品的成品形态，他们之间产生了争执，李広师兄作为作品角色的主要设计师希望将作品做成二维的。&emsp;&emsp;不过，工作室的目的是要做成三维的，于是这些创作意见的分歧，在加上他女朋友希望他退出工作室的诸多原因，他也离开了工作室。 &emsp;&emsp;于是当我们将大致的剧情定下来之后，这个三维的片子就差不多只有一周的时间去制作了。&emsp;&emsp;当时聪哥负责了这个创业比赛的策划书准备以及上台演讲，我们则负责制作片子的宣传片。&emsp;&emsp;我负责准备宣传片需要的模型素材，场景搭建，还有后期渲染。&emsp;&emsp;当时工作室只有我最熟悉三维制作流程，于是我就包办了这个动画的Maya部分。&emsp;&emsp;除了一些场景搭建和关键帧动画之外，其他流程全部由我来做了。 &emsp;&emsp;我们的作品叫做《快乐的喏比》，其实故事有点类似于《多啦A梦》的儿童片，国产片的参考就是 《电击小子》 。&emsp;&emsp;当时他们讨论了很多剧情相关的东西，不过我没怎么参与(:з」∠)&emsp;&emsp;上面看到的绑定和角色就是我建模并且用 ADV 绑定的啦，下面就是黑历史环节了 &emsp;&emsp;由于制作时间不充足，除了喏比主角是建模的之外，其他的素材都是来源于网上的。&emsp;&emsp;特别是胖瘦两个角色，都是用男主角的模型经过一些修改做出来的，连绑定和权重都没有怎么修改。惭愧惭愧(:з」∠)&emsp;&emsp;好在只是做宣传片，做好一些镜头摆拍即可。 &emsp;&emsp;我记得当时渲染的时间严重不够，有没有听聪哥的要求，给整个制作项目设置工程文件夹，结果后面需要将项目搬到其他电脑进行渲染。&emsp;&emsp;这个过程因为贴图的问题吃了很大的亏，那个时候我还不知道 Maya 自带了 File Path Editor 可以自动修正有问题的贴图路径。&emsp;&emsp;于是就只好一个贴图一个贴图地去索引，然后去渲染，当时摆场景，调整渲染参数可把我累死，那个星期上完课就是工作室赶项目，选修课都逃课了。 &emsp;&emsp;有不少场景还是我接触 Maya 的 paint effect 做出来的，包括后面的稻田以及森林。&emsp;&emsp;当时Maya2017刚出，还没有人去学 Arnold ，全部渲染都是通过 Mentalray 完成的。&emsp;&emsp;因为以前高中我也是用 Mentalray ，算是比较熟悉一点吧。 &emsp;&emsp;动画的部分则是集工作室全体的力量完成，我只是指导并没有直接参与到K帧中来。 &emsp;&emsp;后面渲染也是借用工作室所有的机器进行通宵渲染，中间有个地方的材质还出了明显的错误，可以注意看喏比身上的反光，可是没时间修改了。&emsp;&emsp;立明师兄拿到渲染好的片子剪辑了一个早上，然后下午聪哥就去到大学城去演讲了。 &emsp;&emsp;创业比赛，其实我们这个渲染片只是个引子，无关紧要的（当时在现场真的戳心了）&emsp;&emsp;不过评委有懂行的人，知道这种片子得上传到网上看流量的，当时就把聪哥给问倒了（如果不懂行还可以忽悠一下呢(:з」∠)）&emsp;&emsp;结果我们费尽心血的粗制滥造作品只得到了创业比赛的二等奖，算是挺令人失望的（预期有点高） 三维漫画 &emsp;&emsp;打完比赛之后，已经接近 5 月份了，聪哥也快要毕业。 &emsp;&emsp;另外聪哥还给我们拉了个大三妹子进来，我们叫她小瑞，她是中印动画专业的，不过专业能力不是很强，给我们做文案相关的工作。&emsp;&emsp;那个时候我们工作室其实处于一个迷茫的摸索阶段。&emsp;&emsp;于是聪哥启动了三维漫画项目，希望通过漫画的形式去讲编程。&emsp;&emsp;于是立明、小卓、小瑞和我一起组成了团队开始探讨制作方式。&emsp;&emsp;立明设计出了以12生肖为主题的角色，然后我们当时做了实验的漫画版。 &emsp;&emsp;这些角色绑定都是当时做三维漫画的时候做的，也算是自己的积累吧。&emsp;&emsp;当时做动作还遇到了一些坑爹的情况。&emsp;&emsp;当时都是刷权重，结果发现一套动作下来，角色做某个动作权重有问题，修复完了之后做另一套动作又出现问题的情况&emsp;&emsp;这种问题其实可以借助ADV的corrective shape 来解决，这个功能其实在 Maya2017 已经集成进去了。&emsp;&emsp;那个时候还不太懂，好在我们的形式是漫画，并不需要担心这些问题，模型的pose摆好了之后甚至可以直接用雕刻工具修复到满意为止~&emsp;&emsp;当时聪哥是希望以这种方式的漫画作为我们创业的主营业务的。&emsp;&emsp;还把其中的一些角色作为我们企业的吉祥物一样放到公司的官网上~ &emsp;&emsp;那个时候晚上回去没有去做翻译，而是追了一部番，叫做 《花牌情缘》 ，的确很不错，真的是热血的运动番(☆_☆)&emsp;&emsp;第一次认识了日本的花牌，还挺有意思的。 花牌情缘 &emsp;&emsp;一追剧就追了大概好几天，把整部番追完了，感觉回到以前追番的感觉~ 暑假 | 恐龙动画 | IKFK切换 &emsp;&emsp;那会临近暑假，聪哥联系上了一个已经毕业两年的师兄 加杭 回来，希望可以指导我们做出动画。&emsp;&emsp;而聪哥努力在外面跑投资人，给我们工作室拉投资。 &emsp;&emsp;现在想来，这个加杭师兄也了不得，居然辞了工作跟我们搞动画，我当时是完全没有意识到这一点的困难。&emsp;&emsp;不过加杭师兄主要从事游戏行业的工作，三维方面用 Max 多，也不必我Maya强多少。 &emsp;&emsp;当时我们又做了一个全新的策划，要做一个恐龙和机器人的动画。&emsp;&emsp;大概也是差不多的时候，又拉来了数媒艺术的两个女生进来，来学习模型和贴图制作。&emsp;&emsp;因为要做机器人涉及到履带的制作，加杭师兄让我研究这方面的绑定方法。&emsp;&emsp;于是我又在网上搜索呀，很幸运地找到了 DT Delano 大大的教程。 &emsp;&emsp;教程里面大量使用 mel 语言加快履带的制作，这为我后面做开发做好了铺垫。&emsp;&emsp;再加上我们专业数字媒体技术也是有编程课，那时候大一学的是 C 语言，刚好给我编程来了个相互补充。&emsp;&emsp;当时研究这个充满了兴致，还觉得教程里面的东西只能针对单一场景，非常弱鸡，当时想要做一个通用的履带工具出来。&emsp;&emsp;于是才有了速制履带插件。 &emsp;&emsp;可以参照视频 1m06s - 1m21s&emsp;&emsp;那会我们动画组都交给加杭师兄进行管理，聪哥负责网页组的项目。&emsp;&emsp;暑假的时候工作室要求我们留下来一起做动画，我当时欣然接受了，想着回家也不过是在浪费时间而已。 &emsp;&emsp;那个暑假其实我也挺浪的，因为舍友都回去了，我一个在宿舍，可以借用他们的电脑玩。&emsp;&emsp;我还在3DM上面下载了一大堆单机游戏，都是些有意思的小游戏，然后在舍友的电脑上玩。&emsp;&emsp;因为工作室管理很松散，早上可以10点多到，晚上则一般是7点就回去了，当时好像保安有要求我们找点回去。&emsp;&emsp;午饭晚饭都是工作室一起点，选得都是一桶天下的家常菜，特别有家里吃饭的感觉。&emsp;&emsp;我中午还回宿舍午休，其实就是回宿舍打游戏去了_(:з」∠)_233 &emsp;&emsp;那个时候舍友还给我推荐了一本女频的网文，他说看了不下10遍，很好看(/ω＼)&emsp;&emsp;我出于好奇，也试着看了，我小说看得少也看得慢，加上又经常打游戏，暑假结束了都还没看完，整体感觉写得还不错，名字叫 《盛世嫡妃》&emsp;&emsp;这估计是最后用眼睛看的小说了，后面都是听书为主了。 &emsp;&emsp;回到恐龙动画上面来，当时我负责建模和绑定。 &emsp;&emsp;这个恐龙就是当时根据概念设计图我建的模，贴图是两位数媒艺术的女生用 bodyPaint 绘制的 &emsp;&emsp;这个图则是暑假接近尾声的时候，做的最后渲染图。&emsp;&emsp;这个机器人的建模我做了好久，构思和设计都是立明师兄做的，当时还做了很多版修改，头部造型也改了好久。&emsp;&emsp;当时暑假天天弄这个机器人，都快弄到泥潭里去了。&emsp;&emsp;我趁着这段空当的时间做好了速制履带工具，有了一些编程的经验。&emsp;&emsp;mel 语言真的和 C 语言很相似，两者都没有面向对象的东西，语法结构都极为相似，不过mel没有指针和内存管理，还是要比 C 简单很多。&emsp;&emsp;mel 语言的处理基于 Maya 平台，很多操作都非常直观，这方面真的完爆 C 语言。&emsp;&emsp;当时大一 C 语言的大作业是做一个学生管理系统，做出来还是个命令行操作的工具，给人感觉非常落后(:з」∠)，不知道做来有何用。 &emsp;&emsp;后来在实际的开发中遇到 IKFK 切换的问题，当时不知道，其实 ADV 已经做好了工具，可以使用工具自动切换 IKFK 控制器。&emsp;&emsp;于是我从头开发了一套IKFK切换的工具，这些都有教程可以参考，所以我一点也不慌。 &emsp;&emsp;当时主要根据这个教程的思路去做 IKFK 切换，因为 IKFK 本质上就是三套骨骼系统合为一体。&emsp;&emsp;为什么会是三套呢？具体要看绑定相关的教程了，上面推荐的 2017 绑定入门有讲到的。&emsp;&emsp;本质上就是一套 IK 骨骼 、 FK 骨骼 外加一套 绑定在模型上的骨骼。&emsp;&emsp;控制器控制的是 IK 或者 FK ，而这两套骨骼会互相约束绑定在模型上的骨骼。&emsp;&emsp;因此ADV控制器上的 IKFK切换 会导致错位问题，也就是 IK 和 FK 不同步的问题。&emsp;&emsp;举个例子，当前如果是 IK 状态的情况下， FK 模式的骨骼需要对准到 IK 的骨骼上，然后再将绑定的骨骼对到IK位置，然后切换控制器的显示。&emsp;&emsp;后面我慢慢的开始用 mel 语言写界面，丰富界面上的功能。&emsp;&emsp;看到教程不懂也是查 Maya 的文档，Maya 的 mel 文档好在都是有 案例 的 ，特别是界面开发，不懂可以直接上代码了解这其中的奥妙。&emsp;&emsp;因此虽然没有人教我，我的开发还是渐入佳境。 &emsp;&emsp;后来看了上面的教程，突然颠覆了我认知。&emsp;&emsp;上面的教程居然实现了选择控制器即可实现切换的操作，这太牛逼，太方便了。&emsp;&emsp;于是又去研究教程的实现方法，然后将相关的效果添加到自己的插件上。&emsp;&emsp;看了教程才知道原来是利用 scriptJob 的命令去做的，可以在 Maya 的特定场景下回调相关函数，真的好用。&emsp;&emsp;这里就是选择的时候判断一下是否是IK或者FK的控制器如果是相关控制器就进行切换功能。 &emsp;&emsp;可以参照视频 1m21s - 2m02s&emsp;&emsp;当时开发起了劲，晚上留到快11点被保安催了才宿舍的。&emsp;&emsp;另外自己也给自己提了很多需求，比如说获取了 ADV 的控制器之后，相关控制器的标题也变成按钮可以直接选择到获取的控制器。&emsp;&emsp;还有就是加了一个折叠的按钮，当时都是自己摸索开发出来的。&emsp;&emsp;至于生成临时工具架的方法则是参考了 mel 语言的参考。&emsp;&emsp;当时写这个工具写了上千行代码，还是挺满足的，理论上适用所有三套骨骼系统的 IKFK 切换，不过自己没有经过仔细验证，可能还有BUG&emsp;&emsp;后来我发现 ADV 其实自带了这些功能之后，就没有继续维护下去的动力，这个东西不了了之也挺惋惜的。]]></content>
      <categories>
        <category>回忆录</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【回忆录】 - 我的高中]]></title>
    <url>%2Fposts%2F40745d4d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近打算写一篇文章记录一下自己校招顺利拿到Offer的情况。&emsp;&emsp;但是写之前又想要重新总结一下自己整一个CG学习的心路历程，于是越写越长。&emsp;&emsp;后来干脆就额外开一个回忆录系列吧~&emsp;&emsp;这个系列属于自己写个自己看的，语言表达请见谅。 原点 &emsp;&emsp;中考的时候，很佛系地上了当地最好的重点高中，因为初中的学校只有学习，而高中就多了一些课外的活动。&emsp;&emsp;比如美术课、音乐课有分享，学校还举行科技节之类的活动，可以让大家发挥所长。&emsp;&emsp;刚好那个时候正值大圣归来上映的大环境，周围都充斥着国漫崛起的风气，我希望自己也可以在讲台上分享自己制作的动画。&emsp;&emsp;也算是为国漫的发展贡献自己的力量，或者直白一点就是想实现自己的中二妄想(/ω＼)&emsp;&emsp;然而那个时候我完全没有学习过画画，家里也没有任何懂行的人，于是我只能自己在网上搜索怎么制作动画。&emsp;&emsp;经过初步了解，我发现画画需要了解光影关系什么的，自己日漫的阴影线稿就觉得头皮发麻。&emsp;&emsp;于是我就尝试有没有其他方法可以解决这些绘画不行的问题，于是我找到了三维动画。&emsp;&emsp;三维动画渲染的时候阴影是通过渲染引擎自动生成出来的，可以解决我的问题。&emsp;&emsp;于是我就开始尝试自学三维软件，当时也不知道学什么软件，就直接在百度搜索排在前面的答案。&emsp;&emsp;那个时候也还没有那么多培训班以及相关的广告，我记得当时是去了 我要自学网 的网站开始自学 3dsmax&emsp;&emsp;但是后来越学就越枯燥，可能做教程的那个人做得不好吧，也可能是自己很迷茫吧。&emsp;&emsp;于是在网上搜索一些动画制作相关的知识的时候，很偶然的发现了 翼虎网 （现在已经更名为翼狐网）&emsp;&emsp;那个时候网站的首页就是 Digital Tutors - Maya2013 的全面入门教程，而且还有中文字幕，免费观看。&emsp;&emsp;第一集的介绍看到那个特别棒的飞船渲染就吸引住我了，于是我一口气将全集看完，还跟着做了一个乱七八糟的飞船模型(:з」∠)&emsp;&emsp;我就是从那个时候与 Maya 结缘。 &emsp;&emsp;后来就在翼虎网看其他相关的教程自学动画、渲染。&emsp;&emsp;以班级代表的身份参加了学校两年的科技节，也获得了二等奖和一等奖。&emsp;&emsp;到了高三之后就打住了，为了高考。 高一 | 高二 &emsp;&emsp;其实现在回头看自己高中的学习经历，其实是很不系统，全当兴趣玩着学的。&emsp;&emsp;因为没有任何人指导我，所以那个时候我就不知不觉地锻炼了自己的自学能力，特别是怎么通过搜索解决疑难问题。&emsp;&emsp;不过总得来说，我还是觉得自己学这些杂七杂八的东西都是对高中学习的逃避。&emsp;&emsp;感觉高中三年对学习的态度都特别佛系，也不算是不努力，只是完全没有竞争的压力、也没有让自己拼尽全力的感觉。&emsp;&emsp;别人考完试是对答案，出成绩就互相对分数。我考完试就放下了，不想再让这些东西成为自己心中的包袱。&emsp;&emsp;不过当然考好了会沾沾自喜，考差了也会不高兴，这都是人之常情吧。 &emsp;&emsp;其实那个时候自己也算是个奇葩了，因为受哥哥的影响，自己坚决不玩网络游戏，当然我那个时候也没有手机，没有手机游戏了。&emsp;&emsp;那些年英雄联盟真的非常火，然而我就是那个置之度外的人，一直坚守自己的单机阵地。&emsp;&emsp;所以自己非常孤僻，我成绩一般，和成绩好的同学交集不多。不打游戏，也不玩篮球，基本上算是班里非常特立独行的小人。&emsp;&emsp;Maya是我自己的兴趣爱好，也算是孤独的坚守，我那个时候连一起学习的同伴都没有o(╥﹏╥)o &emsp;&emsp;不过也算是典型的技术宅吧，因为学习一般，那个时候喜欢玩各种技术获取成就感。&emsp;&emsp;像PS、FL Studio、Flash、AE、绘声绘影，这些和学习无关的东西，我就特别喜欢去玩。&emsp;&emsp;最后也确实实现了当初做动画的目标，毕竟还获奖了，但是有多少东西是敷衍了事的，自己内心还是非常清楚的。 &emsp;&emsp;高中的学习经历其实真的非常感谢我的父母，他们从来没有反对过我学习这些东西。&emsp;&emsp;老实说他们也不懂这些东西，但是对于电脑的态度还是很宽松的，我基本上回家都可以让我接触电脑，无论是打游戏还是学习都不太管。&emsp;&emsp;我记得最初学习 3ds Max 的时候还特意挑父母不在身边的时候才看教程，印象特别深刻。&emsp;&emsp;晚上放学回家吃饭到晚自习的空当在家里自学30分钟，听着 Vincent 的 starry starry night 学习 3ds Max 。 &emsp;&emsp;现在每次听到这首曲子都能回想起当初偷摸着学习 3ds Max 的岁月，时间荏苒，人不再少年。&emsp;&emsp;其实为什么学习要偷偷摸摸的，反而打游戏的时候却光明正大的，我自己也说不上为什么。&emsp;&emsp;可能只是不想表现自己很努力学习的样子，然后扮猪吃老虎吧，也或许是不想打破自己一直都是打游戏的形象吧。&emsp;&emsp;我当时也有扪心自问过，后来终究还是觉得偷偷摸摸的学习时间太短了，我还是向他们公开了学习这些技术，然后就开始转学 Maya 了。 &emsp;&emsp;另外也非常感谢我哥哥的帮助，初中的时候受他影响，开始坚持使用扇贝背单词，这个一直坚持到大一6级的结束。&emsp;&emsp;尽管中间也有不少放鸽子的情况，但是的确让我的英语水平有了长足的进步，因为这个习惯，我高中的英语一直保持佛系学习也不会太差。&emsp;&emsp;到了大学才深刻体会到懂英语有多重要，特别是我从事的影视游戏行业、亦或者说编程也是一样的。&emsp;&emsp;虽然自己的英语语法很一般，不过我初中暑假就经历过每天背700个单词的计划，到高中都开始背四六级的单词了。&emsp;&emsp;因为这样的背景，我非但不排斥英文教程，而且会觉得很洋气，很高大上，这样才顺利搭上了 Digital Tutors 的教程学习 Maya&emsp;&emsp;不过也确实 Digital Tutors 的教程做得确实是很专业。&emsp;&emsp;我是到后来学会找资源之后才知道 Digital Tutors 每年都会出一部入门教程，而且教程内容基本是坐飞船的 (:з」∠) 一触即发 I一触即发 音乐彩蛋一触即发 II &emsp;&emsp;高一的学习其实还是集中 Maya 动画制作上面。&emsp;&emsp;到了高二之后虽然 Maya 学习没有那么上心了，但是的确也学习了很多乱七八糟的东西。&emsp;&emsp;比如说那个时候刚好有个班歌制作大赛，我那个时候也不知道是谁给的勇气，在完全没有乐理的基础之下，硬是打谱做了一曲。&emsp;&emsp;视频我就不放出来了，实在是太羞耻了，想看的可以查我的空间。&emsp;&emsp;那个垃圾国产软件名字都忘了，我记得当时在信息科技教科书上看到的，下载下来玩玩而已，反正对比 FL studio 真的垃圾得不行。 &emsp;&emsp;后面也学习了不少别的东西，比如 AE 后期剪辑，当时也是看翼虎网的中文教程学习的，以前都是绘声绘影剪辑的。&emsp;&emsp;第一次发现原来特效都是用这种东西做的，当时还小，还不知道有 Houdini 这种特效软件的存在。&emsp;&emsp;后面也有追 AK大神的教程，当时还借了别人做好的新闻联播模板改成了自己的片头。。。&emsp;&emsp;当时还想着组队做微电影的，不过结果黄了，ε=(´ο｀*))) &emsp;&emsp;最后 Flash 也接触不少，当时电脑老师的确是有教我们用 Flash 做动画的，后面还要交 Flash 作业。&emsp;&emsp;当时很多同学不知道作业怎么做，我就给他们一手操办了，一个人做了三份作业吧，有寓言故事的也有关于当时马航失联的。&emsp;&emsp;我自己做的Flash作业就是拳王格斗向的了，真的往事不堪回首了。&emsp;&emsp;当时看了 lynda 的教程，发现可以给图形添加骨骼，这才又后来做的火材人动画，毕竟我画画不行。&emsp;&emsp;现在回想起来， 这个 Flash 的 lynda 教程算是我第一次挑战纯英文的教程，意外发现 Lynda 的教程非常容易听懂。 一中Flash 高三 &emsp;&emsp;后来到了高三，因为学业的原因，我自己停止了 Maya 的学习，不过佛系地学习状态依旧是一成不变。&emsp;&emsp;那个时候经常考试，还经常考不好，放假了回家不是查漏补缺，而是玩 Fl studio，做音乐解压(/ω＼)&emsp;&emsp;不过我到现在了也没有学习过乐理，真的很业余。很业余。。很业余。。。&emsp;&emsp;我每每回想自己的高三都觉得不可思议，高三没玩Maya了，反而追《太阳的后裔》和《命运石之门》，书籍还看了《全职高手》和《三体》全集。&emsp;&emsp;主要是高三终于有了人生第一部手机吧，电脑玩少了，开始玩手机了，我记得那个时候还接触了开罗的游戏发展国，然后用了几天时间打通它，还有决战隐者村。&emsp;&emsp;因为太过佛系，好几次考试都只是徘徊在一本线上，不过家里人也完全没有给我压力，再不济也可以去我们当地的二本大学保底。&emsp;&emsp;这直接导致佛系的状态真的一直贯穿了我整个高中的学习历程 (´ο｀*))) &emsp;&emsp;后来高考结束之后，我还是保持自己一贯的作风，不对答案、也不和别人讨论分数。&emsp;&emsp;那个时候我们家还一起探讨了报专业的问题，我当时就很明确要进动画专业，要继续把Maya搞下去。&emsp;&emsp;结果网上一查才发现，不好意思，这个专业要艺术生才能报。如果不是艺术生，就只剩下三本和技校可以报了。&emsp;&emsp;因此当时只能找一些相关的专业，我又不想离开广东省，因此只找到了一个契合度最高的专业，广东工业大学 的 数字媒体技术 专业。&emsp;&emsp;当时我们所能查到的资料上，全广东省就只有广工有这个专业了。&emsp;&emsp;所以我什么都没想就拍板一定要去这个专业了，为此还和父母吵了一架。&emsp;&emsp;当时我确实对这个专业一无所知，只是从介绍上看到会学到一些动画相关的东西而已，不过我现在回顾，我觉得这个专业的确是最最最适合我了。&emsp;&emsp;确实这个专业什么都学，什么都学不精，经常被人诟病，不过里面要学的东西很多我高中就学过，真的是契合度最高了。 &emsp;&emsp;后来高考成绩出来了。&emsp;&emsp;也不知道到底是日积月累了，还是自己保持平常心了，亦或者是受到了幸运女神的眷顾了，我中考、高考都超常发挥了。&emsp;&emsp;中考自不必说，高考的确是让我吃惊了，居然高了一本线50多分。&emsp;&emsp;对于学霸来说，这分数也不算啥，在广东省连211都进不去，但我可是高考前经常发挥在一本线上的人(:з」∠)&emsp;&emsp;然而即便是如此超常的发挥，也仅仅是过了数字媒体技术专业分数线不到10分而已。&emsp;&emsp;真的一题不慎，我的人生轨迹都将完全不一样呢~ 上大学之前 &emsp;&emsp;虽然我有高中积累的基础，但是高三荒废了一年，其实也忘得差不多了。&emsp;&emsp;高考结束的暑假，我没有去做兼职、也没有去学车，而是待在家里打游戏度日。&emsp;&emsp;那个时候玩了看门狗、上古卷轴，玩到后面都腻了，天天就是打游戏、吃饭、睡觉的循环。&emsp;&emsp;于是到暑假的后半程，我开始接触魔法门3的wog版本，以前就是魔法门系列的忠实粉丝（不过我是个假粉，只玩过1、3、5、6，还是魔法门3玩得最多）&emsp;&emsp;wog是俄罗斯公司推出的魔改版本，推出了很多新的机制，新的事件。&emsp;&emsp;最厉害的是推出了游戏语言 erm ，这个神奇的语言就是我的启蒙语言了，神奇不神奇。&emsp;&emsp;虽然初中的时候有在网上接触VB，但是学习到函数的时候想到数学也有函数要学就弃坑了，所以回想起来 erm 真的是我最初的编程语言。 &emsp;&emsp;我当时还用这个语言写出了施放攻击加速动画然后攻击前方三个格子的攻击效果。&emsp;&emsp;回想起来非常感慨。&emsp;&emsp;现在想来已经三年多没有碰过这个东西了，其实我几乎都忘光了这个东西写起来是怎么样的，很多资料也因为旧电脑的硬盘损坏没了。&emsp;&emsp;我百度了一下，真的谢天谢地，wog论坛还活着，这个小众的游戏还有一帮中国人愿意去维护开发，真的很不容易，&emsp;&emsp;我翻起自己的旧号，重新找到当年学习用的erm手册。&emsp;&emsp;真的是很让人怀念的手册，这个东西还没有视频教程，当时全靠这个中文手册进行学习，真的很感谢手册的翻译人员，太不容易了。&emsp;&emsp;或许对于游戏的热爱就是这么神奇，没有人指导，遇到问题也几乎没有可以查询的地方，但是就是这样看着这个复古的API文档，我真的把效果做出来了。&emsp;&emsp;很可惜以前的代码估计已经没了，这里可以贴API文档教程里面的一些代码来感受一下这个神奇的语言。&emsp;&emsp;我现在看这个语言，虽然它有变量的存在，但还真的说不上是语言了，更像是一个配置文档。&emsp;&emsp;可惜上了大学之后就弃坑了，当时还想自己做一个 wog mod 来着的(:з」∠) &emsp;&emsp;另外那个时候翼虎网差不多更名成 翼狐网 的时候，还可以免费看很多 Digital Tutors 的英文教程。&emsp;&emsp;但是这些教程都是没有中文字幕，最初只是想装逼，试着看一个建模讲解的教程，看着看着感觉没有想象中那么困难。&emsp;&emsp;于是一下子就看完了，而且学习到了很多新的词汇和干货，感觉受益匪浅。&emsp;&emsp;这个为我日后翻译教程埋下了种子，也完全打消了看生肉的恐惧。]]></content>
      <categories>
        <category>回忆录</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode - MayaPy插件开发总结]]></title>
    <url>%2Fposts%2F4d164b82.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;VScode 扩展插件 MayaPy 已经发布在应用市场上&emsp;&emsp;在这里我会记录一下一路开发遇到的坑，关于插件的使用可以参考 仓库内的readme.md文档 &emsp;&emsp;7月因为要准备开发新生网站而因为下学期有数据库的实训要做，所以爆肝学习Vue.js&emsp;&emsp;哎。。。后来因为各种原因，新生网站不了了之了。&emsp;&emsp;到了8月为了能够入职大厂，开始爆肝 Unreal&emsp;&emsp;后来9月开始因为校招的settle down，unreal的学习就被搁置下来了。(果然还是得靠外力逼自己去学)&emsp;&emsp;在之后不久我就在网上找到了用 ptvsd 模块 在 VScode Debug python 代码的文章&emsp;&emsp;经过我自己摸索我也已经实现了文章的断点 Debug 效果，不过我想要简化设置的流程。&emsp;&emsp;另外也想实现更好的 Python 代码自动提示的效果，基于这些想法，开发一个自己的 VScode 插件就非常强烈了。&emsp;&emsp;于是 9 月份就花了很多时间在开发 VScode 插件上了。 Ptvsd 远程 Debug &emsp;&emsp;首先还是得先补充一下ptvsd是如何实现在 VScode 设置断点 Debug 的。&emsp;&emsp;这个包兼容 Python2 ，不需要安装就可以直接在 Maya 里面 import 使用。 &emsp;&emsp;可以先去到 github 下载仓库&emsp;&emsp;先将文件下载下来，可以将src目录下的ptvsd目录拿出来，导入到Maya。&emsp;&emsp;github的官网其实有python的启动代码。 12345import ptvsd# 默认情况开启 localhost:5678 端口ptvsd.enable_attach()# 可以传入元组来定义 地址和端口号ptvsd.enable_attach(('localhost',3000)) &emsp;&emsp;在Maya开启 ptvsd 模块之后，下一步就是利用 VScode 的 Python 模块进行连接。&emsp;&emsp;这里我们需要用到 Remote Debug 即 远程调试。&emsp;&emsp;VScode默认是带有这个 Debug 模式，按 F5 可以选择 &emsp;&emsp;可以选择开启 Remote Debug ， 不过直接点选可能会报错，因为没有开启相应的端口&emsp;&emsp;这里可以按 Esc 键，这样 VScode 会在当前的 workspace 下创建 lauch.json 文件&emsp;&emsp;json文件包含了 所有的调试设置，其中就有 远程调试 的设置内容 &emsp;&emsp;这里我们需要将 pathMappings 的属性修改一下，方便定位到测试文件目录。 &emsp;&emsp;为什么两个路径要设置成一样的？&emsp;&emsp;其实远程调试时用于给远程电脑进行调试使用的，不过我们其实是通过远程socket来访问Maya，因此两端都是在本地电脑上的。&emsp;&emsp;${fileDirname}可以定位到当前执行文件的目录上 &emsp;&emsp;下面只要在 Maya 里面开启 ptvsd 模块，就可以在 VScode 开启远程调试了。&emsp;&emsp;Maya开启 ptvsd 模块会出现命令行窗口闪烁出现的情况，这是正常现象。&emsp;&emsp;下面就可以开启 VScode 的 Debug 模式连接Maya了。 &emsp;&emsp;连接成功之后 VScode 会一直处于 Debug 模式，并且暂定调试的按钮会变成断开连接的按钮。&emsp;&emsp;这种状态说明已经成功实现连接了。 &emsp;&emsp;下面就是设置断点，并且在Maya执行当前文件&emsp;&emsp;只要Maya运行到相关文件，断点就会被触发。 &emsp;&emsp;更多操作截图可以直接参考我的插件介绍页面。&emsp;&emsp;这里主要讲解 ptvsd Debug 的操作，有利于理解后续插件如何实现自动 Debug&emsp;&emsp;关于Debug配置，我的插件也添加了自动补全的代码块，非常方便 VScode 插件开发 &emsp;&emsp;VScode插件开发主要基于 Typescirpt 语言，有微软开发并维护&emsp;&emsp;Typescript 就是 Javascirpt 的进阶版，将弱类型的js变成强类型语言，写法更加规范，现在越来越受到大厂的青睐。&emsp;&emsp;因为我之前有做过前端开发，上手 typescript 其实没有什么压力，基本按照 ES6 的要求来写，ts 和 js 已经很接近了。&emsp;&emsp;当然用 JavaScript 开发或者其他语言都是可以的，但是配置会比较麻烦。 &emsp;&emsp;开发第一步当然还是得从 hello world 教程开始，不过关于 VScode 开发网上并没有多少视频教程。&emsp;&emsp;因此只能依赖于官方的资料，不过好在很多插件都是开源的，也可以参考（借鉴）别人写好的插件进行学习。&emsp;&emsp;在开发的过程中，MayaCode 的插件就给了我不少的帮助。 &emsp;&emsp;在百度搜索 VScode API 可以找到 微软官方的插件开发入门的文档 &emsp;&emsp;根据官方教程认真阅读 Getting Started 的内容，基本就可以理解如何实现一个简单的 hello world 扩展了。 &emsp;&emsp;需要补充的是 VScode 的基于 Yeoman 作为项目脚手架，方便快捷生成不同类型扩展的模板。&emsp;&emsp;一个 VScode 扩展插件其实本质就是一个 npm 包，都需要用到 package.json&emsp;&emsp;而且 VScode 很多配置多需要写在 package.json 里面，也需要依赖 vscode 相关的 npm 包。&emsp;&emsp;之前因为看过 node.js 开发相关的教程，对于这一步的理解还是没有问题的。 &emsp;&emsp;最后推荐 VScode 官方维护的多个不同类型的小型插件案例 github仓库&emsp;&emsp;如果要开发不同类型的插件，这里的简单案例可以更快理解清楚要如何配置和开发。 &emsp;&emsp;另外遇到一些开发问题要如何解决呢？&emsp;&emsp;这个时候就是 面向Stack Overflow开发的时候了，&emsp;&emsp;这个编程社区实在是太有用了，尽管关于 VScode 开发的问题数量不多，但是我的需求基本都能找到相关的问题来解决。 &emsp;&emsp;点击 vscode-extensions 标签可以将问题范围锁定在 VScode 开发上。&emsp;&emsp;然后再去找有回到绿色的问题去查看相关的问题解决方案，有官方维护人员在上面作答，还是挺不错的。&emsp;&emsp;有时候找不到想要的答案也可以在 bing 上搜索，说不定 github 的 issue 也有相关的解决方案。 MayaPy 开发之前 &emsp;&emsp;其实 MayaPy 的开发可谓是一波三折，在开发这个插件之前，&emsp;&emsp;其实我还弄了一个 MayaDev 插件的开发方案，当时是想要不依赖于 Python 插件来实现自动补全。&emsp;&emsp;大家也可以去查看 MayaDev 的 github仓库，不过我暂时已经放弃开发这个项目了。&emsp;&emsp;为啥我想要跳过 Python 插件来实现补全？&emsp;&emsp;其实我在自动补全的文章里面就吐槽过，VScode 的自动补全生成实在是太慢了，经常会陷入 loading 的状态。&emsp;&emsp;这主要归咎于 Maya 各种库的模块实在太大，生成补全列表需要花费很多时间去加载。&emsp;&emsp;不过最让人诟病的是缓存记载没有弄好，因此每一次自动补全都需要等上十几秒，&emsp;&emsp;这种开发体验是不可忍受的，因此我打从一开始就打算自己来实现自动补全效果。&emsp;&emsp;而且官方的 VScode example 中也有相关的自动补全案例，所以我就铆足了劲去开发这个插件。&emsp;&emsp;而且MayaCode这个插件也实现了 Mel 语言的自动补全，因此有可以借鉴学习的案例，我觉得自己实现自动补全问题不大。 &emsp;&emsp;我当时分析过 Python 插件加载缓慢的原因，主要是因为补全列表是动态生成的，毕竟模块的内容可能有变更。&emsp;&emsp;因此补全列表每次补全都需要读取相关的补全代码来确认是否有变化。&emsp;&emsp;但是其实对于Maya的模块来说是不必的，因为Maya模块都是写好的 API ，而且内置的都是闭源的（除了pymel），想要修改也做不到。&emsp;&emsp;因此我的想法是直接在插件加载的时候就将相关的数据加载到内存当中。&emsp;&emsp;后续调用只需要获取内存中的数组就可以了，果然这个触发的速度就非常的快。&emsp;&emsp;但是在什么地方触发相应的补全又难倒我了，最开始我在弄 cmds 补全，这个其实非常好弄，因为是 MEL 语句转过来的&emsp;&emsp;没有那么多类、返回值的补全，只需要用正则匹配到 cmds 对应的变量名称就可以了。&emsp;&emsp;因此我当时是实现了 cmds 的快速自动补全的，而且基于这个生成的 自动补全 还可以让用户设置显示的内容，可以说是非常灵活。&emsp;&emsp;但是当时遇到了一个不知道怎么解决的问题，我想要将 文档 的 网址链接显示出来并且保留可以超链接的状态。&emsp;&emsp;然而当时却没能在 completionItem 里面实现这个效果。。。 &emsp;&emsp;最大的打击要算是写 OpenMaya 补全的时候，我发现 OpenMaya 有很多类，这个时候正则匹配已经远远不够了。&emsp;&emsp;我需要实现变量的追踪，这样才可以有正确的代码补全。&emsp;&emsp;为了解决这个问题，我特意研究了 Jedi 自动补全模块的代码，想弄清楚这个牛逼的自动补全是怎么实现的。&emsp;&emsp;当时有用断点简单测试过 Jedi 模块，不过 Jedi 的底层逻辑非常绕，因为他需要遍历代码，逐一生成代码树。&emsp;&emsp;Jedi内部定义了许多不同类型的 类 来区分不同代码代表的东西，这个东西非常难，我当时简单测试了一下，感觉要写成 Typescript 简直难于上青天。&emsp;&emsp;如果是用 Python 外调 Jedi 模块，那就和 Python Extension 所实现的自动补全是一样的，我担心还是会出现性能问题。&emsp;&emsp;于是到这里我开始研究 Extension 的依赖，因为既然 Python Extension 已经实现了自动补全的功能，难道就没有相关的 API 来调用这些补全状态吗？&emsp;&emsp;不过结果是令人失望的， Python Extension 只保留了两个 API，可以在源码中找到。 &emsp;&emsp;buildApi 函数会在 activate 函数作为返回值，activate 的返回值就是当前插件返回可调用的 API.&emsp;&emsp;最后是暴露了 ready 和 debug 两个函数&emsp;&emsp;ready返回 Promise 对象用来触发插件完成加载之后的代码&emsp;&emsp;debug则是返回 ptvsd_launcher.py 文件的执行参数，还需要在 node.js 里面外调 python 进行执行。&emsp;&emsp;所以这里并没有补全相关的 API (:з」∠) &emsp;&emsp;这个时候我开始动摇了，因为这样开发下去， OpenMaya 的自动补全将会是非常大的工作量，感觉没必要搞到这么复杂。&emsp;&emsp;既然插件的依赖都研究了，何必就直接使用 Python 的 自动补全效果呢？&emsp;&emsp;说不定就真香了。。。 &emsp;&emsp;不过我还是没有放弃，既然 Python 解析很可能效率低，而且等于重复实现 Python Extension 所做的东西，没有意义。&emsp;&emsp;难道 npm 就没有相关的 代码 解析的模块吗？&emsp;&emsp;没想到我真的找到了一个解析代码的模块 tree-sitter&emsp;&emsp;它其实就是一个语法树生成器，毕竟跨语言处理，也就只能实现将语法进行对应划分，类似Jedi的自动补全是没有的，但是辅助我实现自动补全绰绰有余了。&emsp;&emsp;可以去 tree-sitter 的 playground 查看代码语法树的生成效果，我觉得这个方案还是可行的。 &emsp;&emsp;而且 VScode 也有一个插件是基于 tree-sitter 的，简直是最好的教材。&emsp;&emsp;在这里还学习到了 wasm 文件格式，一种编译成二进制的js文件，牛逼有木不有！ &emsp;&emsp;然而我始终还是逃不过真相定律。。。&emsp;&emsp;我平时在公司开发代码的时候也添加了自动补全，只是因为太慢，一直都是手打的。&emsp;&emsp;另外由于公司是断网的，因此我用不了微软官方的 Python Language Server 只能退而求其次使用 Jedi 补全。&emsp;&emsp;最近突然发现 pymel 的自动补全挺快的，明明 pymel 还有大量的说明，我开始疑惑为啥 cmds 的补全明明就没啥说明，咋就这么慢呢？&emsp;&emsp;我研究了 pymel 的补全结构发现是将模块拆成多个文件的形式，而官方的 cmds 就直接将上千个函数放到了一个文件里面。&emsp;&emsp;于是我花了一些时间将 cmds 切分成多个文件，奇迹出现了，cmds的补全明显加快了。&emsp;&emsp;这个时候真香开始了，我发现解决 cmds 的问题之后，在Jedi模式下只要经过最初的加载，后续的补全都挺快的，最多也就是等 1、2 秒&emsp;&emsp;嗯，想到 tree-sitter 浩大的工程量，我还是妥协了。 &emsp;&emsp;于是全新的 MayaPy 方案才正式起航，这个过程真的是一波三折。 MayaPy 开发 &emsp;&emsp;经过前面各种瞎折腾，我开发这个插件的时候目标就已经很明确了&emsp;&emsp;我不打算取代现有的插件，而是在现有的插件上做得更好&emsp;&emsp;因此我的插件就直接依赖了 MayaCode 和 Python 两个插件。&emsp;&emsp;MayaCode 给我解决将代码发送到 Maya 以及 Mel 处理的问题。&emsp;&emsp;Python 插件给我解决自动补全的问题。 &emsp;&emsp;剩下的坑就涉及到 VScode 开发的坑了。&emsp;&emsp;在这里真的很感谢 MayaCode 提供的 logger 方案，可以直接将信息输出到对应 output Panel 上&emsp;&emsp;如果用 console.log 的话，估计找输出得累死我了。 Python 模块修改属性 &emsp;&emsp;Python 的自动补全其实非常好解决，只需要将补全代码的路径添加到 extraPath 设定里面就可以了。&emsp;&emsp;我可以设置成每一次激活插件就查询属性是否有相关的补全路径，如果没有就插入补全路径更新 json。 &emsp;&emsp;获取路径这种操作不难， node.js 提供了 Path 模块，操作基本和 Python os.path 类似。&emsp;&emsp;问题是如何更新 setting.js ，我一度以为要用 fs 模块将数据写入到 setting.js 里面&emsp;&emsp;后来才发现 update 函数可以完成这个操作。 MayaCode 与 Maya 交互 &emsp;&emsp;下面要实现如何自动完成 Ptvsd 模块加载并且开启 Debug 的方案。&emsp;&emsp;这个过程也是相当曲折，最后确定下来的方案是这样子的 先通过 socket 检测 maya 7001 端口是否开启 socket 检测 ptvsd 模块是否开启 判断是否已经处于 远程调试 模式 如果上面操作都完成则将执行当前文件的代码 &emsp;&emsp;MayaCode 可以利用 socket 将代码发送到maya进行执行，因此我方案是触发命令的一瞬间生成一份加载 ptvsd 模块的python代码发送到Maya进行ptvsd激活。&emsp;&emsp;而且 ptvsd 模块不需要安装也可以使用，因此只需要定位路径并且 import 就可以在 Maya 里面激活。&emsp;&emsp;因此我在插件包里面内置 ptvsd 模块，然后用下面的代码自动定位到相应的为位置执行。 &emsp;&emsp;这里遇到了不少坑！！ 如何在执行命令的时候获取当前文件的路径 &emsp;&emsp;我在网上搜索到的时在回调函数的参数上返回相应 uri 路径 &emsp;&emsp;然而这个 uri 参数只有在右键菜单下才会传入，如果是敲 ctrl + P 的命令行则没有任何参数返回。&emsp;&emsp;这我就没办法直接执行命令来获取文件路径了，最后我只好在 package.json 文件配置上去掉命令行的显示。&emsp;&emsp;后来我在研究 Python Extension 的源码的时候 偶然发现 document.uri 选项&emsp;&emsp;而 document 可以通过 vscode.window.activeTextEditor 来获取，这样就完美解决我的需求。 maya 端口 socket 检测后 端口被占用 &emsp;&emsp;最初socket测试我参考了 MayaCode 的内部代码，通过 net 模块 createConnection 进行访问，&emsp;&emsp;Maya 的端口是否开启正是通过这个方法，&emsp;&emsp;但是检测完成之后就会发现 mayaPort 一直被占用，再也无法通过 MayaCode 将可执行代码发送到 Maya 里面了&emsp;&emsp;这个问题还卡了我好久，因为这个占用导致的结果是，MayaCode 一直显示代码在发送，但是一直没有数据返回，Maya也没能够执行代码。&emsp;&emsp;后来我是看到 MayaCode 内部使用了 destroy 方法才明白，这个 Connection 会一直连接&emsp;&emsp;导致后面 MayaCode 发送代码的时候无法连接上了。因此后续都加入销毁 这个连接的操作. ptvsd socket检测报错从而切换到不同的端口。 &emsp;&emsp;最初检测 ptvsd 模块是否开启也是使用了上面的 createConnection&emsp;&emsp;但是ptvsd的端口一旦被非法访问，就会直接报错，并且自动生成一个新的端口。&emsp;&emsp;这让我无法检测 ptvsd 端口到底在哪里开启了。&emsp;&emsp;于是我只好查 Python Extension 的源码，看看它是如何实现代码 交接 的&emsp;&emsp;最后在 RemoteDebugServerv2.ts 找到了内部的连接方案， &emsp;&emsp;他是通过 socket.connect 的方式进行连接测试。&emsp;&emsp;通过这个方法的确可以判断 ptvsd 模块是否开启了。 &emsp;&emsp;如果被拒绝说明没有开启，可以发送开启代码&emsp;&emsp;如果没有被拒绝，则说明已经开启了。 发送代码必须保存到本地 &emsp;&emsp;这个坑是最坑的，我当时开发 Extension 的时候是打开一个 Untitle 文件，然后利用 MayaCode 发送代码的&emsp;&emsp;因此也理所应当需要关闭临时打开的文件，我在 插件开发模式下 关闭文件是不会弹出是否保存的文件的查询的。&emsp;&emsp;因此我开发很顺利，直到我发布到线上了，一测试才发现居然还有这种BUG。&emsp;&emsp;所以最后只好参照 MayaCode 的实现方案，在 os.tmpdir() 的系统临时目录里添加 python 代码文件。 ptvsd连接文件 和 代码执行文件必须分开 &emsp;&emsp;本来我打算两个执行代码都写在一个文件里面实现的。&emsp;&emsp;没想到这样的话，第一次开启 ptvsd 是没有问题的，但是第二次执行命令的时候仍然还是执行 ptvsd 激活的代码。&emsp;&emsp;这里实在搞不懂为什么，我想到可能是还没有写入文件数据就执行了文件，因此代码还是上一次的代码。&emsp;&emsp;于是我加入了删除机制，每次执行完之后就删除文件，然而还是存在同样的问题。&emsp;&emsp;没有查到问题到底是出在哪里的，但是将代码执行分成两个文件就可以解决这个问题。&emsp;&emsp;于是我最后还是无奈分成两个不同的文件进行保存。 VScode 的 message 无法换行 &emsp;&emsp;VScode 内置的在右下角显示消息的窗口不知道如何实现代码换行&emsp;&emsp;试验了 \n 和 &lt;br&gt; 换行都不可以，最后只好估摸着文字的长度来换行 (:з」∠) MayaPy 发布 &emsp;&emsp;最后插件开发完成之后就是激动人心的发布到应用市场的环节了。&emsp;&emsp;发布到应用市场，人人都可以使用我开发的插件，这种感觉真的美滋滋~&emsp;&emsp;发布和打包插件其实也是有官方文档的，照着做就可以了。 &emsp;&emsp;安装了 vsce 模块之后就可以本地打包自己的插件也可以注册之后将插件发布到线上。&emsp;&emsp;可以通过 .vscodeignore 实现打包过滤无关的文件，减少打包文件 .vsix 的大小。 总结 &emsp;&emsp;历时半个月的插件开发，差不多就结束了。&emsp;&emsp;插件目前还需要加强自动补全的功能，基本的需求都已经完成了。&emsp;&emsp;真的非常感谢 开源 的 VScode ，很多模块不懂也可以查看别人插件的代码进行摸索。&emsp;&emsp;如果大家对插件有什么建议和想法的，欢迎到 Github 的仓库发布 issue ，也可以通过 820472580@qq.com 邮箱来联系我&emsp;&emsp;希望这款插件能够对大家有帮助！~]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记 Unreal 官方 - Water Pack Overview]]></title>
    <url>%2Fposts%2F9915f9db.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;没想到上次分析水弄得太长了。&emsp;&emsp;所以就单独将官方的水材质弄一篇文章进行讲解。&emsp;&emsp;结合 官方素材的水 以及 Udemy - Unlocking the Unreal Engine Material Editor 教程的水 M_LakeWater 湖水材质解析 &emsp;&emsp;上图就是官方水材质的属性连接&emsp;&emsp;其实水的制作都大同小异。&emsp;&emsp;比如法线贴图的处理都是一样的。 &emsp;&emsp;官方使用了 Motion_4WayChaos_Normal 的材质函数来处理动态效果&emsp;&emsp;这个函数内置在 Unreal 引擎里面，不过并没有开放到函数库当中。 &emsp;&emsp;可以到 Unreal 引擎的安装目录找到这个函数。 &emsp;&emsp;打开函数可以看到其实使用了 四个方向不同的偏移叠加到一起形成水动态效果 &emsp;&emsp;值得注意的是使用了 AbsoluteWroldPosition 节点，这样物体的偏移和世界坐标相关联&emsp;&emsp;好处就是如果两个相同材质的平面可以无缝衔接。 &emsp;&emsp;基本原理是一样的&emsp;&emsp; power 节点用来降低灰度的亮度，因为小数的平方只会更小。 &emsp;&emsp;power的值足够大可以让贴图变得黑边分明。 M_OceanWater 海洋材质置换效果 &emsp;&emsp;这次加入了置换贴图的效果 &emsp;&emsp;这个节点大概可以细分为三大模块&emsp;&emsp;看起来很复杂，其实稍微结构之后重复的节点很多的。 &emsp;&emsp;法线贴图上两个方块内的节点大部分是相同的。&emsp;&emsp;下方的方框代表大波涛的效果，上方是小波涛的效果。&emsp;&emsp;大波涛只是多了一个 Rotator 节点来增加细节&emsp;&emsp;完全可以合并成一个 Material Function 来弄得。 &emsp;&emsp;置换贴图也是如法炮制，节点的连接和大波涛的连接一样的。 海水颜色 &emsp;&emsp;颜色设置这里就大有学问了 &emsp;&emsp;我大致将整理了一下&emsp;&emsp;这里用到 switchNode(青色的节点) 来分离效果，因此连接也比较混乱 &emsp;&emsp;我们往上看&emsp;&emsp;首先红框上的三个节点都是 switchNode 节点&emsp;&emsp;用户可以勾选来触发更多选项，默认都是不勾选的。&emsp;&emsp;因此只有黄色框框的部分是连接起来的。 &emsp;&emsp;通过菲涅尔输出海水的颜色，效果更加真实。&emsp;&emsp;菲尼尔效应可以查看这个视频链接&emsp;&emsp;简单地说就是光线入射角(于接触平面形成的夹角)越小，物体的反光越强，入射角越大反光越弱。&emsp;&emsp;上面小视频也可以看到，当角度越小黑白越分明，角度越大就几乎纯白了。 &emsp;&emsp;normalize 节点是向量归一化节点，是将向量转换为单位 1 保留自身方向的操作。&emsp;&emsp;TrasnfromVector 则是将 tangent space 转换为 World space&emsp;&emsp;tangent space 是基于物体空间而 world space 反之。 &emsp;&emsp;由此就将法线贴图转换带菲涅尔的灰度图。 &emsp;&emsp;最后颜色输出的效果如上图 反射贴图 &emsp;&emsp;下面来讲解发射效果，因为比较简单好讲&emsp;&emsp;反射加上去就像在水面上贴了一层膜，其实这个反射是假反射&emsp;&emsp;因为这个反射需要 CubeMap 环境贴图来伪造出天空效果。 &emsp;&emsp;主要是靠 RefelectionVector 获取反射效果的UV&emsp;&emsp;连接到贴图上就有种贴图带来的镜面反射的质感。 荡漾的泡沫 &emsp;&emsp;默认FoamDistortion属性为零，因此这里的连接就和波浪的连接一样的。&emsp;&emsp;但是如果不为零就复杂了。 &emsp;&emsp;我们可以看到这张波浪贴图的RG通道上的效果&emsp;&emsp;这和传统意义上的 TextureCoordinate 输出的 UV 空间扭曲了多少 &emsp;&emsp;这种意义不明的扭曲叠加直接做出了泡沫丛生的贴图。 &emsp;&emsp;最后就是将置换贴图的效果提取出来，增加对比度。 &emsp;&emsp;中间部分的这些节点都是为了混合泡沫节点的效果。&emsp;&emsp;置换的效果限制一层&emsp;&emsp;菲涅尔法线的效果再限制一层&emsp;&emsp;所以最后泡沫出现的地方都是波浪很高而且需要较高角度才能看到。 M_TranslucentWater 透明水材质 &emsp;&emsp;其实透明水材质的波涛设置和都是使用了四象波涛，基本原理是一样的。&emsp;&emsp;重点在于透明效果的实现 &emsp;&emsp;这里的透明材质采用了不同于 Udemy 课程的实现方法&emsp;&emsp;Udemy是使用相减，而官方水素材则是使用了相除，我特意做了一个测试材质进行验证。 &emsp;&emsp;使用相除的效果 &emsp;&emsp;相除的特点在于越靠近水面，白色的区域就会越多，而相减的效果则趋向于平静。&emsp;&emsp;也就是说相除的效果会产生，越靠近水面越清澈，越远离水面越朦胧的效果。 &emsp;&emsp;不过最后会乘上世界坐标减去摄像机坐标的数值，所以最后呈现的结果其实和 Udemy 教程实现的效果相似]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记 水材质制作 Unlocking the Unreal Engine Material Editor]]></title>
    <url>%2Fposts%2F99ca25ca.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这一次填上之前留下说分析水制作的坑。&emsp;&emsp;结合 官方素材的水 以及 Udemy - Unlocking the Unreal Engine Material Editor 教程的水&emsp;&emsp;总结一波关于水制作的一些知识点。 水的基本形态 &emsp;&emsp;制作水最重要要实现波光粼粼的波浪效果&emsp;&emsp;而这种效果毋庸置疑要用到panner节点对贴图进行偏移 &emsp;&emsp;这里使用 法线贴图 分别朝向不同方向进行偏移 &emsp;&emsp;贴图在不同方向上的偏移就有了湖水荡漾的效果&emsp;&emsp;毕竟法线贴图只是扭曲了光线，无法挪动模型上的顶点，因此置换贴图制作起伏才能让效果更加真实。 &emsp;&emsp;同样使用法线贴图相似的偏移值制作荡漾，最后乘以起伏系数方便后面调整波浪高度。 &emsp;&emsp;将上面的法线贴图连接到 Normal 上，置换贴图连接到 World Position Offset 上 &emsp;&emsp;基本上水的 7 成效果已经完成了。 &emsp;&emsp;更进一步的制作需求有两点 物体接触到水的泡沫 水底下的效果 接触泡沫 &emsp;&emsp;根据上期教程的 Hologram 全息投影材质制作就可以知道。&emsp;&emsp;要制作物体接触产生的效果需要用到 DistanceToNearestSurface 节点&emsp;&emsp;这个节点需要配合 AbsoluteWroldPosition 节点一起使用。 &emsp;&emsp;可以看到如果直接使用到颜色通道上的效果是白茫茫一片的，&emsp;&emsp;因为这里生成的数值太大了，需要除以一个系数才能看到效果。 &emsp;&emsp;可以看到物体接触得区域都有了黑色的过渡渐变了&emsp;&emsp;我们可以将效果翻转实现接触处的区域为白色，不接触的地方为黑色。 &emsp;&emsp;经过限制数值范围以及 1 减数值的操作之后就可以看到上面的效果。 &emsp;&emsp;可以将前面的数值水波叠加回去就可以生成上面的效果。 &emsp;&emsp;下面我们可以优化泡沫的效果&emsp;&emsp;添加一张泡沫贴图并让贴图进行偏移 &emsp;&emsp;将泡沫效果和边缘的效果叠加到一起 &emsp;&emsp;泡沫效果已经出现在沿岸的区域了，但是效果很假，很明显地可以看到有黑白过渡的效果。&emsp;&emsp;因此这里需要用 HeightLerp 节点让灰度图的过渡更加真实。 &emsp;&emsp;可以看到泡沫的过渡自然了很多&emsp;&emsp;那到底 HeightLerp 在这里实现了什么操作呢？ &emsp;&emsp;其实 HeightLerp 就是让过渡贴图和高度贴图混合，让过渡更加自然。&emsp;&emsp;那 A 和 B 有分别代表了什么呢？ &emsp;&emsp;其实 A 和 B 代表了过渡贴图的 取值区间范围 &emsp;&emsp;打开 HeightLerp 节点可以看到就是 Lerp 节点上的两个值。 &emsp;&emsp;因此如果A 和 B 的数值对调就可以实现反向取值 &emsp;&emsp;最后按照教程的数值调整到 0.1 - 0.7 的区间&emsp;&emsp;需要注明这里的过渡贴图是根据接触模型产生的，&emsp;&emsp;因此不到0是因为 0 - 0.1 是湖中心的区域了，0.7 - 1则是很靠近岸边了，这些区域都按照边界取值即可。&emsp;&emsp;也就是说 0 - 0.1 的区域为黑色没有效果，0.7 - 1 的区间为白色，全部效果&emsp;&emsp;最后贴图将粗糙度也连上可以增强水的质感。 &emsp;&emsp;可以看到，做到这里的效果已经很棒了。&emsp;&emsp;加入粗糙度之后水的反光质感出来，真的真实了很多。&emsp;&emsp;湖面远处也有了波光粼粼的感觉。 水底下的效果透光 &emsp;&emsp;要制作水底下的效果首先要获取到模型下面的湖底的图像&emsp;&emsp;然后再根据这里的图像进行处理&emsp;&emsp;我们需要用到 ScreenPosition 和 SceneColor 连个节点配合使用 &emsp;&emsp;要制作透光效果，需要将材质转为 translucent 透明材质&emsp;&emsp;否则使用 SceneColor 会出现报错 &emsp;&emsp;转成 translucent 之后会导致 粗糙度 等材质效果失效 &emsp;&emsp;因此还需要设置一下 Light Mode 为 SurfaceTranslucencySurface 这样属性就会回来。 &emsp;&emsp;我们可以复制一个 HeightLerp 节点将过渡贴图和泡沫都保留&emsp;&emsp;靠岸的的地方添加偏太阳的颜色，让岸边的泡沫偏暖色。&emsp;&emsp;最后湖水不靠岸的地方连接 ScreenPosition 以及 SceneColor ，就可以生成上图所示的透光效果。&emsp;&emsp;ScreenPosition 可以获取屏幕上的UV空间， SceneColor则可以获取到屏幕上的像素。&emsp;&emsp;这两个一结合就可以获取到湖水之下的像素，并且叠加到湖面上。&emsp;&emsp;这样就形成了一种清水的透光效果。 &emsp;&emsp;或许 ScreenPosition 和 SceneColor 节点的行为依旧让人疑惑，&emsp;&emsp;我们来具体分析这两个节点的效果。 &emsp;&emsp;这个效果就是材质直接连接 SceneColor 节点的效果&emsp;&emsp;可以看到材质就像玻璃一样自带透明，因为 SceneColor 可以获取到透明物体背后的像素 &emsp;&emsp;其实 ScreenPosition 可以不连接到 SceneColor 的UV上&emsp;&emsp;因为 SceneColor 默认就已经是 屏幕UV ，官方文档上有说明。 &emsp;&emsp;如果使用 TextureCoordinate 连接到 SceneColor 上就会有上面神奇的效果。 深不见底 &emsp;&emsp;下面要实现湖中央深不见底的效果。&emsp;&emsp;首先需要计算摄像机到湖底的深度来判断深浅。&emsp;&emsp;这需要用到 SceneDepth 和 PixelDepth 两个计算深度的节点。 &emsp;&emsp;SceneDepth 类似于 SceneColor 都是获取透明材质背后的东西&emsp;&emsp;因此也必须要透明材质才可以使用 &emsp;&emsp;除以一个数值之后就可以看到材质背后物体的深度了。&emsp;&emsp;可以看到较浅的地方呈现灰色，较深的地方呈现白色。 &emsp;&emsp;PixelDepth 则是计算材质到摄像机的深度&emsp;&emsp;从上图就可以很好体会到，摄像机越靠近颜色就越深。 &emsp;&emsp;通过这两个效果相减就可以计算出湖底到湖面的距离&emsp;&emsp;教程给截图就很好的说明了这一点。 &emsp;&emsp;这样搭建会看到效果恰恰和我们所想的相反&emsp;&emsp;越靠近湖心就越白了，因此需要 1减 节点来翻转，可以顺便再叠加个湖心的深蓝色效果。 湖水折射 &emsp;&emsp;湖水折射效果是希望光线穿过湖水之后能够让底下的纹理有荡漾的感觉。&emsp;&emsp;要实现这个效果就需要通过 UV 偏移来实现。&emsp;&emsp;我们需要将湖水的 panner 效果叠加到 SceneDepth 和 SceneColor 的UV上&emsp;&emsp;这样他们呈现图案就是带偏移的。 &emsp;&emsp;如果直接将 panner 节点连接上去就是上图的效果，显然有点变形过渡了。&emsp;&emsp;因此这里需要连接一张 折射贴图 来减弱效果 &emsp;&emsp;这里使用 lerp 节点 -1 和 1 是为了增强贴图的对比度，让折射的区域更加分明一些。&emsp;&emsp;将 ScreenPosition 拆分可以实现往一个方向的偏移运动 &emsp;&emsp;最后将这些 SceneDepth 和 SceneColor 的UV都连上就大功告成了。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记 Udemy - Unlocking the Unreal Engine Material Editor]]></title>
    <url>%2Fposts%2F11d100be.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近深刻感觉到自己的学习不太在状态，需要重新调整状态，然后好好学习才行。&emsp;&emsp;这次教程总结算是拖更了，本来应该更快完成的。 Udemy - Unlocking the Unreal Engine Material Editor 材质编辑器基础讲解 &emsp;&emsp;这个教程的第一部分介绍了材质编辑器很基础且很常用的节点&emsp;&emsp;比如 multiply subtract add 等等&emsp;&emsp;也讲解了材质上可以连接的几个属性的意义。 多重UV叠加材质 &emsp;&emsp;当我们使用纹理来提高细节的时候，我们经常会添加 UV 重复来添加更多细节。&emsp;&emsp;但是如果贴图属于不可重复的贴图再添加 UV 重复会导致方格贴图的出现。&emsp;&emsp;如何才能让贴图的重复更加自然呢？&emsp;&emsp;教程就给出了一种解决方案。 &emsp;&emsp;通过不同UV重复叠加的方式制作不重复纹理 &emsp;&emsp;在不重复的纹路上叠加金属 铝 的颜色 &emsp;&emsp;其他属性的连接方式都很常规 无缝投射贴图材质 &emsp;&emsp;在复杂的模型上，如何在不考虑UV的情况下将将贴图完美贴合到物体上呢？&emsp;&emsp;投射就是一个很好地解决方案。 &emsp;&emsp;对三个轴同时进行投射，然后再将边缘部分混合到一起就可以创建出完美贴合的贴图 &emsp;&emsp;这种贴图称之为 TriplanerProjection 三平面投射 &emsp;&emsp;这种贴图有个缺点就是贴图是按世界坐标给的，如果物体旋转的话，纹理是不会发生变化的，因此只适合在静景中使用这个材质，不过正因为这样也为后面做积雪埋下伏笔。&emsp;&emsp;如果要给这种静景添加动画就需要将贴图烘焙出来使用了。 &emsp;&emsp;将三平面投射做成一个 MaterialFunction 方便后续贴图复用这种投射效果 &emsp;&emsp;那么如何才能在 Unreal 中实现贴图投射呢？&emsp;&emsp;首先需要有相关模型的渐变图，然后只要将渐变图连接到UV通道上就可以实现投射。&emsp;&emsp;当然渐变也不是说就线性渐变可以实现的，必须根据模型的空间坐标生成的渐变图才可以的。&emsp;&emsp;因此根据这样的要求，我们可以利用 AbsoluteWroldPosition 节点获取模型当前的空间坐标的 &emsp;&emsp;通过节点的说明可以看到这个节点可以作为贴图坐标来使用。 &emsp;&emsp;连接这个节点之后，材质球会有相应的颜色，但是颜色过强了，我们可以除以500来看看颜色效果。 &emsp;&emsp;这个颜色质感的感觉就非常像 TextureCoordinate 节点的渐变颜色效果。 &emsp;&emsp;但是如果其实两者的颜色过渡是有区别的， TextureCoordinate 给的是二维的颜色渐变&emsp;&emsp;而 AbsoluteWroldPosition 获取的三维的颜色渐变。&emsp;&emsp;那么 AbsoluteWroldPosition 应该也可以像二维的 TextureCoordinate 分离出对应的渐变图。&emsp;&emsp;因此也是用 mask 来提取渐变，不过这次的三维渐变不是二维的UV上的，而是三维的空间上的。 &emsp;&emsp;通过 maskComponent 节点我们的确可以分离出模型三个轴向上的渐变图 &emsp;&emsp;不过要实现贴图投射一个轴向还不够，贴图的UV是两个轴向的，因此需要传入平面来定义投射的方向 &emsp;&emsp;这样就实现了不同轴向上的贴图投射了。&emsp;&emsp;问题是如何将这三个投射混合到一起，实现无缝拼接呢？&emsp;&emsp;同样我们也需要相关的渐变图来实现。&emsp;&emsp;但是这一次我们不可以使用 AbsoluteWroldPosition 节点了，否则渐变贴图不是物体坐标会无法实现混合效果。 &emsp;&emsp;因此这里需要使用 VertexNoramlWS 节点来达到目的。 &emsp;&emsp;你会发现这个贴图的效果，基本上就和 AbsoluteWroldPosition 除以 500 之后的效果差不多的。&emsp;&emsp;注：我发现这个效果差不多只有在球形的时候是，如果是方块面片，着色效果都是不一样的。&emsp;&emsp;不过呢这里也不可以用 AbsoluteWroldPosition 节点来替代，否则生成的岩石纹理是不对的。 &emsp;&emsp;通过 maskComponent 节点也可以分离出相应的渐变贴图。&emsp;&emsp;不过这一次我们需要解决贴图投射的融合问题，因此也不需要单纯的渐变贴图。 &emsp;&emsp;我们需要这种效果的贴图，其实也只不过是 abs 将黑色的部分也变成白色，中间会有黑色的过渡区域，通过 Power 可以控制黑色区域范围。&emsp;&emsp;你可能会很疑惑，为啥 power 节点可以控制黑色区域的范围？ &emsp;&emsp;其实通过 if 节点输出值就可以看到贴图输出的是完完全全的 0 - 1 渐变图&emsp;&emsp;那么小数经过 power 之后会变得更小，更加趋向于 0 ，因此黑色的区域就会变得更多。 &emsp;&emsp;最后一步其实就是将这些投射根据渐变效果混合到一起。&emsp;&emsp;弄成一个材质函数的好处在于方便复用生成的方法 积雪岩石材质 &emsp;&emsp;根据之前做好的三面投射效果可以轻松做出雪的贴图。&emsp;&emsp;另外雪需要开启次表面散射效（subsurfaceScattering）效果来增加透光效果，从而让雪的的质感更加真实。&emsp;&emsp;什么是 次表面散射 呢？通常我们会简称为 SSS 三S模型 ，可以参照这个教程的讲解 链接&emsp;&emsp;教程中用动画生动形象地表现了光线照射物体的过程，很好阐述了 次表面散射的产生原因 。 &emsp;&emsp;好了，因此雪的材质根据教程的做法就如上图所示&emsp;&emsp;下面需要将雪混合到演示材质上，并且确保雪永远都在岩石的上方，有种积雪的感觉。 &emsp;&emsp;首先需要将岩石材质以及雪材质做成 材质函数 ，这样方便使用 BlendMaterialAttribute 来混合材质效果。 &emsp;&emsp;在材质函数中使用 makeMaterialAttributes 节点连接输出即可 &emsp;&emsp;最后材质需要勾选 use Material Function 来完成连接 &emsp;&emsp;下面我们来看看积雪的制作效果 &emsp;&emsp;这里又用了 VertexNoramlWS 来生成相应的渐变，通过 HeightLerp 节点生成高度图的过渡效果。 &emsp;&emsp;最后通过 if 节点 生成不留积雪的部分。 &emsp;&emsp;最后两层高度贴图混合到一起的效果，用这张图作为混合的alpha通道就可以生成和逼真的积雪贴图。&emsp;&emsp;因为 VertexNoramlWS 也是世界坐标的，因此积雪永远在上方。 全息投影材质 &emsp;&emsp;全息投影材质 英文叫做 Hologram 材质，效果就是上图所示，只有接触模型的地方才有辉光效果。&emsp;&emsp;下面就来详细讲解搭建方法。 &emsp;&emsp;这里要介绍无比重要的节点 DistanceToNearestSurface 节点，通过这个节点就可以获取模型接触的面&emsp;&emsp;从节点的面片可以看到，接触得部分是黑色，没有接触的部分是白色的。&emsp;&emsp;可能这个面片看效果还不太明显，我们将材质连接到场景中看效果 &emsp;&emsp;由于直接输出的效果白刷刷的，所以这里先除一个数值来控制衰减，然后 clamp 0 到 1 之间，之后 1 减将黑白对调。 &emsp;&emsp;这样就可以实现接触物体的地方亮起的效果。 &emsp;&emsp;基于同样的原理就可以实现接触的地方产生网格动画的效果，动画效果主要通过 spanner 节点实现。 &emsp;&emsp;将上面两种效果叠加到一起，基本上全息投影的效果基本完成了。 &emsp;&emsp;教程还加上扫描线的效果，增加了投影的真是质感。&emsp;&emsp;扫描线使用 screenPosition 节点，使扫描叠加永远在屏幕上。 &emsp;&emsp;最后将扫描线的效果叠加上就大功告成了。 总结 &emsp;&emsp;教程后面还有地形和粒子材质的制作，这部分我暂时放下了。&emsp;&emsp;另外最后一部分制作水的效果是真的很牛逼，不过我打算结合着官方水包的讲解到时候一起讲，因此也挖个坑，后面再来填吧。&emsp;&emsp;今天看了官方中文的直播视频，制作效果超牛逼的，近期也会更新关于直播中的骚操作。 链接]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记 Pluralsight - Unreal Engine 4 Materials Fundamentals]]></title>
    <url>%2Fposts%2Fc476f94c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在完成了前面两部入门教程之后，我开始着手Unreal材质的学习。&emsp;&emsp;后续要看的教程我都已经筹划好了。 Pluralsight - Unreal Engine 4 Materials Fundamentals Udemy - Unlocking the Unreal Engine Material Editor 3DMotive - Introduction To Materials in Unreal Engine 4 &emsp;&emsp;材质入门的教程也已经看完，大部分内容其实都和 Lynda 的入门教程重合了。&emsp;&emsp;一些细枝末节的东西，比如 metallic 属性的讲解其实和 PBR 材质讲解一样的，这些我都接触过了。&emsp;&emsp;因此很多东西我也只是过了一遍。&emsp;&emsp;不过教程提到的一些材质制作方法还是很有意思的。 Baker蓝图 输出贴图 &emsp;&emsp;虚幻引擎可以在材质编辑器中生成程序化贴图 &emsp;&emsp;但是程序化贴图使用比较耗费资源，每一次移动都需要重新计算贴图。&emsp;&emsp;于是有没有办法将这种程序化生成的贴图转换成我们所熟知的贴图就不需要一次又一次地计算&emsp;&emsp;教程就通过蓝图实现了这个效果 &emsp;&emsp;首先新建一个 actor 蓝图，并添加一个 sphere 命名为 TextureSphere &emsp;&emsp;再创建一个 RenderTarget 用来显示贴图输出 &emsp;&emsp;添加蓝图自定义事件，将获取蓝图中球上的材质渲染输出到 RenderTarget 上 &emsp;&emsp;在脚本编译过程中触发这个自定义事件 &emsp;&emsp;将刚才看到的噪波材质添加到球上，需要注意的是材质必须连到发光通道上才可以正确渲染出贴图&emsp;&emsp;然后点击编译按钮就可以看到 RenderTarget 上有了贴图了 &emsp;&emsp;这里 RenderTarget 和 Unity 里面的应该没有什么区别，相当于动态生成的贴图。&emsp;&emsp;如果需要静态贴图，可以右键 RenderTarget 输出静态贴图，也可以双击 RenderTarget 进入编辑器调整生成贴图的大小。 Blinker 闪烁材质 &emsp;&emsp;下面要实现这种一闪一闪的信号灯材质&emsp;&emsp;需要注意的是，这种材质发光效果和灯光是不一样，它无法照亮其他物体，或者展现其他物体的影子。&emsp;&emsp;如果要实现光照效果还需要添加额外的灯光去实现。 &emsp;&emsp;这里使用了 time函数加载 sine 函数实现了 -1 到 1 的来回变化&emsp;&emsp;通过 clamp 函数将输出数值限制到 0-1 的区间上&emsp;&emsp;将输出值输出到 lerp 函数中就可以实现 由蓝色到黑色的来回变化。 Strip 条纹材质 &emsp;&emsp;这个材质其实是教程里面作为传送带用的。&emsp;&emsp;我自己加了一些修改。 &emsp;&emsp;教程里面条纹贴图是自己做好导进来的，我这里通过 Unreal 动态生成的。 &emsp;&emsp;通过 spaner 节点可以实现UV的动态偏移，实现平移效果，有传送带的感觉。&emsp;&emsp;后面是UV分段的控制，可以让UV多次重复。 &emsp;&emsp;这里就是我自己研究出来生成条纹贴图的方法。&emsp;&emsp;首先是生成黑到白的线性过渡值，然后通过内置的 valueStep 函数将过渡效果去掉，变成无过渡效果。&emsp;&emsp;通过提高UV重复的值，实现多个条纹效果。&emsp;&emsp;其实 valueStep 函数就是一堆写好的数学计算，打开节点可以看到。 &emsp;&emsp;到这里就是根据输出的条纹贴图生成对应的颜色贴图、粗糙度贴图以及法线贴图。&emsp;&emsp;由于贴图转法线没办法通过生成的贴图完成，只好通过 Baker 输出一张条纹纹理，然后导入到 NormalFromHeightMap 进行转换。 距离变色材质 &emsp;&emsp;这个材质根据当前的摄像机位置变色 &emsp;&emsp;其实构建非常简单&emsp;&emsp;主要是获取了 摄像机 和 物体 的位置计算距离，根据距离来输出 lerp 节点的透明度，就可以实现远近颜色的过渡变化。 总结 &emsp;&emsp;教程中比较有意思的点主要是这三个材质。&emsp;&emsp;当然后续也介绍了一些有用的概念 Parallax Mapping - POM and Bump Offset - 通过近快远慢的透视原理，模拟深度效果 World Space (WS) Normal Maps - 细节不会跟随物体运动旋转，比如说雪永远在物体的上面覆盖 blueprint - 蓝图切换材质 &emsp;&emsp;不过这些概念都讲得很浅，我就不再做进一步的总结了。&emsp;&emsp;而教程的其他部分都是一些材质基础的讲解以及 材质实例的使用，我觉得都做得很好，但是过一遍就可以了。&emsp;&emsp;最后四节课还专门分享了一波网站资源以及Unreal的官方案例Demo，真的很良心。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记 Packt Publishing - Unreal Engine 4 - The Complete Beginner's Course]]></title>
    <url>%2Fposts%2Fd58573f8.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这次是第二部入门教程，这一部教程完整讲解了一个入门级项目的完整制作流程，非常有用。&emsp;&emsp;我跟着教程的步骤做了完整的流程，感觉受益匪浅，非常推荐。 【UE4】虚幻引擎完全入门教程 &emsp;&emsp;另外教程将基础教学和案例教学完全分开，并且标注好名称非常好。第一遍看的时候可以先过一遍基础，顺带看看案例的操作。&emsp;&emsp;第二遍就可以直接看案例跟着操作制作自己的案例了。 自制Demo &emsp;&emsp;下面就重点分析教程的案例制作 创建天空 &emsp;&emsp;天空其实 UE4 有内置蓝图，可以创建出带有动态云的天空。&emsp;&emsp;官方的天空蓝图是开源可编辑的，有机会可以分析一波这里面的逻辑。&emsp;&emsp;将平行光添加到 蓝图天空 就可以了。 &emsp;&emsp;在项目设置可以设置当前项目使用的默认的地图，这样打开项目的时候就可以自动加载对应的 Level 创建地图 &emsp;&emsp;其实这一步操作完全发挥自己的想象空间做地图就可以了。&emsp;&emsp;材质贴图都可以借用初学者素材里面的内容 创建机关动画 &emsp;&emsp;这个圆盘的运动动画是通过关键帧实现的。 &emsp;&emsp;首先需要创建一个 static mesh component 的类，在类当中设置圆盘的大小。 &emsp;&emsp;构建动画蓝图，设置两个变量。 initialPlatformLocation 记录初始位置 startWithUpwardMovement 记录运动是往上走还是往下走 &emsp;&emsp;在游戏运行开始时记录当前物体的位置到变量中。 &emsp;&emsp;通过 timeline 节点可以创建动画曲线&emsp;&emsp;动画曲线的编辑类似于 Maya 之类的DCC软件，这里将三维的数值限制到 Unreal 上下朝向的 Z 轴上了。&emsp;&emsp;通过 timeline 可以输出 Z 轴上下变化的数值。 &emsp;&emsp;通过外部可编辑变量 startWithUpwardMovement 来判断圆盘往上走还是往下走。&emsp;&emsp;通过 vector + vector 节点完成上下向量变化的计算。 &emsp;&emsp;如此实现了这个平台机关来回上下运动的效果。 火球运动 &emsp;&emsp;根据上面的效果，教程如法炮制，也给火球添加关键帧动画实现运动。 &emsp;&emsp;但是我觉得这样运动非常不方便，教程是卡准了所有地图的位置，所以很清楚动画曲线应该设置运动多少的距离。&emsp;&emsp;但是我自己做的地图并没有这么精确，因此我想到了之前 Unity 开发的时候填入向量自动完成过渡计算的方法。&emsp;&emsp;借助 vector 的 interpolate 插值运算就可以算出从初始位置到结束位置的运动。 &emsp;&emsp;首先还是的创建一个 static mesh component 然后添加 shape_shpere&emsp;&emsp;另外还需要添加一个 fire 特效，这个燃烧效果也是初学者内容里面有的 &emsp;&emsp;构建蓝图，需要先声明一些需要的变量 initialLocation 记录初始位置 tmpLocation 临时记录位置，用于交换变量数据 targetLocation 记录目标位置 moveSpeed 移动速度 closeThersold 接近阈值 &emsp;&emsp;首先游戏开始的时候记录当前物体的位置到 initialLocation 变量中&emsp;&emsp;targetLocation 的数值则是在外部输入进来的&emsp;&emsp;通过 VInterp To 节点可以计算出两个向量的过渡值。 &emsp;&emsp;后续就是判断当前位置是否到达目标位置&emsp;&emsp;如果到达目标位置则交换初始位置和目标位置实现往返效果 &emsp;&emsp;这样我就可以设置小球的初始位置和目标位置实现循环往复的运动。&emsp;&emsp;这样我设置这里的小球就方便了很多很多。 创建旋转门 &emsp;&emsp;其实门的旋转和上面的操作是一样的，教程依旧采用曲线动画的制作方式。&emsp;&emsp;而我只是修改为旋转插值的实现。 &emsp;&emsp;教程是一步一步完善效果的，比较符合实际，我这里已经是最终效果了&emsp;&emsp;添加了碰撞器，可以实现靠近触发的操作。 &emsp;&emsp;开门的逻辑基本上和上面的火球运动一致。&emsp;&emsp;就是加了按F触发数值调换，可以实现按F开门或者关门。&emsp;&emsp;另外输入触发由碰撞体实现，如果没有碰撞则无法按F键开门&emsp;&emsp;这个实现逻辑和我之前Unity使用光线距离触发的方案不太一样，不过异曲同工。 &emsp;&emsp;靠近碰撞器则会判断是否将得分点全部获取完成&emsp;&emsp;如果获取完成就开启 F 键开门，如果没有完成就设置屏幕信息 创建可运动的角色 &emsp;&emsp;这里需要按照教程的按键设置去操作。&emsp;&emsp;虽然这个设置有点繁琐，但是比起 Unity 要自己去算鼠标移动的位置真的简单了很多。&emsp;&emsp;当然可以学习的东西也少了很多(:з」∠) &emsp;&emsp;创建第一人称控制器还需要将 GameMode 和 Controller 创建出来。 &emsp;&emsp;首先获取当前角色的存储到变量中 &emsp;&emsp;这里的input都是来源于一开始设置里面设定的按键，名称也是对应的。&emsp;&emsp;如此以来可以直接获取到输入的值设置到角色对应的控制上。 &emsp;&emsp;移动角色也是一样的。 &emsp;&emsp;按 P 键输入的时候使游戏暂停，显示暂停界面。&emsp;&emsp;基本上 Controller 都是处理输入相关的操作。 &emsp;&emsp;而 Character 里面则包含了很多全局的变量，各种面板的显示等等。 Orb 得分点 &emsp;&emsp;得分点也属于 static mesh component ，只需要设置碰撞效果触发即可。&emsp;&emsp;蓝图就可以设置碰撞触发之后给角色的分数自增1并且设置显示变量使屏幕泛蓝色。&emsp;&emsp;最后就是销毁自己了。 HUD 窗口UI构建 &emsp;&emsp;其实这里面还是比较复杂的，不过我接触过 PyQt 的组件开发，有很多概念都是相似的，也没有多少特殊的东西。&emsp;&emsp;这次总算明白什么是 HUD 了，没想到全称就是 HeadUpDisplay &emsp;&emsp;最后只要将组件的相关属性和变量关联就可以实现UI的动态变化了。 总结 &emsp;&emsp;教程还有一步关于声音合成的，我暂时忽略掉了。 &emsp;&emsp;这个教程让我进一步更加全面地了解了 Unreal 这个软件。&emsp;&emsp;而且对蓝图编程有了非常友好的使用感觉。&emsp;&emsp;我特别认同这个教程提供的案例，非常简单，但是又可以涉及到 Unreal 制作游戏的方方面面。&emsp;&emsp;我觉得新人学 Unreal 这个教程真的很值得推荐]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记 Lynda - Unreal Essential Training]]></title>
    <url>%2Fposts%2F54f0044c.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近开始了 虚幻引擎 的学习。&emsp;&emsp;虽然之前我学习过 Unity 也为课程实训做了一个小游戏Demo，不过最后还是打算入手 Unreal 了&emsp;&emsp;出于各方面的考虑吧，而且留给我自己的时间已经不多了。 &emsp;&emsp;写这篇文章的时候，其实这套教程已经看完了。&emsp;&emsp;总结一下，教程的整体设计思路是很不错的，基本上囊括了 虚幻引擎 的各个模块。&emsp;&emsp;教程整体是基于一个港口场景素材制作一段虚幻影片入手的，各个模块都点到为止，对新手还算不错。【UE4】虚幻引擎基础教程 Lynda - Unreal Essential Training 安装 &emsp;&emsp;安装 Unreal Engine 首先需要下载 Epic 官方商城 Epic Games Launcher&emsp;&emsp;安装相当简单，去到虚幻官网注册一个账号即可免费安装 &emsp;&emsp;目前虚幻引擎已经和 Unity 一样免费开发给个人开发者学习，只有发布游戏的时候 Epic 官方会抽取 5% 提成。 &emsp;&emsp;官方启动器也有很多游戏以及开发的素材免费提供，可以自己去挖掘。 基本操作 &emsp;&emsp;在虚幻视窗中按住鼠标左中右键可以分别进入不同的浏览模式。&emsp;&emsp;左键可以拖动摄像机，中键可以平移摄像机，右键可以旋转摄像机。&emsp;&emsp;在按住鼠标的时候，按 WASD 键可以像第一人称视角一样移动摄像机。&emsp;&emsp;我个人比较喜欢按住鼠标右键配合 WASD 键，很有游戏的移动感觉。 &emsp;&emsp;按住 Alt 键再按鼠标左键可以进入 Maya、Houdini 的围绕物体旋转的 tumble 模式，通常都需要配合 F 键 Focus 物体来使用。&emsp;&emsp;按住 Alt 键再按鼠标右键则是缩放摄像机。 &emsp;&emsp;以上的操作多试试就会有感觉，我从Maya转过来，问题不大，就是鼠标中键的运动和Maya有点不同不太习惯。 &emsp;&emsp;左上角的菜单可以切换摄像机视角 &emsp;&emsp;此处可以切换视图显示模式 &emsp;&emsp;此处可以限制物体的显示类型 &emsp;&emsp;右侧部分则是 移动、旋转、缩放 以及 吸附相关的按钮。 &emsp;&emsp;视图左侧是模式面板，用于创建编辑模型&emsp;&emsp;下面是内容面板，包含项目的层级目录&emsp;&emsp;右侧上面是大纲视图，包含场景中所有的文件&emsp;&emsp;右侧下方是详细视图，包含每物体的详细信息。 &emsp;&emsp;剩下的东西基本上和各种 3D package 差不多了&emsp;&emsp;比如移动旋转物体，创建灯光。 使用技巧总结 End 键可以让物体自动吸附到下方的物体上，比如说地面 按住 alt 键移动物体可以自动复制物体 复制的快捷键是 ctrl + W,当然也可以用 ctrl + C 配合 ctrl + V 按住 shift 键移动物体可以让是摄像机跟随移动 Landscape 地形编辑 &emsp;&emsp;使用起来基本上和Unity的地形编辑差不多&emsp;&emsp;可以使用雕刻软件处理地形效果。&emsp;&emsp;可以通过绘制材质来对地形绘制效果。 多边形编辑 &emsp;&emsp;unreal 可以编辑器几何体还是比较让我意外的&emsp;&emsp;而且内置的几何体还可以实现布尔效果，修改方便。&emsp;&emsp;缺点也如截图上面所示会消耗不必要的资源。 &emsp;&emsp;可以使用Unreal内置的几何体将模型的位置布置好&emsp;&emsp;后面再到三维软件中填充相应的内容，然后用FBX导入到Unreal中&emsp;&emsp;需要注意的是 Unreal 是 Z 轴向上的。 材质 &emsp;&emsp;Unreal使用节点流的材质编辑方式，在Maya、3dsMax等等DCC软件中都有类似的操作。&emsp;&emsp;Unreal采用 PBR 流程也和 Unity 是一样的，但是渲染效果要比Unity好看一些。 &emsp;&emsp;Unreal中有材质实例这种方式，可以避免重复创建材质的繁琐操作。&emsp;&emsp;这个真的是挺好用的，在材质的原本类编辑中将相关的属性 promote 成可以编辑的参数，就可以在实例中任意修改，大大提高复用性，真的舒服。 蓝图 &emsp;&emsp;使用蓝图真正让人高手到了 Unity 的巨大区别。&emsp;&emsp;蓝图不需要写一行代码就可以取代 Unity 的 C# 脚本。&emsp;&emsp;不过作为程序员还是比较喜欢代码写程序(:з」∠)，艺术家应该会爱上蓝图的。 &emsp;&emsp;教程中的蓝图Demo我个人觉得不太好，没有铺垫就开始做，让我初学者很懵逼。&emsp;&emsp;应该做些更加简单的蓝图来讲解的。 总结 &emsp;&emsp;其实到后面的内容都是点到为止，算是一个比较全面的入门。&emsp;&emsp;这些相关的模块也不是我学习的重点，因此我也只是看了一下，留个印象。&emsp;&emsp;作为入门教程还是相当认可这个教程，基本涵盖了Unreal所有的模块。]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unreal</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠃUnreal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya BlendShape 中间值获取]]></title>
    <url>%2Fposts%2Fb5d3f6ab.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;今年一月份的时候有遇到 BlendShape 需要特殊处理的地方于是研究了 OpenMaya 底层的 MPxBlendShape 实现。链接&emsp;&emsp;不过那个时候还没有搞懂 MPxBlendShape 这个东东的实现原理，后来因为弄 RBF 表情驱动，又研究了 BlendShape 一些属性，方才懂了一些。&emsp;&emsp;可以看我 2019-5-25 更新的说明。&emsp;&emsp;今天看到有人求解 BlendShape 的中间值过渡，我就在这里整理一下我目前所知道的。 BlendShape 节点 &emsp;&emsp;我们可以到节点编辑器下创建一个 BlendShape 来查看 BlendShape 有的属性&emsp;&emsp;通过帮助可以打开 BlendShape 的属性详解页面，里面有 BlendShape 每一个属性的说明。 &emsp;&emsp;当然上面的属性繁杂，通常我们只需要关注几个属性即可。&emsp;&emsp;我们可以去创建一个 BlendShape 链接来查看链接的属性。 &emsp;&emsp;打开节点编辑器查看被连接的属性 &emsp;&emsp;可以看到这么多属性只有 inputTargetItem 是被连接了的&emsp;&emsp;并且还是连接到了 6000 序号上，到这里肯定会很疑惑，之前连接属性都是从零开始的，咋这里就直接蹦到 6000 去了，而且后面还有个 6001 (O_O)?&emsp;&emsp;其实帮助文档中有说明的 &emsp;&emsp;通过文档可以知道序号值是 权重值 * 1000 + 5000 得到的。&emsp;&emsp;默认 BlendShape 的权重值为1 因此这里得到的数值就是 6000&emsp;&emsp;至于 6001 则是因为 Maya 节点属性会自动递增保留一个可连接的空属性&emsp;&emsp;那么更进一步 inbetween 的中间值就是 5500 指代 0.5 的权重了 &emsp;&emsp;我们可以连接 inbetween 属性验证一下我们的想法 &emsp;&emsp;打开添加 BlendShape 的面板 &emsp;&emsp;换句话说，如果中间过渡权重超过 1 或者 小于 0 那相应的序号应该是 大于 6000 或者 小于 5000 了 代码操作 &emsp;&emsp;理解上面的原理之后，要去找到 BlendShape 的中间权重也就不困难了&emsp;&emsp;废话不多说直接上代码。 pymel 获取12345678910111213141516171819202122232425262728293031323334353637383940414243import pymel.core as pm# NOTE 获取 BlendShape 节点BS = pm.ls("blendShape1")[0]# NOTE 获取连接节点的数量BS.inputTarget[0].inputTargetGroup[0].inputTargetItem.numConnectedElements()# Result: 4 # # NOTE 获取连接节点的序号BS.inputTarget[0].inputTargetGroup[0].inputTargetItem.getArrayIndices()# Result: [4500, 5500, 6000, 6500] # # NOTE 获取连接的属性BS.inputTarget[0].inputTargetGroup[0].inputTargetItem.elements()# Result: [u'inputTarget[0].inputTargetGroup[0].inputTargetItem[4500]',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[4500].inputGeomTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[4500].inputRelativePointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[4500].inputRelativeComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[4500].inputPointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[4500].inputComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[5500]',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[5500].inputGeomTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[5500].inputRelativePointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[5500].inputRelativeComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[5500].inputPointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[5500].inputComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6000]',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6000].inputGeomTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6000].inputRelativePointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6000].inputRelativeComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6000].inputPointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6000].inputComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6500]',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6500].inputGeomTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6500].inputRelativePointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6500].inputRelativeComponentsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6500].inputPointsTarget',# u'inputTarget[0].inputTargetGroup[0].inputTargetItem[6500].inputComponentsTarget']# NOTE 权重值转换[(weight-5000)/1000.0 for weight in BS.inputTarget[0].inputTargetGroup[0].inputTargetItem.getArrayIndices()]# Result: [-0.5, 0.5, 1.0, 1.5] # cmds 获取123456789from maya import cmds# NOTE 假设存在 blendShape1 节点cmds.getAttr("blendShape1.inputTarget[0].inputTargetGroup[0].inputTargetItem",multiIndices=1)# Result: [4500L, 5500L, 6000L, 6500L] # # NOTE 权重值转换[(weight-5000)/1000.0 for weight in cmds.getAttr("blendShape1.inputTarget[0].inputTargetGroup[0].inputTargetItem",multiIndices=1)]# Result: [-0.5, 0.5, 1.0, 1.5] # MEL 获取123456789101112131415getAttr -multiIndices "blendShape1.inputTarget[0].inputTargetGroup[0].inputTargetItem";// Result: 4500 5500 6000 6500 // // 权重值转换int $weights[] = `getAttr -multiIndices "blendShape1.inputTarget[0].inputTargetGroup[0].inputTargetItem"`;float $originWeights[];int $i;for($i=0;$i&lt;size($weights);$i++)&#123; $originWeights[$i] = ($weights[$i]-5000.0) / 1000.0;&#125;print $originWeights;// -0.5// 0.5// 1// 1.5 总结 &emsp;&emsp;以上就是 BlendShape 处理中间权重的方法。&emsp;&emsp;比较推荐使用 pymel 的方法，借助 OpenMaya 可以轻松获取到更多信息。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 研究记录</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python 视锥可视工具]]></title>
    <url>%2Fposts%2Fa1569efd.html</url>
    <content type="text"><![CDATA[安装说明 将 install.mel 拖拽到 maya 视窗当中，当前的工具架会多出一个 摄像机 图标按钮点击 图标按钮 即可打开 窗口 使用说明单帧测试中有两个按钮 第一个按钮 选择摄像机 切换视角范围显示 可以切换摄像机的视角显示 第二个按钮 选择摄像机 获取视角内的物体 可以获取视角内的物体 获取数据 填写起始帧和结束帧可以限定数据获取范围 选择摄像机，点击 获取时间范围内的摄像机视角数据 按钮才可以进行下一步的操作 json数据输入输出 有了数据之后就可以以json的形式将数据输出和输入。 json数据记录了每一帧摄像机视角内的物体 切分场景 上面两个按钮为可选操作，对切分场景没有影响 遍历物体设置可视关键帧 可选按钮 - 根据上述的数据给镜头可视数据设置 visibility 属性的关键帧 遍历物体设置Arnold渲染可视 可选按钮 - 与上一个按钮相似，设置渲染参数中的 primary visibility 属性的关键帧 切分阈值，用于过滤切分范围的峰值大小，气氛阈值越大，推荐切分范围越少。 推荐切分范围 - 会自动生成切分范围的数组。 根据情况需要修改切分范围的数组注意： 按照python数组的格式 数组至少有两个元素 - 如果有重复元素会自动去重再判断 数组中的元素必须为整数数字 自动切分场景会选择导出路径，然后根据切分范围自动将场景切分导出视角内可见的物体。 自动切分范围分析 &emsp;&emsp;自动切分，通过获取的数据计算出每一帧出现的物体数量，通过求导（曲线加速度）可以判断出物体在时间范围内出现的极小峰。极小峰的帧就是切分断点。 &emsp;&emsp;上图第一条曲线为 在时间范围物体出现数量的曲线&emsp;&emsp;第二条线为 第一条曲线的求导曲线&emsp;&emsp;可以看到求导曲线在前后帧不为零的时间上对应了原曲线的峰值位置。&emsp;&emsp;将求导曲线中由正变负的点筛选出去，就可以获得极小峰的点。 &emsp;&emsp;数据曲线在 visualize_test 文件夹的 keyframe_display_num 测试文件中 2019-7-16 更新面板显示优化 添加了缩放系数 &emsp;&emsp;调整缩放系数可以复制摄像机并缩放摄像机的范围 摄像机缩放分析 &emsp;&emsp;根据摄像机的fov farClipPlane nearClipPlane 计算摄像机视锥的八个顶点位置。&emsp;&emsp;计算公式在 OpenMaya2.0 的文档中的 MFnCamera getViewParameters 中 &emsp;&emsp;尽管 OpenMaya2.0 也提供了 getFilmFrustumCorners 方法，但是我却一直获取空数组，而且这个函数在 Maya 2015 是不支持的。&emsp;&emsp;于是我在 github 上找脚本，发现了另一个大神用 OpenMaya 写的计算方法。&emsp;&emsp;原理是一样的，我参照它的写法用PyMel实现了 &emsp;&emsp;然而按照这种方法获取的坐标是 object 空间的，&emsp;&emsp;还需要将摄像机的坐标控件计算进去。&emsp;&emsp;位移坐标还好说，直接让位移向量相加即可，但是旋转变换的新坐标要如何计算出来，还真的难住我了。&emsp;&emsp;尽管这个问题其实可以用约束解决的，但是我想要更加代码的方式计算出结果。&emsp;&emsp;功夫不负有心人，只要获取到摄像机的矩阵然后让坐标向量相乘就可以了。&emsp;&emsp;计算出8个点的坐标之后，只要将8个点求平均值就是视锥内的中心位置了。 &emsp;&emsp;有了中心点就可以用 cmds.scale 命令进行缩放了。 总结 &emsp;&emsp;最后这个工具其实没什么用，因为渲染过滤场景要考虑的问题远比这样简单可视过滤来得复杂&emsp;&emsp;如果单纯将物体排除到场景外，那样就无法渲染出镜头之外的阴影、灯光元素，这样会出问题的&emsp;&emsp;但是如果保留的话，其实从渲染器的层面并没有太多的优化，内存不够还是不够的。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js 学习之路（二）]]></title>
    <url>%2Fposts%2Fc45f3e57.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;本次记录 Day3 —— Day4 JQuery 的 each 和原生 JavaScript 方法 foreach &emsp;&emsp;结合之前看的 Vue 源码解析，可以知道什么是伪数组了。&emsp;&emsp;如果用Python来理解的话，伪数组就是一个关键字和数组一致的 字典。&emsp;&emsp;在 JavaScript 中就是像数组一样调用的对象。 12345678910111213141516var fakeArray = &#123; 0:"a", 1:"b", 2:"c", length:3&#125;console.log(fakeArray);console.log(fakeArray[0]); console.log(fakeArray['1']);// console.log(fakeArray.2); 调用会出错console.log(fakeArray.length); // 英文字符则可以调用console.log(fakeArray['length']);// console.log(fakeArray[length]); 调用会出错[].slice.call(fakeArray) &emsp;&emsp;js的对象既可以像 python的字典一样通过方括号关键字调用，也可以像 python 的类实例一样通过 . 去调用。 &emsp;&emsp;浏览器提供了遍历标签元素的方法 querySelector ，通过这个查询可以获取元素标签的伪数组。&emsp;&emsp;进一步要使用foreach需要将对象转换为数组才可以使用。&emsp;&emsp;转换方法也是通过调用数组的 slice 方法实现。 exports 和 module.exports 的区别 &emsp;&emsp;在 Node 中，每个模块内部都有一个自己的 module 对象&emsp;&emsp;该 module 对象中，有一个成员叫：exports 也是一个对象&emsp;&emsp;也就是说如果你需要对外导出成员，只需要把导出的成员挂载到 module.exports 中&emsp;&emsp;我们发现，每次导出接口成员的时候都通过 module.exports.xxx = xxx 的方式很麻烦，点儿的太多了&emsp;&emsp;所以，Node 为了简化你的操作，专门提供了一个变量：exports 等于 module.exports 123456789var module = &#123; exports: &#123; foo: 'bar', add: function()&#123; &#125; &#125;&#125;exports = module.exports &emsp;&emsp;可以理解每一个js脚本被解析的时候都会提供一将这些代码嵌入到脚本当中&emsp;&emsp;require执行调用的时候就会获取 module.exports 中的内容&emsp;&emsp;因此exports变量赋值的时候需要注意，否则很有可能会覆盖掉之前内容。&emsp;&emsp;一般不推荐使用赋值语句，而是使用成员赋值 301 &amp; 302 状态码 &emsp;&emsp;301 是永久重定向，浏览器会进行缓存，下次进入页面的时候就不再发送请求直接进行跳转。&emsp;&emsp;302 只是暂时的，每一次访问都会进行请求。 require 加载规则 &emsp;&emsp;如果require两个模块，而第一个模块已经在内部require了第二个模块，这个时候node会从缓存中加载第二个模块而不会重复加载 &emsp;&emsp;node会根据require的字符串进行加载，如果字符串包含 ./ 等的路径标识符，则根据路径标识查找。&emsp;&emsp;如果没有包含路径则从核心模块查找。 &emsp;&emsp;第三方包的加载方式类似于核心模块，但是命名绝对不会和核心模块一致，否则无法加载。&emsp;&emsp;加载第三方包是node会从node_module文件夹中查找包的文件夹。&emsp;&emsp;找到文件夹之后会读取 package.json 的main属性指定的入口js&emsp;&emsp;如果上述文件不存在或者指定的js有问题，就会读取默认的 index.js&emsp;&emsp;如果都没有则加载失败。 package.json 包说明书 &emsp;&emsp;npm 安装的时候加入 –save 会将包依赖写入到 package.json 当中&emsp;&emsp;通过读取 package.json 的依赖就可以重建 node_module&emsp;&emsp;因此git管理通常都会过滤 node_module 文件夹 1234567891011121314151617181920&#123; "dependencies": &#123; "gitment": "0.0.3", "hexo": "^3.2.0", "hexo-abbrlink": "^2.0.5", "hexo-deployer-git": "^0.3.1", "hexo-generator-archive": "^0.1.4", "hexo-generator-baidu-sitemap": "^0.1.2", "hexo-generator-category": "^0.1.3", "hexo-generator-feed": "^1.2.2", "hexo-generator-index": "^0.2.0", "hexo-generator-searchdb": "^1.0.8", "hexo-generator-sitemap": "^1.2.0", "hexo-generator-tag": "^0.2.0", "hexo-renderer-ejs": "^0.3.0", "hexo-renderer-marked": "^0.3.0", "hexo-renderer-stylus": "^0.3.1", "hexo-server": "^0.2.0" &#125;&#125; &emsp;&emsp;当你打开 node_module 可能会看到有更多莫名其妙的文件夹，根本就没有写入到 package.json 的依赖当中。&emsp;&emsp;其实这一点不用担心，我们安装一些常用包的时候，那些包也会依赖其他的包。&emsp;&emsp;npm会自动下载管理好这一切的问题，因此我们只要有目标包的依赖就可以了，更多的依赖就不用我们操心。&emsp;&emsp;通过 npm install 就会自动读取 packag.json 的数据自动安装依赖。&emsp;&emsp;如果我们想要创建 package.json 可以输入 npm init 来生成一个 关于js模块化]]></content>
      <categories>
        <category>前端</category>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>࠷JavaScript</tag>
        <tag>࠴编程/后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js 学习之路（一）]]></title>
    <url>%2Fposts%2Ff449d28f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;经过了一周半的时间学习Vue，已经基本掌握Vue的用法。&emsp;&emsp;最近也花了将近一周的时间简单开发了一个 SPA ，感觉实践之后才发觉自己掌握还很粗浅。&emsp;&emsp;不过没关系，慢慢练习，自然就不断精进了。&emsp;&emsp;因为 SPA 还需要后台系统，因此开发到中途，我将UI设计交给了舍友，继续来肝 Nodejs 做服务端的教程&emsp;&emsp;这次依旧是在B站找了个教程。 Node.JS-黑马程序员 &emsp;&emsp;因为我之前已经接触过 PHP 也大致了解服务端的处理，因此我看得速度很快，基本上就挑些重点记录下来。&emsp;&emsp;本期记录了教程 1 - 25 集 Day1 —— Day2 基础操作hello,world &emsp;&emsp;node.js 第一行代码&emsp;&emsp;其实非常好理解，就像安装python编译器之后，跑代码是一样的。&emsp;&emsp;node.js的特点就是让JavaScript跳出了浏览器的束缚，有更加自由的能力。 没有浏览器的 DOM 和 BOM &emsp;&emsp;毕竟node.js已经跳过了浏览器来执行，也就没有了 window 和 document 的全局变量。 文件读取 &emsp;&emsp;通过输入node的命令就可以实现文件读取。&emsp;&emsp;需要注意的是 require 是 node.js 添加的功能&emsp;&emsp;如果在浏览器上执行 require 会报错 文件写入 以及 错误处理 &emsp;&emsp;文件写入也很简单，可以参照文件读取 &emsp;&emsp;Nodejs执行会在回调函数传入错误信息&emsp;&emsp;需要调用错误信息才能将错误反馈&emsp;&emsp;如果没有错误信息 回调函数额 error 参数获取的是null，通过这个值就可以进行错误处理。 搭建服务器 &emsp;&emsp;node.js 搭建服务器也非常简单，如上图代码。&emsp;&emsp;通过listen进行监听，打开网页，就可以request的函数，在命令行中进行输出。 服务器响应处理 &emsp;&emsp;通过上面代码就可以知道用户访问的网页地址，并且可以通过 write 输出信息到页面上。 node 中的模块加载 &emsp;&emsp;模块加载和 python 基本一样，只不过了换成 require 并且支持路径加载&emsp;&emsp;不过 node 加载模块之后是不会暴露模块中的东西，需要用过 exports 来讲模块中对应的内容传递出来。 通信原理 &emsp;&emsp;程序通信需要有唯一地址来避免通信干扰，一般IP地址的端口就是用来区分不同程序的通信。&emsp;&emsp;通信两方都会开启端口进行信息互通，不仅仅是服务器暴露通信端口，浏览器也会调用客户端的端口来去和服务器通信，发送请求。 &emsp;&emsp;不过用户不用担心端口的问题，浏览器自动调用系统中的资源。&emsp;&emsp;端口号可以选用的数值为 0 - 65536 服务器 header &emsp;&emsp;因为浏览器不知道服务器返回数据的编码格式，因此会默认调用系统的编码。&emsp;&emsp;因此指定返回头文件就可以解决问题。 &emsp;&emsp;通过请求可以让浏览器正确处理服务器返回的内容。 地址处理 &emsp;&emsp;通过地址处理以及头信息的正确返回，可以让任意地址指向不同的资源。 分号处理 &emsp;&emsp;在 standard JavaScript 权威规范中，推荐代码不添加分号&emsp;&emsp;但是在上述的符号作为行首的时候，不加分号会导致代码出问题，留个心眼就好。 客户端 &amp; 服务端 &emsp;&emsp;客户端和服务端的异同&emsp;&emsp;服务端之所以可以实现SEO优化，是因为搜索引擎的爬虫爬取信息是不会执行 js 脚本的（节省资源）&emsp;&emsp;因此只有纯文本的信息会被抓取。 资源请求 &emsp;&emsp;当浏览器识别到网页的内容之后，会一次解析HTML中的相关属性标签然后发送请求 服务端处理请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// app application 应用程序// 把当前模块所有的依赖项都声明再文件模块最上面// 为了让目录结构保持统一清晰，所以我们约定，把所有的 HTML 文件都放到 views（视图） 目录中// 我们为了方便的统一处理这些静态资源，所以我们约定把所有的静态资源都存放在 public 目录中// 哪些资源能被用户访问，哪些资源不能被用户访问，我现在可以通过代码来进行非常灵活的控制// / index.html// /public 整个 public 目录中的资源都允许被访问// 前后端融会贯通了，为所欲为var http = require('http')var fs = require('fs')var url = require('url')var template = require('art-template')var comments = [ &#123; name: '张三', message: '今天天气不错！', dateTime: '2015-10-16' &#125;, &#123; name: '张三2', message: '今天天气不错！', dateTime: '2015-10-16' &#125;,]// /pinglun?name=的撒的撒&amp;message=的撒的撒的撒// 对于这种表单提交的请求路径，由于其中具有用户动态填写的内容// 所以你不可能通过去判断完整的 url 路径来处理这个请求// // 结论：对于我们来讲，其实只需要判定，如果你的请求路径是 /pinglun 的时候，那我就认为你提交表单的请求过来了http .createServer(function (req, res) &#123; // 简写方式，该函数会直接被注册为 server 的 request 请求事件处理函数 // 使用 url.parse 方法将路径解析为一个方便操作的对象，第二个参数为 true 表示直接将查询字符串转为一个对象（通过 query 属性来访问） var parseObj = url.parse(req.url, true) // 单独获取不包含查询字符串的路径部分（该路径不包含 ? 之后的内容） var pathname = parseObj.pathname if (pathname === '/') &#123; fs.readFile('./views/index.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; var htmlStr = template.render(data.toString(), &#123; comments: comments &#125;) res.end(htmlStr) &#125;) &#125; else if (pathname === '/post') &#123; // 其它的都处理成 404 找不到 fs.readFile('./views/post.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125; else if (pathname.indexOf('/public/') === 0) &#123; // /public/css/main.css // /public/js/main.js // /public/lib/jquery.js // 统一处理： // 如果请求路径是以 /public/ 开头的，则我认为你要获取 public 中的某个资源 // 所以我们就直接可以把请求路径当作文件路径来直接进行读取 fs.readFile('.' + pathname, function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125; else if (pathname === '/pinglun') &#123; // 注意：这个时候无论 /pinglun?xxx 之后是什么，我都不用担心了，因为我的 pathname 是不包含 ? 之后的那个路径 // 一次请求对应一次响应，响应结束这次请求也就结束了 // res.end(JSON.stringify(parseObj.query)) // 我们已经使用 url 模块的 parse 方法把请求路径中的查询字符串给解析成一个对象了 // 所以接下来要做的就是： // 1. 获取表单提交的数据 parseObj.query // 2. 将当前时间日期添加到数据对象中，然后存储到数组中 // 3. 让用户重定向跳转到首页 / // 当用户重新请求 / 的时候，我数组中的数据已经发生变化了，所以用户看到的页面也就变了 var comment = parseObj.query comment.dateTime = '2017-11-2 17:11:22' comments.unshift(comment) // 服务端这个时候已经把数据存储好了，接下来就是让用户重新请求 / 首页，就可以看到最新的留言内容了 // 如何通过服务器让客户端重定向？ // 1. 状态码设置为 302 临时重定向 // statusCode // 2. 在响应头中通过 Location 告诉客户端往哪儿重定向 // setHeader // 如果客户端发现收到服务器的响应的状态码是 302 就会自动去响应头中找 Location ，然后对该地址发起新的请求 // 所以你就能看到客户端自动跳转了 res.statusCode = 302 res.setHeader('Location', '/') res.end() &#125; else &#123; // 其它的都处理成 404 找不到 fs.readFile('./views/404.html', function (err, data) &#123; if (err) &#123; return res.end('404 Not Found.') &#125; res.end(data) &#125;) &#125; &#125;) .listen(3000, function () &#123; console.log('running...') &#125;)// Node 不适合从来没有接触过服务端的人学习// 如果想要真正的学号服务端，还是老牌的 Java、PHP 这些平台// Node 不是特别适合入门服务端，但不代表 Node 不强大// Node 很厉害，具有经验的人可以玩儿的非常的牛// 不适合新手的原因就在于比较偏底层、而且太灵活// Java、PHP 好入门的原因就在于：这些平台屏蔽了一些底层// res.redirect('重定向') &emsp;&emsp;通过将数据发送到服务端对应的地址,就可以通过 nodejs 来写服务端的请求&emsp;&emsp;确实 Nodejs 很灵活，写起来也比起 LAMP 或者 LNMP 要复杂一些。&emsp;&emsp;不过理解了背后的原理制作起来也没有那么困难。]]></content>
      <categories>
        <category>前端</category>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>࠷JavaScript</tag>
        <tag>࠴编程/后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 坑爹记录]]></title>
    <url>%2Fposts%2F284524f6.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;继续看上期的教程 组件无法注册 - 2019-7-8 &emsp;&emsp;今天尝试局部引用组件到另一个组件中&emsp;&emsp;然而控制台报错无法找到该组件，问我有没有正确注册逐渐。&emsp;&emsp;然而我仔细检查了所有的步骤都没有发觉有任何问题。&emsp;&emsp;最后居然发现是引用的时候 component 没有加 s &emsp;&emsp;在这个情况下VScode没有报错，因此完全没有发现这里出问题了]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python RBF工具开发研究]]></title>
    <url>%2Fposts%2Ff6cd0ecb.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;总结一下这段时间开发表情相似方案来替代RBF变形器的方案。&emsp;&emsp;最近一直在专研这个方案，中途有些困惑的地方不清楚的地方也是通过张峥前辈的讲解才算明白。&emsp;&emsp;中间也有过一些其他的想法，走了不少弯路。&emsp;&emsp;这一篇文基本上就是 7 月份第一周的所有工作内容了。 初期准备 - 弯路 &emsp;&emsp;最开始前辈有给我讲了大概的计算方案。 给模型画曲线 将曲线压成二维空间进行相似度比较 算出相似度来模拟RBF的输出值 &emsp;&emsp;最初我听完前辈的讲解只获取到了这些信息&emsp;&emsp;(有时候真的应该做些记录的，前辈讲解很长，有很多细节都没有记下来) &emsp;&emsp;考虑到要相似计算，于是就到网上搜索了相似计算的相关算法&emsp;&emsp;其中涉及到大都是数据分析，机器学习之类的东西，感觉和我想象的图形学相差甚远。&emsp;&emsp;不过没关系，既来之，则安之。&emsp;&emsp;首先我找到了一篇很棒的文章，讲解了最常用的五种计算数据相似的方案。 http://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/ &emsp;&emsp;后面又在国内的网站上找到更多关于相似度计算的方案 https://blog.csdn.net/u014782458/article/details/58180885 &emsp;&emsp;于是大概花了两天，都在研究并将相关的相似算法封装到py中进行调用 &emsp;&emsp;主要封装了 minkowski_distance 闵可夫斯基距离 和 cosine_similarity 夹角余弦 相似 &emsp;&emsp;研究到这里之后，我发现要判断曲线的相似需要判断曲线上的点的相似。&emsp;&emsp;于是我就开始了插件开发。 曲线生成 &emsp;&emsp;很明显曲线是需要人工去生成的。&emsp;&emsp;这个过程需要用到简模上的点来生成曲线，因为简模上的每一个点都代表了一个底层骨骼。&emsp;&emsp;&emsp;&emsp;最初的方案： 获取模型上的点 生成曲线 重建曲线 - 让曲线上的顶点数量和选择的模型点数一致 遍历曲线上的点匹配到模型的点上 &emsp;&emsp;原本以为这个方案生成曲线已经万无一失了，但是经过我一步步实现之后，还是出现了问题。&emsp;&emsp;最后一步的位置匹配上，由于模型上的点的选择顺序是混乱的。&emsp;&emsp;这将会导致位置匹配的混乱 &emsp;&emsp;为了解决这个问题，我想到了我以前做的选点成盒插件。 MEL - 选点成盒插件 &emsp;&emsp;当时也遇到选点生成混乱的问题，最后是通过开启选择顺序的追踪实现了按选择顺序获取列表的效果。&emsp;&emsp;不过我觉得这样的交互体验不好，选择的时候必须要按照对应的顺序选择才可以正确生成曲线。&emsp;&emsp;于是我想有没有更好的方案。&emsp;&emsp;经过一番搜索，在网上找到了一个blender的解决方案。 https://blender.stackexchange.com/questions/72367/how-to-order-a-list-of-vertices-based-upon-position &emsp;&emsp;问题的需求和我所先要实现的效果基本一致的。&emsp;&emsp;于是我参照Blender的API改成了Maya的实现方式 &emsp;&emsp;这个方案通过选择的边进行遍历对应，最后实现顺序选择的效果。&emsp;&emsp;当然这个方案的缺点就是算法复杂度较高，执行效率很低。&emsp;&emsp;不过考虑到我们生成的曲线也不会有有太高的精度，也不失为一个智能的解决方案。 曲线匹配 &emsp;&emsp;曲线生成成功了，我可以手动将每个表情的曲线创建出来&emsp;&emsp;模拟曲线匹配的效果了。&emsp;&emsp;于是我创建了一个只有几个曲线用于匹配的文件。 &emsp;&emsp;通过上面的相似算法，就可以计算各个点的余弦角相似度以及距离相似度&emsp;&emsp;╮(╯▽╰)╭ 其实相似度算法算出来的压根就不是什么相似度。&emsp;&emsp;就是算出了 距离 和 夹角的cos值&emsp;&emsp;因此在相似匹配上没有太好的对比方法。&emsp;&emsp;于是我不得已又去咨询了张峥前辈。 &emsp;&emsp;然后才知道前辈想要的计算方法根本就不是这样的。&emsp;&emsp;我需要计算曲线上每个点到坐标系的距离、点相邻的两条边的边长、点两边的夹角角度。&emsp;&emsp;然后根据上面获取到的数值逐一和运动曲线进行比值运算。&emsp;&emsp;通过比值的百分比就可以知道当前点的相似度。 &emsp;&emsp;这个想法非常有道理，也不复杂，或许是因为自己在网上找到的相似算法给框住了，完全没有想到这种比值的运算方法。&emsp;&emsp;于是我赶紧将相关的数据或取出来。 &emsp;&emsp;上面是最终获取到的数据列表，最后一列是数据相乘的结果。&emsp;&emsp;获取比值应该有大有小，还需要将比值限制在 0 - 1 的区间内 &emsp;&emsp;最后的权重应该如何输出我也咨询过前辈。&emsp;&emsp;前辈说要通过 距离比值作为可输出的阈值，角度值作为百分比乘上去。&emsp;&emsp;但是这样输出的话还是有问题，我们可以将输出值整理一下，按照曲线的点去排序。 &emsp;&emsp;可以看到即便已经有数值取 1.0 完全相似，其他表情的相似度数值也依然高居不下。&emsp;&emsp;或许会想到，用条件判断，如果数值为1.0的话就将其他数值归零。&emsp;&emsp;然而因为是条件判断会导致数据不连续。&emsp;&emsp;也就是说在 0.99 的时候函数还有很多修型效果，到 1.0 的瞬间表情就跳了。 数值优化 &emsp;&emsp;关于上面的数值输出优化，我想了很多很多，但也没有想到好的解决方案。&emsp;&emsp;为此我都开始翻数据分析、统计学的教程来尝试解决这个数据问题。&emsp;&emsp;然后最终那些零零碎碎的概念也没有派上多大用场 (:зゝ∠) &emsp;&emsp;制作这个真的深刻体会到了自己数学知识的匮乏 /(ㄒoㄒ)/~~&emsp;&emsp;不管有用没用，我先将有可能用到的数据输出出来。 &emsp;&emsp;因为找不到数据间的关系，我还一度打算吃透RBF，在RBF的基础上改良吧。&emsp;&emsp;RBF终究是太过神秘了，我想找个简单的说明，看看RBF是怎么实现这样的计算的。 RBF的研究尝试 &emsp;&emsp;无论是之前研究 weightDriver 的时候还是现在研究相似，我都有看过网上说的RBF到底是什么&emsp;&emsp;然而在一大堆数学名词的辅助下，成功让我这个门外汉看到自闭了 ╮(╯▽╰)╭&emsp;&emsp;我打算先找一篇简单一点的说明文章吧，起码要说人话吧。&emsp;&emsp;没想到还真的找到了一片相当不错的科普 透彻理解高斯核函数背后的哲学思想与数学思想&emsp;&emsp;文章里面有两张图真的太过形象了，一看就懂了。 &emsp;&emsp;在平面上看数据可能是混乱的，但是如果我们用数学的方式延伸到更高的维度，或许就可以在高维度上找到线性可分的数学计算方法。&emsp;&emsp;然后我们将高维度的数据复原回低维度就可以获取到我们认为不可能划分的区域。&emsp;&emsp;这个思想怎么让我想到了三体 (:зゝ∠) ，真的 tgl :-)&emsp;&emsp;不过看到文章后面的 泰勒级数、维度延伸 之后。再度自闭了。&emsp;&emsp;不是失去了兴趣，而是根本就没有这么多时间来研究这个东西了。&emsp;&emsp;于是至此我就暂时把 RBF 的研究放到一边了。 样本过滤 &emsp;&emsp;因为自己的能力有限，只能运用记忆模糊的高中知识来尝试解题了。(大学的高数真的白学了 (ㄒoㄒ))&emsp;&emsp;首先要找到一些过滤数据有用的方法，于是在网上我找到了一些有用的数学方法。&emsp;&emsp;比如将数值范围 归一化 &emsp;&emsp;封装成函数如下 &emsp;&emsp;关于样本数据，我首先想到要将一些相似度比较低的数据过滤出去。&emsp;&emsp;比如说只保留3个或者4个表情数据，其他的表情相似一律不再进行考虑，那么需要处理的数据就会大大减少。&emsp;&emsp;按照这个想法可以先获取数组中最大的四个值，经过网上一番搜索，可以通过 heapq 的原生包来实现。 1234import heapqvalue_list = [0.261, 0.332, 0.0, 1.0, 0.059]heapq.nlargest(4, value_list) # 从数组中抽取最大的四个元素返回数组# 返回 [0.261, 0.332, 1.0, 0.059] &emsp;&emsp;于是根据这个想法可以过滤出最大的四个元素，其他表情一概不再考虑。&emsp;&emsp;但是当数值最大的四个元素发生变动的时候，还是会有数值跳动的情况。&emsp;&emsp;如何才能确保数值不会跳动，而是连续呢？&emsp;&emsp;我想到了数据重映射，类似于Houdini fit 函数来改变数据的区间。 &emsp;&emsp;将最大区域的四个数进行归一化处理，范围就在最大区域的区间上&emsp;&emsp;最大区域以外的数就会被映射为负数了&emsp;&emsp;这样就可以进行统一过滤，见所有的负数变为0。&emsp;&emsp;这样会牺牲掉最大区域中最小的数，这个数会被转换为0，但是也因为这个数作为桥梁。&emsp;&emsp;才实现了数值过滤同时不会出现数值跳动的问题。 :-) 样本压缩 &emsp;&emsp;经过了样本过滤之后，剩下的数值可能还是会过大。&emsp;&emsp;即便有的点已经达到了 1.0 ，也可能和附近的某个表情位置有 0.8 的相似程度&emsp;&emsp;但是表亲相似不允许数值相加之后过大，很容易造成表情叠加产生各种问题。&emsp;&emsp;因此这里要想办法压缩其他的样本数值，促进两极分化才可以。&emsp;&emsp;我需要一个在 0 - 1 区间内单调递增的函数。 &emsp;&emsp;上图是之前研究RBF曲线修正的时候绘制的。&emsp;&emsp;我发现我们想要的效果正是之前处心积虑要修正的 RBF 输出曲线(:зゝ∠)&emsp;&emsp;只有通过这样的曲线输出方才而已将其他数值压缩，而保持最相似数值的不变 ╮(╯▽╰)╭&emsp;&emsp;没办法，先把数据压缩实现了吧 ……&emsp;&emsp;符合这样增长的曲线就是指数函数了。 &emsp;&emsp;指数函数过定点 (0,1) 只要在x轴往右挪动一个单位就可以实现过定点 (1,1)&emsp;&emsp;定点 (1,1) 正是我们所期待的的输出值。&emsp;&emsp;只要指数函数的底数是大于1，就可以确保指数函数是单调递增的。&emsp;&emsp;不过这里底数也不应该是个定值，这里的底数会影响到指数函数的斜率变化。&emsp;&emsp;底数越大，斜率变化也就越大，(其实求导就可以知道的)&emsp;&emsp;我们希望在输入的数据中，如果数值没有那么两级分化，那么应该减少压缩的效果。&emsp;&emsp;反之亦然，因此这里的底数应该根据样本的两极分化程度来标定的。&emsp;&emsp;更具统计学的定义，标准差就是来判断数据之间的相差程度的。&emsp;&emsp;(因为数值都在 0 - 1 的区间，传个最大值其实区别也不大)&emsp;&emsp;这里应该传入最大值，因为做了传入值为 1 的时候过滤其他数值为0的操作&emsp;&emsp;这里通过if判断进行过滤是因为到其他数值已经压缩了，数值跳动不会很大。 &emsp;&emsp;通过上面的方法可以有效的压缩无关数值，但也会造成和之前RBF节点输出的问题。&emsp;&emsp;小数值输出会更小，只有很接近的时候才可以让修型体现出来(:зゝ∠) &emsp;&emsp;remap_list 是经过样本过滤的值&emsp;&emsp;shrink_list 是在经过样本压缩的输出值 插件优化多表情同步 &emsp;&emsp;考虑到生成的曲线是对应多个表情，因此在一个模型上创建的曲线需要同时在多个其他表情上创建出来。 &emsp;&emsp;实现原理也不复制，for循环表情数组逐个选择顶点创建即可，毕竟顶点序号是一致的。&emsp;&emsp;另外，为了实现每次打开的状态记录，也沿用了之前开发 RBF_Panel 的方法，通过一个数据节点记录插件内部数据，实现场景关闭打开也可以读取相关的数据。 驱动曲线 &emsp;&emsp;经过上面的步骤，终于将需要匹配的曲线创建出来了。&emsp;&emsp;不过运动模型上的曲线还需要让曲线跟着模型运动，这样才可以实现和其他表情曲线比较。&emsp;&emsp;如何让曲线跟着模型运动呢？&emsp;&emsp;最初想到的方案就是 cluster curve 让曲线上的每一个顶点生成簇，然后用毛囊对簇进行约束。&emsp;&emsp;但是想想就知道这个方案有多麻烦。还有找到毛囊与簇的对应关系，麻烦死人。&emsp;&emsp;于是我又想到了以前学习绑定时候的 wire deformer&emsp;&emsp;线变形器可以让线来控制器模型的表面效果。 &emsp;&emsp;然而很明显这个效果恰恰和我们要的完全相反了。&emsp;&emsp;我们要模型驱动曲线，而不是曲线驱动模型(:зゝ∠)&emsp;&emsp;不过变形器终究还是启发了我。&emsp;&emsp;maya还有一个 wrap 变形器可以实现模型带动效果 &emsp;&emsp;于是我尝试让曲线包裹到模型上，成功实现了模型带动曲线运动的效果。&emsp;&emsp;这个方案比一开始设想的方案要简单得太多太多了。&emsp;&emsp;手动操作已经实现了，理论上代码实现也不会有太大的问题，然而这里还是有坑。&emsp;&emsp;maya所有的变形器都是通过 cmds.deformer 命令去创建的。&emsp;&emsp;因此就完全不知道 wrap deformer 需要传入什么参数，链接什么相关的模型才能正常工作。&emsp;&emsp;而代码的回显只有一句 &emsp;&emsp;我尝试复制这段代码，执行，但是却无法实现wrap的效果，这行代码仅仅是创建了一个变形器附着到目标模型上而已。&emsp;&emsp;于是经过研究深层的代码回显才找到了核心代码。 &emsp;&emsp;只要按照顺序选择模型，通过这行代码就可以实现包裹变形器的绑定。&emsp;&emsp;总算是大功告成！]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat连接远程数据库]]></title>
    <url>%2Fposts%2Fc38bc3c2.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近开始看 node 的后端相关的教程&emsp;&emsp;教程提到了连接 mongodb 数据库的操作&emsp;&emsp;于是我就尝试着在自己的服务器上搭建数据库进行连接 Navicat &emsp;&emsp;之前学习 PHP Larvel 框架的时候就下载下来用过了&emsp;&emsp;这个软件还是非常不错的，相当于本地客户端版本的 PhpMyAdmin&emsp;&emsp;而且可以连接多种不同类型的数据库，支持可视化操作&emsp;&emsp;也可以输入 sql 指令进行操作 mysql远程连接 &emsp;&emsp;远程连接mysql其实不难&emsp;&emsp;宝塔面板已经为我创建好了 mysql 数据库以及相关的操作&emsp;&emsp;我只需再创建一个专门的数据库用于连接就可以了&emsp;&emsp;根据账号密码配置 Navicat 的连接就可以了&emsp;&emsp;然而连接就出错了 &emsp;&emsp;后来看了别人写的文章才知道原因 链接&emsp;&emsp;端口是已经开放了&emsp;&emsp;那就是数据库的权限问题。&emsp;&emsp;按照文章所写的，将数据的权限修改为所有人就可以连接了。 mongodb 远程连接 &emsp;&emsp;原以为搞定了 mysql ，mongodb就不会那么困难&emsp;&emsp;没想到还是连接不上 &emsp;&emsp; mongodb 连接方法&emsp;&emsp;需要遵循这样的规范去连接 mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]&emsp;&emsp;Navicat可以输入这样的规范去连接 &emsp;&emsp;然而我这么做了还是无法链接&emsp;&emsp;于是又搜了一些文章&emsp;&emsp;链接 这个文章告诉我需要将本地IP改为所有IP&emsp;&emsp;然而它并没有说要修改的文件在哪里，于是又找了一下&emsp;&emsp;链接 这个文章有了修改路径了&emsp;&emsp;但是重启服务不对&emsp;&emsp;我的服务器 service 找不到 mongodb&emsp;&emsp;原来我服务器重启服务需要输入 mongod 才可以重启&emsp;&emsp;重启之后就可以连接了！！！]]></content>
      <categories>
        <category>前端</category>
        <category>Navicat</category>
      </categories>
      <tags>
        <tag>࠴编程/数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（十）]]></title>
    <url>%2Fposts%2F372dc2f3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;继续看上期的教程 多页应用 VS 单页应用 &emsp;&emsp;多页应用每一次范文都会从服务器返回HTML文件 &emsp;&emsp;减少Http请求，不利于搜索引擎抓取&emsp;&emsp;通过服务器渲染可以解决单页应用的一些问题 vue cli 环境配置 &emsp;&emsp;设置移动端的显示效果，使页面无法缩放。 &emsp;&emsp;路径标识 @ 表示 src 文件夹路径 &emsp;&emsp;引用 reset.css 确保移动端上所有设备的初始 css 是统一的&emsp;&emsp;引用 border.css 确保移动设备渲染边框都是占用一个像素的 &emsp;&emsp;为了兼容双击命令，浏览器默认的单机延迟为 300 ms&emsp;&emsp;这可能会对移动端的交互体验产生印象，因此可以安装 fastclick 库 来解决问题。 &emsp;&emsp;webpack设置可以配置路径 @ 符号路径也源于此 &emsp;&emsp;修改webpack配置需要重启服务器 ajax网络请求 &emsp;&emsp;通过 webpack-dev-server 的配置可以实现将 api 的地址替换为 /static/mock 方便我们读取json进行接口测试 &emsp;&emsp;在 swiper 中通过 ajax 获取数据，会因为组件提前生成导致数据生成的时候不在第一个轮播图上显示&emsp;&emsp;通过 v-if 可以实现判断数据再去实现轮播图 &emsp;&emsp;HTML中尽量减少逻辑层的代码，可以将相关代码写到函数当中]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（九）]]></title>
    <url>%2Fposts%2Fb21fe737.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;尚硅谷的Vue教程已经做完了，原本打算去看Vue Cli3.0全栈项目之资金管理系统带权限教程&emsp;&emsp;奈何 node.js 还没有学习，教程提到要有一定的基础，所以我打算先把这个教程放一放。&emsp;&emsp;然后又找了一个 Vue 教程，打算再重新过一遍基础，也可以发现一些新的 Vue 知识。 input输入 input输入 &emsp;&emsp;在Vue中 使用条件渲染来切换 input 的输入&emsp;&emsp;如果 input 没有指定key值，那么切换的输入框会继承之前输入框中的内容 组件使用细节组件使用细节 &emsp;&emsp;使用 is 属性可以根据Vue的组件过滤放到相应位置。&emsp;&emsp;如果直接使用组件标签，可能会导致无法放到HTML正确的位置上 &emsp;&emsp;Vue 比较起 JQ 插件，更加注重数据的处理，而非 DOM 的处理。&emsp;&emsp;这样有利于节省大量的代码，也让运行效率大大提升。&emsp;&emsp;尽管Vue不推荐操作DOM，但是在一些复杂的场景中，还是需要有对 DOM 进行处理的功能&emsp;&emsp;在 HTML 标签中嵌入 ref 属性，就可以通过 Vue实例下的 $ref 获取到相关的 DOM 元素。&emsp;&emsp;DOM元素如果是Vue组件则获取到了组件的引用，可以获取到组件内部的数据。 父子组件传值 &emsp;&emsp;父子组件传值其实很类似于函数传参。&emsp;&emsp;也提供了参数的校验器方便Debug&emsp;&emsp;如果没有传参，但是在父组件的调用上写了一些特殊的属性，会自动添加到子组件上。 插槽 &emsp;&emsp;通过slot的方式可以再父组件中嵌入Html传到子组件当中 &emsp;&emsp;可以设置默认的插槽内容 &emsp;&emsp;可以通过制定插槽形成映射关系，从而显示对应的内容 &emsp;&emsp;作用域传值&emsp;&emsp;template 的 slot-scope 可以接受插槽返回的值 动态组件 &emsp;&emsp;通过传递 is 判断type变量中的内容，从而切换不同组件 &emsp;&emsp;在组件的切换过程中，vue需要创建新的组件，然后再将旧的组件删除&emsp;&emsp;这个过程会消耗一定的资源。&emsp;&emsp;使用 v-once属性 可以直接将数据存储到内存中，下次调用直接从内存中取值，效率更高。 Vue CSS3 动画过渡动画过渡 &emsp;&emsp;Vue通过添加class的方式来实现动画效果&emsp;&emsp;上图就是自动添加 class 的流程&emsp;&emsp;因此要实现过渡，需要定义 CSS 这些 class 切换的效果 &emsp;&emsp;大概可以参考上述的写法&emsp;&emsp; v-enter v-leave-to 静态&emsp;&emsp; 带有 active 后缀 为 动态 &emsp;&emsp;可以给transition命名，默认引用是 v- 开头，如果加了 name 怎会沿用 name- 开头&emsp;&emsp;也可以添加 enter-active-class 和 来分别指定 CSS &emsp;&emsp;animate.css 指定动画效果 官网参考&emsp;&emsp;不用自己来写动画 CSS Vue js 动画过渡 &emsp;&emsp;vue的transition提供了一些钩子可以触发相关的回调函数&emsp;&emsp;有enter当然也有leave&emsp;&emsp;通过 methods 定义对应的触发函数&emsp;&emsp;运行中的函数会对带一个done参数来执行结束回调。 &emsp;&emsp;velocity.js 是js的动画库，可以轻松实现各种动画过渡。 官网 Vue 多重动画 &emsp;&emsp;transition添加 mode 可以实现同时切换的效果 &emsp;&emsp;同样的方法可以实现组件间的切换 &emsp;&emsp;for循环添加动态效果可以使用 transition-grp 相当于给每个div单独添加了 transition &emsp;&emsp;可以将动画过渡效果封装到组件当中，那么每次调用相关的组件就有相应的动画效果了。]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（八）]]></title>
    <url>%2Fposts%2Fc8d2c668.html</url>
    <content type="text"><![CDATA[前言 本文章结合VUE核心技术-尚硅谷的63-75集做的归纳总结。&emsp;&emsp;这里发现教程的 readme.md 已经将知识点整理好了，我在做了一些个人风格化的修改。 Vuex效果 vuex是什么 github站点: https://github.com/vuejs/vuex在线文档: https://vuex.vuejs.org/zh-cn/简单来说: 对应用中组件的状态进行集中式的管理(读/写) 状态自管理应用 state: 驱动应用的数据源view: 以声明方式将state映射到视图actions: 响应在view上的用户输入导致的状态变化(包含n个更新状态的方法) 多组件共享状态的问题 多个视图依赖于同一状态来自不同视图的行为需要变更同一状态以前的解决办法 将数据以及操作数据的行为都定义在父组件 将数据以及操作数据的行为传递给需要的各个子组件(有可能需要多级传递) vuex就是用来解决这个问题的 vuex的核心概念state vuex管理的状态对象它应该是唯一的 123const state = &#123; xxx: initValue&#125; mutations 包含多个直接更新state的方法(回调函数)的对象谁来触发: action中的commit(‘mutation名称’)只能包含同步的代码, 不能写异步代码 12345const mutations = &#123; yyy (state, data) &#123; // 更新state的某个属性 &#125;&#125; actions 包含多个事件回调函数的对象通过执行: commit()来触发mutation的调用, 间接更新state谁来触发: 组件中: $store.dispatch(‘action名称’) // ‘zzz’可以包含异步代码(定时器, ajax) 12345const actions = &#123; zzz (&#123;commit, state&#125;, data1) &#123; commit('yyy', data2) &#125;&#125; getters 包含多个计算属性(get)的对象谁来读取: 组件中: $store.getters.xxx 12345const getters = &#123; mmm (state) &#123; return ... &#125;&#125; modules 包含多个module一个module是一个store的配置对象与一个组件(包含有共享数据)对应 向外暴露store对象123456export default new Vuex.Store(&#123; state, mutations, actions, getters&#125;) 组件中:12345import &#123;mapGetters, mapActions&#125; from 'vuex'export default &#123; computed: mapGetters(['mmm']) methods: mapActions(['zzz'])&#125; @click=”zzz(data)” 映射store1234import store from './store'new Vue(&#123; store&#125;) store对象 所有用vuex管理的组件中都多了一个属性$store, 它就是一个store对象 属性:state: 注册的state对象getters: 注册的getters对象 方法:dispatch(actionName, data): 分发action 将vuex引到项目中 下载: npm install vuex –save 使用vuex 123456789// store.jsimport Vuex from 'vuex'export default new Vuex.Store(&#123; state, mutations, actions, getters, modules&#125;) 12345// main.jsimport store from './store.js'new Vue(&#123; store&#125;) vue-devtool &emsp;&emsp;点击devtool 的第二个按钮可以检测到 vuex var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（七）]]></title>
    <url>%2Fposts%2F3fb9ee2b.html</url>
    <content type="text"><![CDATA[前言 本文章结合VUE核心技术-尚硅谷的56-62集做的归纳总结。 1.数据绑定(model==&gt;View): 1). 一旦更新了data中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会更新(更新) 2.数据劫持 1). 数据劫持是vue中用来实现数据绑定的一种技术 2). 基本思想: 通过defineProperty()来监视data中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 3.四个重要对象 1). Observer * 用来对data所有属性数据进行劫持的构造函数 * 给data中所有属性重新定义属性描述(get/set) * 为data中的每个属性创建对应的dep对象 2). Dep(Depend) * data中的每个属性(所有层次)都对应一个dep对象 * 创建的时机: * 在初始化define data中各个属性时创建对应的dep对象 * 在data中的某个属性值被设置为新的对象时 * 对象的结构 { id, // 每个dep都有一个唯一的id subs //包含n个对应watcher的数组(subscribes的简写) } * subs属性说明 * 当一个watcher被创建时, 内部会将当前watcher对象添加到对应的dep对象的subs中 * 当此data属性的值发生改变时, 所有subs中的watcher都会收到更新的通知, 从而最终更新对应的界面 3). Compile * 用来解析模板页面的对象的构造函数(一个实例) * 利用compile对象解析模板页面 * 每解析一个表达式(非事件指令)都会创建一个对应的watcher对象, 并建立watcher与dep的关系 * complie与watcher关系: 一对多的关系 4). Watcher * 模板中每个非事件指令或表达式都对应一个watcher对象 * 监视当前表达式数据的变化 * 创建的时机: 在初始化编译模板时 * 对象的组成 { vm, //vm对象 exp, //对应指令的表达式 cb, //当表达式所对应的数据发生改变的回调函数 value, //表达式当前的值 depIds //表达式中各级属性所对应的dep对象的集合对象 //属性名为dep的id, 属性值为dep } 5). 总结: dep与watcher的关系: 多对多 * 一个data中的属性对应对应一个dep, 一个dep中可能包含多个watcher(模板中有几个表达式使用到了属性) * 模板中一个非事件表达式对应一个watcher, 一个watcher中可能包含多个dep(表达式中包含了几个data属性) * 数据绑定使用到2个核心技术 * defineProperty() * 消息订阅与发布 4.双向数据绑定 1). 双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的 2). 双向数据绑定的实现流程: * 在解析v-model指令时, 给当前元素添加input监听 * 当input的value发生改变时, 将最新的值赋值给当前表达式所对应的data属性 数据绑定 model==&gt;View 一旦更新了data中的某个属性数据, 所有界面上直接使用或间接使用了此属性的节点都会更新(更新) 数据劫持 数据劫持是vue中用来实现数据绑定的一种技术 基本思想: 通过defineProperty()来监视data中所有属性(任意层次)数据的变化, 一旦变化就去更新界面 四个重要对象数据劫持-数据绑定 - 打开控制台调试 Observer 用来对data所有属性数据进行劫持的构造函数 给data中所有属性重新定义属性描述(get/set) 为data中的每个属性创建对应的dep对象 &emsp;&emsp; mvvm.js 内部会执行 observe 方法 &emsp;&emsp;observe 会创建 Observer 观察者实例 &emsp;&emsp;观察者内部会执行 walk 函数遍历数据&emsp;&emsp;walk函数会遍历 data 中的数据，然后分别将data的键值对传入到 defineReactive 中 &emsp;&emsp; defineReactive 会再次对子元素的键值对对象调用 observe 方法，实现递归遍历所有子层级 &emsp;&emsp;遍历到的值会放到data中进行绑定&emsp;&emsp;通过 get 和 set 方法来对数据进行监听和更新 Dep(Depend) &emsp;&emsp;在上一节中也提到上面的代码执行，唯独跳过了 Watcher 的说明&emsp;&emsp;这里就是用 Watcher 来监视数据变化，表达式exp对应的属性发生变化就执行更新方法 &emsp;&emsp;Watcher 内部会执行 this.get() 获取数据 &emsp;&emsp;在 get 中又用到了 Dep 对象 &emsp;&emsp;而 Dep 自身又 id 属性，每一次创建 id 都会 ++&emsp;&emsp;里面有 subs 表示订阅者，可以实现监听。&emsp;&emsp;subs 数组存放的是 Watcher 监听者 &emsp;&emsp;回到前面可以看到 Dep 实在 defineProperty 之前创建的，属于初始化的时候更新的 &emsp;&emsp;而Watcher是在 bind 方法中生成的，属于更新过程创建 &emsp;&emsp;每一组需要更新的元素会创建 watcher&emsp;&emsp;dep则对依赖关系 双向数据绑定双向数据绑定 - 打开控制台调试 &emsp;&emsp;编译指令属性到会去 编译 v-model 属性 &emsp;&emsp; compileUtil 中有 model 函数&emsp;&emsp;model函数会执行bind方法 &emsp;&emsp;bind方法 会创建 Watcher 实现数据监听 &emsp;&emsp;接着获取 VM 数据&emsp;&emsp;接着会添加事件监听器，通过 input 监听可以实现输入的触发&emsp;&emsp;当 input 发生时，获取 input 的数据更新到变量当中 &emsp;&emsp;最后更新modelUpdater更新页面 observer.js 代码注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function Observer(data) &#123; // 保存data对象 this.data = data; // 走起 this.walk(data);&#125;Observer.prototype = &#123; walk: function(data) &#123; var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function(key) &#123; // 针对指定属性进行处理 me.convert(key, data[key]); &#125;); &#125;, convert: function(key, val) &#123; // 对指定属性实现响应式数据绑定 this.defineReactive(this.data, key, val); &#125;, defineReactive: function(data, key, val) &#123; // 创建与当前属性对应的dep对象 var dep = new Dep(); // 间接递归调用实现对data中所有层次属性的劫持 var childObj = observe(val); // 给data重新定义属性(添加set/get) Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; // 建立dep与watcher的关系 if (Dep.target) &#123; dep.depend(); &#125; // 返回属性值 return val; &#125;, set: function(newVal) &#123; if (newVal === val) &#123; return; &#125; val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); // 通过dep dep.notify(); &#125; &#125;); &#125;&#125;;function observe(value, vm) &#123; // value必须是对象, 因为监视的是对象内部的属性 if (!value || typeof value !== 'object') &#123; return; &#125; // 创建一个对应的观察都对象 return new Observer(value);&#125;;var uid = 0;function Dep() &#123; // 标识属性 this.id = uid++; // 相关的所有watcher的数组 this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, depend: function() &#123; Dep.target.addDep(this); &#125;, removeSub: function(sub) &#123; var index = this.subs.indexOf(sub); if (index != -1) &#123; this.subs.splice(index, 1); &#125; &#125;, notify: function() &#123; // 通知所有相关的watcher(一个订阅者) this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;;Dep.target = null; watcher.js 代码注解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function Watcher(vm, exp, cb) &#123; this.cb = cb; // callback this.vm = vm; this.exp = exp; this.depIds = &#123;&#125;; // &#123;0: d0, 1: d1, 2: d2&#125; this.value = this.get();&#125;Watcher.prototype = &#123; update: function () &#123; this.run(); &#125;, run: function () &#123; // 得到最新的值 var value = this.get(); // 得到旧值 var oldVal = this.value; // 如果不相同 if (value !== oldVal) &#123; this.value = value; // 调用回调函数更新对应的界面 this.cb.call(this.vm, value, oldVal); &#125; &#125;, addDep: function (dep) &#123; if (!this.depIds.hasOwnProperty(dep.id)) &#123; // 建立dep到watcher dep.addSub(this); // 建立watcher到dep的关系 this.depIds[dep.id] = dep; &#125; &#125;, get: function () &#123; Dep.target = this; // 获取当前表达式的值, 内部会导致属性的get()调用 var value = this.getVMVal(); Dep.target = null; return value; &#125;, getVMVal: function () &#123; var exp = this.exp.split('.'); var val = this.vm._data; exp.forEach(function (k) &#123; val = val[k]; &#125;); return val; &#125;&#125;; var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（六）]]></title>
    <url>%2Fposts%2Fedb999b4.html</url>
    <content type="text"><![CDATA[前言 本文章结合VUE核心技术-尚硅谷的49-55集做的归纳总结。 数据代理准备1.通过一个对象代理对另一个对象中属性的操作(读/写) 2.通过vm对象来代理data对象中所有属性的操作 3.好处: 更方便的操作data中的数据 4.基本实现流程 1). 通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符 2). 所有添加的属性都包含getter/setter 3). 在getter/setter内部去操作data中对应的属性数据 &emsp;&emsp;vm实例中有 _data 数据，存储了Vue初始化的数据。&emsp;&emsp;name属性则是动态属性，需要在控制台点击获取 &emsp;&emsp;点击其实是执行了 name 的 get 方法，这个就是代理&emsp;&emsp;set方法就是当值发生改变的时候执行 浏览器 Debug 调试 &emsp;&emsp;浏览器的控制台上 Source 标签提供了 断掉调试模式&emsp;&emsp;方便追踪代码的运行情况。 &emsp;&emsp;浏览器上如上图的有四个按钮用来进行代码测试 第一个按钮，开启断点调试或跳到下一个断点 第二个按钮，执行下一行 第三个按钮，执行到下一个函数 第四个按钮，跳出当前函数 &emsp;&emsp;浏览如上图的位置可以切换控制台的摆放方式 &emsp;&emsp;右边可以看到当前断点运行的位置，还可以看到是什么文件以及第几行代码&emsp;&emsp;如此点击第二个按钮就可以一行一行执行代码，可以看到变量属性在执行代码之后的变化。 数据代理分析数据代理 - 打开控制台调试 &emsp;&emsp;此处遍历data的所有数据，并执行代理函数 &emsp;&emsp;代理函数执行 defineProperty 到 vm 对象上&emsp;&emsp;这样就完成了所有数据代理，实现数据获取和更新 mvvm.js 代码注解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*相关于Vue的构造函数 */function MVVM(options) &#123; // 将选项对象保存到vm this.$options = options; // 将data对象保存到vm和datq变量中 var data = this._data = this.$options.data; //将vm保存在me变量中 var me = this; // 遍历data中所有属性 Object.keys(data).forEach(function (key) &#123; // 属性名: name // 对指定属性实现代理 me._proxy(key); &#125;); // 对data进行监视 observe(data, this); // 创建一个用来编译模板的compile对象 this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; $watch: function (key, cb, options) &#123; new Watcher(this, key, cb); &#125;, // 对指定属性实现代理 _proxy: function (key) &#123; // 保存vm var me = this; // 给vm添加指定属性名的属性(使用属性描述) Object.defineProperty(me, key, &#123; configurable: false, // 不能再重新定义 enumerable: true, // 可以枚举 // 当通过vm.name读取属性值时自动调用 get: function proxyGetter() &#123; // 读取data中对应属性值返回(实现代理读操作) return me._data[key]; &#125;, // 当通过vm.name = 'xxx'时自动调用 set: function proxySetter(newVal) &#123; // 将最新的值保存到data中对应的属性上(实现代理写操作) me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 模板解析1.模板解析的关键对象: compile对象 2.模板解析的基本流程: 1). 将el的所有子节点取出, 添加到一个新建的文档fragment对象中 2). 对fragment中的所有层次子节点递归进行编译解析处理 * 对表达式文本节点进行解析 * 对元素节点的指令属性进行解析 * 事件指令解析 * 一般指令解析 3). 将解析后的fragment添加到el中显示 3.解析表达式文本节点: textNode.textContent = value 1). 根据正则对象得到匹配出的表达式字符串: 子匹配/RegExp.$1 2). 从data中取出表达式对应的属性值 3). 将属性值设置为文本节点的textContent 4.事件指令解析: elementNode.addEventListener(事件名, 回调函数.bind(vm)) v-on:click=&quot;test&quot; 1). 从指令名中取出事件名 2). 根据指令的值(表达式)从methods中得到对应的事件处理函数对象 3). 给当前元素节点绑定指定事件名和回调函数的dom事件监听 4). 指令解析完后, 移除此指令属性 5.一般指令解析: elementNode.xxx = value 1). 得到指令名和指令值(表达式) 2). 从data中根据表达式得到对应的值 3). 根据指令名确定需要操作元素节点的什么属性 * v-text---textContent属性 * v-html---innerHTML属性 * v-class--className属性 4). 将得到的表达式的值设置到对应的属性上 5). 移除元素的指令属性 双大括号表达式双大括号表达式 - 打开控制台调试 &emsp;&emsp;compile函数会获取绑定 el 对象，如果没有则获取 body 对象上 &emsp;&emsp;检查传入的对象是不是元素节点，如果不是元素则通过 querySelector 来获取元素，H5添加了类似JQuery选择器的功能 &emsp;&emsp;将node节点转换为 fragment 容器 &emsp;&emsp;正如之前 fragment 演示的一样，会将页面的内容截取掉。&emsp;&emsp;下一步就会执行 init 函数 &emsp;&emsp;init函数会执行 compileElement 函数 &emsp;&emsp;compileElement 内部会获取 fragment 获取到的节点&emsp;&emsp;然后将数组转为真数组进行遍历&emsp;&emsp;通过正则表达式来匹配 双大括号 &emsp;&emsp; isElementNode 可以过滤 div 等等 Html 节点&emsp;&emsp;然后继续进入子对象，就会获取到 div 中的内容&emsp;&emsp;如果检测是 文本信息 就通过上面的正则表达式进行匹配，由于正则表达式加入了括号，获取的内容会放到 $1 变量中&emsp;&emsp;这个正则表达式非常好用，Vscode编辑器也是一样的 &emsp;&emsp;鼠标指向可以看到 $1 存储了name数据 &emsp;&emsp;这里会进入到 compileUtil 工具集 &emsp;&emsp;可以看到这个工具集函数定义了很多相关的方法 &emsp;&emsp;执行工具集会跳转到 bind 方法，bind中使用了 updater 相关函数 &emsp;&emsp;updater也有很多设置好的更新方法 &emsp;&emsp;通过 [] 传值，动态获取updater中的函数 &emsp;&emsp;如果 updaterFn 不存在就不执行，如果存在执行函数 &emsp;&emsp; _getVMVal 返回 vm._data 对象中的数据&emsp;&emsp;同时拆分了传入的变量 exp 中的内容 &emsp;&emsp;最后将返回的值赋值到 textContent 上,完成了内容的更新 事件指令事件指令 - 打开控制台调试 &emsp;&emsp;在HTML中添加按钮绑定点击事件 &emsp;&emsp;在节点解析的过程中会进入到相关属性的处理 &emsp;&emsp;在这里遍历标签上的属性&emsp;&emsp;判断指令是否是 directive 指令，就是判断是否含有 v-&emsp;&emsp;然后截取后两个字符的字符串 &emsp;&emsp;判断是不是事件指令 (‘on’ 开头)&emsp;&emsp;然后进入 eventHandler 函数 &emsp;&emsp;截取 : 获取事件名&emsp;&emsp;从 methods 中获取传入的事件&emsp;&emsp;如果时间名和函数同时存在，就执行 addEventListener&emsp;&emsp;fn.bind(vm) 可以让函数的 this 指向 vm 一般指令事件指令 - 打开控制台调试 &emsp;&emsp;修改HTML标签 &emsp;&emsp;普通指令的执行会获取到 dir 的 text 属性 &emsp;&emsp;然后会执行到 compileUtil 的 text 函数&emsp;&emsp;再接着执行 bind 函数 &emsp;&emsp;updater 里面通过 textContent 更新页面内容&emsp;&emsp;通过 innerHtml 实现 HTML 标签的渲染 &emsp;&emsp;class的更新稍微复杂一点，需要和原有的class进行合并 &emsp;&emsp;点击第五个按钮可以禁用 所有的断点 compile.js 代码注解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226function Compile(el, vm) &#123; // 保存vm this.$vm = vm; // 保存el元素 this.$el = this.isElementNode(el) ? el : document.querySelector(el); // 如果el元素存在 if (this.$el) &#123; // 1. 取出el中所有子节点, 封装在一个framgment对象中 this.$fragment = this.node2Fragment(this.$el); // 2. 编译fragment中所有层次子节点 this.init(); // 3. 将fragment添加到el中 this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; node2Fragment: function (el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;, init: function () &#123; // 编译fragment this.compileElement(this.$fragment); &#125;, compileElement: function (el) &#123; // 得到所有子节点 var childNodes = el.childNodes, // 保存compile对象 me = this; // 遍历所有子节点 [].slice.call(childNodes).forEach(function (node) &#123; // 得到节点的文本内容 var text = node.textContent; // 正则对象(匹配大括号表达式) var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // &#123;&#123;name&#125;&#125; // 如果是元素节点 if (me.isElementNode(node)) &#123; // 编译元素节点的指令属性 me.compile(node); // 如果是一个大括号表达式格式的文本节点 &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; // 编译大括号表达式格式的文本节点 me.compileText(node, RegExp.$1); // RegExp.$1: 表达式 name &#125; // 如果子节点还有子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; // 递归调用实现所有层次节点的编译 me.compileElement(node); &#125; &#125;); &#125;, compile: function (node) &#123; // 得到所有标签属性节点 var nodeAttrs = node.attributes, me = this; // 遍历所有属性 [].slice.call(nodeAttrs).forEach(function (attr) &#123; // 得到属性名: v-on:click var attrName = attr.name; // 判断是否是指令属性 if (me.isDirective(attrName)) &#123; // 得到表达式(属性值): test var exp = attr.value; // 得到指令名: on:click var dir = attrName.substring(2); // 事件指令 if (me.isEventDirective(dir)) &#123; // 解析事件指令 compileUtil.eventHandler(node, me.$vm, exp, dir); // 普通指令 &#125; else &#123; // 解析普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp); &#125; // 移除指令属性 node.removeAttribute(attrName); &#125; &#125;); &#125;, compileText: function (node, exp) &#123; // 调用编译工具对象解析 compileUtil.text(node, this.$vm, exp); &#125;, isDirective: function (attr) &#123; return attr.indexOf('v-') == 0; &#125;, isEventDirective: function (dir) &#123; return dir.indexOf('on') === 0; &#125;, isElementNode: function (node) &#123; return node.nodeType == 1; &#125;, isTextNode: function (node) &#123; return node.nodeType == 3; &#125;&#125;;// 指令处理集合var compileUtil = &#123; // 解析: v-text/&#123;&#123;&#125;&#125; text: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'text'); &#125;, // 解析: v-html html: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'html'); &#125;, // 解析: v-model model: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'model'); var me = this, val = this._getVMVal(vm, exp); node.addEventListener('input', function (e) &#123; var newValue = e.target.value; if (val === newValue) &#123; return; &#125; me._setVMVal(vm, exp, newValue); val = newValue; &#125;); &#125;, // 解析: v-class class: function (node, vm, exp) &#123; this.bind(node, vm, exp, 'class'); &#125;, // 真正用于解析指令的方法 bind: function (node, vm, exp, dir) &#123; /*实现初始化显示*/ // 根据指令名(text)得到对应的更新节点函数 var updaterFn = updater[dir + 'Updater']; // 如果存在调用来更新节点 updaterFn &amp;&amp; updaterFn(node, this._getVMVal(vm, exp)); // 创建表达式对应的watcher对象 new Watcher(vm, exp, function (value, oldValue) &#123;/*更新界面*/ // 当对应的属性值发生了变化时, 自动调用, 更新对应的节点 updaterFn &amp;&amp; updaterFn(node, value, oldValue); &#125;); &#125;, // 事件处理 eventHandler: function (node, vm, exp, dir) &#123; // 得到事件名/类型: click var eventType = dir.split(':')[1], // 根据表达式得到事件处理函数(从methods中): test()&#123;&#125; fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp]; // 如果都存在 if (eventType &amp;&amp; fn) &#123; // 绑定指定事件名和回调函数的DOM事件监听, 将回调函数中的this强制绑定为vm node.addEventListener(eventType, fn.bind(vm), false); &#125; &#125;, // 得到表达式对应的value _getVMVal: function (vm, exp) &#123; var val = vm._data; exp = exp.split('.'); exp.forEach(function (k) &#123; val = val[k]; &#125;); return val; &#125;, _setVMVal: function (vm, exp, value) &#123; var val = vm._data; exp = exp.split('.'); exp.forEach(function (k, i) &#123; // 非最后一个key，更新val的值 if (i &lt; exp.length - 1) &#123; val = val[k]; &#125; else &#123; val[k] = value; &#125; &#125;); &#125;&#125;;// 包含多个用于更新节点方法的对象var updater = &#123; // 更新节点的textContent textUpdater: function (node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value; &#125;, // 更新节点的innerHTML htmlUpdater: function (node, value) &#123; node.innerHTML = typeof value == 'undefined' ? '' : value; &#125;, // 更新节点的className classUpdater: function (node, value, oldValue) &#123; var className = node.className; className = className.replace(oldValue, '').replace(/\s$/, ''); var space = className &amp;&amp; String(value) ? ' ' : ''; node.className = className + space + value; &#125;, // 更新节点的value modelUpdater: function (node, value, oldValue) &#123; node.value = typeof value == 'undefined' ? '' : value; &#125;&#125;; var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（五）]]></title>
    <url>%2Fposts%2F88b7d26d.html</url>
    <content type="text"><![CDATA[function transitionShow(id){ $(id).next().show(1000,function(){ window.dispatchEvent(new Event('resize')); }); } $(function(){ // 去除代码块中的换行 $('.demo').each(function(){ text = $(this).html().replace(//gi,'') $(this).html(text) }) // 将HTML代码与文本之间切换 $('.switchToHtml').each(function () { $(this).click(function () { let element = $(this).next(); if (element.hasClass("converted")) { element.html(element.text()) element.removeClass("converted") $(this).text('切换为HTML文本') } else { text = element.html() element.text(text) let regex = new RegExp("(&lt;\/.*?&gt;)", "gi"); text = element.html().replace(regex, "$1") // let regex2 = new RegExp("(&lt;.*?&gt;).*?(&lt;?!(\/))", "gi"); // text = text.replace(regex2, "$1$2") element.html(text) element.addClass("converted") $(this).text('切换为HTML渲染') } }) }) }) 前言 本文章结合VUE核心技术-尚硅谷的45-48集做的归纳总结。&emsp;&emsp;教程的文档里面提到仿照github上的朋友实现的库进行讲解 github&emsp;&emsp;抛开视频教程的讲解，其实github上的readme文档已经有了很详细的说明。&emsp;&emsp;视频教程提供了几个点 数据代理 模板解析 数据绑定 &emsp;&emsp;Hexo 博客的 Markdown 是支持嵌套 &lt;script&gt;&lt;/script&gt; 标签来执行js代码的。&emsp;&emsp;下面我直接使用 Markdown 来写 js 验证教程的输出结果。&emsp;&emsp;不仅将运行结果打印到控制台上，也添加了网页的显示。 根据伪数组生成对应的真数组 &emsp;&emsp;当我们使用 getElementsByTagName 获取到元素数组，会发现这个并不是js的数组。&emsp;&emsp;尽管它可以通过数组下标获取到对应的元素&emsp;&emsp;数组的一些常规方法如 foreach 也无法识别 &emsp;&emsp;在 es6 中可以使用 Array.from 来获取到真数组&emsp;&emsp;在 es5 中可以借助 Array.slice() 不传参数获取到数组的浅拷贝&emsp;&emsp;借助 slice.call 可以让非数组对象执行slice方法&emsp;&emsp;在 es5 中可以使用 Array.prototype.slice.call(lis)来获取到真数组 12345678const lis = document.getElementsByTagName('li') console.log(lis instanceof Array)console.log(lis[1].innerHTML)console.log(lis.forEach)const lis2 = Array.prototype.slice.call(lis);console.log(lis2 instanceof Array);console.log(lis2[1].innerHTML);console.log(lis2.forEach); 切换为HTML文本 1 2 3 点击执行js代码 $(function(){ $('#output_1').next().hide() $('#output_1').click(function(){ function outputData(output, data,display=false) { if(display){ output.innerHTML = output.innerHTML + "" + data + "" + ""; console.log(data); } else{ output.innerHTML = output.innerHTML + "" + data + "" + " : " + "" + eval(data) + "" + ""; console.log(eval(data)); } } const demo = document.getElementById('demo_1').nextElementSibling; const lis = demo.getElementsByTagName('li'); const output = document.getElementById('output_1').nextElementSibling; output.innerHTML = ""; outputData(output,"lis instanceof Array"); outputData(output,"lis[1].innerHTML"); outputData(output,"lis.forEach"); const lis2 = Array.prototype.slice.call(lis) outputData(output,"-------------------------------------",display=true); outputData(output,"执行 Array.prototype.slice.call(lis) 获取到真数组",display=true); outputData(output,"lis2 instanceof Array"); outputData(output,"lis2[1].innerHTML"); outputData(output,"lis2.forEach"); transitionShow("#output_1"); }) }); node.nodeType: 得到节点类型 &emsp;&emsp;不同类型的节点 nodeType 值是不一样的 123456const elementNode = document.getElementById('test')const attrNode = elementNode.getAttributeNode('id')const textNode = elementNode.firstChildconsole.log(elementNode.nodeType)console.log(attrNode.nodeType)console.log(textNode.nodeType) 切换为HTML文本 blog.l0v0.com 点击执行js代码 $(function(){ $('#output_2').next().hide() $("#output_2").click(function(){ function outputData(output, data,display=false) { if(display){ output.innerHTML = output.innerHTML + "" + data + "" + ""; console.log(data); } else{ output.innerHTML = output.innerHTML + "" + data + "" + " : " + "" + eval(data) + "" + ""; console.log(eval(data)); } } const output = document.getElementById('output_2').nextElementSibling; output.innerHTML = ""; const elementNode = document.getElementById('test'); const attrNode = elementNode.getAttributeNode('id'); const textNode = elementNode.firstChild outputData(output,"elementNode"); outputData(output,"elementNode.nodeType"); outputData(output,"attrNode"); outputData(output,"attrNode.nodeType"); outputData(output,"textNode"); outputData(output,"textNode.nodeType"); transitionShow("#output_2"); }) }); 给对象添加属性 defineProperty 的属性含义属性描述符： 数据描述符： configurable：是否可以重新定义 enumerable：是否可以枚举 value：初始值 writable：是否可以修改属性值 访问描述符： get：回调函数，根据其它相关的属性动态计算得到当前属性值 set：回调函数，监视当前属性值的变化，更新其它相关的属性值 &emsp;&emsp;通过设定 enumerable true 可以实现 for .. in keys() 的效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const obj = &#123; firstName: 'A', lastName: 'B'&#125;Object.defineProperty(obj, 'fullName', &#123; // 当读取对象此属性值时自动调用, 将函数返回的值作为属性值, this为obj get () &#123; return this.firstName + "-" + this.lastName; &#125;, // 当修改了对象的当前属性值时自动调用, 监视当前属性值的变化, 修改相关的属性, this为obj set (value) &#123; const names = value.split('-'); this.firstName = names[0]; this.lastName = names[1]; &#125;&#125;)console.log(obj.fullName); // A-Bobj.firstName = 'C';obj.lastName = 'D';console.log(obj.fullName); // C-Dobj.fullName = 'E-F'console.log(obj.firstName); // Econsole.log(obj.lastName); // F// 不可以使用两次 defineProperty /*Object.defineProperty(obj, 'fullName', &#123; configurable: true, enumerable: true, value: 'G-H', writable: true &#125;)*/// Object.keys(obj): 得到对象自身可枚举属性组成的数组Object.defineProperty(obj, 'fullName2', &#123; configurable: false, //是否可以重新define enumerable: true, // 是否可以枚举(for..in / keys()) value: 'A-B', // 指定初始值 writable: false // value是否可以修改 &#125;)console.log(obj.fullName2) // A-Bobj.fullName2 = 'E-F'console.log(obj.fullName2) // A-B const names = Object.keys(obj)console.log(names)// obj.hasOwnProperty(prop): 判断prop是否是obj自身的属性console.log(obj.hasOwnProperty('fullName')) // trueconsole.log(obj.hasOwnProperty('toString')) // false 点击执行js代码 $(function(){ $('#output_3').next().hide() $('#output_3').click(function(){ function outputData(output, data,display=false) { if(display){ output.innerHTML = output.innerHTML + "" + data + "" + ""; console.log(data); } else{ output.innerHTML = output.innerHTML + "" + data + "" + " : " + "" + eval(data) + "" + ""; console.log(eval(data)); } } let output = document.getElementById('output_3').nextElementSibling; output.innerHTML = ""; const obj = { firstName: 'A', lastName: 'B' } Object.defineProperty(obj, 'fullName', { get () { return this.firstName + "-" + this.lastName; }, set (value) { const names = value.split('-'); this.firstName = names[0]; this.lastName = names[1]; } }) outputData(output,"obj.firstName"); outputData(output,"obj.lastName"); outputData(output,"obj.fullName"); obj.firstName = 'C'; obj.lastName = 'D'; outputData(output,"-------------------------------------",display=true); outputData(output,"修改 firstName 和 lastName 的值",display=true); outputData(output,"obj.firstName"); outputData(output,"obj.lastName"); outputData(output,"obj.fullName"); obj.fullName = 'E-F'; outputData(output,"-------------------------------------",display=true); outputData(output,"修改 fullName 的值",display=true); outputData(output,"obj.fullName"); outputData(output,"obj.firstName"); outputData(output,"obj.lastName"); Object.defineProperty(obj, 'fullName2', { configurable: false, //是否可以重新define enumerable: true, // 是否可以枚举(for..in / keys()) value: 'A-B', // 指定初始值 writable: false // value是否可以修改 }) outputData(output,"-------------------------------------",display=true); outputData(output,"obj.fullName2"); obj.fullName2 = 'E-F' outputData(output,"obj.fullName2 = 'E-F' 无法修改值",display=true); outputData(output,"obj.fullName2"); const names = Object.keys(obj) outputData(output,"-------------------------------------",display=true); outputData(output,"通过 Object.keys(obj) 可以枚举数据",display=true); outputData(output,"names"); outputData(output,"-------------------------------------",display=true); outputData(output,"hasOwnProperty 判断是否含有相关的函数",display=true); outputData(output,"obj.hasOwnProperty('fullName')"); outputData(output,"obj.hasOwnProperty('toString')"); transitionShow("#output_3"); }); }) &emsp;&emsp; defineProperty 属性直到 es5 才支持，因此 IE8 及以下的浏览器都不支持 defineProperty 属性&emsp;&emsp;因此 Vue 也不支持 IE8 及以下的浏览器 DocumentFragment: 文档碎片(高效批量更新多个节点) &emsp;&emsp;document: 对应显示的页面, 包含n个element 一旦更新document内部的某个元素界面更新&emsp;&emsp;documentFragment: 内存中保存n个element的容器对象(不与界面关联), 如果更新framgnet中的某个element, 界面不变。&emsp;&emsp;使用documentFragment只需更新一次界面，执行效率更加高效！！！ 操作步骤： 创建fragment 取出ul中所有子节点取出保存到fragment 更新fragment中所有li的文本 将fragment插入ul 12345678910111213141516171819const ul = document.getElementById('fragment_test')// 1. 创建fragmentconst fragment = document.createDocumentFragment()// 2. 取出ul中所有子节点取出保存到fragmentlet child// 注意：这里不是判断语句 ！！！ child 获取 ul 下的标签元素，然后判断child是否为真while(child=ul.firstChild) &#123; fragment.appendChild(child) // 先将child从ul中移除, 添加为fragment子节点&#125;// 3. 更新fragment中所有li的文本Array.prototype.slice.call(fragment.childNodes).forEach(node =&gt; &#123; if (node.nodeType===1) &#123; // 判断元素节点 &lt;li&gt; node.textContent = 'l0v0.com' &#125;&#125;)// 4. 将fragment插入ulul.appendChild(fragment) 切换为HTML文本 www.l0v0.com www.l0v0.com www.l0v0.com 点击执行js代码 $(function(){ let clickCheck = false; $('#output_4').click(function(){ // Note 如果是文本显示模式 切换为渲染模式 let element = $('#output_4').prev() if (element.hasClass("converted")) { $('#demo_4').trigger('click') } function outputData(output, data,display=false) { if(display){ output.innerHTML = output.innerHTML + "" + data + "" + ""; console.log(data); } else{ output.innerHTML = output.innerHTML + "" + data + "" + " : " + "" + eval(data) + "" + ""; console.log(eval(data)); } } const demo = document.getElementById('demo_4').nextElementSibling; const lis = demo.getElementsByTagName('li'); const ul = document.getElementById('fragment_test') // 1. 创建fragment const fragment = document.createDocumentFragment() // 2. 取出ul中所有子节点取出保存到fragment let child while(child=ul.firstChild) { // 一个节点只能有一个父亲 fragment.appendChild(child) // 先将child从ul中移除, 添加为fragment子节点 } clickCheck = !clickCheck; // 3. 更新fragment中所有li的文本 Array.prototype.slice.call(fragment.childNodes).forEach(node => { if (node.nodeType===1) { // 元素节点 if(clickCheck) node.innerHTML = 'blog.l0v0.com'; else node.innerHTML = 'www.l0v0.com'; } }) // 4. 将fragment插入ul ul.appendChild(fragment) }) });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（四）]]></title>
    <url>%2Fposts%2Fe729172a.html</url>
    <content type="text"><![CDATA[前言 本文章结合VUE核心技术-尚硅谷的35-44集做的归纳总结。由于 vue-resource 已经弃用，所以跳过这个部分 axios 基本使用方法 &emsp;&emsp;首先需要执行 npm install axios --save 安装 axios 库 &emsp;&emsp;通过上述的代码就可以实现数据获取 获取github上v开头赞数最高的项目地址 axios 抓取github用户信息体验一下 &emsp;&emsp;通过 https://api.github.com/search/users?q=username github提供的API可以自由获取用户的基础信息。 Element &amp; Mint UI 库 &emsp;&emsp;来自饿了么前端团队开发的 Vue 组件样式库&emsp;&emsp;可以去官网支持一波 Mint UI Element Vue Router 基本用法 &emsp;&emsp;注意路由和路由器是不一样的&emsp;&emsp;路由是键值对 的 映射关系&emsp;&emsp;路由在后端用来处理回调函数，在前段用来处理组件显示 简单路由效果 &emsp;&emsp;路由配置 &emsp;&emsp;在Vue实例中进行注册 &emsp;&emsp;在页面元素中定义路由 Vue Router 嵌套路由 &emsp;&emsp;通过children实现路由嵌套 &emsp;&emsp;在HTML中调用路由相应的UI &emsp;&emsp;通过 keep-alive 缓存路由中的数据，切换路由的时候相应的数据不丢失 Vue Router 传递数据路由路径携带参数 &emsp;&emsp;在路由路径上加上 :id 来获取数据 &emsp;&emsp;相应在地址上传入对应的变量数据 &emsp;&emsp;通过 this.$route.params 可以获取到路由设置的变量，通过 .id 就可以获取路径传入的数据 &emsp;&emsp;通过监听 $route 的数据可以直到路由发生了改变 属性携带数据 &emsp;&emsp;类似于组件传递数据一样 编程式路由导航 &emsp;&emsp;简单的理解就是用自定义的js函数来改变路由地址 var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（三）]]></title>
    <url>%2Fposts%2F50040e4f.html</url>
    <content type="text"><![CDATA[前言 本文章结合VUE核心技术-尚硅谷的17-34集做的归纳总结。 Vue Devtools &emsp;&emsp;安装浏览器的Vue插件可以很方便 Debug Vue 下载地址&emsp;&emsp;使用Chrome内核的浏览器打开 crx 文件就可以自动安装插件到浏览器上了&emsp;&emsp;安装完成就可以在浏览器上找到插件&emsp;&emsp;我们打开一个用 Vue 开发的网页，然后按 F12 进入控制台&emsp;&emsp;控制台就会多出一个 Vue 的标签 创建 Vue 项目 安装步骤 (先确保电脑安装了 node.js 或者 yarn) 打开命令行 输入 npm install -g vue-cli 全局安装 vue-cli 跳转到项目路径下输入 vue init webpack vue_demo 使用 webpack 打包方式初始化 vue-cli 这个时候会需要输入一些选项来配置项目，根据需求配置即可。 操作完成之后会在目录下多出 vue_demo 文件夹，输入 cd vue_demo 跳转到文件夹 输入 npm install 安装工程插件 输入 npm run dev 开启服务器用于本地访问 在浏览器中输入 http://localhost:8080/ 就可以访问到 vue-cli 搭建的初始网页 认识 Vue Cli &emsp;&emsp;完成项目创建之后，项目路径下会有如下的文件 &emsp;&emsp;进入config文件夹，打开 index.js 可以进行一些启动配置 &emsp;&emsp;键入src文件夹，可以看到如下文件 main.js 入口函数 和 外部的 index.html 照相呼应。这里填入的el元素来自于 index.html 的元素同时引用 App.vue 进行组件注册 App.vue 是vue的模板文件包含三个模块 templete script style 通过引入外部组件就可以实现自定义的HTML标签 项目打包与发布 &emsp;&emsp;项目开发完之后执行 npm run build 会读取build文件夹中的配置&emsp;&emsp;最后生成一个完整的页面存放在 dist 目录下&emsp;&emsp;打包完成的网页构建服务器才可以访问。（主要原因是资源路径都是通过根目录索引，没有服务器站点无法获取正确的根目录 解决方案） 搭建服务器有很多方法 npm 静态服务器 npm 安装 serve 模块 npm install -g serve 然后再dist上层目录执行 serve dist 浏览器输入 localhsot:5000 访问 vscode liveserver 静态服务器 安装vscode liveserver 插件 去到 dist 根目录，然后右键 Open with Code 打开html文件点击状态栏上的 Go Live 按钮就可以自动打开网页 动态服务器 - 不再赘述 Tomcat Apacahe Ngnix &emsp;&emsp;Apache&amp;Ngnix 可以安装 phpStudy 或者 wamp 快速配置服务器环境 体验一下 ESlint 代码检查 &emsp;&emsp; ESlint 工具可以再发布之前检查代码是否符合编写规范&emsp;&emsp;如果不符合规范就会在相应位置报错。 &emsp;&emsp;可以再 .eslintignore 下配置ESlint的检查范围 评论 - 案例制作评论效果 - 体验一下 &emsp;&emsp;这里通过案例介绍了网页组件化的思想。&emsp;&emsp;开干之前我们应该先设计好静态页面，确定网站的布局。&emsp;&emsp;然后根据静态页面拆分出需要用到的组件。&emsp;&emsp;拆分出组件之后就可以对需要用到的数据进行分类。 &emsp;&emsp;通过在组件上定义 props 可以实现组件传值，完成组件与组件之间的通信 &emsp;&emsp;传值也很简单，直接绑定到组件的属性上即可 &emsp;&emsp;当然后面有 Vuex 可以作为全局的数据管理器，通信更简单。 todoList - 案例制作todoList - 体验一下 &emsp;&emsp;同样地这里也是先准备好静态页面，再对页面进行组件划分&emsp;&emsp;然后创建相应组件的 vue 文件引入到 app.vue 当中&emsp;&emsp;css也要分组件管理好&emsp;&emsp;映射了HTML标签之后，可以根据大小写切分出对应的标签&emsp;&emsp; &lt;=&gt; &emsp;&emsp;通过 @mouseenter @mouseleave 可以监听鼠标是否在元素上，实现颜色的变化&emsp;&emsp;这个实现效果类似于 CSS 的 hover 效果 &emsp;&emsp;通过 localstorage 可以将一些数据临时保存在浏览器的 localstorage 缓存中，只要网页不清空历史数据，就可以读取缓存将数据保存在本地。 PubSub.js 组件通信 &emsp;&emsp;安装 PubSub.js 来实现事件全局注册调用&emsp;&emsp;原理就是 观察者模式&emsp;&emsp;通过注册事件和触发事件来达到满足特定条件才执行事件函数&emsp;&emsp;这样就无须考虑父子层级的问题 Slot 组件通信 &emsp;&emsp;和 Qt 的槽函数基本能一致&emsp;&emsp;需要在子组件注册槽函数&emsp;&emsp;然后再父组件中触发槽函数完成操作 &emsp;&emsp;参考第9期文章 localstroage 存储优化 &emsp;&emsp;可以将部分js代码拆分成单独的js库&emsp;&emsp;在 .vue 文件中调用js库来实现相应的函数功能 var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（二）]]></title>
    <url>%2Fposts%2F1d1aad1d.html</url>
    <content type="text"><![CDATA[前言 本文章结合VUE核心技术-尚硅谷的11-17集做的归纳总结。 事件处理 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt; &lt;div id="demo"&gt; &lt;h2&gt;1. 绑定监听&lt;/h2&gt; &lt;button @click="test1"&gt;test1&lt;/button&gt; &lt;button @click="test2('test')"&gt;test2&lt;/button&gt; &lt;button @click="test3"&gt;test3&lt;/button&gt; &lt;button @click="test4(13,$event)"&gt;test4&lt;/button&gt; &lt;h2&gt;2. 事件修饰符&lt;/h2&gt; &lt;div style="width: 200px;height: 200px;background:red;" @click="test5"&gt; &lt;div style="width: 100px;height: 100px;background:blue;" @click.stop="test6"&gt;&lt;/div&gt; &lt;/div&gt; &lt;a href="https://www.baidu.com" @click.prevent="test7"&gt;去百度&lt;/a&gt; &lt;h2&gt;3. 按键修饰符&lt;/h2&gt; &lt;input type="text" @keyup="test8"&gt; &lt;br&gt; &lt;input type="text" @keyup.enter="test9"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;// Vue 的数组方法都是经过写了，实现界面更新vm = new Vue(&#123; el:'#demo', methods:&#123; test1()&#123; alert('test'); &#125;, test2(msg)&#123; alert(msg); &#125;, test3(event)&#123; alert(event.target.innerHTML); &#125;, test4(number,event)&#123; alert(number + '---' + event.target.innerHTML); &#125;, test5()&#123; alert('out'); &#125;, test6()&#123; alert('inner'); &#125;, test7()&#123; alert('点击了'); &#125;, test8(event)&#123; if(event.keyCode === 13)&#123; alert(event.target.value + ' ' + event.keyCode); &#125; &#125;, test9(event)&#123; alert(event.target.value + ' ' + event.keyCode); &#125;, &#125;&#125;)&lt;/script&gt; 体验一下 绑定监听 @click=&quot;&quot; 可以再字符串中写入调用的函数名，通过加括号来获取参数 如果不传入参数，默认可以接受一个 $event 参数 事件修饰符 @click=&quot;&quot; 等同于 addEventListener 的点击事件 在Vue中可以使用 `@click.stop=””快速实现stopPropagation` 同样可以使用 `@click.prevent=””快速实现preventDefault` 按键修饰符 @keyup=&quot;&quot; 可以绑定键盘事件 `@keyup.enter=””可以实现enter键触发 代替event.keyCode === 13` 的判断 表单输入绑定 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;div id="demo"&gt; &lt;form action="/xxx" @submit="handleSumbit"&gt; &lt;span&gt;用户名：&lt;/span&gt; &lt;input type="text" v-model="username"&gt; &lt;br&gt; &lt;span&gt;密码：&lt;/span&gt; &lt;input type="password" v-model="pwd"&gt; &lt;br&gt; &lt;span&gt;性别：&lt;/span&gt; &lt;input type="radio"id="female" value="女" v-model="sex"&gt; &lt;label for="female"&gt;女&lt;/label&gt; &lt;input type="radio"id="male" value="男" v-model="sex"&gt; &lt;label for="male"&gt;男&lt;/label&gt; &lt;br&gt; &lt;span&gt;爱好：&lt;/span&gt; &lt;input type="checkbox"id="basket" value="basket" v-model="likes"&gt; &lt;label for="basket"&gt;篮球&lt;/label&gt; &lt;input type="checkbox"id="foot" value="foot" v-model="likes"&gt; &lt;label for="foot"&gt;足球&lt;/label&gt; &lt;input type="checkbox"id="pingpang" value="pingpang" v-model="likes"&gt; &lt;label for="pingpang"&gt;乒乓&lt;/label&gt;&lt;br&gt; &lt;span&gt;城市：&lt;/span&gt; &lt;select v-model="cityId"&gt; &lt;option value=""&gt;未选择&lt;/option&gt; &lt;option :value="city.id" v-for="(city,index) in allCitys" :key="index"&gt;&#123;&#123;city.name&#125;&#125;&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;介绍：&lt;/span&gt; &lt;textarea rows="10" v-model="desc"&gt;&lt;/textarea&gt; &lt;br&gt; &lt;br&gt; &lt;input type="submit"value="注册"&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;vm = new Vue(&#123; el:'#demo', data:&#123; username:'', pwd:'', sex:'男', likes:['foot'], allCitys:[&#123;id:1,name:'北京'&#125;,&#123;id:2,name:'上海'&#125;,&#123;id:3,name:'广东'&#125;], cityId:'3', desc:'' &#125;, methods:&#123; handleSumbit()&#123; alert(this.username,this.pwd,this.likes,this.cityId,this.desc) &#125; &#125;&#125;)&lt;/script&gt; 体验一下 v-model 可以绑定到HTML的组件上，实现表单数据的抓取 生命周期 官网介绍 核心代码 123456789101112131415161718192021222324252627282930&lt;body&gt; &lt;div id="demo"&gt; &lt;button @click="destroyVM"&gt;destroy vm&lt;/button&gt; &lt;p v-show="isShow"&gt; l0v0.com &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;const vm = new Vue(&#123; el:'#demo', data:&#123; isShow:true, &#125;, mounted()&#123; this.internalId = setInterval(() =&gt; &#123; this.isShow = !this.isShow &#125;, 1000); &#125;, beforeDestry()&#123;// 死亡之前调用 // 清除定时器 clearInterval(this.internalId) &#125;, methods:&#123; destroyVM()&#123; this.$destroy() &#125; &#125;, &#125;)&lt;/script&gt; 体验一下 &emsp;&emsp;生命周期于 Android React 这些框架的生命周期大致相同&emsp;&emsp;也就是 Vue 实例启动的时候回调用的函数&emsp;&emsp;通过复写这些函数可以实现在对应的时间段执行对应的代码，确保实现效果符合预期。 过渡 &amp; 动画 核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;style&gt;/* 显示/隐藏的过滤效果 */.xxx-enter-active, .xxx-leave-active&#123; transition: opacity 1s;&#125;/* 隐藏时的样式 */.xxx-enter , .xxx-leave-to &#123; opacity: 0;&#125;/* 显示的过滤效果 */.move-enter-active&#123; transition: all 1s&#125;/* 隐藏的过滤效果 */ .move-leave-active&#123; transition: all 1s&#125;/* 隐藏的过滤效果 */.move-enter, .move-leave-to&#123; opacity: 0; transform: translateX(20px);&#125;.bounce-enter-active &#123;animation: bounce-in .5s;&#125;.bounce-leave-active &#123;animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123;0% &#123; transform: scale(0);&#125;50% &#123; transform: scale(1.5);&#125;100% &#123; transform: scale(1);&#125;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id="demo" style="text-align: center"&gt; &lt;button @click="isShow=!isShow"&gt;toggle&lt;/button&gt; &lt;transition name="xxx"&gt; &lt;p v-show="isShow" class="xxx-enter-to"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;br&gt; &lt;button @click="isShow=!isShow"&gt;toggle&lt;/button&gt; &lt;transition name="move"&gt; &lt;p v-show="isShow" class="xxx-enter-to"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;br&gt; &lt;button @click="isShow = !isShow"&gt;Toggle show&lt;/button&gt; &lt;transition name="bounce"&gt; &lt;p v-if="isShow"&gt;Lorem ipsum dolor sit amet.&lt;/p&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;const vm = new Vue(&#123; el:'#demo', data:&#123; isShow:true, &#125;,&#125;)&lt;/script&gt; 体验一下 &emsp;&emsp;通过 transition 标签来定义相关CSS快速实现过渡效果 官网参考 过滤器 核心代码 123456789101112131415161718192021222324&lt;body&gt; &lt;div id="demo"&gt; &lt;h2&gt;显示格式化的日期时间&lt;/h2&gt; &lt;p&gt;&#123;&#123;date&#125;&#125;&lt;/p&gt; &lt;p&gt;完整版 : &#123;&#123;date | dateString&#125;&#125; &lt;/p&gt; &lt;p&gt;年月日 : &#123;&#123;date | dateString('YYYY-MM-DD')&#125;&#125; &lt;/p&gt; &lt;p&gt;时分秒 : &#123;&#123;date | dateString('HH:mm:ss')&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;// 自定义过滤Vue.filter('dateString',function(value,format = 'YYYY-MM-DD HH:mm:ss')&#123; return moment(value).format(format)&#125;)const vm = new Vue(&#123; el:'#demo', data:&#123; date:new Date(), &#125;,&#125;)&lt;/script&gt; 体验一下 &emsp;&emsp; 通过 moment.js 对时间进行格式化&emsp;&emsp; 通过过滤器可以给定特定条件返回对应的值 过滤器 常用内置指令 v:text：更新元素的 textContent V-htmL：更新元素的 innerHTML v-if：如果为true，当前标签才会输出到页面 v-else：如果为false，当前标签才会输出到页面 v-show：通过控制dispLay样式来控制显示/隐藏 V-for：遍历数组/对象 V-on：绑定事件监听，一般简写为@ v-bind：强制定解析表达式，可以省略v-bind V-modeL：双向数据绑定 ref：为某个元素注册一个唯一标识，vue对象通过sels属性访问这个元素对象 v-cLoak：使用它防止闪现表达式，与css配合：[v-cloak]{display:none} 核心代码 12345678910111213141516171819202122232425262728&lt;style&gt; [v-cloak] &#123; display: none; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="demo"&gt; &lt;p&gt;l0v0.com&lt;/p&gt; &lt;button @click="hint"&gt;提示&lt;/button&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p v-cloak&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;const vm = new Vue(&#123; el:'#demo', data:&#123; msg: 'l0v0', &#125;, methods:&#123; hint()&#123; alert(this.$refs.content.textContent) &#125; &#125;&#125;)&lt;/script&gt; 体验一下 自定义指令 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;body&gt;&lt;!-- 1.注册全局指令 Vue.directive('my-directive',function(el,binding)&#123; el.innerHTML=binding.value.toUpperCase() &#125;) 2.注册局部指令 directives:&#123; 'my-directive'：&#123; bind(el,binding)&#123; el.innerHTML=binding.value.toUpperCase() &#125; &#125; &#125; 3.使用指令 v-my-directive='xxx' 需求：自定义2个指令 1.功能类型于v-text,但转换为全大写 V-upper-text 2.功能类型于v-text,但转换为全小写 -Lower-text--&gt; &lt;div id="demo"&gt; &lt;p v-upper-text='msg1'&gt;&lt;/p&gt; &lt;p v-lower-text='msg1'&gt;&lt;/p&gt; &lt;/div&gt; &lt;div id="test"&gt; &lt;p v-upper-text='msg1'&gt;&lt;/p&gt; &lt;p v-lower-text='msg1'&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;//定义全局指令//el：指令属性所在的标签对象//binding：包含指令相关信息数据的对象Vue.directive('upper-text',function(el,binding)&#123; el.innerHTML=binding.value.toUpperCase()&#125;) new Vue(&#123; el:'#demo', data:&#123; msg1: 'l0v0', &#125;, directives:&#123; 'lower-text': function(el,binding)&#123; el.textContent = binding.value.toLowerCase() &#125; &#125;, methods:&#123; hint()&#123; alert(this.$refs.content.textContent) &#125; &#125;&#125;)new Vue(&#123; el:'#test', data:&#123; msg1: 'l0v0', &#125;,&#125;)&lt;/script&gt; 体验一下 注册指令 - 在Vue实例加入 directives 属性进行注册 - 注册会返回绑定的element 使用指令 - 在绑定的属性上加上 v- 就可以和内置指令一样使用特殊效果的属性 插件官网参考 核心代码 12345678910111213141516171819202122// 闭包写法(function () &#123; // 需要向外暴露的插件对象 const MyPlugin = &#123;&#125; // 插件对象必须有一个install属性 MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或属性 Vue.myGlobalMethod = function () &#123; &#125;; // 2. 添加全局资源 Vue.directive("my-directive", function (el, binding) &#123; el.textContent = binding.value.toUpperCase(); &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;; &#125;; window.MyPlugin = MyPlugin;&#125;)();123456789101112131415161718&lt;script src="./14.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;div id="demo"&gt; &lt;p v-my-directive="msg"&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; Vue.use(MyPlugin) const vm = new Vue(&#123; el: '#demo', data: &#123; msg: 'l0v0', &#125; &#125;) &lt;/script&gt; 体验一下 编写 Vue 插件步骤 Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象 添加全局方法或属性 添加全局资源 注入组件选项 添加实例方法 var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 学习之路（一）]]></title>
    <url>%2Fposts%2F2d0c41c5.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;今年暑假，也算是我大学最后一个暑假了，我老早就打算趁这段时间重构去年开发的 数字媒体技术 网站，也是为下学期的动态网页打基础。&emsp;&emsp;之前一直都是在脑海里筹备，但是一直没有将行动落实到位。&emsp;&emsp;最近总算是逼迫自己行动起来了，打算想把前端的框架过一遍，之前学习了 PHP 的 Laravel 框架，学习的时候总是惦记着前端框架。&emsp;&emsp;再加上教程用的是 Laravel 5.4 ，还停留在结合 JQ 的时代，再加上前后端模板的高度耦合，让我越学就越烦。&emsp;&emsp;所以无论是暑假的网站重构还是下学期的动态网页数据库大作业，我都打算用 前端框架去做。&emsp;&emsp;然后又继续陷入了框架的选择而纠结。&emsp;&emsp;之前开发手机app的时候，也在 Flutter &amp; 原生Android &amp; React Native 上面纠结。&emsp;&emsp;最后我三个都学了，然而也只不过是浅尝辄止，然后还欠了一篇博客没写额(:з」∠)&emsp;&emsp;这一次我还是纠结，因为毕设我打算开发一个跨平台的 Todo 软件，兼顾 网站 、 APP 、 小程序。&emsp;&emsp;然后我就找到了国内开发的 uniapp框架，这个框架可以完美兼容以上的平台，而且是用 Vue 进行开发，学习成本较低。&emsp;&emsp;所以我最后就决定了 Vue 框架深入学习了，之前也看了一个 React 的入门教程，完全没有做总结的后果就是我基本忘光了 React 的知识点了(:з」∠)&emsp;&emsp;其实之前也写了一些看教程的记录，问题是后续没有进一步的学习，长时间的不使用也就忘得产不多了，虽然后面学习 React Native 还过了很多有用的 es6 语法，但是还是那句话，不用就会忘的。&emsp;&emsp;而且之前一直努力写PyQt的教程，耗费了不少时间额。&emsp;&emsp;总之，现在我就从零开始，以最快的速度过一遍 Vue 框架的核心技术。 &emsp;&emsp;这一次也不例外，也是从B站搜教程开始学习，搜集了如下几个教程(其实我以前很喜欢看英文教程来秀优越感，今年开始都看中文教程了，可以加速到3、4倍看，看得酸爽，入门来说也不比英文教程差) VUE核心技术-尚硅谷 Vue Cli3.0全栈项目之资金管理系统带权限教程 本文章结合VUE核心技术-尚硅谷的1-10集做的归纳总结。 Vue 基本使用 Vue官方教程&emsp;&emsp;Vue官方有教程可以参考&emsp;&emsp;上面就阐述搭建一个最简单的Vue效果的案例。&emsp;&emsp;我们只需要将HTML代码修改一下就可以实现很神奇的效果。 1234&lt;div id="app"&gt; &lt;input type="text" v-model="message" &gt; &lt;p&gt;Hello &#123;&#123;message&#125;&#125; &lt;/p&gt;&lt;/div&gt; 体验一下 &emsp;&emsp;这里 v-model 就是将 vue data 中的变量 message 绑定到了输入框当中&emsp;&emsp; 用来显示变量数据 &emsp;&emsp;Vue的内核关系 DOM 为 HTML 树，即显示层 View ViewModel 是 Vue 内核，实现数据的监听和双向绑定 实现数据互相更新 Model 即为底层的数据 模板语法 核心代码 12345678910111213141516171819202122232425262728293031323334&lt;div id="app"&gt; &lt;h2&gt;1. 双大括号表达式&lt;/h2&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg.toUpperCase()&#125;&#125;&lt;/p&gt; &lt;p v-text="link"&gt;&lt;/p&gt; &lt;p v-html="link"&gt;&lt;/p&gt; &lt;h2&gt;2. 指令一：强制数据绑定&lt;/h2&gt; &lt;img src="imgUrl"&gt; &lt;img v-bind:src="imgUrl"&gt; &lt;img :src="imgUrl"&gt; &lt;h2&gt;2. 指令二：绑定时间监听&lt;/h2&gt; &lt;button v-on:click="click"&gt;点击事件1&lt;/button&gt; &lt;button @click="click2(msg)"&gt;点击事件2&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const vm = new Vue(&#123; el: '#app', data: &#123; msg: 'l0v0.com', link: '&lt;a href="https://blog.l0v0.com"&gt;blog.l0v0.com&lt;/a&gt;', imgUrl: 'https://cn.vuejs.org/images/logo.png', &#125;, methods: &#123; click() &#123; alert('点击事件1触发') &#125;, click2(content)&#123; alert(content) &#125; &#125; &#125;)&lt;/script&gt; 体验一下 双大括号表达式 Vue使用双括号表达式可以将 Vue 实例中data数据显示到页面上 双大括号里面支持js语句对变量进行操作 v-text 可以将变量输出 v-text 可以将变量以html的形式输出 强制数据绑定 在html的属性上加上 v-bind:属性值 就可以绑定 vue 的数据 可以简写为 :属性值 绑定时间监听 在html的属性上加上 v-on:事件属性值 就可以实现 vue 的方法监听触发 可以简写为 @事件属性值 vue中的事件给可以在实例参数中加入 methods 进行方法绑定 计算属性和监视 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;body&gt; &lt;div id="app"&gt; 姓：&lt;input type="text" placeholder="First Name" v-model="firstName"&gt;&lt;br&gt; 名：&lt;input type="text" placeholder="Last Name" v-model="lastName"&gt;&lt;br&gt; 姓名1：&lt;input type="text" placeholder="Full Name1" v-model="fullname1"&gt;&lt;br&gt; 姓名2：&lt;input type="text" placeholder="Full Name2" v-model="fullname2"&gt;&lt;br&gt; 姓名3：&lt;input type="text" placeholder="Full Name3" v-model="fullname3"&gt;&lt;br&gt; &lt;/div&gt;&lt;script&gt;vm = new Vue(&#123; el:'#app', data:&#123; firstName : 'A', lastName : 'B', &#125;, computed:&#123; fullname1 ()&#123; return this.firstName + " " + this.lastName &#125;, fullname3:&#123; get ()&#123; return this.firstName + ' ' + this.lastName &#125;, set (value)&#123; const names = value.split(' ') this.firstName = names[0] this.lastName = names[1] &#125; &#125; &#125;, watch : &#123; firstName: function(value)&#123; this.fullname2 = value + ' ' + this.lastName &#125;, lastName: function(value)&#123; this.fullname2 = this.firstName + ' ' + value &#125; &#125;&#125;)&lt;/script&gt; 体验一下 &emsp;&emsp;Vue采用MVVM，双向数据绑定的模型，当变量变化时，所有和采用变量相关信息的组件都会同步数据，非常方便。&emsp;&emsp;Vue 里面有几种方式可以监听数据实现动态更新 computed - 变量发生变化时触发 watch - 监听Html组件变化 computed &emsp;&emsp;computed的字典可以填入函数或者带get&amp;set方法的字典。传入的名称要和变量保持一致。&emsp;&emsp;直接填入函数的话，那么函数内调用的变量发生变化时，会触发函数修改 函数名相同的变量值。&emsp;&emsp;单向响应。 &emsp;&emsp;如果传入字典要写入 get 和 set 方法&emsp;&emsp;get方法获取数据，set会传入get获取的数据进行回调。&emsp;&emsp;双向响应。 watch &emsp;&emsp;可以监听数据，实现效果和 computed 效果差不多，不过只会改变受监视的对象而不考虑所有变量的变化情况。&emsp;&emsp;单向响应。 Class 与 style 绑定 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt; .aClass&#123; color:red; &#125; .bClass&#123; color:blue; &#125; .cClass&#123; font-size:30px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="demo"&gt; &lt;h2&gt;1. class 绑定 :class='xxx'&lt;/h2&gt; &lt;p class="cClass" :class="a"&gt;字符串&lt;/p&gt; &lt;p :class="&#123;aClass:isA,bClass:isB&#125;"&gt;对象&lt;/p&gt; &lt;p :class="['aClass','cClass']"&gt;数组&lt;/p&gt; &lt;h2&gt;2. style 绑定&lt;/h2&gt; &lt;p :style="&#123;color:activeColor,fontsize:fontSize + 'px'&#125;"&gt; style 样式&lt;/p&gt; &lt;button @click="update"&gt;class切换按钮&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; new Vue(&#123; el:"#demo", data:&#123; a:'aClass', isA:true, isB:false, activeColor:'red', fontSize:20, &#125;, methods:&#123; update()&#123; this.a = 'bClass' this.isA = this.isA === false ? true : false this.isB = this.isB === false ? true : false this.activeColor = 'green' this.fontSize = 50 &#125; &#125; &#125;)&lt;/script&gt; 体验一下 class 绑定 :class 实现类的绑定，可以 class &amp; :class 可以共存 :class 可以传入对象键值对，根据值的布尔数据来决定是否采用键 :class 可以传入数组，全部添加到class中 style 绑定 :style 可以实现样式绑定 使用方法类似于class绑定，不过传入的字符串为 js对象写法的 css 语句，支持使用 js 变量。 条件渲染 核心代码 1234567891011121314151617181920&lt;body&gt; &lt;div id="demo"&gt; &lt;p v-if="ok"&gt; 成功了&lt;/p&gt; &lt;p v-else&gt; 失败了&lt;/p&gt; &lt;p v-show="ok"&gt;表白成功&lt;/p&gt; &lt;p v-show="!ok"&gt;表白失败&lt;/p&gt; &lt;button @click="ok = !ok"&gt;切换&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;vm = new Vue(&#123; el:'#demo', data:&#123; ok : false, &#125;,&#125;)&lt;/script&gt; 体验一下 v-if 判断变量是否为真，真就显示，假则显示v-else v-else 依托 v-if 判断 v-show 和v-if一样，不需要 v-else，只关心自身的显示 列表渲染 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;div id="demo"&gt; &lt;h2&gt;测试：v-for 遍历数组&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="(p,index) in persons" :key="index"&gt; &#123;&#123;index&#125;&#125; --- &#123;&#123;p.name&#125;&#125; --- &#123;&#123;p.age&#125;&#125; --- &lt;button @click="deleteData(index)"&gt;删除&lt;/button&gt; --- &lt;button @click="updateData(index,&#123;name:'test',age:22&#125;)"&gt;更新&lt;/button&gt; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;测试：v-for 遍历对象&lt;/h2&gt; &lt;ul&gt; &lt;li v-for="(value,key) in persons[1]" :key="index"&gt; &#123;&#123;value&#125;&#125; --- &#123;&#123;key&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;script&gt;// Vue 的数组方法都是经过写了，实现界面更新vm = new Vue(&#123; el:'#demo', data:&#123; persons:[ &#123;name:"Tom",age:18&#125;, &#123;name:"Jack",age:16&#125;, &#123;name:"Bob",age:19&#125;, &#123;name:"Rose",age:17&#125;, &#123;name:"Tim",age:20&#125;, ] &#125;, methods:&#123; deleteData(index)&#123; this.persons.splice(index,1); &#125;, updateData(index,data)&#123; this.persons.splice(index,1,data); &#125; &#125;&#125;)&lt;/script&gt; 体验一下 注：刷新页面可以重置显示效果 v-for 遍历数组123&lt;li v-for="(p,index) in persons" :key="index"&gt; &#123;&#123;index&#125;&#125; --- &#123;&#123;p.name&#125;&#125; --- &#123;&#123;p.age&#125;&#125;&lt;/li&gt; &emsp;&emsp;使用方法挺容易理解的，和js的循环差不多，只是书写的形式变化了而已。&emsp;&emsp;v-for 传入循环的对象，另外这里也和react一样需要加上循环的 index 属性&emsp;&emsp;可能会有为什么需要加入index属性的疑问，可以参考一下别人写的文章&emsp;&emsp;主要是为了加入给循环的对象加入唯一标识，确保Vue可以获取并修改它。 使用数组的方法来修改数组 &emsp;&emsp;需要注意的是，Vue不可以直接修改数组以及对象的值，如: persons[inedx] = nexP&emsp;&emsp;因为Vue的监听是浅层的(深层监听非常耗费资源，而且没有必要)，因此数组内部的值发生修改的时候 Vue 无法更新页面的显示效果。&emsp;&emsp;不过变量已经改变了，只要触发Vue的更新函数就可以了，当然官方用了更好的解决方案。&emsp;&emsp;Vue官方在原生的数组操作函数上加上了内部的更新函数，实现了变异方法。&emsp;&emsp;因为接触过PyQt编程，这个太好理解了，就是继承原生的方法基础上，加入自己的自定义代码。也就如同教程说的，对原生方法进行了包装。&emsp;&emsp;如此一来，只要使用变异方法就不需要监听也可以触发更新效果。 列表过滤 &amp; 列表排序核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;body&gt; &lt;div id="demo"&gt; &lt;input type="text" v-model="searchName"&gt; &lt;ul&gt; &lt;li v-for="(p,index) in filterPersons" :key="index"&gt; &#123;&#123;index&#125;&#125; --- &#123;&#123;p.name&#125;&#125; --- &#123;&#123;p.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;button @click="setOrderType(0)"&gt;原本顺序&lt;/button&gt; &lt;button @click="setOrderType(1)"&gt;年龄升序&lt;/button&gt; &lt;button @click="setOrderType(2)"&gt;年龄降序&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt;// Vue 的数组方法都是经过写了，实现界面更新vm = new Vue(&#123; el:'#demo', data:&#123; searchName: '', orderType:0,// 0代表原本，1代表升序，2代表降序 persons:[ &#123;name:"Tom",age:18&#125;, &#123;name:"Jack",age:16&#125;, &#123;name:"Bob",age:19&#125;, &#123;name:"Rose",age:17&#125;, &#123;name:"Tim",age:20&#125;, ] &#125;, methods:&#123; setOrderType(num)&#123; this.orderType = num; &#125; &#125;, computed:&#123; filterPersons(index)&#123; // 取出相关的数据 const &#123;searchName,persons,orderType&#125; = this // 对persons进行过滤 let fPersons = persons.filter(p =&gt; p.name.indexOf(searchName) !== -1) if(orderType !== 0)&#123; fPersons.sort(function(p1,p2)&#123; if(orderType === 2)&#123; return p2.age - p1.age &#125;else&#123; return p1.age - p2.age &#125; &#125;) &#125; return fPersons; &#125;, &#125;&#125;)&lt;/script&gt; 体验一下 通过 computed 函数方法的返回值来对 data 中的数组进行排序过滤 &emsp;&emsp;补充一下：computed主要写页面渲染相关的，methods 主要写触发调用相关的&emsp;&emsp;简单来说就是 点击按钮触发一类的事件全部交给 methods&emsp;&emsp;页面显示相关的方法 则交给 computed var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ // Note 触发 resize 事件 window.dispatchEvent(new Event('resize')); $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>前端</category>
        <category>Vue</category>
        <category>Vue学习之路</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡂVue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Maya 100 招 - 第四十一招到第五十招]]></title>
    <url>%2Fposts%2F4e9ee1dc.html</url>
    <content type="text"><![CDATA[第四十一招 挤出和保持面在一起 &emsp;&emsp;挤出命令按住 shift键配合鼠标右键 往下拖动选择挤出 &emsp;&emsp;Maya2016 之后添加了 ctrl+E 快捷键来实现挤出 &emsp;&emsp;如何实现多个面单独自身挤出 &emsp;&emsp;借助浮动面板可以也可以切换 &emsp;&emsp;还可以 ctrl + shift + 右键 可以弹出标记菜单，选择单独挤出 第四十二招 快速选择集 &emsp;&emsp;快速选择集可以将选择记录下来。&emsp;&emsp;去到 Create &gt; Sets &gt; Quick Select Set 可以创建快速选择集 &emsp;&emsp;弹出了一个命名窗口，添加命名。 &emsp;&emsp;去到 Create &gt; Quick Select Sets &gt; 可以去选择之前保存下来的 快速选择集 第四十三招 创建字体 &emsp;&emsp;去到 Create &gt; Text 可以创建文字 &emsp;&emsp;点击选项框打开设置窗口 &emsp;&emsp;可以先创建出曲线，方便后期控制&emsp;&emsp;创建出曲线之后可以到 Surfaces &gt; Bevel Plus 去创建实体模型 &emsp;&emsp;这个方法比起字体面板的 Bevel 有更多的控制属性 注： Maya2018 之后文字生成工具升级了，加入了更多有用的新功能。 第四十四招 扭曲命令的使用第四十五招 三角化命令的使用第四十六招 曲线直角变圆角第四十七招 面片挤出为什么底部不见了第四十八招 不同摄像机如何开启背面消隐第四十九招 Max和Maya模型文件互导第五十招 如何使用创建参考]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>Maya 100 招</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Maya 100 招 - 第三十一招到第四十招]]></title>
    <url>%2Fposts%2F410ea085.html</url>
    <content type="text"><![CDATA[第三十一招 转换选择 &emsp;&emsp;如何快速选择圆柱上的三角面 先选择上半部分的面，再反选掉无关的面 &emsp;&emsp;如果圆柱的分段很多，就很难通过上述方法选择 &emsp;&emsp;当然也可以通过正交视图去精确框选 &emsp;&emsp;如果模型经过了选择，就很那通过正交视图的方法去选择了 一个个面进行点选 （比较慢） Maya2014 之后增加了 Drag 选择。 按住 Tab 键拖拽鼠标 通过点转换到面的方式选择 第三十二招 如何把边界边捕捉到网格中心 &emsp;&emsp;建模可能会导致中线凹凸不平，怎么将中线压平到世界坐标上？ 选择中键的边，然后用缩放轴压平，然后按X键吸附到网格中心上。 选择中间的边，然后转成点，在不勾选 keep spacing 的状态下，可以一键吸附到网格上。 第三十三招 环形选择 按住 shift 键选择一个面，然后再对一个相邻面上双击就可以环选。 先选择三条边，然后按住 ctrl 右键打开标记菜单，往左下选择 Edge Ring Utilities &gt; To Edge Ring 环形选择边，然后再次按住 ctrl 右键打开标记菜单，往下选择 To Faces &gt; To Faces 将边转到面。 第三十四招 循环选择 循环选择面 : 按住 shift 键选择一个面，然后再对一个相邻面上双击就可以环选面。循环选择边 ：双击一条边即可 选择一部分的循环面 : 按住 shift 键选择一个面，然后再对循环面上的一个面双击就可以选择起始位置到双击位置的面。选择一部分的循环边 : 按住 shift 键选择一条边，然后再对循环边上的一条边双击就可以选择起始位置到双击位置的边。 第三十五招 创建螺旋结构 &emsp;&emsp;这一集都是技术点，所以我直接贴视频地址了。 地址 如何创建螺旋线？ 创建一个NURBS圆柱体,选择 Make Live 将圆柱体激活 去到 Create &gt; Curve Tools &gt; CV Curve Tool 创建 CV 曲线 在圆柱上随意点选，然后拖动一个曲线顶点在偏俯视的视角旋转顶点创建环形线。 去到 Curves &gt; Duplicate Suface Curves 复制当前 CV 曲线获取螺旋线 如何创建螺旋表面？ (也可以参照老师另一套视频 8分钟开始) 链接 创建一个圆柱 选择一条边，按住 ctrl 右键打开标记菜单 Edge Ring Utilities &gt; To Edge Ring and Split 添加中线 选择中线 shift 右键打开标记菜单选择右边 Bevel ,然后调节倒角的分段数。 选择需要顶点，shift 右键打开标记菜单，选择右边 Chamfer Vertex 切点。调节参数为0.5。 注：切点的顶点都是断开，需要合并顶点。 选择需要合并的顶点，然后shift右键打开标记菜单，选择上面 Merge Vertices &gt; Merge Vertices 选择一条边，然后按住 Ctrl 打开标记菜单，往左下选择 Edge Ring Utilities &gt; To Edge Ring 环形选择边 再次按住 ctrl 右键打开标记菜单，往下选择 To Faces &gt; To Faces 将边转到面 ctrl + shift + i反选其他的面进行删除 处理掉多余的面即可 如何创建螺设计结构？ 去到 Create &gt; Polygon Primitives &gt; Helix 调整螺旋体的参数 第三十六招 沿着曲线放置物体 选择曲线再选择物体，去到 Modify &gt; Snap Align Objects &gt; Position Along Curve 第三十七招 重建曲线 曲线的顶点分布不均匀 去到 Curves &gt; Rebuild 调节 Number of spans 参数的数值，数值越大，均分越多。 第三十八招 创建路径动画 创建运动履带 准备运动路径曲线，以及单个履带模型。 确保曲线有足够多的顶点，可以重建曲线来均匀添加。 去到 Constraint &gt; Motion Paths &gt; Attach to Motion Path 设置好运动的朝向就可以依附到曲线上 目前创建的运动路径是缓入缓出的，打开曲线编辑器将曲线变直。 创建动画快照,调整合适的参数进行创建。 微调创建的效果。 第三十九招 连接组件、选择类似 如何创建风扇铁丝网?&emsp;&emsp;这一集也都是技术点，所以我又贴视频地址了。 地址 连接组件 圆柱体或者球体上的三角面没有办法直接添加中线 可以通过连接组件添加分段 选择类似选择出一定的面，然后右键选择 Select Similar 可以自动将类似的面选择出来。 第四十招 添加中线 选择一条边，然后按住 Ctrl 打开标记菜单，往左下选择 Edge Ring Utilities &gt; To Edge Ring 环形选择边 选择一条边，shift右键打开标记菜单，选择 Multi-Cut，鼠标会变成小刀。按住 ctrl 配合鼠标中键即可切入中线 选择一条边，然后按住 Ctrl 打开标记菜单，往左下选择 Edge Ring Utilities &gt; To Edge Ring 环形选择边,再shift右键选择 Connect Components 或者 Maya2019 中的 Connect Tool]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>Maya 100 招</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Maya 100 招 - 第二十一招到第三十招]]></title>
    <url>%2Fposts%2F9ab1cd0e.html</url>
    <content type="text"><![CDATA[第二十一招 镜像 &emsp;&emsp;传统的镜像方法就是删除一半的面，然后 ctrl+D 复制一个新的模型，将对称轴的缩放值调为-1。&emsp;&emsp;当然也可以用之前学过的 j 键，递进到-1，就不用输入数字。 &emsp;&emsp;最后还可以进入菜单选择 特殊复制，将复制轴向的值调为-1，即可一次镜像。 额外补充 - Maya2018 镜像 &emsp;&emsp;Maya2018之后更新了镜像功能，可以更加方便实现镜像 总结： 复制一个新的模型，将对称轴的缩放值输入为-1 复制一个新的模型，按住J键拖动，将对称轴的缩放值调为-1 特殊复制预先设置好对称轴的值 使用 maya2018 新的镜像功能 第二十二招 居中轴心点 &emsp;&emsp;一般情况下就是去到 Modify &gt; Center Pivot 来居中轴心点 &emsp;&emsp;上述方法有时候也并不方便。如何将轴心点定位到物体的特定位置上呢？&emsp;&emsp;按 d 键进入轴心点设置状态&emsp;&emsp;点击任意的 边 面 点，轴心点会自动居中到对应位置。&emsp;&emsp;这个时候轴心点并不是按世界坐标。&emsp;&emsp;按住 w 键配合鼠标左键进入标记菜单，往左选择 world 世界坐标。 第二十三招 自定义坐标轴向 &emsp;&emsp;和上一招一样，通过按 d 键进入轴心点设置状态&emsp;&emsp;点击任意的 边 面 点，轴心点会自动居中到对应位置。&emsp;&emsp;通过这个方法可以方便调整轴向来移动。 第二十四招 快速定义材质球位置 通过 Hypershade 面板展出节点找到材质 (比较麻烦) 在属性面板的最后找到材质节点 对模型右键,在菜单下面有 Material Attributes 选项 第二十五招 当前视图角度创建摄像机 &emsp;&emsp;默认创建一个新的摄像机，摄像机的位置在坐标原点。 使用热盒界面，然后点击中键的Maya按钮然后在弹出的标记菜单选择 New Camara 在视图的菜单上有 View &gt; Create Camera From View , 快捷键是 ctrl + shift + c 第二十六招 导入参考视图的几种方法 在视图的菜单上 View &gt; Image Plane &gt; Import Imag e 视图的菜单下的图标 在摄像机的Environment属性下有 Image Plane Create 按钮 第二十七招 更改视图界面的颜色 &emsp;&emsp; alt + B 可以切换视图的背景颜色 第二十八招 隔离选择 视图的菜单下的图标 shift + i 或者 ctrl + 1 键切换格里选择 第二十九招 如何快速赋予材质 通常都是通过 hypershade 创建材质球，再将材质球赋予到物体上 (速度很慢) 对物体鼠标右键选择 Assign New Material ... 通过快捷键 shift + T 快速打开赋予材质面板 第三十招 隔边选择 &emsp;&emsp;默认的Maya是没有隔边选择的功能&emsp;&emsp;不过Autodesk官方提供了一个 Bonus Tool 插件可以拓展Maya的功能 &emsp;&emsp;在maya的帮助界面可以找到 Bonus Tool 的下载地址&emsp;&emsp;安装完成重启Maya就有菜单了 &emsp;&emsp;Bonus Tool &gt; Modeling &gt; Select Every N.th Edge in Loop/Ring 可以实现隔边选择 &emsp;&emsp;也可以通过 shift 右键的标记菜单快速隔边选择。 &emsp;&emsp;也可以隔多条边进行选择]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>Maya 100 招</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader学习之路(六)]]></title>
    <url>%2Fposts%2Fd81d7e23.html</url>
    <content type="text"><![CDATA[GrabPass 使用抓屏通道，GrabPass{} 或GrabPass{“纹理名称”}; _GrabTexture访问 后续的Pass通道使用这个抓屏; 编写案例 (1)：创建一个顶点片元着色器; (2)：将这个着色器放到Overlay队列 (3)：使用GrabPass通道截屏，并定义好变量来接收 (4)：设置顶点的UV坐标; (5)：着色使用截图的纹理 代码截图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970Shader "Custom/GrabShader"&#123; Properties &#123; _MainTex ("Texture", 2D) = "white" &#123;&#125; &#125; SubShader &#123; Tags &#123; "RenderType"="Opaque" "Queue" = "Overlay" &#125; LOD 100 GrabPass&#123; &#125; Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #pragma multi_compile MY_multi_1 MY_multi_2 #include "UnityCG.cginc" struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; UNITY_FOG_COORDS(1) float4 vertex : SV_POSITION; &#125;; sampler2D _MainTex; float4 _MainTex_ST; sampler2D _GrabTexture; float4 _GrabTexture_ST; v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _GrabTexture); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; // 不同版本输出 #ifdef MY_multi_1 fixed4 col = fixed4(1.0,0.0,0.0,1.0); #endif #ifdef MY_multi_2 // sample the texture fixed4 col = tex2D(_GrabTexture, i.uv); #endif return col; &#125; ENDCG &#125; &#125;&#125; 常用的gcinc cginc文件：宏，帮助函数等，放在CGlncludes下面，开发人员可以开发自己的cginclude文件 常用的cginc文件： HLSL.Support.cginc协助多平台开发的一些宏等，自动包含 UnityShaderVarirables.cginc全局变量，自动包含; UnityCG.cginc常用的帮助函数; AutoLight.cginc 光照和阴影功能; Lighting.cginc表面着色器的光照模型; TerrainEngine.cginc地形植被的光照着色函数; UnityCG.gcinc常用函数 UnityWorldSpaceViewDir：给定对象空间的顶点位置朝向摄像机方向的世界坐标空间方向; ObjspaceViewDir：给定对象空间的顶点位置朝向摄像机方向的对象空间方向; ParallaxOffset：计算用于视差法线贴图的UV偏移量; Luminance：将颜色转为亮度; DecodeLightmap：从光照贴图中解码颜色; float EncodeFloatRGBA(float4 rgba)：将RGBA颜色编码为[0，1]的浮点数; float4 DecodeFloatRGBA(float v)：将一个浮点数解码为RGBA的颜色; UnityWorldspaceLightDir给定对象空间的顶点位置到光源的世界坐标空间方向; ObjspaceLightDir：给定对象空间的顶点位置到光源的对象空间方向; UsePass 复用 编写过的pass可以重复使用，借助UsePass “ShaderPath/PASS_NAME” PASS名字要大写； Pass{name=&quot;ONE&quot; } UsePass”Custom/ShaderName/ONE” multi_compile 通过multi comile编译多个版本的shader； #pragma multi complie MY_multi_1 MY_multi_2； 1#ifdef MY muliti 1#endif1 Shader.EnableKeyword(“MY_multi_1”)； Shader.DisableKeyword(“MY_multi 1”)；控制shader编译出不同的版本； 移动平台优化 代码优化： 预先计算好对应的值sqrt（2）-&gt;根号2-&gt;1.414； 放心的使用向量相关操作，叉积，点击，基本都是硬件实现，很高效； 尽量减少函数调用减少开销； 尽可能的计算放在顶点着色器中，顶点着色器的调用频率远低于片着色器； 几何复杂度考量：在IOS平台视口内的顶点数不要超过100K个，l05默认的缓冲区就是就是”这么大，超过这个数字，底层会做一些操作消耗更多的资源； 纹理大小为2n次方大小，16，64，128，256，512，1024； 使用适当的数据类型float &lt; half &lt; fixed 性能 尽量慎用透明效果，透明效果GPU要逐像素渣染 let ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ $(this).parent().next().slideToggle(1000); // 触发resize函数 修正复制按钮位置 setTimeout(() => { var myEvent = new Event('resize'); window.dispatchEvent(myEvent); }, 1000); }); } });]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>Shader学习之路</category>
      </categories>
      <tags>
        <tag>ࡆUnity</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader学习之路(五)]]></title>
    <url>%2Fposts%2F41123651.html</url>
    <content type="text"><![CDATA[设置LOD值 LOD Level of Detail，根据LOD来设置使用不同版本的Shader; 着色器中给SubShader一个LOD值，程序来设置这个shader的LOD值，只有第一个小于等于LOD值subShader才会被执行; 每个shader最多只会有一个Subshader被使用; 通过Shader maximumLOD来设置最大的LOD值; 设置全局的LOD值，Shader.globalMaximumLOD; Unity内置着色器分LOD等级： (1)Vertexlit kind of shaders 100 (2)Decal，Reflective Vertexd.it 150 (3)Diffuse 200 (4)Difuse Detail 250 (5)Bumped，Specular 300 (6)BumpedSpecular 400 (7)Parallax 500 (8)Parallax Specular 600 渲染队列 演染队列标签可选值： (1)8ackground背景，对应的值为1000; (2)Geometry(default)几何体对应的值为2000，这个队列是默认的渲染队列，大多数不透明的物体; (3)AlphaTest Alpha测试，对应值为2450，alpha测试的几何体使用这种队列，它是独立于Geometry的队列，它&gt; 可以在所有固体对象绘制后更有效的渲染采用Alpha测试的对象; (4)Transparent透明，对应值3000，这个演染队列在Geometry被渲染，采用从后向前的次序;任何有alpha混合的&gt; 对象都在这个队列里面渲染; (5)Overlay 覆盖对应值为4000，这个道染队列是最后渲染的物体; Unity 演染模式：普通物体从前向后演染，Alpha从后向前演染： 渲染队列的数值决定了Unity在渲染场景物体时的先后顺序，关闭深度测试的情况下; 混合模式 在所有计算完成后，决定当前的计算结果输出到帧缓冲区时，如何混合源和目标，通常用来绘制半透明的物体； Blend Off关闭混合 Blend源因子，目标因子：配置并开启混合，产生的颜色和源因子相乘，然后两个颜色相加 Blend源因子，目标因子，源因子A，目标因子A：源因子与目标因子用户混合颜色值，源因子A，与目标因子A，用于混合alpha BlendOp操作命令：不是将颜色混合在一起，而是对他们进行操作，主要有：Min，Max，Sub，RevSub 混合因子的类型： One使用源或目标色完全显示出来; OneMinusSrcColor 阶段值*（1-源颜色的值） Zero 删除源颜色或目标颜色; One MinusSrcAlpha 阶段值*（1-源颜色的Alpha值） SrcColor这个阶段的值*源颜色值; OneMinusDstColor阶段值*（1-目标颜色的值; DstColor这个阶段的值*帧缓冲颜色值; OneMinusDstAlha阶段值*（1-目标颜色Alpha值） DstAlpha这个阶段的值*帧缓冲源Alpha值 一般放在放在Pass通道里面 混合模式类似于 PS 的 blending mode Alpha测试 Alpha测试：阻止片元被写到屏幕的最后机会，最终渲染出来的颜色计算出来后可通过透明度和最后一个固定值比较，如果通过测试则绘制次片元，否则丢弃此片元； Alpha Test Off/On：开启/关闭Alpha测试，默认是关闭的； 比较测试值的模式： Greater &gt; GEqual&gt;= Less &lt; LEqual&lt;= Equal == NotEqual != Always（永远渲染） Never（重不渲染） AlphaTest条件[变量]，一般放在放在Pass通道里面； 深度测试 为了使近距离的物体挡住远距离的物体，当片元写入到缓冲的时候，需要将片元的深度值与缓冲区的深度值进行比较，测试成功写入帧缓冲区； ZWrite深度写开关，控制是否将深度Z的片元写入缓冲区中，如果不绘制透明物体设置为On，否则的话设置为off，默认为On； ZTest深度测试模式：设置深度测试的执行方式，默认为LEqual，深度测试的模式： Greater &gt; GEqual&gt;= Less &lt; LEqual&lt;= Equal == NotEqual != Always（永远渲染） ZTest条件 一般放在放在Pass通道里面； 通道遮罩 通道遮罩可以是开发人员指定道染结果输出的通道，而不是通常情况下的RGBA四个通道； 可选的是RGBA的任意组合以及0，如果为0意味着不会写入到任何通道； ColorMask RG … ColorMask 0 面剔除 通过不渲染背对摄像机的几何体的面来提高性能优化错误，所有的几何体都包含正面和反面 面剔除操作，大多数都是封闭的物体，所以不需要绘制背面； 面剔除操作： Cull Back：不绘制背对摄像机的面，默认项 Cull Front，不绘制面向摄像机的面 Cull off，关闭面剔除操作 混合模式案例 代码截图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Shader "Custom/BlendShader"&#123; Properties &#123; _MainTex ("Texture", 2D) = "white" &#123;&#125; _Color ("Color", Color) = (1.0,0.0,0.0,1.0) &#125; SubShader &#123; Tags &#123; "RenderType"="Opaque" "Queue" = "Transparent+1" &#125; LOD 100 Pass &#123; // 添加alpha混合模式 Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; &#125;; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; &#125; fixed4 _Color; fixed4 frag (v2f i) : SV_Target &#123; // sample the texture fixed4 col = _Color; return col; &#125; ENDCG &#125; &#125;&#125; 通道遮罩 &emsp;&emsp;只输出红色通道 代码截图 1234567891011Shader "Custom/ColorMaskShader"&#123; SubShader &#123; pass&#123; ColorMask R Color(1.0,1.0,1.0,1.0) &#125; &#125; FallBack "Diffuse"&#125; let ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ $(this).parent().next().slideToggle(1000); // 触发resize函数 修正复制按钮位置 setTimeout(() => { var myEvent = new Event('resize'); window.dispatchEvent(myEvent); }, 1000); }); } });]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>Shader学习之路</category>
      </categories>
      <tags>
        <tag>ࡆUnity</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader学习之路(四)]]></title>
    <url>%2Fposts%2F47b9612c.html</url>
    <content type="text"><![CDATA[表面着色器 表面着色器包括4个函数： (1)顶点变换函数; (2)表面着色函数; (3)光照模型; (4)最终颜色修改函数; 表面着色器最终会被编译为一个复杂的顶点着色程序; 定义入口函数 #pragma surface 入口函数名称光照模型[Options] suface 后面跟表面着色的入口函数 surf (lnput IN,inout SurfaceOutput o); 光照模型： (1)系统内置Lambert(漫反射光照)BlinnPhong(高光光照) (2)自定义光照：名字为Name half4 Lighting(SurfaceOutput s,half3 lightDir,half atten); half4 Lighting(SurfaceOutput s,half3 lightDir,half3 viewDir,half atten); half4 Lighting(SurfaceOutput s,half4 light);可选参数 vertexname vertex入口函数： void (finout appdata_full v)只需改顶点着色器中的输入顶点数据; half4 (inout appdata_full v,out Input o)修改输入顶点数据,以及为表面着色器传递数据; finalcolor:name 最终颜色修改函数： void (nput IN,SurfaceOutput o,inout fixed4 color); 其它可选参数 alpha:Alpha 混合模式，用户半透明着色器。 alphatest:varirableName Alpha测试模式，用户透明镂空着色器。 exclude_path:prepass 使用指定的渲染路径; addshadow：添加阴影投射器和集合通道; dualforward：将双重光照贴图用于正向道染路径中; fullforwardshadows在正想渲染路径中支持的所有的阴影类型; decal:add 附加印花著色器; decal:blend 附加半透明印花着色器; softvegetation 使用表面着色器，仅在Soft Vegetation 开启时被演染; noambient不使用任何光照 novertexdights在正向道染中不适用球面调和光照或逐点光照; nolightmap在这个着色器上禁用光照贴图; nodirlightmap在这个着色器上禁用方向光照贴图; noforwardadd 禁用正向道染添加通道; approxview.对于有需要的着色器，逐顶点而不是逐像素计算规范化视线方向。 halfasview.将半方向传递到光照函数中。 Input 结构附加数据 Input：包含着色器所需要的纹理坐标 uv 纹理名字;使用第二张纹理是uw2纹理名字;附加数据： float3 viewDir 视图方向。 float4 color 每个定点的颜色插值 float4 screenPos屏幕空间中的位置。 float3 worldPos 世界坐标空间; float3 worldRef1世界空间中的反射向量： float3 worldNormal世界空间中的法线向量; float3 worldRef1;INTERNAL DATA 世界坐标反射向量，但必须表面着色写入o.Normal参数; float3 worldNormal;INTERNAL_DATA 世界坐标法线向量，但必须表面着色写入o.Normal参数; SurfaceOutput 结构体 SurfaceOutput： half3Albedo：漫反射的颜色值：I half3 Nomal：法线坐标标 half3 Emission;自发光颜色; half Specular;镜面反射系数; half Gloss;光泽系数： half Alpha;透明度系数;SurfaceOutputStandard： half Smoothness;/∥0-粗糙，1-光滑 half Metallic;//0-非金属，1-金属 12345678SurfaceOutputStandardSpecular： fixed3Albedo; fixed3 Specular; fixed3 Normal; half3 Emission; half Smoothness;//0=粗糙，1=光滑 half Occlusion;//遮挡（默认1） fixed Alpha;]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>Shader学习之路</category>
      </categories>
      <tags>
        <tag>ࡆUnity</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader学习之路(三)]]></title>
    <url>%2Fposts%2F671aaad8.html</url>
    <content type="text"><![CDATA[cg基本语法基本类型表达式 语法和C语言类是，有对应的编译器，程序是给显卡运行; 可以从渲染流水线中获得对应的输入;3：指定的输出能流入下一个流水线模块; 操作符号和C语言一样，可以使用+，，*/&lt;，&gt;，&lt;=，&gt;=等运算; Cg提供了float half double浮点类型; Cg支持定点数fixed来高效处理某些小数; Cg使用int来表示整数;I bool 数据类型来表示逻辑类型; sampler*，纹理对象的句柄，sampler/1D/2D/3D/CUBE/RECT 内置向量数据类型：float4f(float，float，float，float)，向量长度不能超过4; 内置矩阵数据类型：float1x1 float2x3 float4x3 float4x4;不能超过4x4; 数组类型float a[10];10个float，float4 b[10]，10个float4; 语义绑定float4 a:POSITION，返回值也可以语义绑定; &emsp;&emsp;fixed定点数通过整数的形式来处理浮点数，可以避免浮点数的误差。 结构体与语义 12345struct name&#123; 类型 名字; //尽量不要使用; 返回值函数名称(参数)&#123;//如果成员函数里面使用，数据成员，该成员定义在结构体前;&#125;&#125;; 输入语义与输出语义：语义：一个阶段处理数据，然后传输给下一个阶段，那么每个阶段之间的接口，例如：顶点处理器的输入数据是处于模型空间的顶点数据(位置、法向量)，输出的是投影坐标和光照颜色;片段处理器要将光照颜色做为输入;C/C++用指针，而Cg通过语义绑定的形式; 输入语义：绑定接收参数，从上一个流水线获得参数; 输出语义：绑定输出参数到下一个流水线模块; 语义：入口函数上有意义(顶点着色入口，像素着色入口)，普通的函数无意义; 标准内置函数 abs(num)绝对值; 三角函数; cross(a，b)两个向量的叉积; determinant(M)矩阵的行列式; dot(a，b)两个向量的点积; floor(x)向下取整; lerp(a，b，f)在a，b之间线性插值; log2(x)基于2为底的x的对数; mul(m，n)：矩阵x矩阵，矩阵x向量，向量×矩阵; power(xy)x的y次方;11：radians(x)度转弧度; reflectfv，n)v关于法线n的反射向量; round()靠近取整; tex2D(smaple，x)二维纹理查找 tex3Dproj(smaple，x)投影三维纹理查找; texCUBE 立方体贴图纹理查找; distance() 计算点的距离; Unity自带函数 引用Unity自带的函数库：#include”UnityCG.cginc”Unity-&gt;Edit-&gt;Data-&gt;CGlncdudes; TRANSFORM_TEX：根据项点的纹理坐标，计算出对应的理的真正的UV坐标; 使用属性的委量：在shader里面需要使用属性变量还需要在shader中定义一下这个变量的类型和名字;名字要保持一致; 外部修改shader的编辑器上的参数值; 定点片元shader实例float4 fixed4_Time float4是内置向量(xy，z，w);float4 a;访问单独成员a.x，a.y，a.z，a.w; fixed4是内置向量(r，g，b，a);fixed4c;color.r，color.g，color.b，color.a; float3是内置向量(x，y，z); fixed3是内置向量(r，g，b); float2是内置向量(x，y); _Time：自场景加载开始所经过的时间，4个分量分别是(t/20，t，t2，t3); _SinTime:t是时间的正弦值，4个分量分别是(t/8，t/4，t/2，t); _CosTime:t是时间的余弦值，4个分量分别是(t/8，t/4，t/2，t); unity_DeltaTime:dt 是时间增量，4个分量的值(dt，1/dt，smoothDt，1/smoothDt)，平滑时间，防止时间间隔起伏太大; 正弦波 代码截图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Shader "Custom/SineShader"&#123; Properties &#123; _MainTex ("Texture", 2D) = "white" &#123;&#125; &#125; SubShader &#123; Tags &#123; "RenderType"="Opaque" &#125; LOD 100 Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata v) &#123; v2f o; // 计算点到原点的距离 float dist = distance(v.vertex.xyz,float3(0,0,0)); // 随着时间正弦偏移 float h = sin(dist + _Time.z); // 模型空间转世界空间 o.vertex = mul(unity_ObjectToWorld,v.vertex); o.vertex.y = h; // 转换回去 o.vertex = mul(unity_WorldToObject,o.vertex); o.vertex = UnityObjectToClipPos(o.vertex); o.uv = TRANSFORM_TEX(v.uv,_MainTex); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; // sample the texture fixed4 col = tex2D(_MainTex, i.uv); return col; &#125; ENDCG &#125; &#125;&#125; UV动画 代码截图 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Shader "Custom/UVShader"&#123; Properties &#123; _MainTex ("Texture", 2D) = "white" &#123;&#125; _SubTex ("Texture", 2D) = "white" &#123;&#125; &#125; SubShader &#123; Tags &#123; "RenderType"="Opaque" &#125; LOD 100 Pass &#123; CGPROGRAM #pragma vertex vert #pragma fragment frag #include "UnityCG.cginc" struct appdata &#123; float4 vertex : POSITION; float2 uv : TEXCOORD0; &#125;; struct v2f &#123; float2 uv : TEXCOORD0; float4 vertex : SV_POSITION; &#125;; sampler2D _MainTex; sampler2D _SubTex; float4 _MainTex_ST; v2f vert (appdata v) &#123; v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.uv = TRANSFORM_TEX(v.uv, _MainTex); return o; &#125; fixed4 frag (v2f i) : SV_Target &#123; // UV 偏移 float2 uv_offset = float2(0,0); uv_offset.x = _Time.y * 0.25; uv_offset.y = _Time.y * 0.25; fixed4 light_color = tex2D(_SubTex,i.uv + uv_offset); // sample the texture // 颜色叠加，通过黑白图实现黑色区域无效果，白色区域高亮 fixed4 col = tex2D(_MainTex, i.uv) + light_color; return col; &#125; ENDCG &#125; &#125;&#125; let ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ $(this).parent().next().slideToggle(1000); // 触发resize函数 修正复制按钮位置 setTimeout(() => { var myEvent = new Event('resize'); window.dispatchEvent(myEvent); }, 1000); }); } });]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>Shader学习之路</category>
      </categories>
      <tags>
        <tag>ࡆUnity</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader学习之路（二）]]></title>
    <url>%2Fposts%2F2a04098a.html</url>
    <content type="text"><![CDATA[坐标空间 物体空间：3D物体自己的坐标空间一般设计时几何体以中心为原点，人物以双脚为原点; 世界空间：30物体在场景中的世界坐标，整个游戏场景的空间; 摄像机空间：以观察摄像机为原点的坐标系下的坐标空间; 投影成像3D坐标转换到屏幕空间; Unity坐标系转换 transform.localTo WoridMatrix局部转世界的矩阵; transfrom.worldTolocalMatrix 世界坐标转局部坐标矩阵;Multiply Point，MultiplyPoint3x4 MultiplayVector 来进行坐标变换; shader中左乘_World2Object 矩阵来实现世界坐标转局部坐标变换; shader中左乘_Object2World 矩阵来实现局部转世界的转换; UNITY_MATRIX_MV基本变换矩阵x摄像机矩阵; UNITY_MATRIX_MVP 基本变换矩阵x摄像机矩阵x投影矩阵; UNITY_MATRIX_V 摄像机矩阵; UNITY_MATRIX_P 投影矩阵; UNITY_MATRIX_VP 摄像机矩阵x投影矩阵; UNITY_MATRIX_T_MV（基本变换矩阵x摄像机矩阵）转置矩阵; UNITY_MATRIX_IT_MV（基本变换矩阵x摄像机矩阵）的逆转置矩阵; UNITY_MATRIX_TEXTUREO 纹理变化矩阵; GPU 管道流水线 顶点片元着色器 控制灵活，但不能参与光照计算; 在着色器中插入Cg代码段，编写在CGPROGRAM与ENDCG之间; 编译指令： #pragma控制着色器代码编译; #pragma vertex name将名称为name的函数编译为顶点着色器; #pragma fragment name将名称为name的函数编译为片元着色器; 参数和返回值有语义修饰 常用语义修饰 POSITION：位置 TANGENT：切线 NORMAL：法线 TEXCOORDO：第一套纹理 TEXCOORD1：第二套纹理 TEXCOORD2：第三套纹理 TEXCOORD3：第四套纹理 COLOR：颜色 第一个shader 创建一个shader，编写最简单的shader代码。 创建一个立方体，创建一个材质，使用自己的shader，，将立方体的材质制定为自己的shader; 123456789101112131415161718192021222324252627282930313233Shader &quot;Custom&#x2F;MyShader&quot;&#123; &#x2F;&#x2F; 属性，可以再Unity中修改和绑定 Properties &#123; _Color (&quot;Color&quot;, Color) &#x3D; (1,1,1,1) _MainTex (&quot;Albedo (RGB)&quot;, 2D) &#x3D; &quot;white&quot; &#123;&#125; _Glossiness (&quot;Smoothness&quot;, Range(0,1)) &#x3D; 0.5 _Metallic (&quot;Metallic&quot;, Range(0,1)) &#x3D; 0.0 &#125; SubShader &#123; Pass &#123; CGPROGRAM &#x2F;&#x2F; 编写CG代码开始 #pragma vertex my_vert &#x2F;&#x2F; 获取上一个工位的参数 -&gt; 语义bind float4 my_vert(float4 pos : POSITION ): POSITION&#123; return UnityObjectToClipPos(pos); &#125; #pragma fragment my_frag fixed4 my_frag() : COLOR&#123; &#x2F;&#x2F; 设置红色 return fixed4 (1.0,0.0,0.0,1.0); &#125; ENDCG&#x2F;&#x2F; 编写CG代码结束 &#125; &#125; FallBack &quot;Diffuse&quot;&#125;]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>Shader学习之路</category>
      </categories>
      <tags>
        <tag>ࡆUnity</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shader学习之路（一）]]></title>
    <url>%2Fposts%2F1a12e552.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近打算恶补一下游戏引擎shader相关的模块。&emsp;&emsp;毕竟之前学three.js的时候就接触过GLSL语言，也知道有shadertoy之类神仙般的网站。&emsp;&emsp;但是因为实习各种原因，还是没能够进行深入学习。&emsp;&emsp;这次我在B站找了一部shader教程进行入门，没想到看完其实只是个开头而已，还没讲完，不过讲师讲得还可以吧。要吐槽的就是经常念PPT，另外shader开发不是很熟练，有些BUG犯的都是低级错误。不过视频下载来跳着看还算可以的。教程地址 Shader概述 Shader是给GPU执行的程序，中文叫做着色器; 着色器是运行在图形处理单元上，可以让开发人员直接操作图形硬件渲染功能; shader能开发出很多好的效果，UV动画，水，雾等一些特效，这些用程序开发出来比较困难，性能还不好; 渲染流水线，模型投影，定点着色; shader一般主要有： 固定管线着色器，顶点片元着色器，表面着色器; 固定管线着色器（慢慢会被淘汰）; 顶点shader：干预模型形态的shader; 像素shader：干预像素着色的shader; 模型定点运算的时候，可以加入顶点shader来干预顶点的位置;顶点着色的时候，加入像素shader来干预像素的上色; GPU编程语言 什么是Direct3D和opengl; 目前面向GPU的编程语言主要有三种： HLSL语言通过Direct3D编写的着色器程序，只能在Direct3D里面使用; Cg语言NVIDIA和微软合作提供的语言，与c相似，Direct3D和opengl都支持; GLSL语言支持OpenGL上编写Shader程序; Unity使用ShaderLab来进行着色程序的编写，对不同的平台进行编译，重点支持Cg语言; OpenGL 是开源标准，适用于所有的平台Directx 是微软开发的标准，只适用于Windows平台，windows也支持OpenGL Shader Lab语法基础 定义一个Shader，每一个着色程序都要有一个Shader 123456789Shader "name"&#123;//name shader名字 //定义的一些属性，定义在这里的会在属性查看器里面显示 [Propeties] //子着色器列表，一个Shader必须至少有一个子着色器; Subshaders&#123;...&#125; /如果子着色器显卡不支持，就会降级，即Fallback操作; [Fallback]&#125; Properties定义 name（”display name”，type）=值; name指的是属性的名字，Unity中用下划线开始_Name; display name是在属性检查器的名字; type：这个属性的类型值：只这个属性的默认值; 类型： Float，Int，Color（num，num，num，num）（0~1）Vector（4维向量），Range（start，end） 2D：2D纹理属性;Rect：矩形纹理属性;Cube：立方体纹理属性; 3D：30纹理属性I name（”displayname””，2D）=”name”（options} Options：纹理属性选项 TexGen：纹理生成模式，纹理自动生成纹理坐标的模式;顶点shader将会忽略这个选项; ObjectLinear，Eyelinear，SphereMap，CubeReflect CubeNormal LightmapMod：光照贴图模式如果设置这个选项，纹理会被渲染器的光线贴图所影响。 _Range（“range value”，Range（0，1）=0.3;//定义一个范围 _Color（”color”，Color）=（1，1，1，1）;//定义一个颜色 _FloatValue（”float value”，Float）=1;//定义一个浮点 _MainTex（”Albedo”，Cube）=”skybox”{TexGen CubeReflect}//定义一个立方贴图纹理属性; &emsp;&emsp;Properties 定义必须是下划线开头 SubShader SubShader{[Tags]，[CommonState]，Pass{}}子着色器由标签（Tags），通用状态，通道列表组成，它定义了一个渲染通道列表，并可选为所有通道初始化需要的通&gt; 用状态; SubShader渲染的时候，将优先渲染一个被每个通道所定义的对象。 通道的类型：RegularPass，UsePass，GrabPass， 在通道中定义状态同时对整个子着色器可见，那么所有的通道可以共享状态; 1234567SubShader&#123; Tags&#123;&quot;Queue&quot;，&quot;Transparent&quot;&#125; Pass&#123; Lighting Off&#x2F;&#x2F;关闭光照 ... &#125;&#125; Tags Tags{“标签1”=”value1””key2”=”value2”} 标签的类型： Queue tag队列标签; Render Type tag 渲染类型标签; DisableBatching tag禁用批处理标签; ForceNoShadowCasting Tag 强制不投阴影标签; lgnoreProjecttor忽略投影标签; TCanUseSpriteAtlas Tag，使用精灵图集标签; PreviewType Tag预览类型标签; Pass subshader包装了一个渲染方案，这些方案由一个个通道（Pass）来执行的，SubShader可以包括很多通道块，每&gt; 个Pass都能使几何体渲染一次; Pass基本语法：Pass{[Name and Tags][RenderSetup][Texture Setup]}Pass块的Name引用此Pass，可以在其它着色器的Pass块中引用它，减少重复操作，Name命令必须打大写; RegularPass 渲染设置 Lighting光照：开启关闭定点光照On/off Material{材质块}:材质，定义一个使用定点光照管线的材质; ColorMaterial：颜色集计算定点光照的时使用&gt; 顶点颜色; SeparateSpecular：开光状态开启或关闭顶点光照相关的镜面高光颜色，On/Off; Color 设置定点光照关闭时的所使用的颜色; Fog{雾块}：设置雾参数; AlphaTest:Alpha测试 ZTest：深度测试模式; ZWrite：深度写模式; Blend：混合模式SourceBlendMode，DestBlendMode，AlphaSourcesBlendMode，AlphaDstBlendMode; ColorMask 颜色遮罩：设置颜色遮罩，颜色值可以由RGB或A或0或R，G，B，A的组合，设置为0关闭所有颜色通道&gt; 渲染; Offset偏移因子：设置深度偏移; 特殊通道Pass UsePass：插入所有来自其它着色器的给定名字的通道;UsePass”Shader/Nmae”，Name为着色器通道;UsePass”Specular/BASE”//插入Specular中为Bass的通道; GrabPass{}：一种特殊通道类型，他会捕获物体所在的位置的屏幕的内容，并写入一个纹理中，这个纹理能被用于后续通道中完成一些高级图像特效，后续通道可以使用GrabTexture进行访问; GrabPass{“纹理名称”}捕获屏幕内容到指定纹理中，后续通道可以通过纹理名称来访问; Fallback 降级：定义在所有子着色器之后，如果没有任何子着色器能运行，则尝试降级； Fallback “着色器名称”； Fallback Off；没有降级，并且不会打印任何警告； Category分类 分类是渲染命令的逻辑组。例如着色器可以有多个子着色器，他们都需要关闭雾效果 1234567Shader&quot;xxxx&quot;&#123; Categroy&#123; Fog&#123;Mode Off&#125; SubShader&#123;...&#125; SubShader&#123;...&#125; &#125;&#125;]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
        <category>Shader学习之路</category>
      </categories>
      <tags>
        <tag>ࡆUnity</tag>
        <tag>ࡅOpenGL/Shader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Maya 100 招 - 第十一招到第二十招]]></title>
    <url>%2Fposts%2Fdf0a441f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;屎一样的分P的原因是因为动态还是挺大的，为了减少流量压力，分开多篇文章比较省心。 第十一招 中键调节数值 &emsp;&emsp;在Maya2016及更高的版本，很多建模操作会出现一个面板。&emsp;&emsp;通过面板可以非常快速地调节属性数值。&emsp;&emsp;这个面板可以按住相应的属性用鼠标左键修改数值。 &emsp;&emsp;也可以点击属性，让面板的属性呈现黄色。(说明属性被选中了)&emsp;&emsp;然后再视图的任意位置按鼠标中键来修改数值。 &emsp;&emsp;这样修改数值只能修改到小数点后一位的数值。&emsp;&emsp;可以配合 ctrl+鼠标中键 调整小数后两位 &emsp;&emsp;可以配合 shift+鼠标中键 调整整数 第十二招 自动保存 &emsp;&emsp;开启自动保存可以去到 windows &gt; setting/preferences &gt; preferences 打开首选项&emsp;&emsp;首选项中有 Files/Projects 设定，里面有 Autosave ，可以勾选 Enable 启用自动保存。 &emsp;&emsp;默认设置下，maya会每十分钟自动保存当前文件（前提是文件已经是保存过的） 第十三招 方便快捷的移动操作 &emsp;&emsp;按住 shift + 鼠标中键 可以不通过操作手柄移动物体 第十四招 离线旋转 &emsp;&emsp;按住键盘的 J键，然后旋转就可以触发离线旋转，每次旋转15度 &emsp;&emsp;双击旋转图标打开旋转设置面板&emsp;&emsp;可以开启 step Snap 调节旋转度数，实现90度旋转限制。 &emsp;&emsp;还可以按住 E键 配合鼠标左键，可以打开标记菜单。&emsp;&emsp;选择右下的 Discreate Rotate 离散旋转。 第十五招 设置摄像机的裁切距离 &emsp;&emsp;三维摄像机都有一个裁切距离，可以理解为可视范围，只有区域内的范围才是可见的。 &emsp;&emsp;在Maya视图上面的摄像机图标可以进入摄像机设置。 &emsp;&emsp;裁切演示 &emsp;&emsp;建议最近裁切设置小一点，最远距离设置大一点，确保场景都可以看到。 额外补充 - 裁切数值要适中 &emsp;&emsp;注：这一点在第 58 招 有补充&emsp;&emsp;如果最小距离设置太小的话，会让模型产生黑色区域，因此也不宜设置太小或太大。 第十六招 物体和元素级别切换的几种方式 &emsp;&emsp;可以通过对模型右键切换当前选择模式 &emsp;&emsp;按快捷键也可以快速切换 F8 物体级别 F9 顶点级别 F10 线级别 F11 面级别 &emsp;&emsp;也可以 Alt + q 打开标记菜单进行切换 第十七招 反向选择 &emsp;&emsp;先选中物体，然后右键菜单上有 Invert Selection 可以反向选择其他的物体&emsp;&emsp;也可以 ctrl + shift + i 快捷键进行反选 &emsp;&emsp;也可以 将镜头 缩小，然后按住 shift 键选择所有物体来实现反选 第十八招 删除历史的几种操作方法 &emsp;&emsp;完成模型需要删除历史，否则容易导致Maya出错，也可能会导致不同版本的Maya不兼容，导致模型布线混乱。&emsp;&emsp;可以去到 Edit &gt; Delete by Type &gt; History 删除历史，快捷键为 alt + shift + D &emsp;&emsp;按住键盘 A键，点击鼠标左键可以进入标记菜单，左上角是删除历史。 额外补充 - 删除单一历史节点 &emsp;&emsp;有时候我们想要删掉模型其中一个历史节点，而不是全部的历史。&emsp;&emsp;比如说我想要删除这个模型的挤出效果&emsp;&emsp;假设模型是读取进来的，已经没有办法撤销的情况。&emsp;&emsp;我能想到三种解决方案。 方案一 暴力复原 &emsp;&emsp;将挤出部分定点吸附会正方体的表面上，然后合并定点就可以复原了。 &emsp;&emsp;这种方法属于暴力复原，只适用于比较简单的操作。&emsp;&emsp;如果是复杂的操作，比如多段倒角等等的情况，修复起来还是非常麻烦的。&emsp;&emsp;并且这种方法并不适用于这里讨论的主题，因为并没有将我们的历史节点删除，只是达到了删除它的效果。 方案二 通过节点编辑器 或者 Hypergraph 删除节点 &emsp;&emsp;打开节点编辑器，获取前后连接的历史节点，然后将我们不想要节点删除即可。 方案三 直接删除节点 &emsp;&emsp;上面的方案可行，就是太麻烦了，其实还有更方便的操作。 第十九招 创建标注 &emsp;&emsp;选择物体到 Edit &gt; Anootation &emsp;&emsp;这样会弹出一个输入框，输入标注，在2016之后就支持中文输入了 &emsp;&emsp;选择标注，可以再属性上开启和关闭箭头。 输入 1 是开启， 输入 0 是关闭。 第二十招 分离物体 &emsp;&emsp;在制作模型经常需要删除一半，操作完之后再将另一部分镜像过去。&emsp;&emsp;传统的删除做法是选择模型一半的面进行删除，但是遇到复杂的模型这个操作就会很困难，必须去到正交视图，小心选择。&emsp;&emsp;这里提供了另一种删除模型一半的方案。&emsp;&emsp;选择模型中轴线，shift右键选择 Detach Component 分离模型的边 &emsp;&emsp;执行操作之后，模型看上去没有变化，其实中轴线上的顶点都一分为二了，选中模型shift右键可以选择 Seperate 分离模型，这样就可以将模型分成两半。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>Maya 100 招</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Maya 100 招 - 第一招到第十招]]></title>
    <url>%2Fposts%2F23e3cff.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这套教程非常受用，我在大二的时候就已经看过，可惜那个时候还只有40招，还有待更新，目前已经更新到98招了，我打算重新看一遍，做个教程总结。&emsp;&emsp;也在这里做一波自来水，介绍这个超级牛逼的讲师，我很多骚操作都是以前看他的直播偷师的，只是后来做TD之后，制作就少了。（主要是自己美术基础不行，干不了建模。）&emsp;&emsp;另外这个教程是完全免费的，报名即可观看 链接&emsp;&emsp;另外大佬有B站账号，可以关注一波。&emsp;&emsp;那就废话不多说，将每一招都整理起来。 第一招 专家模式 &emsp;&emsp;在Maya2016以前的版本可以通过 ctrl+shift+空格 进入无UI界面。&emsp;&emsp;可是到 Maya2016 之后快捷键就改为 ctrl+空格 这和我们的中文输入法冲突了。&emsp;&emsp;我们可以通过 Display &gt; UI Elements &gt; Hide All UI Elements 来关闭所有无关UI &emsp;&emsp;不过当前还是会有写菜单栏在上面碍眼。&emsp;&emsp;可以通过 ctrl+m shift+m ctrl+shift+m 来下显示上方的菜单栏。 &emsp;&emsp;又恢复显示也是对应按同样的快捷键进行显示。 &emsp;&emsp;也可以通过热盒 hotbox 来控制上方的菜单栏显示。 第二招 创建自己的工具架 &emsp;&emsp;可以菜单栏的对应命令上点击按 ctrl+shift+左键 来将命令添加到工具架上。 第三招 自定义标记菜单 &emsp;&emsp;可以先将需要的命令放到工具架上。&emsp;&emsp;然后打开标记菜单编辑器 &emsp;&emsp;用鼠标左键将工具架上的图标拖拽到自定义标记菜单的窗口当中 &emsp;&emsp;给标记菜单添加名称，也可以通过鼠标左键查看生成效果。 &emsp;&emsp;给标记菜单添加快捷键，快速调用命令。 &emsp;&emsp;设置快捷键为 9 之后，就可以按住键盘9键在按鼠标左键触发标记菜单 第四招 中英文版本切换 &emsp;&emsp;Maya 切换中英文可以去到系统设置环境变量&emsp;&emsp;将环境变量 MAYA_UI_LANGUAGE 设置为 zh_CN 可以切换为中文&emsp;&emsp;en_US 可以切换为中文 &emsp;&emsp;设置完成之后重开Maya就可以进入相应的中文界面。 第五招 拖动选择对象 &emsp;&emsp;开启Maya的拖动选择，获得类似 3ds Max 的体验 &emsp;&emsp;这个时候只要单机拽鼠标就可以拖拽模型了。&emsp;&emsp;但是这种操作很容易不小心产生了偏差，不建议开启。 第六招 更新操作杆大小 &emsp;&emsp;按键盘的 + 可以放大操纵杆，按键盘 - 可以缩小操作杆 第七招 清除选择 &emsp;&emsp;如果场景太大都是物体，如何快速清除当前所有的选择，而无需缩小场景点空白处呢？&emsp;&emsp;配合键盘 W 或 E 或 R 键按鼠标左键可以开启标记菜单，菜单往下的 select &gt; clear select 第八招 大纲视图的拆分 &emsp;&emsp;通过热盒在上面点击打开标记菜单往下选可以快速打开大纲视图 &emsp;&emsp;在大纲视图下方可以通过拖拽splitter拆分出第二个大纲视图 &emsp;&emsp;大纲视图 show &gt; Objects 可以过滤相应的物体 第九招 精准移动物体 &emsp;&emsp;如果精确地将模型放到网格的上方。&emsp;&emsp;移动操作手柄不好定位，操作数值也不太明确。&emsp;&emsp;按住 alt + 方向键 可以以 0.001 的单位移动物体。 第十招 恢复默认的Maya界面设置 &emsp;&emsp;打开 我的文档 &gt; maya 文件夹。&emsp;&emsp;关闭maya，然后删除对应版本的文件夹。&emsp;&emsp;这时候再次启动maya会自动将相应文件夹生成出来并且重置所有的设置为默认设置。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>Maya 100 招</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（九） - 服务器配置 | 博客部署]]></title>
    <url>%2Fposts%2F77c88c0d.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;其实去年9月份的时候就想买一台服务器来玩了，因为那个时候担心github没有办法完成SEO，想通过购买服务器来解决问题。&emsp;&emsp;后来发现根本不需要服务器也可以完成百度的收录，所以购买服务器的计划一直搁置了。&emsp;&emsp;直到今年5月份的时候，考虑到要制作带后台的app，那没有服务器是麻烦的，尽管网上搜索也有一些云服务提供了SDK和一定限量的服务，完全可以满足个人开发。&emsp;&emsp;不过我还是觉得自己弄台服务器来玩耍比较好，因此就把钱给花出去了。&emsp;&emsp;然后顺便也把域名给弄好了，现在我有了自己的域名 l0v0.com ，很难得有四个字母的短域名是没有被注册的了，而且这个颜文字还是挺有意思的，短小精悍又好记。&emsp;&emsp;其实当时也没有立刻就购买服务器，而是试用了一个7天免费的服务器，最后决定购买腾讯云的学生套餐了。&emsp;&emsp;再后来花了100多买了一年最便宜的服务器，顺便也把这个域名给注册备案了。&emsp;&emsp;原以为弄服务器是很麻烦的事情，毕竟都是命令行操作，幸亏自己还是在B站查了一下教程，然后发现有个宝塔的神器，可以快速配置好服务器环境。 服务器配置 &emsp;&emsp;维护服务器其实有专门的岗位，叫做运维。需要熟练操作 Linux 系统，会写一些脚本完成批处理操作才行。&emsp;&emsp;我这个渣滓还没有时间去研究这方面的东西，大四要来了一大堆事情等着我来弄呢。&emsp;&emsp;我之前工作室的师兄也是弄后台的，他当时有给我玩过宝塔，但是我还不直到原来是国内的人做的一个 PHP后台。&emsp;&emsp;当时只是觉得好方便，一切都图形化了，连数据库都有 phpmyadmin 可视化管理。&emsp;&emsp;后面因为自己配置服务器太累了，虽然腾讯云有教程，但是比较生涩，操作起来很懵圈。&emsp;&emsp;于是去B站搜了配置教程，然后我就发现了新大陆，没想到师兄之前用的就是宝塔。&emsp;&emsp;宝塔面板的使用真的是非常非常简单，可以去官网一探究竟。&emsp;&emsp;安装宝塔面板只需要一行代码即可。 &emsp;&emsp;非常简洁，安装过程类似 node.js 的 npm 和 python 的 pip&emsp;&emsp;安装完之后就可以到服务器的 8888 端口登录宝塔界面了。&emsp;&emsp;初次进入宝塔界面就会提示安装服务器需要的运行环境了 可以选择 LAMP/LNMP 两种不同的服务器环境，主要是 Nginx 和 Apache 服务器上的区别&emsp;&emsp;选择好了之后，后续的操作也是自动完成，不过因为服务器是最低配置的，所以安装过程需要半个小时左右。&emsp;&emsp;配置完成之后就可以愉快玩耍了。 Hexo 博客部署 &emsp;&emsp;Hexo 博客部署到自己的服务器上其实网上是有教程的 网址&emsp;&emsp;我基本就是按照这篇文章去操作的，然而却遇到一个天坑，坑了我半天才解决问题。&emsp;&emsp;服务器等环境都通过宝塔面板处理好了，因此只需要配置好git的环境进行上传就可以了。&emsp;&emsp;这个过程有非常重要的步骤就是需要配置 ssh rsa 验证，从而实现无需密码 push 到服务器上&emsp;&emsp;这些操作之前也在github的时候配置过，现在却出现了很奇葩的问题。&emsp;&emsp;我按照教程的指引，通过 ssh-keygen 生成了 私人秘钥 和 公开密钥。&emsp;&emsp;随后我用宝塔面板的文件管理器创建了authorized_keys文件，并且将公开密钥的内容填写了进去。&emsp;&emsp;然后我却依然无法实现免密登录。&emsp;&emsp;于是在网上搜索了大量的资料，涉及到权限问题，也有ssh的配置问题。&emsp;&emsp;其实上述的文章也提到了权限的问题，已经设置为了 600 和 700 权限，确保是可以读取的了。&emsp;&emsp;ssh配置也确实是个问题，后面我找到了这篇文章解决了问题。&emsp;&emsp;然而进行了一大通的操作之后，我还是无法实现免密登录。&emsp;&emsp;于是我就佛了，继续在并bing上搜索外国人的资料，也没有任何收获。&emsp;&emsp;后面我尝试在其他的用户上试试能否实现免密登录，然后奇怪的事情发生了，我发现我可以在root账户下实现免密登录但是其他账户却不可以。&emsp;&emsp;然后我又创建了一个新的test账户，尝试免密登录，结果失败告终。&emsp;&emsp;于是又在网上搜索了一大通资料，只有root账户可以ssh免密登录，然后也没有任何结果。&emsp;&emsp;于是我真的佛了，放弃了。&emsp;&emsp;我打算先把hexo配置好，试试水吧，麻烦一点没关系，就是 deploy 的时候输入一下密码而已，没什么大不了的。&emsp;&emsp;于是又开始折腾hexo的配置，最后hexo配置完成了，但是 hexo d 报错，没有访问权限。&emsp;&emsp;所以hexo是不支持密码登录的，只能用免密登录(:з」∠)&emsp;&emsp;然后我就几乎放弃了，只是做无谓的挣扎测试一下 git clone 的情况。&emsp;&emsp;每一次都是需要输入密码的。&emsp;&emsp;后面我在对 root 账户进行测试，我直接将其他账户下的 authorized_keys 文件覆盖了 root 账户下的文件。&emsp;&emsp;然后神奇的事情发生了，root账户的免密登录也失效了，我真的是哭死的心都有了。&emsp;&emsp;就好像拆了一个玩具装不回去的感觉，难受的一批啊~~&emsp;&emsp;我又把root账户下的 authorized_keys 文件内容替换了其他的 rsa 验证，依然不行。&emsp;&emsp;后面我打开宝塔面板的权限，看到文件的所属账户并不是 root 账户的。 &emsp;&emsp;抱着试一试的心态，我将的用户所属改为了 root ，然后免密登录测试，通过了！！！&emsp;&emsp;于是我到git目录下也将这个文件的所属改为 git ，然后就可以免密登录，解决问题。&emsp;&emsp;归根到底，教程是通过 vim 在当前用户下处理文件的，而我是通过宝塔生成这个文件，因此宝塔下生成的问题就得用户所属不对应，导致坑了半天(:з」∠) 总结 &emsp;&emsp;功夫不负有心人，我总算是将博客部署到了自己的服务器上，大家可以参考 博客&emsp;&emsp;后续暑假的任务实在是太多，太沉重了，希望自己能够规划好时间，好好学习吧。（明天考马克思，老天保佑我逢考必过。）]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
        <tag>ࠓLinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Laravel框架试水]]></title>
    <url>%2Fposts%2Fccad2d76.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;由于这学期有个数据库的课程，虽然我把数据库的设计都交给了和我一起组队的学委了，但是无论如何，下学期还是需要将这个教学系统做成动态网页。&emsp;&emsp;因此我就网上找教程，发现了一个 PHP Laravel 框架的教程完全符合我们要做的效果，因此了就开始我的PHP试水之旅。&emsp;&emsp;当然学之前还是给自己准备好了教程2018千峰php教程高手养成计划之laravel框架 PHP 基础 &emsp;&emsp;我是先过了千峰php的基础，教程分了好几个部分，我就选择了基础的部分去看。 &emsp;&emsp;这些部分是我看过的，我看的非常得快，基本是加到 3 - 4 倍速度，因为都是些很基础的东西。&emsp;&emsp;编程是共通的，细节部分可以后面慢慢研究。&emsp;&emsp;后面还有一些 PHP 的进阶用法，比如利用PHP修改本地文件，制作图片验证码。&emsp;&emsp;大概过了一下思路，没有自己动手测试，想着这些功能都有现成框架，所以就没有深入学习。&emsp;&emsp;其实我知道这样会非常不好的，终究变成最后还是逃不过底层的。不过这次只是试水应付作业，就不管这么多了。 框架选择 &emsp;&emsp;其实在学习PHP之前，我还在犹豫到底要用什么语言做这个动态网页的作业，之前我们的动态网页课程是学习了原生 java web 的技术&emsp;&emsp;而且后端还有 go 语言、python、node 等成熟的体系。&emsp;&emsp;而且PHP是最好的语言都成了编程的梗了，也看过一些文章吐槽PHP内置函数屎一样的命名规则。&emsp;&emsp;不过想到PHP的易用性还是先从它试试水吧，毕竟世界上有30%的网页是用 wordpress 做的，而wordpress框架是PHP做的。&emsp;&emsp;屎一样的命名规则也是有起历史原因的，以前松散的命名便于学习，后面PHP其实也做了一些规范的努力。但是为了做到向前兼容也无可奈何地保留了一些命名。&emsp;&emsp;既然选择了PHP就要选择PHP框架了，应付作业就不可能从零做所有的事情。&emsp;&emsp;发现PHP有好多框架，国内最火的框架是国人开发的 ThinkPHP ，而国外最热门的是 Laravel。&emsp;&emsp;最后我还是崇洋媚外地选择了 Laravel，背靠Stack Overflow可以解决问题。（真· 面向 Stack Overflow编程）&emsp;&emsp;然后顺便再B站搜索 Laravel 框架实现的东西。&emsp;&emsp;没想到当中就有我所想要的东西， laravel在线教育项目，真的是直切要害的教程。 学习Laravel &emsp;&emsp;B站的教程没有教程相关的资料，于是我在CSDN找到了很棒的百度云链接 链接&emsp;&emsp;不仅有源码还有教程笔记。&emsp;&emsp;教程总共分为10天，其中有一天的视频缺失了。&emsp;&emsp;前4天讲解 Laravel 框架基础，后6天搭建在线教育系统。&emsp;&emsp;我看了前两天的讲解之后就坐不住了，因为想要赶在汇报之前将demo坐出来，否则暑假可能没有压力去学习 Laravel 了&emsp;&emsp;前两天的讲解也确实学到了不少东西，包括 Laravel 的路由机制、数据库处理方式，后面还有些关于文件存储的，但是后面飘了，没有看进去。&emsp;&emsp;于是我就匆匆开始从第4天的在线教育平台搭建开始看起。&emsp;&emsp;配置服务器环境，配置Laravel环境，搭建后台路由，一切都顺理成章。 Laravel 在线教育平台坑爹的Composer &emsp;&emsp;PHP也有了类似于前端的 NPM 包管理器，叫做Composer。&emsp;&emsp;教程也提到使用国内服务器的景象可以极大提高访问速度。&emsp;&emsp;然后我配置还是很慢，配置一次 Laravel 的环境花了1个小时，慢到流泪的下载速度啊~~&emsp;&emsp;总而言之折腾了很久，但是最后还算是有惊无险地将环境配置好了。 H-ui.admin 搭建后台路由 &emsp;&emsp;万万没想到这个 ui 框架，也是我之前工作室师兄使用后台前端页面啊&emsp;&emsp;这个东西是开源免费的，我当时还以为是他自己搭建的。&emsp;&emsp;不过难受的事情才刚刚开始。 搭建数据库 &emsp;&emsp;首先不得不吐槽一下 Laravel 对接数据库的封装方法，虽然将 sql 语句解构成了 PHP 的函数来执行了。&emsp;&emsp;获取数据也可以是一个实例一样可以通过get方法获取，但是解构出来的 selct 语句 where 语句真的让我很反感。&emsp;&emsp;因为要写select where 函数都必须满足你懂sql语句的前提，那既然是sql通过分割得来的，那么为啥不干脆直接传入sql语句执行。&emsp;&emsp;反正不懂sql语句也没办法用那些函数来查询数据库的，这个点真的让我很懵圈，不够DB库内置了 Eloquent ，可能也算是框架简洁的一部分吧。&emsp;&emsp;然后就可以同过 artisan 创建 migrate 文件来创建数据库表&emsp;&emsp;也可以通过 migrate:seed 以及 faker 库来给数据库填充可靠的假数据，这个功能真的很出乎意料的棒。 登录验证 &emsp;&emsp;我按照教程一步一步去做，成功完成了 captche 图片验证&emsp;&emsp;但是密码登录却一直无法返回成功值，即便我直接拷贝了教程的部分代码也一直验证密码是错误的。&emsp;&emsp;经过我很长时间的搜索也没有找到很好的解决方案(其实当时找到了解决方案，因为框架验证密码写在Model文件当中实现的,我当时完全按照教程的方法添加使用了trait代码块，并不认为添加多一个函数可以解决问题。 )&emsp;&emsp;我们实在找不到问题的原因，于是深入框架内部，看看到底是框架内部的验证哪里反馈了错误。&emsp;&emsp;然后才知道，验证代码的时候会自动将用户输入的密码进行 bcrypt 加密，确保数据库的密码是加密的。&emsp;&emsp;但是我现在数据库存储的就是明文，所以只能添加 getAuthPassword 函数来让获取的密码也bcrypt加密，保持一致。&emsp;&emsp;这样总算解决登录验证的问题。 登录验证错误反馈 &emsp;&emsp;当PHP的验证错误之后，需要在前端反馈错误信息。&emsp;&emsp;这就涉及到 PHP 和 js 的交互，这也是我觉得前后端耦合，极度恶心的地方之一。&emsp;&emsp;毕竟是不同平台语言，PHP只能跳转回当前页面，将数据传递给 JS 来启动JS的时候出发错误报错。&emsp;&emsp;毕竟PHP是HTML的预处理器语言，所以它是将信息写到HTML当中，然后再通过浏览器解析JS来出发JS报错弹窗。&emsp;&emsp;所以我总算明白为什么学PHP的人要回JS，不会JS，不会前端还怎么写网页？！ 后端的各个页面的逐一处理 &emsp;&emsp;PHP最恶心我的地方出现了，毕竟我是前端出身的，PHP在这个地方给我带来严重的不适应。&emsp;&emsp;在Laravel框架中使用后缀 blade.php 来作为HTML模板&emsp;&emsp;通过HTML模板可以将 PHP 的变量输出到 HTML 页面上。&emsp;&emsp;然而双大括号的输出方式完全和前端的React 是一样的，而且前后端高度耦合，都不知道功能需求怎么分配。&emsp;&emsp;我个人是非常讨厌后端模板的，虽然在SEO上面有它的优势，但是后端模板于前端结合，很容易让两者的开发混在一起，一个人做还好，如果团队开发就理还乱剪不断了。 &emsp;&emsp;另外 Laravel 是一个统一框架 而不是像 wordpress 那种一键部署&emsp;&emsp;所以所有的后端页面都需要手动写入，还得依赖前端的 es5 的开发知识，用jq等等框架去做。&emsp;&emsp;当然听过新版的 Laravel 框架也是支持 Vue 、 React 等前端热门框架的开发学习。&emsp;&emsp;但是要一个页面一个页面开发也是将我的耐心消磨殆尽了。 总结 &emsp;&emsp;这次的Laravel框架最终以我的放弃宣告失败。&emsp;&emsp;毕竟是学前端先入为主了，我还是像学学 VUE 结合 Node 来做个后端。&emsp;&emsp;模板还是完全用js来弄比较舒服啊~~]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>࠴编程/后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity - 场景漫游课程设计]]></title>
    <url>%2Fposts%2Fb1b98494.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;由于我们有虚拟现实的课程，需要通过 unity 来实现一个场景漫游效果等等。&emsp;&emsp;由于我实习了，还没有时间去学习 unity ， 汇报也是托了在学校的同学帮忙做前期汇报的。&emsp;&emsp;所以待我接手开发的时候，那位好心同学给我开了个坑，我需要开发一个类似模拟人生一样的，随意搭配家具的系统。&emsp;&emsp;当然，其实也没有那么复杂，做出类似的效果就可以了。 Unity 的准备 &emsp;&emsp;由于不会 Unity ，有需要制作GUI的界面，所以第一步当然是先去找些可用的教程来学习。&emsp;&emsp;尽管我B站上上传了很多 Pluralsight 相关的 Unity 教程，其实我自己都没怎么看过，一直想学，但是精力有限啊~&emsp;&emsp;于是终于为了应付作业开始入门学习，入门的话还是先找些国内的教程看看，基础的操作和 Maya 差不多，也没有什么难度。（我还翻译过Unity的入门教程(:з」∠)） Unity3d第一人称射击游戏项目实战【23集】千锋Unity游戏开发中级教程 【SiKi学院Unity】Unity换装系统【上】 【SiKi学院Unity】Unity换装系统【中】 【SiKi学院Unity】Unity换装系统【下】 &emsp;&emsp;这些就是当初我学习的时候看的教程参考，当然我也没有完全看完，主要挑些有用的重要的部分去看。&emsp;&emsp;换装系统的部分参考得蛮多的，毕竟比较契合我们想要的实现的效果。&emsp;&emsp;另外一些零零总总的问题就是通过 Bing 英文搜索解决了， Unity 的官方论坛真的非常有用，遇到问题通常都能在上面找到解决方案。 制作阶段模型准备 &emsp;&emsp;要搭建场景漫游肯定需要现有一个用于漫游的场景。&emsp;&emsp;模型下载我是在 cg模型网 上面找免费资源下载进行使用。&emsp;&emsp;由于前段时间弄 安卓开发 ，我128G的硬盘不够用，所以最后我把很多软件删掉了，其中就包括 3ds Max。&emsp;&emsp;这次找模型就让我非常痛苦，由于电脑只有 Maya 了，我需要找 Maya 的房屋模型，这就非常难找了。&emsp;&emsp;最后好不容易找到了一个，虽然房子简陋了点，但是最起码的要求还是达标了。 &emsp;&emsp;当然这里还是踩了很多坑，后面需要将有逻辑交互的模型，以及做成 prefab 的模型都要统统在unity分类号，方便后面挂载脚本等的操作。&emsp;&emsp;另外上的一些缺陷也要在 Maya 里面修补好，比如说Unity基本不支持面片模型，面片的法线是只有正反的，碰撞以及光线穿透都很成问题。&emsp;&emsp;因此后面我将所有的单面片全部挤出了一丢丢的厚度。&emsp;&emsp;另外就是墙壁和房间的划分，这部分原模型也没有弄好，因此我做了一些人工的修复。&emsp;&emsp;还要干掉一些面数过大的模型，原模型的窗帘是用动力学模拟的，为了实现效果，模拟的面数达到 70 多万面，占了整个模型大小的 80 % 以上。&emsp;&emsp;这些可以通过 减面操作 降低面数。 第一人称控制器 &emsp;&emsp;看千锋教程时候，第一人称控制器是完全从零开始搭建的，这一点让我很诧异，也很膜拜居然可以自己写。&emsp;&emsp;因为前面做课程的实验，所以我知道 Unity 的官方standard asset 是有做好的第一人称控制器 prefab 的。 &emsp;&emsp;实际上，漫游最难的部分其实官方就已经给你准备好了。&emsp;&emsp;下面就是在官方的基础上配置好相关的碰撞属性即可。 开门脚本编写 &emsp;&emsp;我最开始实现的就是开门脚本编写。&emsp;&emsp;其实没有想象中那么复杂，接触了其他语言的代码编写之后，写C#其实本质也差不多。 &emsp;&emsp;这里我专门看了 千峰 教程是怎么实现门的开闭。&emsp;&emsp;虽然教程里面是自动触发的。使用 Vector3.lerp 来实现动画过渡的核心想法还是保留了下来。（其实这里有坑）&emsp;&emsp;另外使用 public 变量来方便外部调整的 idea 也非常 awesome (运用自如~)&emsp;&emsp;开门动画就是用程序代码实现的，当然也可以在 Maya 里面制作动画，然后用脚本控制门开合的动画状态。&emsp;&emsp;不过这个门的开闭其实是非常简单的，根本不需要这么麻烦的实现。 &emsp;&emsp;另外就是要实现靠近门满足特定条件才会触发门开关的效果。&emsp;&emsp;这里使用了 光线发射器 ，回头一想这就和 three.js 一样的，也是发射光线的碰撞来获取点击。&emsp;&emsp;然后获取到碰撞的物体之后就可以检测这个物体是否是我们想要的物体，也可以获取到碰撞的距离是多少。&emsp;&emsp;通过碰撞的检测可以知道这个物体是否是我们想要的模型。&emsp;&emsp;通过距离的检测不仅可以过滤远程开门，也可以增加一些信息提示。 &emsp;&emsp;setColor 函数就是我封装好的遍历模型下所有的属性进行颜色设置的功能函数&emsp;&emsp;tip_text 也是下方的gui提示的文本。&emsp;&emsp;这样就可以实现接触提示的效果。&emsp;&emsp;Input.GetKeyDown(KeyCode.F) 可以获取到当前的键盘输入。&emsp;&emsp;当输入键盘 F 键的时候触发 clickCheck 实现动画开门，再点击就会反过来实现动画关门。&emsp;&emsp;这个方案可以实现平移开门的实现，但是一旦涉及到旋转门，那设置负值就会让门陷入无限循环的。 &emsp;&emsp;因此后期我将旋转相关的代码改为上面图片的实现方案，通过 bing 搜索出来的。 打开电视 &emsp;&emsp;Unity 实现视频播放其实网上也有很多相关的文章。&emsp;&emsp;我这里是使用 videoPlayer 来实现的。&emsp;&emsp;通过 videoPlayer 播放视频，然后将视频输出成贴图，然后将相关的贴图贴到对应的材质上，再将材质放到对应的模型上，就可以实现视频播放。&emsp;&emsp;由于我是直接使用 mp4 视频格式，所以无法播放视频的 音频 ,因此需要提取视频的音频做一个 wav 文件。&emsp;&emsp;这里是额外添加了一个 audioSource 组件来控制音频。 拾取脚本制作 &emsp;&emsp;控制器模型在拾取状态下的旋转缩放。 &emsp;&emsp;GameObject.Find(&quot;Furniture_Panel&quot;).GetComponent&lt;Furniture_Panel&gt;().PickUp 是另一个脚本上的变量，用于判断全局的状态拾取状态。&emsp;&emsp;判断条件，如果满足可以开启拾取和取消拾取。 &emsp;&emsp;拾取之后需要禁用 刚体和碰撞器的相关属性， 还要确保模型在碰撞区域无法 放下物体。&emsp;&emsp;最后就是在碰撞状态下实现红色高亮显示。&emsp;&emsp;这个地方没有参考教程，完全是自己写的，因此代码比较粗糙。 Furniture_Panel 编写 &emsp;&emsp;这个面板我花了比较多的心思。&emsp;&emsp;首先要将面板搭建出来，这里大量参考了 换装教程的设计思路。&emsp;&emsp;另外因为有 Pyqt 的开发经验，搭建GUI的时候也没有遇到太多的问题。 &emsp;&emsp;首先创建对应的 GUI ， Toggle 就是左边的切换按钮， View 就是右边的视图。&emsp;&emsp;进入程序之后会获取 View 并生成 item ，然后只显示第一个 View 。&emsp;&emsp;通过 Toggle 切换就可以实现在多个 View 中的切换。 &emsp;&emsp;createImageItem又是怎么实现的呢？&emsp;&emsp;我做了一个图片 item 的 prefab ，后续就是用代码生成 prefab&emsp;&emsp;prefab 包括红色的选中边框，图片以及说明文字&emsp;&emsp;在这里最核心的想法是我希望显示出来的item是自动生成图片，而不需要我对模型一个个去截图的。&emsp;&emsp;这个制作在 bing 上搜索了很多解决方案，最后使用下面这些函数可以解决我的问题。 &emsp;&emsp;给定摄像机和长宽就会渲染出当前摄像机对准的图片。&emsp;&emsp;那么还需要给个模型定位，让摄像机到对应的位置。 &emsp;&emsp;这个方案也是在 bing 上找到的，可以根据模型的boundingbox将摄像机定位到模型附近的区域并望向模型。&emsp;&emsp;获取到图片就可以批量给生成的 UI 添加图片 &emsp;&emsp;这个就是G键面板的主要逻辑。&emsp;&emsp;生成了物体之后，只要让物体 prefab 执行脚本的 pickUp 函数就可以实现拾取状态。 总结 &emsp;&emsp;这次Unity开发完全是为了应付作业而速成的，很多效果都很渣。&emsp;&emsp;没有使用第三方的工具包，对Unity不熟悉，害怕坑太多，填不完。&emsp;&emsp;也没有美工修饰，大部分用Unity的原生方案，模型也很粗糙。&emsp;&emsp;作业完成就得了(:з」∠)]]></content>
      <categories>
        <category>游戏开发</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>࠴编程/CSharp</tag>
        <tag>ࡆUnity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(7)]]></title>
    <url>%2Fposts%2F712b664b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;其实为啥要突然要做个古诗默写软件的桌面软件，而不是做 Maya 相关的插件开发呢？&emsp;&emsp;我觉得 Maya 相关的插件开发我之前也有一些文章积累在博客当中了。&emsp;&emsp;当然那些都不是教程，只是个人的开发记录而已， &emsp;&emsp;其实重点是我上上个月做安卓开发的时候做了一个古诗词Demo&emsp;&emsp;不过最后没有用上，有些遗憾。&emsp;&emsp;既然代码都准比好了，将 Java 转换成 Python 应该难度不大的。&emsp;&emsp;所以就有了用 Python Qt 来重建这个 APP 上实现的功能。 &emsp;&emsp;毕竟是桌面级开发，完成代码之后会介绍 pyinstaller 库实现将 py 文件封装成 exe 文件的方法。&emsp;&emsp;最终的成品实现效果。 源码路径: https://github.com/FXTD-ODYSSEY/PoemMaster 开发前的准备 &emsp;&emsp;开发一款应用之前应该要理清楚开发的需求，弄好数据结构和代码存放目录。&emsp;&emsp;做好这些，开发的时候头脑无杂念，条理更清晰。&emsp;&emsp;话虽如此，不过我自己还没能完全驾驭到么高的层次，一般做这一步的人都是传说中的架构师。&emsp;&emsp;我目前还是开发到半路，发现这里需要单独分出一个文件夹做管理，然后统一将代码的路径安排好。 &emsp;&emsp;这个目录就是我写完Qt效果之后，整理好的代码层级。&emsp;&emsp;整理代码层级方便后续的代码维护，提高代码可读性。 Qt Designer 制作界面 &emsp;&emsp;Qt Designer是非常强大的 ui 制作工具。&emsp;&emsp;活用 Qt Designer 可以让开发效率极大提升。 &emsp;&emsp;这些ui文件都在 源码的 ui 文件夹下，大家可以拿下来放到 Qt Designer 下面看是如何实现的。 搭建程序框架 &emsp;&emsp;要运行 Qt 必须创建出 QApplication 12345678910111213# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *def main(): app = QApplication([]) window = QWidget() window.show() app.exec_()if __name__ == '__main__': main() &emsp;&emsp;这样就可以运行一个简单的窗口。&emsp;&emsp;下面需要将我们的 ui 文件添加到窗口上。&emsp;&emsp;从一开始的准备的目录可以知道ui文件的处理应该放到 view 目录下生成&emsp;&emsp;另外为了避免uic编译成py的麻烦，可以写一个 loadUiType 的函数放在 util.py 下 &emsp;&emsp;这样可以就不用手动编译 ui 文件。&emsp;&emsp;各个view下可以先将 ui 编译出来。 &emsp;&emsp;这样我们就可以生成出相关界面。 嵌入界面 &amp; 添加跳转 &emsp;&emsp;下面可以将编译的ui添加到主窗口上。&emsp;&emsp; main.py 可以适当改写扩展一下。 123456789101112131415161718192021222324# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *from view import TitleViewclass PoemMaster(QWidget): def __init__(self): super(PoemMaster,self).__init__() self.setWindowTitle(u"古诗词背诵软件") self.setLayout(QVBoxLayout()) self.layout().setContentsMargins(0,0,0,0) self.title_view = TitleView() self.layout().addWidget(self.title_view)def main(): app = QApplication([]) window = PoemMaster() window.show() app.exec_()if __name__ == '__main__': main() &emsp;&emsp;下面要如何实现界面跳转呢？&emsp;&emsp;其实思路有很多，我这里的思路是将所有相关的界面添加到主界面的layout中。&emsp;&emsp;隐藏其他的界面，只保留当前前面，当需要切换的时候，再做相关的可视化处理。&emsp;&emsp;Stackoverflow 上面有推荐用 stackWidget 来实现切换的，应该也是可行的方案。&emsp;&emsp;我之前也试过将所有的界面存放到数组中，在需要的时候清空当前页面然后从数组中获取页面。 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *from view import TitleViewfrom view import GameViewclass PoemMaster(QWidget): def __init__(self): super(PoemMaster,self).__init__() self.setWindowTitle(u"古诗词背诵软件") self.setLayout(QVBoxLayout()) self.layout().setContentsMargins(0,0,0,0) self.initUI() def initUI(self): # Note 添加界面切换的点击事件 self.title_view = TitleView() self.title_view.Study_BTN.clicked.connect(self.viewNavigator) self.game_view = GameView() self.game_view.Back_Button.clicked.connect(self.viewNavigator) self.game_view.setVisible(False) self.layout().addWidget(self.title_view) self.layout().addWidget(self.game_view) def viewNavigator(self): self.title_view.setVisible(not self.title_view.isVisible()) self.game_view.setVisible(not self.game_view.isVisible()) # Note 调整窗口大小 （可视化切换会让窗口大小变大） self.adjustSize()def main(): app = QApplication([]) window = PoemMaster() window.show() app.exec_()if __name__ == '__main__': main() GameVeiw 主程序编写 &emsp;&emsp;其实其他界面的编写都很简单的，毕竟也么有太复杂的功能。&emsp;&emsp;下面来重点讲解如何实现 GameView 古诗数据显示 &emsp;&emsp;既然要背古诗，当然需要有古诗的数据。&emsp;&emsp;一般来说数据应该使用数据库来管理的，这里我稍微偷懒，将数据以文本的形式存储起来了。&emsp;&emsp;搭建可以在 data 目录下的 struct.py 获取到所有的古诗词数据还有常用汉字列表。&emsp;&emsp;为什么需要常用汉字列表，我本来也想通过 unicode 的字符偏移获取任意的字符的。&emsp;&emsp;奈何这个方案出来的大都是生僻字，选择上一点难度都没有，所以我还把常用汉字列表加进去。 &emsp;&emsp;古诗数据并没有按照字典的形式罗列，因此我在 struct.py 中加入了代码处理，让它变成一个带字典的数组数据。&emsp;&emsp;通过数组可以获取到每一首诗对应的字典，每个字典有 title author body 这三个关键字。 &emsp;&emsp;下面就是通过随机数的方法在数组中随机抽取古诗数据了。&emsp;&emsp;当然由于这里使用的是 Html 富文本，所以数据还需要处理才可以正常显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *from data import common_chinese_listfrom data import poem_dataimport osimport randomfrom util import loadUiTypefrom util import DIRUI_PATH = os.path.join(DIR,"ui","game.ui")form_class , base_class = loadUiType(UI_PATH)class GameView(base_class,form_class): def __init__(self): super(GameView,self).__init__() self.setupUi(self) self.question_char = '' # Note 将按钮添加到数组当中 self.answer_list = [] self.answer_list.append(self.Answer_1) self.answer_list.append(self.Answer_2) self.answer_list.append(self.Answer_3) self.answer_list.append(self.Answer_4) self.answer_list.append(self.Answer_5) self.answer_list.append(self.Answer_6) self.answer_list.append(self.Answer_7) self.answer_list.append(self.Answer_8) self.poemDataHandler() def poemDataHandler(self): rand = random.randint(0,len(poem_data)-1) poem_info = poem_data[rand] body = poem_info['body'] name = poem_info['name'] author = poem_info['author'] # Note 模仿 do while 语句截取字符 while True: num = random.randint(0,len(body)-1) self.question_char = body[num] if self.question_char != '\n': break # Note 添加下划线标注 body = body[0:num] + '__' + body[num+1:] poem = "" poem += "&lt;p align=\"center\"&gt;%s&lt;/p&gt;" % name poem += "&lt;p align=\"center\"&gt;%s&lt;/p&gt;" % author for line in body.split("\n"): poem += "&lt;p align=\"center\"&gt;%s&lt;/p&gt;" % line self.Poem_Label.setText(poem) # Note 循环数组添加点击事件 for answer in self.answer_list: rand = random.randint(0,len(common_chinese_list)-1) answer.setText(common_chinese_list[rand]) rand = random.randint(0,len(self.answer_list)-1) self.answer_list[rand].setText(self.question_char) &emsp;&emsp;通过 while 循环 在正确的位置上挖空。&emsp;&emsp;有了挖空的数据就可以在随机按钮上添加答案了。&emsp;&emsp;而其他按钮就可以使用常用汉字列表中的数据代替。 添加点击事件判断 &emsp;&emsp;下面添加点击按钮检查答案是否正确的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *from data import common_chinese_listfrom data import poem_dataimport osimport randomfrom functools import partialfrom util import loadUiTypefrom util import DIRUI_PATH = os.path.join(DIR,"ui","game.ui")form_class , base_class = loadUiType(UI_PATH)class GameView(base_class,form_class): def __init__(self): super(GameView,self).__init__() self.setupUi(self) self.score = 0 self.question_char = '' # Note 将按钮添加到数组当中 self.answer_list = [] self.answer_list.append(self.Answer_1) self.answer_list.append(self.Answer_2) self.answer_list.append(self.Answer_3) self.answer_list.append(self.Answer_4) self.answer_list.append(self.Answer_5) self.answer_list.append(self.Answer_6) self.answer_list.append(self.Answer_7) self.answer_list.append(self.Answer_8) # Note 循环数组添加点击事件 for answer in self.answer_list: answer.clicked.connect(partial(self.checkAnswer,answer)) self.poemDataHandler() def checkAnswer(self,button): if button.text() == self.question_char: QMessageBox.information(self,u"回答正确", u"恭喜你回答正确") self.score += 1 self.Score_Label.setText(u"学习积分: %s" % self.score) self.poemDataHandler() else: QMessageBox.warning(self,u"回答错误", u"请重新作答") def poemDataHandler(self): rand = random.randint(0,len(poem_data)-1) poem_info = poem_data[rand] body = poem_info['body'] name = poem_info['name'] author = poem_info['author'] # Note 模仿 do while 语句截取字符 while True: num = random.randint(0,len(body)-1) self.question_char = body[num] if self.question_char != '\n': break # Note 添加下划线标注 body = body[0:num] + '__' + body[num+1:] poem = "" poem += "&lt;p align=\"center\"&gt;%s&lt;/p&gt;" % name poem += "&lt;p align=\"center\"&gt;%s&lt;/p&gt;" % author for line in body.split("\n"): poem += "&lt;p align=\"center\"&gt;%s&lt;/p&gt;" % line self.Poem_Label.setText(poem) # Note 循环数组添加点击事件 for answer in self.answer_list: rand = random.randint(0,len(common_chinese_list)-1) answer.setText(common_chinese_list[rand]) rand = random.randint(0,len(self.answer_list)-1) self.answer_list[rand].setText(self.question_char) &emsp;&emsp;其实到这一步就已经完成了古诗的代码逻辑。 创建仿 安卓 弹窗的效果 &emsp;&emsp;上面的弹窗效果比较丑。&emsp;&emsp;因此我不用 QMessageBox ,可以自己实现一个类似安卓的弹窗。&emsp;&emsp;如何才能实现弹窗之后，无法影响其他窗口呢？&emsp;&emsp;我发现 QDialog 有 setModal 方法可以实现这个效果。&emsp;&emsp;QtDesigner 也有相关的设置选项。&emsp;&emsp;而 self.setWindowFlags(Qt.FramelessWindowHint) 则可以实现不带边框的窗口 1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *import osfrom util import loadUiTypefrom util import DIRUI_PATH = os.path.join(DIR,"ui","dialog.ui")form_class , base_class = loadUiType(UI_PATH)class NormalDialog(base_class,form_class): def __init__(self,parent): super(NormalDialog,self).__init__() self.parent_window = parent self.setupUi(self) # Note 不带窗口边框 self.setWindowFlags(Qt.FramelessWindowHint) self.OK_BTN.clicked.connect(self.close) def display(self,title,msg): # Note 设置标题和输出信息 self.Title_Label.setText(title) self.Message_Label.setText(msg) self.show() &emsp;&emsp;注：代码还要修改为调用 NormalDialog&emsp;&emsp;效果虽然实现，但是因为背景没变暗，因此看起来很不舒服。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:utf-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *import osfrom util import loadUiTypefrom util import DIRUI_PATH = os.path.join(DIR,"ui","dialog.ui")form_class , base_class = loadUiType(UI_PATH)class NormalDialog(base_class,form_class): def __init__(self,parent): super(NormalDialog,self).__init__() self.parent_window = parent self.setupUi(self) # Note 不带窗口边框 self.setWindowFlags(Qt.FramelessWindowHint) self.OK_BTN.clicked.connect(self.close) def display(self,title,msg): # Note 设置标题和输出信息 self.Title_Label.setText(title) self.Message_Label.setText(msg) width = self.parent_window.size().width() height = self.parent_window.size().height() # Note 居中显示 centerX = width/2 - self.geometry().width()/2 centerY = height/2 - self.geometry().height()/2 position = self.parent_window.mapToGlobal(QPoint(centerX,centerY)) self.move(position) # Note 添加灰色遮盖 self.label = QLabel(self.parent_window) self.label.resize(width, height) self.label.setStyleSheet('background:rbga(0, 0, 0, 125)') # Note 显示效果 self.label.show() self.show() def close(self): self.label.close() return super(NormalDialog,self).close() &emsp;&emsp;可以添加一个和窗口大小一致的 QLabel 然后用样式添加半透明的黑色，从而实现灰色覆盖在背景的效果。&emsp;&emsp;当然我的源码是使用 pixmap 来实现的，更加底层一点。 &emsp;&emsp;以上就是模仿 Android UI 制作的故事背诵软件。 pyinstaller 打包 &emsp;&emsp;如果将源码拿出来运行时很不方便的，不是每一条电脑都有安装python编译器以及相关的运行库&emsp;&emsp;我们可以借助 pyinstaller 库将 Qt 代码封装成 exe 文件，这样只需要执行 exe 文件就可以打开我们的应用了。 &emsp;&emsp;关于如何打包的方法，网上也有很多教程。&emsp;&emsp;必须得安装 pyinstaller 库。&emsp;&emsp;然后就可以在 源代码目录下 使用 pyinstaller main.py 打包写好的脚本了 &emsp;&emsp;当然我这里打包的 exe 还有坑。&emsp;&emsp;打开之后界面一闪而过就关闭了 &emsp;&emsp;这种问题可以用命令行来运行程序，这样程序的问题就会打印在命令行上。 &emsp;&emsp;报错提示是缺少 ui 文件，因为我们的ui是动态编译的，我们需要将ui文件夹拷贝到程序目录下。&emsp;&emsp;如果我们的ui文件通过 uic 编译出来的就不存在上述问题。 &emsp;&emsp;再次运行程序还是出现问题了&emsp;&emsp;提示显示说 PySide2 目录下缺少 plugins/platforms 的文件 &emsp;&emsp;此处的坑是 PySide2 的问题，不知道为何打包的时候没有将相关的文件夹打包到对应的目录下，需要手动修复这个问题。&emsp;&emsp;我们可以去到 PySide2 的包路径 &emsp;&emsp;可以找到 plugins 目录了&emsp;&emsp;打开目录就有 platforms 文件夹。&emsp;&emsp;将相关的目录拷贝到程序的启动目录的 PySide2 目录下即可 &emsp;&emsp;我用 PyQt4 打包就没有这么多问题。&emsp;&emsp;另外 pyinstaller 打包也有很多属性，可以自定义打包软件的图标，也可以隐藏命令行窗口，甚至可以打包成单个文件。&emsp;&emsp;大家可以自行百度研究。 总结 &emsp;&emsp;筹备了一个月的 Python Qt 系列教程，到这里就算是完结了。&emsp;&emsp;自己算是重新复习了一遍已经掌握的Qt知识。&emsp;&emsp;如果大家觉得有用，不妨在点一下下面 赏 按钮（后面的操作你懂的），你的支持将是我前进的动力↖(^ω^)↗]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(6)]]></title>
    <url>%2Fposts%2F6830570a.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上期教程我们深刻了解了 QSS 样式，通过 QSS 可以很方便自定义自己组件的主题。装自己的逼，让别人无逼可装。&emsp;&emsp;下面我们来讲讲 Qt 的信号槽。并且如何自定义信号槽事件。 什么是信号槽 &emsp;&emsp;其实第三期教程的时候就有讲到信号槽为何物。跳转链接&emsp;&emsp;信号槽是 Qt 的事件响应机制。&emsp;&emsp;通过信号槽可以在满足特定情况下触发相关的函数。&emsp;&emsp;通过第四期教程的实战，我们知道 Qt 也自带了很多 虚函数 可以实现在特定情况下执行特定代码。&emsp;&emsp;但是虚函数需要复写，不便于后续的调用。&emsp;&emsp;因此虚函数只适合在类里面用，不适合在实例化的对象上使用。&emsp;&emsp;那么如果我们自定义一个信号槽到虚函数当中，就可以在实例中使用信号槽触发相关功能了。 # &emsp;&emsp;在第四期教程的实战中，我使用了 keyPressEvent 来实现 Esc 键退出编辑的效果的。&emsp;&emsp;当然这个写法在类里面写是没有问题的，如果我希望组件外面也有一个专门的信号槽来处理 Esc 键触发的事件，我们就可以利用自定义信号槽来解决问题。&emsp;&emsp;下面我模仿 QPushButton 的 clicked 信号槽，将这个信号槽添加到 QLabel 上的效果。 12345678910111213141516171819202122232425262728# -*- coding:UTF-8 -*-from Qt.QtCore import *from Qt.QtGui import *from Qt.QtWidgets import *class Clickable_Label(QLabel): def __init__(self): super(Clickable_Label,self).__init__() def mousePressEvent(self,event): print ("click")if __name__ == "__main__": # Note 兼容maya和外部python写法 # QApplication.instance() 可以判断 QApplication 是否存在实例 if QApplication.instance() == None: QApplication([]) window = QWidget() window.setLayout(QVBoxLayout()) label = Clickable_Label() label.setText('Clickable Label') window.layout().addWidget(label) window.show() QApplication.exec_() &emsp;&emsp;上面加入兼容 Maya 外部执行的效果。&emsp;&emsp;另外上面代码实现了，点击 label 就打印出 click 信息&emsp;&emsp;下面我们来自定义信号槽&emsp;&emsp;PySide 和 PyQt 开自定义信号槽的名称是不一样的，Qt.py 脚本是以PySide为基准的&emsp;&emsp;PySide 使用 Signal() || PyQt 使用 pyqtSignal() 12345678910111213141516from __future__ import print_functionclass Clickable_Label(QLabel): clicked = Signal() def __init__(self): super(Clickable_Label,self).__init__() def mousePressEvent(self,event): self.clicked.emit()# 省略...# Note 调用label信号槽label.clicked.connect(lambda: print('click!!!!')) &emsp;&emsp;特别注意 clicked = Signal() 这个语句不可以写在 init 函数中。&emsp;&emsp;python是支持变量写在类方法外部的，可以通过self来获取到方法外的变量。 &emsp;&emsp;另外这里用了 lambda 函数来实现打印效果。&emsp;&emsp;在 Python3 中 lambda 可以使用 print ，因为 Python3 的 print 是个函数。&emsp;&emsp;而在 Python2 中 print 是关键字，无法在 lambda 函数中执行。 &emsp;&emsp;在网上查找了一番，也是有解决方案的。from __future__ import print_function 可以让 Python2 的print 升级成 Python3 的 print。 Stackoverflow解答 &emsp;&emsp;我们也可以给emit函数添加参数，这样调用的函数就可以获取到相关的传参。 12345678910111213141516171819202122232425262728293031323334# -*- coding:UTF-8 -*-from __future__ import print_functionfrom PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *class Clickable_Label(QLabel): clicked = Signal(object) def __init__(self): super(Clickable_Label,self).__init__() def mousePressEvent(self,event): self.clicked.emit(event)if __name__ == "__main__": # Note 兼容maya和外部python写法 if QApplication.instance() == None: QApplication([]) window = QWidget() window.setLayout(QVBoxLayout()) label = Clickable_Label() label.setText('Clickable Label') label.clicked.connect(lambda e: print(e.pos())) window.layout().addWidget(label) window.show() QApplication.exec_() &emsp;&emsp;Qt 的自定义信号槽其实并不难，基本都是依靠虚函数提供的执行调用，然后让信号槽在特定条件下触发。&emsp;&emsp;我们也可以在虚函数当中加入相关的判断，比如只有点击左上角的特定区域才可以 emit 信号，如此就实现条件更加丰富的自定义效果。 &emsp;&emsp;制定自定义的信号槽我只会这么多，更加复杂的用法可以参照官方的文档相关的函数。 QSignalTransition QSignalMapper&emsp;&emsp;更为复杂的用法，其实我自己也没有怎么研究，也就不加赘述。 扩展说明 这里填个坑，如何让 PySide 的窗口如同 MEL 的窗口一样不会被遮挡。 参考这里 总结 &emsp;&emsp;自定义信号槽也结束了，至此我第一期教程宣布的所有内容已经完结。&emsp;&emsp;下一期教程，我们再来一个实战，通过 PySide2 制作一个默写古诗的软件 &lt;(￣︶￣)&gt;&emsp;&emsp;敬请期待!~]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(5)]]></title>
    <url>%2Fposts%2F431d04c9.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上期教程我们深刻了解了 PyQt|PySide 的事件机制，也知道如何添加一个全局事件处理。&emsp;&emsp;下面我们来重点说说 Qt 自带的 QSS 样式表。 样式表 &emsp;&emsp;如果你接触过前端网页开发的 CSS ，那么就可以很好理解 QSS 了。&emsp;&emsp;在 Qt 当中 QSS 有 70% 是和 CSS 的操作是一样的，当然这里不包括 CSS3 的新特性。CSS 百度百科 &emsp;&emsp;什么是样式表呢？&emsp;&emsp;样式表就是样式配置文件，通过样式表的定义，可以轻松修改页面的整体风格。&emsp;&emsp;由于在大部分基础的代码写法上 QSS 和 CSS 是几乎一样的。&emsp;&emsp;我们入门学习会从前端 CSS 的基础开始，当然也完全可以看网上相关的教程进行学习。 CSS|QSS 样式表讲解 &emsp;&emsp;下面我们用谷歌浏览器的开发者模式来讲解一下CSS的作用。&emsp;&emsp; 当然浏览器除了IE和firefox，世面上流行的浏览器内核都是谷歌chromium，所以其他浏览器的使用体验也差不多。&emsp;&emsp;这里我以我自己的个人主页来进行讲解。 &emsp;&emsp;打开我的个人主页,在浏览器输入 F12 键可以打开开发者模式。&emsp;&emsp;当然也可以用鼠标右键进入选择检查进入。 &emsp;&emsp;网页的右侧会弹出一个 DeBug 窗口，这个就是开发者工具了，对于网页开发来说非常重要。 &emsp;&emsp;当然前端相关的东西就不展开讲了，我们着重关注元素标签下的 style 部分，这里我们可以动态直接修改CSS样式。&emsp;&emsp;修改之后可以直接在网页上看到修改的效果。&emsp;&emsp;点击控制台左上角的按钮，也可以用快捷键 ctrl+shift+c 来调用。 &emsp;&emsp;这个工具可以快速定位到页面对应 html 元素。 &emsp;&emsp;这里我一开始修改了 a 标签下的内容，因此修改一个样式的颜色会对所有相关的标签的颜色进行修改。&emsp;&emsp;然后我在element下修改，那么样式就只会影响到当前元素，因此只有 智伤帝 变成了蓝色。&emsp;&emsp;这些操作在 Qt 里面也是共通的。&emsp;&emsp;只不过 Qt 的标签对应的 QPushButotn 之类的组件。 1234QPushButton&#123; color:yellow; background:rgb(0,123,123);&#125; 123456789101112131415161718192021222324from PySide2.QtCore import *from PySide2.QtWidgets import *from PySide2.QtGui import *window = QWidget()window.setWindowTitle(u'qss样式')window.setLayout(QVBoxLayout())button = QPushButton()button.setText(u'按钮样式')window.layout().addWidget(button)window.setStyleSheet('''background:#123123;''')button.setStyleSheet('''QPushButton&#123; color:yellow; background:rgb(0,123,123);&#125;''')window.show() &emsp;&emsp;QSS的书写形式如上图，我们可以借助组件的 setStyleSheet 来实现样式表添加。&emsp;&emsp;我们可以在 Maya 测试上面的代码。 &emsp;&emsp;同理，我们也可以给按钮添加点击事件来实现动态改变样式。 1234567891011121314151617181920212223242526272829from PySide2.QtCore import *from PySide2.QtWidgets import *from PySide2.QtGui import *from functools import partialdef changeStyleSheet(button): button.setStyleSheet('color:hsl(187, 100%, 100%);')window = QWidget()window.setWindowTitle(u'qss样式')window.setLayout(QVBoxLayout())button = QPushButton()button.setText(u'按钮样式')button.clicked.connect(partial(changeStyleSheet,button))window.layout().addWidget(button)window.setStyleSheet('''background:#123123;''')button.setStyleSheet('''QPushButton&#123; color:yellow; background:rgba(0,123,123,30%);&#125;''')window.show() &emsp;&emsp;你可能会很疑惑，这里的颜色怎么有这么多的表达形式。 颜色码分析参考这里&emsp;&emsp;对于这点，完全不用慌， Qt Designer 可以告诉你怎么表现颜色。 &emsp;&emsp;当然使用浏览器的开发工具也是OK的。 扩展 颜色码分析 参考这里 常用的 QSS 代码 &emsp;&emsp;常用的QSS都是和CSS共同的，当然 CSS3 相关的特性都是不支持的。（CSS3 甚至支持三维动画 ┗|｀O′|┛ ）&emsp;&emsp;需要注意的是 样式表 是不会报错的，如果输入错误的样式只会被忽略，不起作用而已。 &emsp;&emsp;以下的写法都是 Qt 所接受的， margin padding border 这些关键字其实都有拆分写法的，具体可以网上查。 1234567891011121314151617181920212223242526//设置字体颜色color: rgb(64, 148, 195);//设置背景颜色 background 关键字效果一样background-color: aliceblue;//设置长宽height: 250px;width: 400px;//设置外间距margin: 100px;//设置内间距padding: 100px;//设置对齐text-align: left;//设置字体大小 加粗 斜体font-size: 26px;font-weight: bold;font-style: italic;//设置边界大小 样式 颜色 圆角border: 15px solid red;border-radius:50px; &emsp;&emsp;下面这些写法则是 Qt 独有的，可以参考 Qt Designer 使用 1234QPushButton &#123; font:"等线 Light"; background:qradialgradient(spread:pad, cx:0.5, cy:0.5, radius:0.5, fx:0.5, fy:0.5, stop:0 rgba(0, 0, 0, 255), stop:0.19397 rgba(0, 0, 0, 255), stop:0.202312 rgba(122, 97, 0, 255), stop:0.495514 rgba(76, 58, 0, 255), stop:0.504819 rgba(255, 255, 255, 255), stop:0.79 rgba(255, 255, 255, 255), stop:1 rgba(255, 158, 158, 255));&#125; QSS 状态控制 &emsp;&emsp;CSS也有相关的状态控制，通过状态控制，可以让CSS效果在满足特定条件出发改变效果。&emsp;&emsp;而QSS的状态控制远比 CSS 的多。 1234QPushButton:hover &#123; background:yellow; border: 1px solid red;&#125; &emsp;&emsp;由于这方面的控制较多，而且有不少内容可以通过代码实现，这方面可以参照官方的样式例子 和 样式参考&emsp;&emsp;尽管官方的文档是c++方向的，不过在样式参考上还是共通的。 Qt 内置系统样式 &emsp;&emsp;其实Qt内置了一些系统样式来给我们调用。具体可以参照文档 &emsp;&emsp;执行代码不会立即让所有的风格发生变化，需要切换一下窗口才可以，可以将 Maya 整个界面变成老 windows 风格&emsp;&emsp;另外也可以切换为 Plastique 类Mac风格 总结 &emsp;&emsp;其实QSS我使用得并不多，因为这是让软件有各种主题，不同的皮肤，其本质并不影响程序的内部逻辑。&emsp;&emsp;我个人是以功能为导向，因此再丑的界面只要功能没问题，在下是无所谓的(:з」∠)。&emsp;&emsp;当然修改界面样式就会有种无形装逼，最为致命的感觉吧。&emsp;&emsp;下期教程我们来回到事件处理上，来聊聊自定义的信号槽的写法。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya C++ 多核性能测试]]></title>
    <url>%2Fposts%2F5fce3fcb.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在开发RBF节点的过程，我进行了性能测试。&emsp;&emsp;当RBF节点的使用数量达到100个以上之后，maya窗口的帧速率就已经掉到个位数。&emsp;&emsp;而这个还是没有添加任何额外绑定系统的情况。&emsp;&emsp;张峥前辈担心后续搭建出来的表情系统会过于臃肿，导致动画制作很麻烦。&emsp;&emsp;因此将性能优化提升到首位。&emsp;&emsp;于是我就尝试了使用 Maya 的 C++ 多核操作来提升运算效率。 原本的RBF节点运行效果 多核运算的RBF节点 &emsp;&emsp;最终实现的效果是令人失望的，CPU占用率上去了，然而整体的运行效率却更低了。 Maya C++ 多核方案 &emsp;&emsp;在官方文档中，maya的多核操作有很多种方法。 OpenMP Intel TBB Maya API &emsp;&emsp;OpenMP 使用起来惊人地简单，但是效率提升不明显，因此我并没有测试。 &emsp;&emsp;Intel TBB 我拿来测试了，但是效果不太理想。&emsp;&emsp;Intel TBB 没有python多线程的 join 方法，因此它实现的多线程是异步而无法同步的。&emsp;&emsp;这样的输出结果无法将多个运算结果的汇总到一起。&emsp;&emsp;尽管这种问题是可以用代码来弥补的，不过 Maya API其实已经封装好了。&emsp;&emsp;因此最后我采用了 Maya API 的线程池来实现功能。 &emsp;&emsp;关于如何使用 Maya API 的线程池，官方只给了命令相关的例子，没有变形器的例子，变形器使用 TBB 实现的。&emsp;&emsp;因此我在 github 上找到几个通过 maya 线程池实现多核功能的变形器源码。 https://github.com/ahmidou/MayaNodes https://github.com/skeelogy/maya-skNoiseDeformer Maya API 多核性能测试 &emsp;&emsp;多核运算最重要的步骤是对运算过程的切分。&emsp;&emsp;我看到maya给出的测试例子，包括网上实现的多核，都是对模型大量面数处理的时候使用的。&emsp;&emsp;也就是说有一个数量级很大的for循环，而for循环的结果是不需要同步处理的情况。&emsp;&emsp;不过放到 RBF 节点中，这种情况显然不太合适。&emsp;&emsp;RBF 是大量短小精悍的 for 共同运算的结果，因此我也不太清楚如何正确切分这个运算过程。 &emsp;&emsp;我最后是将RBF运算的一些双重for循环替换为 多核切分来提神效率。&emsp;&emsp;因此我的多核切分就会很琐碎，重点是开多线程处理也是有系统开销的。&emsp;&emsp;因此如果我把线程切分的非常碎的话，就会开非常多的线程，最后CPU占用率可以达到70%-80%。&emsp;&emsp;然而大量的CPU运算都浪费在线程的处理上了，反而拖慢了运算的效率，得不偿失。 &emsp;&emsp;所以最后的结果时Maya多核的CPU占用率上去了，但是运行效率还不如单核的理想(:зゝ∠)&emsp;&emsp;另外我找到的变形器中 MayaNodes 就是专门针对Maya多核性能测试而开发的。&emsp;&emsp;开发者给出的结论非常让人沮丧。 &emsp;&emsp;或许正是maya多核上的劣势才导致了 Ziva 这些模拟软件的运行卡顿吧。 附注 &emsp;&emsp;上面动图演示有极高的CPU占用率，是因为我将任务切分数调的很高。（我设置了100）&emsp;&emsp;由于开线程是有系统开销的，虽然这个过程是由TBB内部处理的，但是任务切分越多，开销肯定是越大的。&emsp;&emsp;因此maya的官方说明也提到，这个开销需要自己把握，拿捏尺度。&emsp;&emsp;我这里设置的任务切分数显然是过分了。 &emsp;&emsp;不过即便将任务切分调成2。&emsp;&emsp;CPU占用率不仅没上去，而且效率还是不如单线程的。&emsp;&emsp;因此github上的测试或许是对的，maya的多核运算本质还是单线程的，效率提不起来。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(4)]]></title>
    <url>%2Fposts%2F5a063588.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上期教程我们介绍了 简单的代码封装。&emsp;&emsp;这期教程来进行更加有用的实战案例，以求加深对 Qt 运用的理解。 基础运行环境搭建 &emsp;&emsp;下面我们重新建一个类，来实现近似于 Qt Designer 的 Label 双击效果。 &emsp;&emsp;首先我们先新建一个 Python 脚本,可以名为 My_Label.py ，将脚本放到 我的文档/maya/scripts 目录下。&emsp;&emsp;使用 Qt 的模块来兼容老版本的 Maya (需要将 Qt.py 放入到 我的文档/maya/scripts 目录下) &emsp;&emsp;My_Lable 文件下的代码 123456789# -*- coding:UTF-8 -*-from Qt.QtCore import *from Qt.QtGui import *from Qt.QtWidgets import *class My_Label(QLabel): def __init__(self): super(My_Label,self).__init__() self.setText("My_Label") &emsp;&emsp; Maya 脚本编辑器下的代码 12345# -*- coding:UTF-8 -*-from My_Label import My_Labelreload(My_Label)a = My_Label()a.show() 双击事件 &emsp;&emsp;下面我们来实现一下双击事件。&emsp;&emsp;由于 QLabel 不存在双击事件的信号槽（可以通过虚函数添加一个自定义的信号槽）&emsp;&emsp;因此我们需要借助虚函数来实现双击效果，而这个函数是 mouseDoubleClickEvent&emsp;&emsp;另外还需要添加一个 QLineEdit 来实现双击修改的效果。&emsp;&emsp;我们来继续完善 My_Lable 文件下的代码 123456789101112131415161718# -*- coding:UTF-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *class My_Label(QLabel): def __init__(self): super(My_Label,self).__init__() # Note 设置默认的 Label 名称 self.setText("My_Label") # Note 添加一个 QLineEdit 将其依附到 QLabel 上 self.edit = QLineEdit(self) # Note 默认设置为隐藏 self.edit.setVisible(False) def mouseDoubleClickEvent(self,event): # Note 双击触发时候显示 self.edit.setVisible(True) &emsp;&emsp;似乎效果还相差甚远呀。我们先来理清楚要实现的需求，然后一步一步去完成。 双击添加鼠标左键判断 （目前鼠标三键的双击都可以触发函数） 根据当前组件大小调整 QLineEdit 大小 点击任意位置修改 My_Label 上的内容 点击任意位置隐藏 QLineEdit 添加 enable 函数来开启双击交互效果 双击添加鼠标左键判断 &emsp;&emsp;事件判断可以通过 虚函数传入的 QMouseEvent 进行处理&emsp;&emsp;在API文档可以看到 QMouseEvent 有 button() 方法，可以获取到当前的按键。&emsp;&emsp;我们可以将获取到的信息打印出来。 1print event.button() &emsp;&emsp;可以看到打印出来的是 MidButton LeftButton RightButton&emsp;&emsp;这些都对应到当前的鼠标点击按键。&emsp;&emsp;可以查找 API文档 &emsp;&emsp;Qt 内置了以上这些按钮的触发。&emsp;&emsp;通过判断传入的 event 就可以判断是否是鼠标左键点击。 12345def mouseDoubleClickEvent(self,event): # Note 鼠标左键点击过滤 if event.button() == Qt.MouseButton.LeftButton: # Note 双击触发时候显示 self.edit.setVisible(True) QLineEdit 大小调整 &emsp;&emsp;QLineEdit 大小固定在 Label 上，是因为没有给它添加 Layout&emsp;&emsp;这种状态就和 Qt Designer 没有添加 QWidget 的组件一样，属于随意摆放的组件。&emsp;&emsp;因此我们将它添加到 Layout 中就可以解决大小的问题。 1234567891011121314def __init__(self): super(My_Label,self).__init__() # Note 设置默认的 Label 名称 self.setText("My_Label") # Note 添加一个 QLineEdit self.edit = QLineEdit() # Note 默认设置为隐藏 self.edit.setVisible(False) # Note 添加一个新的 layout 将其依附到 QLabel 上 self.layout = QVBoxLayout(self) # Note 将 edit 添加到 layout 中 self.layout.addWidget(self.edit) 修改 My_Lable 内容 &emsp;&emsp;隐藏组件需要获取一个事件，当我们点击其它位置的时候可以触发的事件。&emsp;&emsp;我们可以去查 QLineEdit 的 API文档 &emsp;&emsp;可以找到 QLineEdit 有 editingFinished 信号槽,&emsp;&emsp;借助这个信号槽我们可以实现部分效果。 12345678910111213141516171819202122def __init__(self): super(My_Label,self).__init__() # Note 设置默认的 Label 名称 self.setText("My_Label") # Note 添加一个 QLineEdit 将其依附到 QLabel 上 self.edit = QLineEdit() # Note 默认设置为隐藏 self.edit.setVisible(False) self.edit.editingFinished.connect(self.__inputComplete) # Note 添加一个新的 layout self.layout = QVBoxLayout(self) # Note 将 edit 添加到 layout 中 self.layout.addWidget(self.edit)def __inputComplete(self): '''函数前添加双下划线让方法作为私有方法，不提供给外部调用''' # Note 设置 edit 不可见 self.edit.setVisible(False) # Note 将 edit 获取到的内容添加到 My_Label 上 self.setText(self.edit.text()) &emsp;&emsp;这样只要在 edit 上输入内容，然后按键盘 enter 键就可以实现隐藏 edit 并且将 edit 的内容添加到 My_Label 上&emsp;&emsp;但是这样无法实现点击任意位置隐藏 edit 的效果。&emsp;&emsp;其实也不全然只能通过按 enter 键才可以隐藏， editingFinished 信号槽和 focus 事件相关，只要 focus 转移也可以实现隐藏。&emsp;&emsp;我们可以将 Maya 中的运行代码做些修改，多添加一些组件进行测试。 &emsp;&emsp;Maya 运行代码 1234567891011121314151617181920212223242526272829# -*- coding:UTF-8 -*-import My_Labelreload(My_Label)from My_Label import My_Labelfrom PySide2.QtCore import *from PySide2.QtWidgets import *from PySide2.QtGui import *# Note 添加窗口组件win = QWidget()win.resize(300,150)# Note 添加布局layout = QVBoxLayout(win)# Note 添加组件my_label = My_Label()my_label.setText("My_Label")label = QLabel()label.setText("QLabel")edit = QLineEdit()# Note 将组件添加到布局当中layout.addWidget(my_label)layout.addWidget(label)layout.addWidget(edit)# Note 显示窗口win.show() &emsp;&emsp;My_Label 代码 123456789101112131415161718192021222324252627282930313233343536# -*- coding:UTF-8 -*-from Qt.QtCore import *from Qt.QtGui import *from Qt.QtWidgets import *class My_Label(QLabel): editable = False def __init__(self): super(My_Label,self).__init__() # Note 设置默认的 Label 名称 self.setText("My_Label") # Note 添加一个 QLineEdit 将其依附到 QLabel 上 self.edit = QLineEdit() # Note 默认设置为隐藏 self.edit.setVisible(False) self.edit.editingFinished.connect(self.__inputComplete) # Note 添加一个新的 layout self.layout = QVBoxLayout(self) # Note 将 edit 添加到 layout 中 self.layout.addWidget(self.edit) def __inputComplete(self): '''函数前添加双下划线让方法作为私有方法，不提供给外部调用''' # Note 设置 edit 不可见 self.edit.setVisible(False) # Note 将 edit 获取到的内容添加到 My_Label 上 self.setText(self.edit.text()) def mouseDoubleClickEvent(self,event): # Note 鼠标左键点击过滤 if event.button() == Qt.MouseButton.LeftButton: # Note 双击触发时候显示 self.edit.setVisible(True) 隐藏 QLineEdit - 方案一 &emsp;&emsp;上面虽然实现了 组件focus跳转的时候 隐藏自身。&emsp;&emsp;却依旧无法实现点击窗口任意位置隐藏 QLineEdit。&emsp;&emsp;我们要实现的是 如果没有点击到组件自身就要隐藏的效果。&emsp;&emsp;如果学习过前端 JS 的事件处理就会知道，通过 document 的点击可以获取到全局的点击，还可以通过 preventPropagation 来阻止冒泡从而实现不点击自身的事件反馈。&emsp;&emsp;然而我并没有在 Qt 中找到简单的实现方法。&emsp;&emsp;因此下面提到的方法会比较复杂，如果看不懂的话可以暂行跳过这个部分。 &emsp;&emsp;我们先来分析要实现点击任意位置需要怎样的条件。&emsp;&emsp;首先我们需要获取一个全局事件的方法，因为组件当中的虚函数只有在组件被触发时才奏效，组件自身无法实现全局响应的。&emsp;&emsp;但是 Qt 的全局事件点击是怎么处理的呢？&emsp;&emsp;一开始我经过了大量的搜索也没有找到 Qt 的全局事件处理的相关方法，因此只能退而求其次，给所有的组件添加一个处理点击的回调函数来实现这个功能。&emsp;&emsp;也就是说 通过一个函数遍历窗口中所有的组件，然后给每个组件的 mousePressEvent 添加点击处理函数，这样就可以实现伪全局的效果。 12345678910111213141516from functools import partialdef __eventHandler(self,widget,event): # widget.mousePressEvent(event) # Note 判断 edit 是否可见 以及 点击区域是否是 edit 当中 if self.edit.isVisible() and widget != self.edit: self.__inputComplete() def setPressEvent(self,win): # Note 判断组件是否有 mousePressEvent 事件 if hasattr(win,"mousePressEvent"): # Note 复写组件的 mousePressEvent 虚函数 win.mousePressEvent = partial(self.__eventHandler,win,win.mousePressEvent) for child in win.children(): # Note 递归执行 self.setPressEvent(child) &emsp;&emsp;由于组件的children是通过嵌套方式存储在各个组件的的 children() 方法当中的，因此不能用简单的 for 循环来实现所有组件的遍历。&emsp;&emsp;这里需要使用递归的方式来实现。 递归-百度百科&emsp;&emsp;递归，就是在运行的过程中调用自己。 -&gt; 我们创建了一个 setPressEvent 方法，不断在children for循环中调用自己，就可以实现遍历一个组件下所有的子组件。 &emsp;&emsp;这里点击函数是通过复写的形式实现的。&emsp;&emsp;国外的大大其实非常不推荐使用这种方式来改写函数的方法，一些代码处理工具没有办法识别这种修改，代码的可读性也会大打折扣。 参考链接&emsp;&emsp;正确的写法应该通过类来继承。&emsp;&emsp;但是这里所有的child都已经实例化了。&emsp;&emsp;再加上并不是所有的组件都有触发点击的信号槽的，而继承QWidget的组件都有 mousePressEvent 虚函数的，因此我只想到了这种不太好的操作。 &emsp;&emsp;在函数内部不好获取当前调用的 __eventHandler 是哪个组件触发的，我们可以将触发的组件作为参数传入到函数中。&emsp;&emsp;复写函数是无法修改传参的，那这种效果要如何实现呢？&emsp;&emsp;我们可以利用python自带的包 from functools import partial patial 来实现，同样在使用信号槽的时候也可以用这种黑科技实现槽函数的传参。 partial内核原理分析 &emsp;&emsp;其实上述方案是有 BUG 的，由于复写函数的原因，如果有多个 My_Label 实例存在的话就会互相覆盖。&emsp;&emsp;我最初想到的方案就是类似于 super 的方法来继承这个方法的调用。&emsp;&emsp;当然因为这里已经实例化当然无法调用 super 方法，因此我想到的是直接 调用在 __eventHandler 第一行加上 widget.mousePressEvent(event)&emsp;&emsp;然而这样执行的话会报错！！！ &emsp;&emsp;原因是 mousePressEvent 已经被复写了，所以在这里直接调用就会陷入递归循环。&emsp;&emsp;所以这里的处理必须是执行被复写之前的函数，因此我想到的方案是通过传参的形式加进来。&emsp;&emsp;下面是完整代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding:UTF-8 -*-from Qt.QtCore import *from Qt.QtGui import *from Qt.QtWidgets import *from functools import partialclass My_Label(QLabel): editable = False def __init__(self): super(My_Label,self).__init__() # Note 设置默认的 Label 名称 self.setText("My_Label") # Note 添加一个 QLineEdit 将其依附到 QLabel 上 self.edit = QLineEdit() # Note 默认设置为隐藏 self.edit.setVisible(False) self.edit.editingFinished.connect(self.__inputComplete) # Note 添加一个新的 layout self.layout = QVBoxLayout(self) # Note 将 edit 添加到 layout 中 self.layout.addWidget(self.edit) def __inputComplete(self): '''函数前添加双下划线让方法作为私有方法，不提供给外部调用''' # Note 设置 edit 不可见 self.edit.setVisible(False) # Note 将 edit 获取到的内容添加到 My_Label 上 self.setText(self.edit.text()) def mouseDoubleClickEvent(self,event): # Note 鼠标左键点击过滤 if event.button() == Qt.MouseButton.LeftButton: # Note 双击触发时候显示 self.edit.setVisible(True) def __eventHandler(self,widget,pressEvent,event): # Note 执行复写之前的函数(实现多重实例化不覆盖)__ pressEvent(event) # Note 判断 edit 是否可见 以及 点击区域是否是 edit 当中 if self.edit.isVisible() and widget != self.edit: self.__inputComplete() def setPressEvent(self,win): # Note 判断组件是否有 mousePressEvent 事件 if hasattr(win,"mousePressEvent"): # Note 复写组件的 mousePressEvent 虚函数 win.mousePressEvent = partial(self.__eventHandler,win,win.mousePressEvent) for child in win.children(): # Note 递归执行 self.setPressEvent(child) &emsp;&emsp;maya 的运行上可以多添加一些 My_Label 来测试多个实例的运行情况。 123456789101112131415161718192021222324252627282930313233# -*- coding:UTF-8 -*-import My_Labelreload(My_Label)from My_Label import My_Labelfrom PySide2.QtCore import *from PySide2.QtWidgets import *from PySide2.QtGui import *# Note 添加窗口组件win = QWidget()win.resize(300,150)# Note 添加布局layout = QVBoxLayout(win)# Note 添加组件my_label = My_Label()my_label2 = My_Label()label = QLabel()label.setText("QLabel")edit = QLineEdit()# Note 将组件添加到布局当中layout.addWidget(my_label)layout.addWidget(edit)layout.addWidget(label)layout.addWidget(my_label2)# Note 显示窗口win.show()my_label.setPressEvent(win)my_label2.setPressEvent(win) &emsp;&emsp;可以看到这个方案初步实现了 Qt Designer 的双击修改，点击任意位置确认修改的效果。&emsp;&emsp;但是使用起来会有很多的限制，是非常不方便的。&emsp;&emsp;setPressEvent(win) 函数必须要添加了所有的组件之后才可以触发，否则递归处理就会缺少了部分组件而导致BUG。&emsp;&emsp;交互以及UI细节上依旧存在差别（在下一个方案中提供解决方案）&emsp;&emsp;另外这里也还没有完成处理判断，一旦调用了 setPressEvent 就无法取消组件的效果。&emsp;&emsp;当然这个无法取消的问题是可以添加额外的判断来修复的。 123456789101112131415def setEditable(self,editable,parent=None): # Note 判断 parent 是否存在 if parent == None: if self.parent() != None: parent = self.parent() else: raise Exception("parent is None") if editable: win = parent.window() # Note 递归设置点击事件 self.__setPressEvent(win) self.editable = True else: self.editable = False &emsp;&emsp;这部分的代码就是我仿造 PyQt 内核的设置函数的编辑方法，可以实现传入布尔参数来开启和禁用事件调用。&emsp;&emsp;也可以通过 QWidget 下的 window 方法来获取最顶层的窗口。&emsp;&emsp;当然执行这个方法的时候，如果组件没有依附到任何窗口上，那么就无法递归，也就无法实现全局点击事件的效果，因此我抛出了错误。 &emsp;&emsp;以上方案是我最初写组件的实现方案。&emsp;&emsp;在写教程的过程中，我觉得这种实现方式非常不优雅，自己很不甘心就这么留着坑不填，于是我重新研究了实现方案。 扩展说明 partial内核原理分析 参考这里 隐藏 QLineEdit - 方案二 &emsp;&emsp;回到最初想要实现的效果，最让我疑惑的是 Qt 内部的全局事件处理。&emsp;&emsp;尽管虚函数是满足相关条件之后才会被触发的，但是根据 Qt 的事件处理机制。&emsp;&emsp;应该有一个专门的地方来处理所有的被调用的事件才对的，于是我以这个为突破口，在网上有查了不少资料。&emsp;&emsp;功夫不负有心人，我还是找到了一些有用的线索。 参考 &emsp;&emsp;参考提问者自己提出的解决方案，可以知道 QApplication 有 notify 方法，这个方法就是一个全局事件处理的相关函数。&emsp;&emsp;于是我尝试继承一个 自己的 QApplication 类来实现效果。 1234567891011121314151617181920212223242526272829303132from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *# from PyQt4.QtCore import *# from PyQt4.QtGui import *class MyApp(QApplication): def notify(self, receiver, event): # Note QEvent.Type.MouseButtonPress 等于数字 2 if event.type() == 2: print (receiver) return super(MyApp, self).notify(receiver, event)if __name__ == "__main__": import sys app = MyApp(sys.argv) win = QWidget() layout = QVBoxLayout(win) label = QLabel() label.setText('test') edit = QLineEdit() combo = QComboBox() layout.addWidget(label) layout.addWidget(combo) layout.addWidget(edit) win.show() app.exec_() &emsp;&emsp;经过测试可以看到 notify 确实是一个全局事件处理器，而且 PyQt4 也可以正确调用（event.type() 需要改为数字进行识别）&emsp;&emsp;然而兴奋瞬间就被冷水当头了，因为 QApplication 只能存在一个。&emsp;&emsp;所以在 Maya 环境下 QApplication 已经是实例了，这也就是为什么 在 Maya 中运行不能声明 QApplication() 参考这里&emsp;&emsp;所以这里也只能采取上面的方法，用覆盖的方法。&emsp;&emsp;但是 QApplication 的实例要怎么获取出来呢？&emsp;&emsp;这个时候真是柳暗花明又一村呀！！ 没想到 QApplication 就有 instance() 方法可以直接获取到当前运行的实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *from functools import partialclass My_Label(QLabel): editable = False def __init__(self): super(My_Label,self).__init__() # Note 添加一个 QLineEdit 将其依附到 QLabel 上 self.edit = QLineEdit() # Note 默认设置为隐藏 self.edit.setVisible(False) # Note 隐藏 lineedit 的边框 self.edit.setFrame(False) self.edit.editingFinished.connect(self.__inputComplete) # Note 设置默认的 Label 名称 self.setText("My_Label") self.edit.setText("My_Label") # Note 添加一个新的 layout self.layout = QVBoxLayout(self) self.layout.setContentsMargins(0,0,0,0) # Note 将 edit 添加到 layout 中 self.layout.addWidget(self.edit) # Note 初始化 Application 的事件 app = QApplication.instance() app.notify = partial(self.__notifyClickEvent,app.notify) def __notifyClickEvent(self, notify, receiver, event): if self.editable: if event.type() == QEvent.Type.MouseButtonPress: if type(receiver) != QWindow: if receiver != self.edit: self.__inputComplete() return notify(receiver, event) def mouseDoubleClickEvent(self,event): # Note 鼠标左键点击过滤 Qt.MouseButton.LeftButton 为 1 | 兼容 PyQt 写法 if event.button() == 1 and self.editable: # Note 双击触发时候显示 self.edit.setVisible(True) # Note 每次显示 label 中的内容 self.edit.setText(self.text()) # Note 选择全部的内容 self.edit.selectAll() # Note 进入 focus 输入状态 self.edit.setFocus() def __inputComplete(self): # Note 设置 edit 不可见 self.edit.setVisible(False) # Note 将 edit 获取到的内容添加到 My_Label 上 self.setText(self.edit.text()) def setEditable(self,editable): self.editable = True if editable else Falseif __name__ == "__main__": import sys app = QApplication(sys.argv) win = QWidget() layout = QVBoxLayout(win) bar = QLabel() bar.setText('test') label = My_Label() label.setEditable(True) edit = QLineEdit() combo = QComboBox() layout.addWidget(bar) layout.addWidget(label) layout.addWidget(combo) layout.addWidget(edit) win.show() app.exec_() &emsp;&emsp;这里改写了双击事件的处理，让双击效果更接近 Qt Designer 的全选选择效果。&emsp;&emsp;取消了 QLineedit 的边框更贴近 Qt Designer 的效果&emsp;&emsp;之前在不拉动窗口双击会看不到 edit 组件，那是因为要放大窗口才可以看到，可以将 layout 的外边框设置为 0 即可。 &emsp;&emsp;在函数实现上，其实上面使用的方法和复写 mousePressEvent 一样的&emsp;&emsp;只是复写了 QApplication 的 notify 方法而已。&emsp;&emsp;由于复写的方法来自于 组件的类方法 ，因此之后也可以利用组件的属性作为判断条件。&emsp;&emsp;这样我们只需要设置 setEditable 函数就可以达到开启和关闭双击效果。 &emsp;&emsp;上述的代码在 PySide2 上可以执行，但是在 PyQt4 下无法实现效果。&emsp;&emsp;原因是 notify 函数并没有像 PySide2 那样调用起来。&emsp;&emsp;更令人沮丧的是 Maya2018 的 PySide2 也无法将 notify 函数顺利跑起来。 扩展说明 如何在 maya 运行 Stackoverflow 里面的 PyQt 代码 参考这里 隐藏 QLineEdit - 方案三 &emsp;&emsp;上面的方案几乎是最完美的解决方案了，然而在临门一脚的时候却失败了。&emsp;&emsp;难道就没有方法实现全局调用了吗？&emsp;&emsp;我又开始在网上寻找答案，最后偶然间在这个Maya官方的技术博客中有了灵感。 &emsp;&emsp;我最初在方案一的阶段的时候，确实有尝试过 installEventFilter 的方法，然而这个方法和 所有的虚函数一样，如果安装在组件上的话，只能对组件进行过滤。&emsp;&emsp;但是通过 方案二 的尝试之后，我猛然发现，如果 installEventFilter 放在 QApplication 上，岂不美哉。 &emsp;&emsp;不过说到底 installEventFilter 要怎么使用呢？&emsp;&emsp;可以参考API文档 installEventFilter eventFilter &emsp;&emsp;installEventFilter 需要传入 QObject 参数，不过这个东西 QWidget 是继承过来的。&emsp;&emsp;因此可以直接将类实例传进去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# -*- coding:UTF-8 -*-from Qt.QtCore import *from Qt.QtGui import *from Qt.QtWidgets import *from functools import partialclass My_Label(QLabel): editable = False def __init__(self): super(My_Label,self).__init__() # Note 添加一个 QLineEdit self.edit = QLineEdit() # Note 默认设置为隐藏 self.edit.setVisible(False) self.edit.editingFinished.connect(self.__inputComplete) self.edit.setStyleSheet("border:None") # Note 添加一个新的 layout 将其依附到 My_Label 上 self.layout = QVBoxLayout(self) self.layout.setContentsMargins(0,0,0,0) # Note 将 edit 添加到 layout 中 self.layout.addWidget(self.edit) # Note 初始化 Application 的事件 app = QApplication.instance() app.installEventFilter(self) def eventFilter(self,receiver,event): # Note QEvent.Type.MouseButtonPress 为 2 if event.type() == 2 and self.editable and self.edit.isVisible(): # Note 过滤接受的组件是否是自己 避免其他组件触发 如 PySide2 QWindow 也会传入进来 if receiver == self: self.__inputComplete() return False def __inputComplete(self): # Note 设置 edit 不可见 self.edit.setVisible(False) # Note 将 edit 获取到的内容添加到 My_Label 上 self.setText(self.edit.text()) def keyPressEvent(self,e): # Note 敲击Esc键触发完成 if e.key() == Qt.Key_Escape: self.__inputComplete() def mouseDoubleClickEvent(self,event): # Note 鼠标左键点击过滤 Qt.MouseButton.LeftButton 为 1 if event.button() == 1 and self.editable: # Note 双击触发时候显示 self.edit.setVisible(True) # Note 每次显示 label 中的内容 self.edit.setText(self.text()) # Note 选择全部的内容 self.edit.selectAll() # Note 进入 focus 输入状态 self.edit.setFocus() def setEditable(self,editable): self.editable = True if editable else False &emsp;&emsp;可以看到这次实现了在maya当中双击修改QLabel的效果，交互感受和 Qt Designer 是一样的。&emsp;&emsp;这里通过 edit 的 keyPressEvent 可以添加 Esc 键触发完成的效果。&emsp;&emsp;另外这里的代码没有使用 setFrame(False) 的方法来取消边框。&emsp;&emsp;而是使用了样式表的 setStyleSheet(&quot;border:None&quot;) 取消边框，可以实现相同的效果。 总结 &emsp;&emsp;这期教程我们介绍了 Qt Designer 的双击效果的实现效果&emsp;&emsp;并且经过了我自己的大量探索，才最终实现了一个全局事件处理的效果。&emsp;&emsp;本期教程前面不算很复杂，后面的全局事件的处理还是有点难度，如果是初学者需要好好消化。&emsp;&emsp;这一次组件封装就实现了 MEL 语言绝对实现不了的效果，终于体现出了 Qt 的强大之处了。&emsp;&emsp;在末尾我也引出了下一期教程要讲的主题 qss 样式。&emsp;&emsp;敬请期待第五期教程吧。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程 扩展说明]]></title>
    <url>%2Fposts%2F2e0af969.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这篇文章针对 Python Qt 开发教程的扩展说明单独开辟的。&emsp;&emsp;因为这里占用的篇幅很多，然而和教程本身并无太大关系，属于对教程一些操作原理的细化说明。&emsp;&emsp;如果是零基础的人，可以在这里了解到更多我对 Python Qt 的一些理解以及我的个人经验。&emsp;&emsp;如果你已经对这些内容有了一定的认识，我觉得放在教程里会很冗余。 Qt.py &emsp;&emsp;正如第一期教程所示，通过 Qt.py 就可以用 Qt5.0 的方式兼容 Qt4.0 即可以以 PySide2 的书写格式兼容 PySide。&emsp;&emsp;那如何使用这个脚本呢？&emsp;&emsp;去到 Qt.py 的 github 网址，下载名为 Qt.py 的文件下来。 &emsp;&emsp;可以将 Qt.py 的文件解压到 我的文档/maya/scripts 目录下&emsp;&emsp;如此一来就可以在 maya 的脚本编辑器直接导入 Qt 123from Qt.QtCore import *from Qt.QtGui import *from Qt.QtWidgets import * &emsp;&emsp;通过这种方法就可以兼容 PySide2 的写法在 Maya2015 中写脚本了。&emsp;&emsp;当然虽然 Qt.py 实现了兼容效果，遗憾的是在脚本编辑器里面就没有了代码提示了。&emsp;&emsp;因此建议在脚本测试完毕之后再将导入的包修改掉。 sys.path &emsp;&emsp;在学习的时候，有些细节总是被我们不经意间忽视了。&emsp;&emsp;我当初学习写插件，用别人做好的插件也从来没有想过这个问题，只是按部就班按照别人写的文档操作，将相关的maya脚本拷贝到 scripts 目录下。&emsp;&emsp;其实为什么将脚本拷贝到 scripts 目录下就可以在 maya 里面直接执行脚本呢？&emsp;&emsp;后面经过我自己的发掘，我才发现，原来这都多亏了 sys 模块的 sys.path&emsp;&emsp;sys.path 是一个数组，你完全可以在 maya 的编辑器里面 打印这个数组出来。 &emsp;&emsp;我们可以将数组排列好，捋一捋里面都有什么 123# -*- coding:UTF-8 -*-import sysprint sys.path &emsp;&emsp;可以看到打印的数组里面是一堆路径，而这些就是 python 的环境变量路径。&emsp;&emsp;每当我们import的时候就会自动从这些路径中寻找相关的包。&emsp;&emsp;我们可以跳出maya来看正常 Python 编译器输出的 sys.path 12345678910111213# -*- coding:UTF-8 -*-import sysprint sys.path# 输出的数组[ 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\python36.zip', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\DLLs', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\lib', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36', 'C:\\Users\\Administrator\\AppData\\Roaming\\Python\\Python36\\site-packages', 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages'] &emsp;&emsp;可以看到相关的 site-packages 都在路径当中，这也就是为什么我们 pip 安装完成之后就可以直接 import 这些包的原因。&emsp;&emsp;如果你将这个这个变量清空的话,那么绝大多数的包都将无法识别。 扩展 sys.path 对比 系统环境变量 参考下面 命令行的使用方法 &emsp;&emsp;这里我们以调用maya的 python 程序 mayapy.exe 进行说明讲解 &emsp;&emsp;我们可以任意目录下 shift + 鼠标右键 ，菜单栏会多出 在此处打开命令窗口 的选项,如果你是 win10 用户 则会是 在此处打开 Powershell 窗口 。&emsp;&emsp;点击选项就会弹出 CMD 或者 Powershell 窗口 并且已经自动定位到当前路径上。 &emsp;&emsp;还可以在文件夹的路径上输入 cmd 打开命令行窗口并且跳转到当前路径。 &emsp;&emsp;当然，更加传统的做法则是按 win + R，调出运行窗口，输入 cmd 打开命令行 &emsp;&emsp;打开命令行窗口之后又要如何使用它呢？ &emsp;&emsp;在默认情况下我们可以输入绝对路径来访问程，比如通过绝对路径访问 python.exe &emsp;&emsp;在输入的过程按 Tab 会搜索路径下的文件自动补全文件名称。 &emsp;&emsp;在 win7 下的命令行是不支持 ctrl+v 粘贴操作，需要鼠标右键选择粘贴。&emsp;&emsp;也可以去到命令行的属性编辑中开启快速编辑功能，这样右键就不是菜单了，选中内容是复制，没有选择是粘贴。 &emsp;&emsp;通过上面的方法访问 mayapy.exe 会报错。 &emsp;&emsp;这是因为这里的路径存在空格，命令行会断开空格，导致识别失败。&emsp;&emsp;这个时候需要用双引号包裹路径才可以使用，也只有这样才可以使用自动补全 &emsp;&emsp;手动输入很麻烦，其实也可以将文件拖拽到命令行工具中，命令行会获取到文件的路径。 &emsp;&emsp;那么除了用绝对路径，还可以通过命令行上的路径直接获取程序，&emsp;&emsp;除了上述自动定位打开命令行的方法之外，也可以手动去定位， 可以用命令行的 cd 命令来跳转到对应的目录。&emsp;&emsp;只要在相应路径下就可以调用程序 &emsp;&emsp;可见使用命令行需要知道程序的路径，就会对程序调用带来极大的不便，那么有没有更方便调用程序的方法呢？&emsp;&emsp;这就需要用到环境变量来方便快捷调用程序了。 环境变量 &emsp;&emsp;Python的环境变量其实和系统的环境变量是一样原理的。&emsp;&emsp;当我们安装了 Python 之后，为什么可以通过命令行进入 python 编译器，也可以在命令行输入 pip 安装相关的包。&emsp;&emsp;其实这是因为安装 Python 的时候自动给你设置了相关路径的环境变量，让你的 cmd 命令行可以找到命令对应的运行程序。&emsp;&emsp;如果你有安装过 java 编译器就会学习到如何设置系统的环境变量。（因为官方提供的安装包没有自动设置的操作(:з」∠)）&emsp;&emsp;我的电脑安装的是 win7 系统，这里以 win7 举例，如果看不懂的话，网上也有大量的文章甚至是视频帮助你。 &emsp;&emsp;在Path属性下可以也可以看到大量的路径，这个地方就是系统的环境变量路径。&emsp;&emsp;通过这里设置的路径，就可以通过cmd命令行调用到相关的命令。 &emsp;&emsp;在没有设置环境变量的情况下，如果不在对应的路径启动程序将会报错。 &emsp;&emsp;下面我们可以将maya的bin路径添加到系统的环境变量中。&emsp;&emsp;这样我们就可以在任意路径上调用 mayapy 了。（环境变量设置完了之后需要重新打开命令行才能生效） &emsp;&emsp;当然环境变量是有优先级的，如果在多个目录下找到相同名称的程序，会优先执行第一个找到的，所以设置路径的时候应该注意。&emsp;&emsp;另外环境变量路径下调用的程序应该以 exe 后缀结尾，调用的时候可以省略 exe 后缀。 如何使用 PySide API 文档 &emsp;&emsp;PySide API 文档&emsp;&emsp;文档的左侧有搜索按钮，搜索 QWidget 会弹出大量 QWidget 相关的API函数，任意点其中一个进入 QWidget 界面。 &emsp;&emsp;在 Virtual functions 下有大量 API 提供的固定用法的函数。&emsp;&emsp;如果网页内容太多，寻找得很累，可以在浏览器上按 ctrl + F 打开搜索。 &emsp;&emsp;如果英文看不懂也不用慌，可以用一些浏览器插件来翻译网页，也可以下载 有道词典 之类的工具来快速翻译。 Python Qt 用搜索引擎解决问题 &emsp;&emsp;当我们遇到问题的时候，特别是诸如使用 API 的问题无从下手的时候，我们要学会自己在网上搜索找到解决方案。&emsp;&emsp;这样做不仅不用麻烦别人，拒绝当伸手党，也可以让自己学到的知识印象更加深刻。&emsp;&emsp;下面我就一如何实现 Python Qt 的 右键菜单 为搜索例子。&emsp;&emsp;要解决问题，我们首先需要选择好的搜索引擎方可事半功倍。&emsp;&emsp;关于代码上的问题，我个人还是比较推荐外网的搜索引擎，毕竟框架是外国人做的，更加容易搜到准确的解决方案。&emsp;&emsp;下面是我推荐的国外的搜索引擎。 Google DuckDuckGo Bing &emsp;&emsp;Google 谷歌 已经无需多言，只是因为众所周知的原因是个404网站。&emsp;&emsp;DuckDuckGo 是一个将用户隐私放到第一位的搜索引擎，在国外的知名度并不比Google差，可惜后来也变成了 404 网站。&emsp;&emsp;Bing 必应 是微软推出的搜索引擎，最让人兴奋的是这个网站居然不是404网站，可以正常访问，有国际版和国内版。&emsp;&emsp;个人强烈推荐使用 必应 ，使用必应的国际版搜索和 谷歌 搜索相差不大，而且可以省去一笔科学上网的费用，岂不美哉。 &emsp;&emsp;至于国内的搜索引擎，其实也不怎么需要我推荐了，大家都知道了。 百度 搜狗 360 &emsp;&emsp;这里必须义正言辞的批评百度，通常最前面的几个搜索都是广告，虽然链接后面有标注，但是看到就觉得烦。&emsp;&emsp;不过由于常年的使用习惯，用起来…我只能表示…真香(:з」∠)&emsp;&emsp;另外需要强调一下 360 和 搜狗都有英文搜索，可以搜索国际内容，不过我自己用不惯，还是推荐必应。（百度没有找到英文搜索） &emsp;&emsp;搜索代码问题时候我一般是直接去 Bing 打英文进行搜索，比如这里我要查 Python Qt 的右键菜单实现。&emsp;&emsp;如果不知道英文怎么拼写可以用翻译软件解决。（CG行业有很多知识是国内搜索不到，要学会善用国外的搜索引擎） &emsp;&emsp;我们可以将关键字用空格隔开输进去, 比如： Python Qt right click menu &emsp;&emsp;通常最上面的网站都是 Stackoverflow 网站，强推这个网站。&emsp;&emsp;这个网站是国外知名的程序员问题社区，基本可以理解为专门给程序员提供的百度知道。&emsp;&emsp;基本上任何编程的问题都有一大批热心的外国人为你解答，很多都是直接奉上代码，美滋滋。 &emsp;&emsp;根据上面的搜索第一条点进去，虽然网站全部是英文的，但是不用慌，看不懂也没关系，直接抄回答上的代码测试即可。 12345678910111213141516171819202122232425262728293031323334import sysfrom PyQt4 import QtGui, QtCoreclass MainForm(QtGui.QMainWindow): def __init__(self, parent=None): super(MainForm, self).__init__(parent) # create button self.button = QtGui.QPushButton("test button", self) self.button.resize(100, 30) # set button context menu policy self.button.setContextMenuPolicy(QtCore.Qt.CustomContextMenu) self.button.customContextMenuRequested.connect(self.on_context_menu) # create context menu self.popMenu = QtGui.QMenu(self) self.popMenu.addAction(QtGui.QAction('test0', self)) self.popMenu.addAction(QtGui.QAction('test1', self)) self.popMenu.addSeparator() self.popMenu.addAction(QtGui.QAction('test2', self)) def on_context_menu(self, point): # show context menu self.popMenu.exec_(self.button.mapToGlobal(point)) def main(): app = QtGui.QApplication(sys.argv) form = MainForm() form.show() app.exec_()if __name__ == '__main__': main() &emsp;&emsp;当然上面代码需要安装 PyQt4 才可以运行的。如果你想要在 maya 里面跑上面的代码可以 参照这里 &emsp;&emsp;而 PyQt4 已经无法通过pip安装了（被淘汰了） &emsp;&emsp;问题真的是接踵而至对吧，这个时候你也可以把搜索引擎用起来。 &emsp;&emsp;还是 Stackoverflow 那个熟悉而亲切的平台。&emsp;&emsp;点开问题看最上面的答案。 &emsp;&emsp;答案会告诉你可以用 wheel 来安装 PyQt4，而具体的地址也提供了。直接去相关网页下载即可。&emsp;&emsp;不知道 wheel 怎么安装，不慌，把搜索引擎用起来。 &emsp;&emsp;这一次我们甚至都不需要打开网页，Bing已经将操作代码贴出来了。 &emsp;&emsp;你可能会觉得，每次都是英文，真的是太难受了。&emsp;&emsp;关于这点也不用担心，一些比较常见基础的问题也完全可以通过度娘解决的，（或者用 Bing 的国内版，比较干净）&emsp;&emsp;而且国内学习 PyQt 做桌面开发的人还是很多的，可以通过百度搜索到很多 博客文章 诸如 CSDN 博客园，里面很多内容以及代码都很有帮助。&emsp;&emsp;只是我个人觉得博客文章的针对性不够强，讲得比较空泛（毕竟是总结性的文章），不如 Stackoverflow 上针对问题解决所提出的短小精悍的代码来得直接。&emsp;&emsp;当然国内的博客总结也很棒，很多时候会有更多预料之外的收获。 &emsp;&emsp;另外搜索的时候多用 PyQt ，PySide的虽然开源，但是使用上更多的是 PyQt ，反正框架基本共通的，搜索 PyQt 能更快找到你想要的答案。 &emsp;&emsp;以上就是我学习 Python Qt 框架时候解决问题的方法，Stackoverflow 真的是一个非常好的平台，我有很多不懂的代码问题都是在上面解决的。&emsp;&emsp;学会使用搜索引擎，从此不求人！ 扩展 如何在 maya 运行 Stackoverflow 里面的 PyQt 代码 参考下面 在 Maya 中运行 PyQt 中的桌面开发代码 &emsp;&emsp;承接上面搜索引擎上搜索到的代码，上面为了将代码跑起来，需要安装 PyQt 相关的库，这过程的周折不然而喻。&emsp;&emsp;maya 本身就搭建好了 PySide 的运行环境，能否直接运行上面代码呢？ &emsp;&emsp;直接硬上肯定是不行的，而且 PyQt4 是 Qt4.0 的风格 并不符合 PySide2 的 Qt5.0 风格。&emsp;&emsp;使用 Qt.py 也需要将代码转换为 Qt5.0 的风格才行。&emsp;&emsp;因此为了避免麻烦，最快速的方法就是去掉代码中 QtCore. 和 QtGui. 的关键字，然后将导入修改为 * 导入 &emsp;&emsp;然而上述的代码在 maya 中执行依然会报错。 &emsp;&emsp;报错的问题也很显然了，因为 maya 本身就已经运行了 QApplication，因此可以将 QApplication 相关的代码删除。&emsp;&emsp;另外 if __name__ == &#39;__main__&#39;: 这个语句可以删除，脚本编辑器中可以没有这个语句。 1234567891011121314151617181920212223242526272829303132# -*- coding:UTF-8 -*-import sysfrom PySide2.QtCore import *from PySide2.QtWidgets import *from PySide2.QtGui import *class MainForm(QMainWindow): def __init__(self, parent=None): super(MainForm, self).__init__(parent) # create button self.button = QPushButton("test button", self) self.button.resize(100, 30) # set button context menu policy self.button.setContextMenuPolicy(Qt.CustomContextMenu) self.button.customContextMenuRequested.connect(self.on_context_menu) # create context menu self.popMenu = QMenu(self) self.popMenu.addAction(QAction('test0', self)) self.popMenu.addAction(QAction('test1', self)) self.popMenu.addSeparator() self.popMenu.addAction(QAction('test2', self)) def on_context_menu(self, point): # show context menu self.popMenu.exec_(self.button.mapToGlobal(point)) form = MainForm()form.show() partial 方法分析 &emsp;&emsp;我们在使用 槽函数 以及 函数复写的时候都可以通过 funtools库 的 partial 偏函数 来实现函数的额外传参。&emsp;&emsp;而且partial最大的好处在于它可以额外添加参数但是不会影响到原函数的传参。&emsp;&emsp;但是偏函数是如何实现的呢？ 链接&emsp;&emsp;stackoverflow 的高分答案已经解析的很清楚，官方也有提供相关的例子。 1234567def partial(func, *part_args): def wrapper(*extra_args): args = list(part_args) args.extend(extra_args) return func(*args) return wrapper &emsp;&emsp;partial 偏函数类似于装饰器，将函数的执行封装到 wrapper 函数当中。&emsp;&emsp;因此使用了偏函数之后，偏函数实际上是返回了 wrapper 函数。 123456789101112131415161718192021222324# Note 例如这里使用了 偏函数 复写 PyQt 的虚函数child.mousePressEvent = partial(self.__eventHandler,child.mousePressEvent)# ! 以下为伪代码，不可执行# ! 以下为伪代码，不可执行# ! 以下为伪代码，不可执行# Note partial 返回的 child.mousePressEvent 等价以下的函数def wrapper(*extra_args): args = list(part_args) args.extend(extra_args) return func(*args)# Note 虚函数会被内部调用，传入 QMouseEventchild.mousePressEvent(event)# Note 调用时上面的代码 等价于wrapper(event)# Note wrapper 执行之后又等价于def wrapper(event): args = list(child.mousePressEvent) args.extend(event) return self.__eventHandler(*args)# Note 等价于self.__eventHandler(child.mousePressEvent,event) &emsp;&emsp;形如上面的代码，执行的时候是 先将child.mousePressEvent加入到函数的参数列表当中，然后再去将参数列表传入到函数中实现偏函数。 CSS|QSS 颜色码 &emsp;&emsp;参照颜色码相关的百度百科 &emsp;&emsp;也可以参照我以前翻译的视频 HSL|HSV rgb &emsp;&emsp;我们可以看到计算机软件表现颜色有几种方案。 颜色名称 - (red,green) rbg - (rgb(0,123,255),rgb(123,0,0)) HEX 16进制 - (#123123,#233233) HSL|HSV -(hsl(187, 100%, 100%)，hsl(4, 40%, 50%)) &emsp;&emsp;颜色名称是顾名思义的表达方式 &emsp;&emsp;rbg - 分别对应 red(红色) green(绿色) blue(蓝色)&emsp;&emsp;在计算机种使用2进制，这里认为规定 三种颜色的范围为 2的六次方 即 256份&emsp;&emsp;当我们把零也算上之后就会得到 0 - 255 的颜色范围。 &emsp;&emsp;HEX 16进制其实本质上和 rgb 表达式方式是一样的&emsp;&emsp;#FF22AA 有6个数位，每个数位可以填写 0-9 和 A-F 共计 16 个字符。&emsp;&emsp;我们可以将每个两个数位进行拆分，就可以得到 FF 22 AA&emsp;&emsp;刚好 16 * 16 是 256 ，也就是说 每两个数位之间的组合有 256 种匹配方式。&emsp;&emsp;因此这和 rgb 的表达式方式是一样的，只不过rgb是10进制的表达而Hex是16进制表达。 &emsp;&emsp;HSL或者HSV 是指 Hue(色调) Saturation(饱和度) Luminance或Value(亮度)&emsp;&emsp;这是有别于 RGB 的颜色表达方法，不过其实两者也有共同之处。 PySide 创建类似 MEL|cmds 的窗口 &emsp;&emsp;相信在学习Maya生成窗口的过程中，通过 show() 方法显示的窗口是独立的，会被Maya主窗口所遮挡，交互体验非常糟糕。 &emsp;&emsp;那有没有办法创建出类似于 MEL或者cmds 命令生成的窗口呢？ &emsp;&emsp;其实方案有很多，下面介绍我知道的三种方案。 方案一:窗口置顶 &emsp;&emsp;Qt支持给窗口设置一个状态，让其永远独立于 Maya 窗口的显示。&emsp;&emsp;QWidget下都有 setWindowFlags 方法，通过设置 setWindowFlags(Qt.WindowStaysOnTopHint) 可以实现置顶。 123456789101112131415from PySide2.QtGui import *from PySide2.QtWidgets import *from PySide2.QtCore import * win = QWidget()win.setWindowFlags(Qt.WindowStaysOnTopHint)win.setWindowTitle(u"使用 PySide2 实现的窗口")layout = QVBoxLayout()win.setLayout(layout)button = QPushButton("hello,world")layout.addWidget(button)win.show() &emsp;&emsp;当然这个方案也显然是治标不治本的，这个窗口依然是独立于Maya主窗口，最小化Maya也不会影响到这个窗口。&emsp;&emsp;因此这个方案虽然简单粗暴，同样也有缺陷。 方案二:结合 OpenMaya 将 Maya 的组件转成 Qt 组件进行操作 &emsp;&emsp;OpenMaya 是更为底层的 Maya API，有 2.0 和 1.0 之分。 OpenMaya分析&emsp;&emsp;OpenMaya1.0是将 Maya 的 C++ API 用转换工具，生成的，使用上保留了很多 C++ 的代码风格，用起来很诡异。&emsp;&emsp;OpenMaya2.0是用 python 底层重写的，因此更加 pythonic ,调用起来更加友好。&emsp;&emsp;这里将演示如何通过 OpenMaya1.0 来获取 Qt 组件 123456789101112131415161718192021222324252627282930from Qt.QtGui import *from Qt.QtWidgets import *from Qt.QtCore import *from Qt.QtCompat import wrapInstancefrom maya import cmdsfrom maya import OpenMayaUI as omui# Note 这个函数可以实现将 Maya 的 UI 转换为 Qt 的 QWidget 组件# Note 这个写法是在 Stackoverflow 上找到的def mayaToQT( name ): # Maya -&gt; QWidget ptr = omui.MQtUtil.findControl( name ) if ptr is None: ptr = omui.MQtUtil.findLayout( name ) if ptr is None: ptr = omui.MQtUtil.findMenuItem( name ) if ptr is not None: return wrapInstance( long( ptr ), QWidget )# Note 检查窗口多开if cmds.window('publish_win',query=True,exists=True): cmds.deleteUI('publish_win')# Note 创建 Maya 窗口publish_win = cmds.window('publish_win',title="使用 cmds 实现的窗口")# Note 显示 Maya 窗口cmds.showWindow(publish_win)# Note Maya 窗口 转换为 Qt 对象ptr = mayaToQT(publish_win)# Note Maya 窗口 添加 Qt 布局ptr.setLayout(QVBoxLayout())button = QPushButton(u"Qt 实现的按钮")# Note 将按钮添加到 Maya 窗口的布局中ptr.layout().addWidget(button) &emsp;&emsp;这个方案是教程提供的，详细的使用方法可以参照 教程 &emsp;&emsp;omui.MQtUtil 可以获取 UI 相关的 C++ 指针。&emsp;&emsp;获取到的指针需要通过 wrapInstance 函数转换为 Python 可以调用的对象。&emsp;&emsp;这里我们使用 Qt.py 获取转换 wrapInstance&emsp;&emsp;在 PySide2 中可以通过 shiboken2 获取到 wrapInstance&emsp;&emsp;在 PyQt 的写法不一样 from sip import wrapinstance as wrapInstance ，导入的模块也有大小写区别。 &emsp;&emsp;上面的 mayaToQT 可以将任意的maya UI 转换成 Qt 对象来调用&emsp;&emsp;wrapInstance 可以将长整型的指针 转换为后面参数的 Qt 类型。&emsp;&emsp;这样我们就可以将 Maya 的窗口当成 Qt 的实例来使用，非常方便。 &emsp;&emsp;由于 Maya 的窗口就是我们想要的效果，因此这里是用 cmds 生成窗口，然后将 Qt 的组件添加到这个窗口上。 &emsp;&emsp;这里我还额外添加了窗口多开的检测，确保插件的窗口是唯一的。 方案三:利用 QApplication 用纯 PySide 的方法实现 &emsp;&emsp;方案二虽然已经完美实现了我们想要的效果，但是不免得有些繁琐。&emsp;&emsp;不仅要 OpenMaya 转Maya的UI，还需要用 wrapInstance 转换 C++ 指针。&emsp;&emsp;在第四期实战的时候，我们介绍了 QApplication ，其实这是个好东西。&emsp;&emsp;通过 QApplication.activeWindow() 可以直接获取到 Maya 的主窗口。&emsp;&emsp;上面的函数就相当于 OpenMayaUI.MQtUtil_mainWindow() 获取到的 C++ 指针再转 QMainWindow 了。&emsp;&emsp;因此我自己研究了一下，觉得这个方案更加简单，更为简洁。 12345678910111213141516171819202122232425# -*- coding:UTF-8 -*-from Qt.QtGui import *from Qt.QtWidgets import *from Qt.QtCore import *# Note 检查窗口多开for child in QApplication.activeWindow().children(): if child.objectName() == "MyDialog": child.deleteLater()# Note 获取当前的主窗口main_window = QApplication.activeWindow()# Note 设置QDialog依附到主窗口上 (不可使用 QWidget)window = QDialog(parent=main_window)window.setObjectName("MyDialog")# Note 将 QDialog 设置为带有最大最小化按钮的窗口window.setWindowFlags(window.windowFlags()|Qt.WindowMinMaxButtonsHint)# Note 设置 QDialog 的标题window.setWindowTitle(u"使用 Qt 实现的窗口")window.setLayout(QVBoxLayout())button = QPushButton(u"Qt 实现的按钮")window.layout().addWidget(button)window.show() &emsp;&emsp;需要注意，这里必须使用 QDialog 作为窗口的形式依附，如果是 QWidget 就会没有窗口，而是将整个组件放到了Maya主窗口上，效果是耸人听闻的。 &emsp;&emsp;由于使用了 QDialog ，因此需要设置一下才能让最大化最小化显示出来，从而达成原生 MEL 窗口的效果。&emsp;&emsp;后面的用法都是 Qt 的用法，比较好理解了。 扩展 OpenMaya 分析 参考下面 OpenMaya 分析什么是 OpenMaya &emsp;&emsp;OpenMaya是 Maya C++ API 用 Python 做了链接绑定的产物。&emsp;&emsp;换句话说就是借助 Python 来调用 C++ 的命令。&emsp;&emsp;最初诞生的 API 是 OpenMaya 1.0 ，后面又诞生了 OpenMaya 2.0 OpenMaya 1.0 || OpenMaya 2.0 区别和选择 &emsp;&emsp;OpenMaya 1.0 是纯粹的 C++ 转换而来。&emsp;&emsp;因此在使用上保留了大量的 C++ 风格，最典型的就是指针传参。&emsp;&emsp;而且很多数据无法直接 print 出来，需要查找文档用相关的方法获取。&emsp;&emsp;因为以上这些问题，OpenMaya 1.0 在 Python 的使用上非常奇葩。&emsp;&emsp;于是后面 OpenMaya 2.0 呼应群众的呼声出来了。 &emsp;&emsp;两者的关系如同 cmds 和 pymel。&emsp;&emsp;maya 的 cmds 库也是因为调用起来各种奇葩，因此才有 pymel 来救场。&emsp;&emsp;OpenMaya 2.0 出现的原因也是类似的。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(3)]]></title>
    <url>%2Fposts%2F1547a34f.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上期教程我们介绍了 Qt Designer 开发的便利之处。&emsp;&emsp;利用 Qt Designer 可以快速开发出跨平台的界面，不仅仅适用于maya，也同样适用于适用 Qt 平台的各个软件。&emsp;&emsp;这期教程我们来聊聊 Qt 组件封装，实现自己个性化的组件。 什么是组件 &emsp;&emsp;组件又叫 控件 ， 英文名为 Component。&emsp;&emsp;我们可以将 组件 理解为各个零件，通过将组件组装到一起，就可以做出一个统一的 UI 界面。&emsp;&emsp;当然 Qt 提供给你的默认零件可能有些功能不足，那么你可以将多个零件组装在一起，形成一个新的零件，下次开发的时候就可以用新的零件来快速组装 UI 界面了。&emsp;&emsp;组件封装就是用现有的组件组合出我们想要的组件效果。&emsp;&emsp;&emsp;&emsp;组件式开发可以参考 前端 React 框架。&emsp;&emsp;模块化的思想对于后期的代码维护非常方便，出问题也可以快速锁定到出问题的组件进行Debug QLabel 组件封装 &emsp;&emsp;在 Qt 当中，要实现组件分装必须使用类来实现。&emsp;&emsp;这就是为什么第一期教程推荐使用类来实现效果的原因，用类继承Qt的组件进行扩展就是组件封装。&emsp;&emsp;下面我们来实现一个比第一期教程还要简单的类封装。&emsp;&emsp;另外再补上第一期教程关于 Qt.py 兼容的问题 1234567891011121314151617# -*- coding:UTF-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *class HelloWorldLabel(QLabel): def __init__(self): super(HelloWorldLabel,self).__init__() self.setText("hello,world") win = QWidget()layout = QVBoxLayout(win)label = HelloWorldLabel()layout.addWidget(label)win.show() &emsp;&emsp;上面代码就实现了最为简单的封装效果，我们可以创建出一个名为 hello,world 的内容标题&emsp;&emsp;self.setText 函数来自 QLabel.setText 可以在 API文档 查到&emsp;&emsp;QLabel.setText 可以修改 QLabel 显示的内容。 &emsp;&emsp;不过上述的代码只能在 Maya 2016 及以上的版本才能执行，如果用 Maya2015 及更旧的版本会出错。&emsp;&emsp;报错提示是找不到 PySide2 的包&emsp;&emsp;这是因为 Maya2015 的时候还没有升级 PySide 包，因此要在老版本上使用 PySide 库需要将导入的代码修改为如下面所示from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import * 12from PySide.QtCore import *from PySide.QtGui import * &emsp;&emsp;当然每一次写代码都需要注意maya的版本号是很繁琐的，而且对于那些以前写的代码，维护起来就更加麻烦。&emsp;&emsp;于是 Qt.py 就针对这种问题而诞生了。&emsp;&emsp;可以将 Qt.py 放到 我的文档/maya/scripts 目录下，就可以直接导入 Qt 了。 扩展说明 想要了解更多 Qt.py 的说明 参考这里 为什么代码放到 我的文档/maya/scripts 文件夹下可以被 maya 调用 参考这里 给 QLabel 组件添加右键菜单 &emsp;&emsp;完成了最简单的 hello,world 封装之后，我们可以实现稍微复杂一点的效果了。&emsp;&emsp;下面我们来给 Label 添加右键菜单来清空 Label 当中的内容。&emsp;&emsp;另外这个功能也是完全可以用 MEL 来实现的。 &emsp;&emsp;利用 MEL 实现右键菜单删除文字功能。 1234567//MEL text 添加右键菜单window -t "利用 MEL 实现右键菜单删除文字功能";columnLayout;string $label = `text -l "hello,world"`;popupMenu;menuItem -l "清空内容" -c ("text -e -l \"\" " + $label);showWindow; &emsp;&emsp;利用 python cmds 实现右键菜单删除文字功能。 12345678import maya.cmds as cmdscmds.window(t="利用 python cmds 实现右键菜单删除文字功能")cmds.columnLayout()label = cmds.text(l='hello,world')cmds.popupMenu()cmds.menuItem(l=u"清空内容",c="cmds.text('%s',e=1,l='')"%label)cmds.showWindow() &emsp;&emsp;利用 PySide2 实现右键菜单删除文字功能。 123456789101112131415161718192021222324252627282930313233343536# -*- coding:UTF-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *class HelloWorldLabel(QLabel): def __init__(self): super(HelloWorldLabel,self).__init__() self.setText("hello,world") # 生成 Menu 菜单 self.menu = QMenu(self) # 给菜单添加一个 QAction action = QAction(self) # QAction 的内容 action.setText(u"清空内容") # 直接触发 QLabel 的清空函数 达到清空文字的目的 # triggered 为 QAction 的信号槽，点击触发 connect 中的函数 action.triggered.connect(self.clear) # QAction使用 triggered 信号触发，和按钮触发的 clicked 不同 self.menu.addAction(action) def contextMenuEvent(self, event): ''' 按右键触发函数 函数名为QT的固定调用名称 - 可以在QWidget的API下找到该虚函数说明 event 为函数的固定传入参数 类型为 QContextMenuEvent ''' # 在鼠标光标位置触发 右键菜单 self.menu.exec_(event.globalPos())win = QWidget()win.setWindowTitle(u"利用 PySide2 实现右键菜单删除文字功能")layout = QVBoxLayout(win)label = HelloWorldLabel()layout.addWidget(label)win.show() &emsp;&emsp;下面的讲解会大量引用PySide文档。如果不懂得如何使用可以参照下面的扩展说明 信号槽 &emsp;&emsp;信号槽是 Qt 框架的一大创举，网上也有很多剖析它的文章，都写得很详细。&emsp;&emsp;这里我说说我自己目前的理解: action.triggered.connect(self.clear)&emsp;&emsp;triggered是信号槽的触发条件，API文档中还提供了其他的信号槽作为触发条件。&emsp;&emsp;triggered的触发条件是点击，connect后面接的是触发的函数。&emsp;&emsp;也就是说当 triggered 信号槽被触发就会执行 connect 之后的函数。&emsp;&emsp;同一个信号槽也可以接多个 connect 函数，函数会被逐一执行。&emsp;&emsp;同样信号槽也有 disconnect 函数可以注销无用的函数触发。 虚函数 &emsp;&emsp;在 Qt 中右键触发已经在 QWidget 中提供了相关的入口虚函数&emsp;&emsp;这些虚函数继承于 QWidget ，满足特定条件就会传入相关事件参数触发函数。&emsp;&emsp;如上面代码所示 contextMenuEvent 事件在点击右键的时候就会触发，通过传入的 event 可以获取到触发的世界坐标。&emsp;&emsp;从而实现将菜单生成到鼠标的位置上。 小结 &emsp;&emsp;看到这里，似乎又会发现， Qt 框架又是写了一大堆的代码，然而才实现了 MEL 或者 cmds 简单几行 代码就可以实现的效果。&emsp;&emsp;而且 PySide 文档还如此复杂，没有人说明根本就不知道从何查起。&emsp;&emsp;这种情况就要学会使用搜索引擎来解决问题。 扩展说明 如何使用 PySide API 文档 参考这里 如何通过搜索解决不懂的问题 参考这里 给 QLabel 组件添加单击事件 &emsp;&emsp;下面就开始来实现一些 MEL 做不到的功能了。&emsp;&emsp;在MEL的 text API文档中并没有点击事件的触发函数，因此要实现这种效果只能通过 Qt 来实现。&emsp;&emsp;在类中要实现点击事件有两种方法： 使用 Virtual functions 虚函数 使用 Signal Slot 信号槽 &emsp;&emsp;虚函数只可以在类中使用，而信号槽实例化后也可以使用。&emsp;&emsp;其实上面的右键触发菜单和 QAction 点击就刚好刚好用到了这两种不同的方法。&emsp;&emsp;下面我们来实现点击 QLabel 弹出输入框来修改内容。 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding:UTF-8 -*-from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *class HelloWorldLabel(QLabel): def __init__(self): super(HelloWorldLabel,self).__init__() self.setText("hello,world") # 生成 Menu 菜单 self.menu = QMenu(self) # 给菜单添加一个 QAction action = QAction(self) # QAction 的内容 action.setText(u"清空内容") # 直接触发 QLabel 的清空函数 达到清空文字的目的 # triggered 为 QAction 的信号槽，点击触发 connect 中的函数 action.triggered.connect(self.clear) # QAction使用 triggered 信号触发，和按钮触发的 clicked 不同 self.menu.addAction(action) def contextMenuEvent(self, event): ''' 按右键触发函数 函数名为QT的固定调用名称 - 可以在QWidget的API下找到该虚函数说明 event 为函数的固定传入参数 类型为 QContextMenuEvent ''' # 在鼠标光标位置触发 右键菜单 self.menu.exec_(event.globalPos()) def mousePressEvent(self,event): # 输入 Dialog text, ok = QInputDialog.getText(self, u'修改', u'输入内容') if ok: self.setText(text)win = QWidget()win.setWindowTitle(u"利用 PySide2 实现点击弹出输入弹窗修改组件内容")layout = QVBoxLayout(win)label = HelloWorldLabel()layout.addWidget(label)win.show() &emsp;&emsp;由于 QLabel 并没有 clicked 相关的触发信号，因此只能使用虚函数来实现点击效果。&emsp;&emsp;这里使用了Qt封装好的 QInputDialog ，可以实现弹窗输入的效果。（MEL中也有 promptDialog 函数） 总结 &emsp;&emsp;这期教程我们介绍了 Qt 封装组件的过程，其实并没有那么神秘。&emsp;&emsp;代码封装的本质就是用面向对象的方法将代码合成到一起，下一次调用就可以初始化很多已经写好的东西，不需要再次书写了。&emsp;&emsp;本期内容不算很多，不过扩展的内容量很大，尽量做到让所有的新手都能够看得懂的程度。&emsp;&emsp;另外本期教程虽然实现了点击效果，但是实现的效果感觉很一般，Qt难道就没有更牛逼的用法吗？&emsp;&emsp;那么敬请期待第四期教程吧。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(2)]]></title>
    <url>%2Fposts%2Fc5c920e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;上期视频我们介绍了 Qt 开发，并且简单对比了原生开发和Qt开发的不同之处。&emsp;&emsp;Qt开发似乎需要写更多的代码，需要更复杂的操作。&emsp;&emsp;其实不慌，当你学习了 QtDesigner 之后，你就会开始觉得原生开发是多么地不人性化了:-) 什么是 QtDesigner &emsp;&emsp;QtDesigner是由官方推出并维护的，图形化界面制作窗口的工具。&emsp;&emsp;如果你接触过 Android 开发 以及 Web前端的 Bootstrap 可视化，都可以感受到这种拖拽开发的快速之处。&emsp;&emsp;当然目前我觉得图形化拖拽做得最好的还是QtDsigner。 安装Qt Designer &emsp;&emsp;安装Qt Designer 的方法有很多 安装官方提供的 Qt Creator 开发软件 安装任意 Qt Python包 安装Maya自带Qt Designer Qt Creator &emsp;&emsp;Qt Creator是一个IDE，是针对Qt优化的 C++ 开发平台，里面内置了许多Qt开发相关的工具，Qt Designer 就在其中。&emsp;&emsp;具体安装流程参考网上的文章 Qt Python 包 &emsp;&emsp;安装任意Qt Python 包&emsp;&emsp;只要安装好 Python 环境，可以打开cmd控制台，通过 pip 安装相关的 Python 包&emsp;&emsp;另外需要注意的是，如果安装旧版本的 PyQt4 ，已经无法直接通过 pip install 安装，需要手动到对应的网站下载 wheel 进行安装。参考&emsp;&emsp;当你安装好之后，你可以在 Python 的 site-packages 目录下找到 PyQt4 文件夹&emsp;&emsp;打开目录可以找到 designer.exe 程序 Maya 自带 Qt Designer &emsp;&emsp;打开 maya 的安装路径&emsp;&emsp;可以在 bin 目录下找到 designer.exe 程序&emsp;&emsp;maya中的 designer.exe 程序打开可能会报错&emsp;&emsp;网上可以找到解决方案 参考 &emsp;&emsp;还有一个方法就是将maya安装目录下的 qt-plugins 中的 platforms 拷贝到 bin 目录下 初始 Qt Designer &emsp;&emsp;启动 Qt Designer 之后可以看到如下画面&emsp;&emsp;我们可以选择 widget 创建出窗口&emsp;&emsp;下面就可以拖拽左侧的组件到窗口上&emsp;&emsp;注：按住 ctrl 拖拽可以快速复制组件&emsp;&emsp;窗口上方的这些按钮可以改变窗口的布局，也可以从左侧拖拽相关的布局到窗口上。&emsp;&emsp;Qt 自带的布局我上期教程也有提及过，最常用的有 QHBoxLayout - 横向布局 QVBoxLayout - 竖向布局 QGridLayout - 网格布局 &emsp;&emsp;通过这些布局就可以让组件等分排布，从而减少UI的凌乱感&emsp;&emsp;横向布局 就是将布局内部的组件 横向等分排列&emsp;&emsp;竖向布局 也顾名思义&emsp;&emsp;&emsp;&emsp;网格布局 则需要给定网格的位置对网格进行等分，也可以让组件占用多个网格，或者空出多余的网格。&emsp;&emsp;通过网格布局可以排列出下面这种形态组件状态。 &emsp;&emsp;在 Qt Designer 的右侧有属性编辑器以及对象查看器的大纲视图&emsp;&emsp;属性编辑器可以编辑UI的属性，不过很多时候，是用代码来动态修改这些属性。&emsp;&emsp;通常情况下，objectName比较重要，因为后面代码调用的时候会通过 objectName 的属性来调用。&emsp;&emsp;当你创建完成 UI 之后，就可以 ctrl+s 保存当前编辑的文件&emsp;&emsp;Qt Designer 会输出一个后缀为 ui 的文件&emsp;&emsp;如果你用文本编辑器打开 ui 文件，你会发现其实它是个XML文件&emsp;&emsp;因此当你熟悉了它XML输出的格式也可以通过魔改XML里面的内容来生成出特殊的组件文件。 在 maya 中调用 ui 文件 &emsp;&emsp;默认情况下 ui 文件只是 XML 配置而已，是无法直接使用的。&emsp;&emsp;不过也有多种情况让ui文件运行起来 通过 python Qt 框架下的 pyuic5 或者 pyside2-uic 将 ui 文件编译为 python 文件 导入uic相关的python模块，通过读取 ui 文件的内容动态编译python代码 直接用 maya 内置的命令编译 ui 文件 编译 ui 文件 &emsp;&emsp;在maya安装目录的bin目录下有 pyside2-uic 程序 - 命令行的使用方法 &emsp;&emsp;这个程序要运行起来需要添加 .exe 后缀，而且在我的电脑上运行会出现报错。&emsp;&emsp;注: bin 目录下还有 uic.exe 程序是可用的，只不过编译出来的文件是 C++ 代码 (:з」∠) &emsp;&emsp;后来我发现这个程序之所以不可用，是因为它压根就不是 exe 程序。&emsp;&emsp;将程序放到编辑器中可以看到它是一个 python 脚本来的 (:з」∠) &emsp;&emsp;因此我们不需要对文件加 exe 后缀，而是要通过 python 来调用这个脚本。&emsp;&emsp;不过外部的python可能会因为 PySide 的相关依赖而报错，因此最为稳妥的方式是使用 mayapy.exe 来调用这个脚本 &emsp;&emsp;因此如果maya内置uic编译器不可用的话，可以通过安装相关的 Python Qt 库，可以在相关路径下找到编译程序&emsp;&emsp;通过命令行调用这个程序后面加上 -h 可以显示出使用方法 1pyside2-uic C:\Users\Administrator\Desktop\img\test.ui -o C:\Users\Administrator\Desktop\img\test_ui.py &emsp;&emsp;基本写法就是： 程序名 ui文件 -o 输出的python文件&emsp;&emsp;这样就可以将 ui 文件 编译为 python 文件，不过需要注意的是 PyQt的编译 maya 需要 改为 PySide 的库进行导入&emsp;&emsp;编译好的文件可以通过继承的方法来调用。 12345678910111213141516# 编译好的 ui 文件 导入其中的类(类名和UI文件当中的最外层的组件的objectName一致)from test_ui import Ui_Formfrom PySide2.QtGui import *from PySide2.QtWidgets import *from PySide2.QtCore import *class window(Ui_Form,QWidget): def __init__(self): # 执行 QWidget 的 __init__ super(window,self).__init__() # 从 Ui_Form 继承的方法，可以直接将ui生成出来 self.setupUi(self) self.setWindowTitle(u"用 pyside2-uic 程序编译python 继承出来的窗口") self.show() win = window() 直接用代码编译 &emsp;&emsp;此处可以参考我以前看教程写的文章 1234567891011121314151617181920212223242526272829303132333435363738394041from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *import sysimport pyside2uicimport xml.etree.ElementTree as xmlfrom cStringIO import StringIOdef loadUiType(uiFile): # 通过XML模块读取ui文件 parsed = xml.parse(uiFile) # 获取Qt相关的组件名 widget_class = parsed.find('widget').get('class') # 获取类名 form_class = parsed.find('class').text with open(uiFile, 'r') as f: o = StringIO() frame = &#123;&#125; # 通过 pyside2uic 编译 ui 文件 pyside2uic.compileUi(f, o, indent=0) # o.getvalue() 这里的数据就是 UI 文件编译成python的代码，通过 exec 执行字符串实现动态执行 python 代码 pyc = compile(o.getvalue(), '&lt;string&gt;', 'exec') exec pyc in frame # form_class 就是ui文件编译出来的类名 form_class = frame['Ui_%s'%form_class] # base_class 就是Qt的窗口组件 eval 获取出 变量 base_class = eval('%s'%widget_class) return form_class, base_classUI_PATH = r"C:\Users\Administrator\Desktop\test.ui"form_class , base_class = loadUiType(UI_PATH)# 这里的继承其实和上面编译好的 ui 文件的代码是一样的class Interface(base_class,form_class): def __init__(self): super(Interface,self).__init__() self.setupUi(self) self.setWindowTitle(u"用 pyside2uic 编译出来的窗口") self.show()ui = Interface() &emsp;&emsp;通过这个函数可以直接将ui文件在编译到内存当中，这样每次修改ui文件就不需要再额外用 exe 工具进行编译了&emsp;&emsp;当然缺点就是没有了ui编译好的python文件，组件的自动代码提示也就没有了，所以开发的时候还需要对着 Qt Designer 的名字，有点麻烦。 &emsp;&emsp;额外补充一下，上述的方案只适用于 PySide ，如果使用PyQt实现的话，代码会简略很多。 12345from PyQt4 import uicUI_PATH = r"C:\Users\Administrator\Desktop\test.ui"# 读取 UI 文件的窗口类型和窗口名form_class , base_class = uic.loadUiType(UI_PATH) &emsp;&emsp;其实后来我才我发现 PySide 也有快速加载 ui 文件的方法 1234from PySide2.QtUiTools import QUiLoaderUI_PATH = r"C:\Users\Administrator\Desktop\test.ui"# 直接返回组件实例widget = QUiLoader(UI_PATH) maya 内置命令编译UI文件 &emsp;&emsp;maya的 mel 有 loadUi 命令，可以直接将ui文件路径读取 生成出 maya 的窗口 123string $dialog1 = `loadUI -f "C:\\Users\\Administrator\\Desktop\\test.ui"`;window -e -title "通过 mel 编译的 ui 文件" $dialog1;showWindow $dialog1; 总结 &emsp;&emsp;Qt designer 的使用并不复杂，虽然Qt Designer 支持信号槽等比较高级的开发内容，但是由于很难通过 XML 来实现所需要的触发效果，因此难当大任。&emsp;&emsp;我目前使用 Qt designer 也是为了快速创建出UI界面，毕竟手打界面的效率还是比较低的，特别是还要考虑各种固定组件的布局位置。&emsp;&emsp;后续的组件触发大都是放在 python 代码当中完成。&emsp;&emsp;如果想要更进一步了解 Qt Designer 的开发，可以参考B站上的教程 Python桌面系统开发 PYQT5全套教程 Python桌面应用开发教程 Pluralsight - Python Desktop Application Development Python桌面应用开发教程第二部 Pluralsight - Python Desktop Application Development part2]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - Python Qt 开发教程(1)]]></title>
    <url>%2Fposts%2F2c06616b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;写文章之前我都喜欢加个前言，说说自己的感受，这次也不例外。&emsp;&emsp;这篇文章是学习 Python Qt 半年来出的教程，因此教程的质量并不能保证，只是将自己的经验分享给大家。&emsp;&emsp;Python Qt 图形界面开发需要有一定的编程基础，观看本教程之前要有Python的使用基础。&emsp;&emsp;因为我本人是 流程TD ，开发环境主要在 Maya 上，因此这套教程主要针对于 Maya 的 开发环境，不过Qt是通用于各个软件平台的，有问题可以相互交流。 什么是Qt &emsp;&emsp;Qt具体是什么，可以自行网上百度.&emsp;&emsp;简单地说就是一个跨平台的图形化框架，通过这个框架可以实现跨平台的软件界面。&emsp;&emsp;跨平台主要指可以在多个平台上运行，最通俗的说法是兼容 Linux、Mac、Windows 这三个最常用的系统。&emsp;&emsp;Qt曾经由诺基亚公司维护，目前由Digia公司维护，在桌面软件开发上有不可撼动的地位。 为什么使用Qt &emsp;&emsp;由于Qt可以减少跨平台维护的问题。&emsp;&emsp;如今很多软件都是利用Qt搭建图形化界面，包括但不限于Houdini、Maya、Nuke等等&emsp;&emsp;作为插件开发者，掌握Qt的图形化开发可以极大加快开发效率。 Qt开发使用的语言 &emsp;&emsp;Qt这个框架是使用 C++ 代码实现的，在现成的软件中嵌入 C++ 代码是非常不便的。&emsp;&emsp;而python作为胶水语言、脚本语言，补足了这方面的短板。&emsp;&emsp;python之所以这么好，原因是底层也是基于 c 语言。 python Qt 框架 &emsp;&emsp;在Qt发展到4.0的时候，PyQt4 框架诞生了，通过python平台调用Qt库，实现了python的图形化界面。&emsp;&emsp;通过python编写的框架，让代码编写更加明了清晰，调用也更为方便。&emsp;&emsp;PyQt由于是不完全开源的，Qt的运营商 诺基亚 交涉无果之后，自行开发了完全免费开源的python库PySide。&emsp;&emsp;由于两个 python 库都是基于 C++ 的 Qt 框架下实现的，因此在使用的API上基本保持一致。&emsp;&emsp;当然后面 Qt 发展到 5.0 之后，也诞生了 PyQt5 以及 PsSide2 , 框架的使用上也有别于之前的版本。&emsp;&emsp;由于 PySide 的开源商用免费，如今大多数软件开发都使用了PySide 最为 Python 平台的选择。 Qt.py 多版本Qt兼容 &emsp;&emsp;由于在 Qt4.0 到 Qt5.0 的API差异，以及 python 平台下两个库的使用，导致 Qt 代码的兼容非常麻烦。&emsp;&emsp;为了解决兼容问题，github上有开源的 Qt.py 脚本，通过这个脚本就可以用 Qt5.0 使用方式兼容 Qt4.0 的写法，以及 PyQt 和 PySide 的不同平台的差异问题。&emsp;&emsp;不过使用这个兼容脚本会导致 代码编辑器（IDE） 的代码补全失效 (:з」∠) Python Qt 在CG行业的运用插件开发 &emsp;&emsp;由于Qt跨平台的特性，以及Python的胶水语言的便利，太多CG软件支持Qt的开发。&emsp;&emsp;正如上文提到的 Houdini、Maya、Nuke 都支持通过 Python 的 Qt 库来编写图形化界面。&emsp;&emsp;那么Qt编写界面的优势在哪里呢？&emsp;&emsp;下面我用maya原生的MEL代码编写界面来对比 PyQt 的实现效果 MEL &amp; cmds VS PySide 图形界面开发 &emsp;&emsp;下面我来写出一个 hello world 标题的窗口界面举例。 1234567proc printHelloWorld()&#123; print "hello,World";&#125;string $window = `window "使用 MEL 编写窗口"`;columnLayout;button -c "printHelloWorld()" "hello,world";showWindow $window; &emsp;&emsp;如果你不喜欢MEL语言，也可以将其转换为 maya cmds 命令库来实现 12345678from maya import cmdsdef printHelloWorld(e): print "hello,World"window = cmds.window("使用 maya cmds 编写窗口")cmds.columnLayout()cmds.button("hello,world",c=printHelloWorld)cmds.showWindow(window) &emsp;&emsp;下面是使用 Qt 的方式来实现 1234567891011121314from PySide2.QtGui import *from PySide2.QtWidgets import *from PySide2.QtCore import *def printHelloWorld(self): print "hello,world"window = QWidget()window.setWindowTitle(u"欢迎使用 PySide2 编写窗口")button = QPushButton("hello,world")button.clicked.connect(printHelloWorld)layout = QHBoxLayout()layout.addWidget(button)window.setLayout(layout)window.show() &emsp;&emsp;除了上述的实现方案之外，也可以使用类来封装，这种写法更加优雅一些 12345678910111213141516from PySide2.QtGui import *from PySide2.QtWidgets import *from PySide2.QtCore import *class Window(QWidget): def __init__(self): super(Window,self).__init__() self.setWindowTitle(u"欢迎使用 PySide2类 编写窗口") self.button = QPushButton("hello,world") self.button.clicked.connect(self.printHelloWorld) self.layout = QHBoxLayout() self.layout.addWidget(self.button) self.setLayout(self.layout) self.show() def printHelloWorld(self): print "hello,world"a = Window() &emsp;&emsp;看完上面的代码实现之后，会有种感觉，使用PySide的实现要写更多的代码，岂不是更加麻烦吗？&emsp;&emsp;其实 MEL 实现的图形化界面也是调用了 Qt 框架，只是在调用上进行封装，因此用更少的代码就可以实现而已。&emsp;&emsp;那在开发的过程中到底孰优孰劣呢？&emsp;&emsp;在CG行业中应该选择哪一个进行图形界面开发呢？&emsp;&emsp;其实 MEL 或者 maya cmds 命令实现要比 PySide 简单很多，如果只是写一个简单的图形化界面的话，用原生实现就已经足够了。&emsp;&emsp;最直观的典型就是 advance skeleton 这款绑定插件了，如此复杂的界面其实全部都是用 MEL 实现的。&emsp;&emsp;有兴趣的可以研究它的 MEL 源码，3万多行代码是真的牛逼。&emsp;&emsp;那 Python Qt 的框架优势在哪里呢？ QtDesigner 组件拖拽式开发 组件封装扩展 多重事件响应触发 qss 自定义样式支持 自定义响应信号 &emsp;&emsp;如果不需要上述这些特性的话，那么完全可以依靠原生来编写界面&emsp;&emsp;那么上述五个特性到底是个啥，就留到后面的教程娓娓道来吧。]]></content>
      <categories>
        <category>CG</category>
        <category>Qt</category>
        <category>Python结合Qt系列开发教程</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
        <tag>ࠆQt</tag>
        <tag>ࠆQt/PySide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya C++ MEL语句 性能测试 & 插件开发]]></title>
    <url>%2Fposts%2Ff0a58164.html</url>
    <content type="text"><![CDATA[benchmark不开启进度条 遍历 100 100 100 分组耗时 31.6019760867s 开启进度条 遍历 100 100 100 分组耗时 34.2383126924s smooth 四次 的球体（加上复制一个形成重叠） 199690(近20万) 个面 分组操作不使用多线程 8.25591907051s不使用多线程 8.11187977459s多线程 1 耗时 8.75691644773s多线程 1 耗时 8.77698555687s多线程 5 耗时 43.4240804933s多线程 10 耗时 45.5020314805s 分组操作 + 匹配不使用多线程 11.7565591304s多线程 1 耗时 10.8794147052s多线程 2 耗时 20.1982408697s注: 不使用多线程情况下有进度条显示 多线程无法兼容进度条细节 多线程1分组操作 + 匹配不使用多线程 10.3431538931s多线程 1 耗时 30.7188326437s多线程 2 耗时 39.0282697662s多线程 2 耗时 41.3114992348s 多线程1分组操作 + 匹配 + 选择面不使用多线程 37.8165342337s不使用多线程 37.9345086101s多线程 1 耗时 34.5169550919s多线程 2 耗时 44.6464130184s注: 不使用多线程情况下有进度条显示 多线程无法兼容进度条细节 结论python的多线程无法由于GIL全局锁的存在,无法调用更多的CPU核进行计算,因此在Maya中的多线程只能应对IO密集型的情况，在对比、三维计算等CPU密集型的工作当中，使用多线程会导致效率更低。 前言 &emsp;&emsp;在开发模型检查的时候，发现有两个功能开发比较难。&emsp;&emsp;因此我就承担了最难的这个部分，而Maya自带的cleanup开发就交给了吴智博。&emsp;&emsp;这两个功能分别是 重叠面 和 穿插面 重叠面检查 开发重叠面检查看似并不困难，只需要获取模型面上的中心点，然后逐一匹配其他的面是否与之重合即可。然而这么想就太天真了，当我将算法写好之后，会发现运行速度非常的缓慢。张峥前辈给我提出了抽屉的概念，将模型切分成多个抽屉进行匹配，这样切分也可以投入到多线程加快匹配速度。虽然后面经过我的 多线程BenchMark，多线程匹配不能加快速度，反而会降低速度 (:зゝ∠)不过这个切分概念还是一个非常不错的算法，我在网上查了之后知道，这个方案称之为 spatial grid 感觉也类似于maya api 当中 uniform grid切分最大的好处在于可以缩小 第二次遍历的数量，由于这里检查的是重叠，所以无论我切得多小，重叠的部分都会在同一个切分抽屉当中。而切分之后的算法复杂度将不再是过高的 O(n²) 情况，当然因为切分抽屉也是需要时间的，所以抽屉的数量是需要针对不同情况有不同的优化方案的。原理很好理解，但是代码写起来坑还是很多的。我最开始先写了 Python 的版本，然而Python代码在检查20万面(全部重叠)的情况下需要检查30多秒，速度慢到我难以忍受。于是我就寻找如何让Python加速的方案。 maya Python 多核运算尝试 由于测试了多线程方案是心不通的，拿难道python就无法调用多核运算吗？答案当然是否定的，只是因为GIL的存在，Python调用多核运算，只能通过多进程实现，每个进程可以占满一个CPU核心。于是我尝试在Maya开启多核操作， 导入Python multiprocessing 模块。多核运算库和多线程的 threading 模块在简单的使用上大同小异。然而在maya环境下一旦使用 multiprocessing 就会导致maya崩溃。网上查了原因之后才知道Maya本身设计之初就没有考虑过多核处理的情况，因此内部很多api调用都是非 threadsafe 的。只有在动力学模拟、渲染等的这些高消耗的模块支持 多核 运算。而作为中间插入的python脚本，多核以及进程交互很容易导致maya崩溃。官方针对这种情况在官方文档当中有专门的一个部分进行说明 文档如果要尝试多核操作只能完全冻结mayaUI，等待结果返回，然后在进行操作。而官方提供的maya库只能在 MainThread 上操作，换而言之还是无法多核操作。经过多方面的研究和搜索，我感觉Maya Python 的多核运算几乎不可能实现了，除非用 C++ 调用线程池。然而这时候一个意外的发现让我眼前一亮（然而却也只是昙花一现）。我发现Maya还有 standalone 模式，也就是可以跳出maya的ui界面，用python重构重构maya的环境，实现在不同python编译器下运算maya。换而言之就是在python编译器上运行maya的环境，可以实现 cmds、openMaya等命令。这个模式通常用来批量修改 maya 场景、以及多核运算的情况。由于这种后台批处理模式，standalone 模式也被称之为 batch mode然而讲过我简单的测试之后我就告退了， standalone的本质和加载maya整个软件是没有区别的，尽管可以通过 subprocess 模块实现 mayapy.exe 调用standalone 模式，在运算结束之后可以返回到 maya 图像界面的编译器上。然而开启standalone模式和打开一个新的maya其实并没有太大的区别，过程也需要加载大量的插件、脚本等，耗时、也耗内存。而且前辈还给了这个模式的致命一击，这个模式打开就那么费劲了，还没有打开文件呢，一旦要用到 IO 操作，那么电脑内存就捉襟见肘了。因此经过多方面的考量，python实现多核运算并非不可能，但是使用成本、用户体验都不好控制，还不如用C++加速来得好。 C++重叠面开发 经过了漫长的摸索之后，最后还是回到了最初的起点，还是得使用C++来加快脚本的运行速度。因为我之前有用C++的SFML库开发过东西，所以C++的基础还不算太大的问题，只是要搭建一下C++的环境废了一点功夫。当然也很长时间没有接触C++了，所以顺手跑了一个hello的入门命令了解一下maya C++ 的开发。这里面最坑爹的就是 Visual Studio 的项目配置了。最后网上又查了一番，发现maya的devkit是由 pluginwizard 这种操作，可以快速搭建Visual Studio 的项目环境。 后面的操作其实差不多就是将我之前写的OpenMaya Python 代码 转换成 C++ 写一遍。这当中的区别其实也不大。当然，因为太久没有开发C++了，还忘记头文件的作用了，折腾了好一会才发现用头文件才可以实现 python import 功能。 在C++写重叠面的操作，最最坑爹的地方就是C++的字典操作。由于我之前用python写了分组操作，而分组不知道如何将组别的序号转换为线性的数字进行存储1,1,1 =&gt; 11,1,2 =&gt; 2类似上面的问题，所以最后Python是通过 字典的key值存字符串来区分的。因此同样的道理，我也找到了 C++ 的字典，stl库中的map函数。然而用这个方案遍历 map 的运行速度慢出了天际。当我将创建写完，在Maya中执行20万面检查的时候，我发现 python 需要 37s 而C++要 30s我简直不敢相信自己的眼睛，于是我将功能拆分看看到底是哪个步骤占用了过多的时间。于是就发现 分组操作 在 xyz 都是 100 分段的细分条件下 python需要7-8s完成分组，而C++只需要0.2 - 0.3s因此当我禁用了后面选面的操作，只是遍历所有的边进行匹配我发现 C++ 依然需要30s 而Python 只需要 13s 左右于是我肯定了是 map 导致了缓慢计算速度。至于原因我也不太清楚，在和胡盼大佬商量了之后，结论就是map本身是不太适合进行这种大规模的遍历的，推荐我使用结构体来将数据存储起来。结构体确实是个好东西。于是我就利用了结构体的方案，通过 stl 库的 Vector 搭建数组。最重要的是，我总算想明白了如何将组别转成线性数组来进行存储x,y,z =&gt; num0,0,0 =&gt; 10,0,1 =&gt; 2只需要转换为上面的形式就可以实现计算了 计算公式 xy分段z分段+y*z分段+z其实非常简单的数学问题，只是上面的形式误导了我。于是我又将之前写好的C++代码转换为重新整理的代码，由于分组过程中有三重循环，在加上自己改变了遍历序号，结果导致了逻辑陷阱产生了意料之外的结果。而我当时一直没有搞清楚自己的代码到底是哪里导致了这种遍历有问题的情况。最后我使用了 Visual Stuido 强大的断点调试功能才终于发现了问题的根源所在。 终于，在折腾了这么长时间之后，总算是写好了第一个C++命令，而且20万面测试中 运算时间在 2-3s，非常符合预期。 C++穿插面开发 终于，就轮到了我近一个星期的开发噩梦了。寻找模型穿插，我最初认为根本不是什么问题，毕竟maya api 就提供了好几种光线计算穿插的方案。在加上我在网上搜索到了相关的C++编写方案，因此当时我充满了自信。然而当我真正投身其中才发现我是多么天真。首先C++的方案根本就不是计算模型穿插的，而是计算面与模型的穿插交线，不过它采用的方案还是被我借鉴过来了。那就是遍历模型上所有的边发射射线。当然网上原文还是有些区别的，但是它给我提供了灵感。于是我就想到了遍历所有的边，发射与边长度相等的光线，如果光线存在碰撞，那就说明这个边肯定和模型上的面存在穿插。这个方案可行但是发射的时候总是将边相邻的面也算成了碰撞，最初也没有想到有什么办法可以过滤这种情况而头疼得很。最后我发现 allintersections 的命令当中是可以输入相应的碰撞面 id的通过将相邻面的id去掉就可以过滤掉这种完全不需要考虑的情况。最后果然实现了我梦寐以求的效果。然而这个方案最大的缺点就是慢，在进行六千个面测试的情况中，即便是C++方案也需要几秒的计算时间，那就不用考虑20万面的情况了。于是我开始想办法优化这个穿插情况，首先比较好好想到的是，如果模型是自穿插的（可以参考第一周截屏的图片）我可以通过cleanup工具找到 模型上不平整 凹凸不平的面，通过这个方案就可以快速过滤掉那些正常的面。当我觉得这个方案万无一失的时候，张峥前辈一语惊醒梦中人。如果模型存在combine的穿插情况，那么cleanup工具是没有办法选择出来的。而针对这种情况也确实是很难缩小穿插的范围来加快计算速度了。但是我还是不死心，因为我看到Ziva插件就完美做到了各种穿插的计算，我觉得我的方案就未必不行，只需要在解决最后一种穿插情况即可。然而到头来我发现这种穿插几乎是无解的(:зゝ∠)我首先想到了 Boundingbox 穿插来缩小检测范围，所以计算出两个物体相交的boundingbox 就可以极大减少计算范围。然而物体是合并到一起的，有如何才能生成boundingbox呢？经过我不懈的努力，我发现maya的polyselect中的shell标记是可以选择出模型的各个可以seperate的部分，通过while循环就可以将模型的面进行分组。然而再通过polyevaluate中的bc标记来计算每个选中面的boundingbox，从而实现了各个部分的boundingbox的计算。最后确实是可以计算出两个boundingbox穿插部分的交集boundingbox然而即便是如此，要计算交集boundingbox的范围，还是需要遍历模型上的点去判断是否在boundingbox当中，这个过程仍然是相当耗时的。而且即便是选中了交集当中所有的component，这个component的数量也可能是上万级别的，那么光线穿插的计算效率依旧堪忧。因此，最后的最后，我得出了结论，光线穿插本身的计算效率就不行，必须要用更快的算法来计算模型穿插的情况。 于是我又投入了大量的时间去研究 向量 点乘 叉乘 法线等等的概念，尝试通过算法计算出穿插。确实国外的网站有不少这种穿插情况的计算方法，然而坑也是数不胜数。我最初是模仿 平面与平面相交的计算情况，没想到这个平面居然是数学意义上的平面，也就是空间上无限大的平面(:зゝ∠)，结果算法呢算出的穿插到处都是。于是我又开始模仿三角面与三角面穿插的算法，然而算法相关的网站没有提供这部分的代码，只有概念，于是我想破头也没有弄出更好的面面相交算法。不过上面还是有光线与面穿插的计算方案的，上面的数学求解还是挺有意思的，利用了参数方程，将直角坐标系转换到三角面的坐标系上，从而可以算出平面上的点是否在这个三角面区域内。算法只考虑了面和光线是否有穿插，但是我却忘记了遍历所有的面和所有的边，这个算法复杂度可是 O(n²) 的结果我花了大量的时间弄出了比光线追踪还要慢的解决方案，我真的是无言以对，而且我开发完成之后发现自己写的算法还有BUG，在很多时候检测的面都是不全的，真是投了大量时间，赔了夫人又折兵。所以到了这个星期的星期一，我放弃了穿插算法的研究了，毕竟时间都耗尽了。现在采用的解决方案是沿用 Ziva 插件的穿插方案，Ziva的计算效率真的强无敌。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】-2019年3月、4月回顾-5月学习计划]]></title>
    <url>%2Fposts%2Fbb58a66.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近我又拖更了，三月上旬快结束了，也没有记得要更新一下博客(:з」∠)&emsp;&emsp;说起来惭愧，这个月就没有学习什么东西，倒是追剧追了三部，四月初的时候还把小说 《黎明之剑》 听到最新的500章 ，简直丧心病狂。&emsp;&emsp;四月初的时候我的同学也来深圳和我一起参加实习。感觉很是开心。&emsp;&emsp;希望后续可以努力学习，将手机app开发的坑填完。 三月总结三月追的剧 &emsp;&emsp;这个月份的追剧经历让我回想起了大一的时候，也是三四月份的时候，一口气追完了 花牌情缘 动漫。&emsp;&emsp;这个三月也不例外，自从二月份发现 AcFun 居然有日剧看之后，我终于有机会在线看闻名已久的几部日剧。&emsp;&emsp;二月份的时候是追 LegalHigh ，那个时候还比较克制，可以将自己控制在周末看一集。&emsp;&emsp;不过到了三月份之后，情况就发生了变化，自己一看就停不下来了。&emsp;&emsp;LegalHigh 第一季之后就开始追 神探伽利略 和 非自然死亡 unnatural&emsp;&emsp;神探伽利略还把所有剧集追完了 (/ω╲) XML 开发 &emsp;&emsp;有机会就将公司里面写的总结拿出来。]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python Publish 检查功能开发]]></title>
    <url>%2Fposts%2F404240a4.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;开发这个工具的时候，张峥的意思是说将多张图片合成成视频，然后通过RV播放器播放视频来切换不同的帧画面。&emsp;&emsp;所以需要我渲染出多张不同的图片然后合成成视频 检查功能开发 最近开发检查工具，需要固定好摄像机并且拍屏，拍出来的图片还需要合成成视频。在这个期间遇到了不少的坑，在这里总结一波。 ffmpeg 视频合成 因为检查功能需要将图片合成为视频，前辈给我提供了两个方案，一个是RV播放器的视频合成，另一个则是万能的 ffmpeg前辈其实更推荐使用 RV 播放器，我也根据他的思路去学习观摩了 RV 播放器的大概RV播放器提供了大量命令行命令 可以实现很多复制的操作 （本质上和 ffmpeg 差不多）后面的二次开发也可以大量借助 RV播放器的功能实现更友好的交互。不过我考虑到 RV播放器的合成功能 需要安装，产线上并不能保证所有人都安装 RV 播放器因此最后还是 ffmpeg 真香，毕竟只需要放在服务器上就可以顺利合成，何乐而不为。 其实 ffmpeg 并不坑，网上有大量的使用案例，可以参考学习。 matadata 处理 前段时间和张峥前辈讨论如何给视频添加上一下备注信息我们预期不要额外的信息存储文件，直接写到视频当中，可以读取出来。那么数据不仅在视频当中，还不影响视频的播放，就涉及到下面的metadata的写入了。 最初我原以为给文件写入meta信息是非常简单的事情，毕竟在windows的文件详情下面都可以轻松修改文件的描述内容那么我相信通过一些工具，是可以添加自定义的描述，甚至是扩展更多的信息。 经过一个下午的搜索之后，我就陷入了巨坑之中。最初其实前辈只需要在视频当中嵌入信息即可，但是我觉得meta信息很简单，应该任何的文件都可以嵌入信息。然而经过努力之后我发现网上并没有很好处理 metadata 的工具。图片的 meta 信息 、 视频的 meta 信息 都是有相关的规定标准的，所有的信息都是按照这个标准来的。在图片领域中这个标准还是日本指定的 exif换而言之，除此之外的文件因为没有标准是无法直接嵌入 meta 信息的（其实网上有通过C#实现的方案，但是python这边找不到）同样 python os 库 里面可以获取文件的修改时间，但是却无法修改这个 meta 信息 当然万能的python什么都有，第三方库也少不了，但是经过一番摸索之后，在youtube上找到了个视频，称python库只能获取极其少量的信息。视频推荐使用 exiftool 工具，这个工具类似于 ffmpeg ，直接敲命令行获取数据。于是我开始研究 exiftool 工具的使用方法，在网上还找到了 exiftoolGUI 的图形化界面。不过这个界面从2012年到现在就没有更新过了。然而搞了好长一段时间之后，居然发现 exiftool 无法修改视频的meta信息。 最后的最后只好绕回来按照前辈的说法 使用 ffmpeg 添加视频的 meta 信息而且前辈也补充道 我们目前压根用不上图片的信息 不过话说回来 exiftool 也可以获取到视频的信息，而且获取的信息比 ffmpeg 详细很多，可以先记录着，说不定以后管用。 Arnold 渲染输出 拍屏这个操作其实并不困难，就是maya playblast 命令然而除了 playblast 之外 还需要 Arnold 的渲染输出，这个着实是个难题。这次遇到的问题和过去的maya命令问题大不相同。当你使用arnold渲染的时候，你会发现压根就没有任何相关的 Arnold 命令回显于是我尝试查找关于 渲染输出 的 cmds 命令回显我发现了 render 命令，然而这个坑爹的命令是给 maya software 渲染用的尽管这个坑有点大，也并非完全无从下手的。虽然 Arnold 专属的渲染窗口完全没有代码回显，而且 Arnold 貌似有它自己的API不过在 Maya 的渲染窗口当中还是可以看到输出的痕迹的，只是这个痕迹让人奔溃得很。 这里面有很多无关的代码参杂其中。经过我长时间的研究提炼 最后 我成功将渲染的核心代码提取了出来 12345678910111213141516171819path = "输出路径"# Note 用 Arnold 渲染if cmds.getAttr("defaultRenderGlobals.currentRenderer") != "arnold": cmds.setAttr("defaultRenderGlobals.currentRenderer", "arnold", type="string")# Note 找到当前渲染窗口editor = cmds.renderWindowEditor(q=True, editorName=True )# Note 开启渲染cmds.RenderIntoNewWindow()# Note 以jpg的格式存储图片import maya.app.general.createImageFormats as createImageFormatsformatManager = createImageFormats.ImageFormats()formatManager.pushRenderGlobalsForDesc("JPEG")# Note 从渲染窗口输出图片cmds.renderWindowEditor(editor, e=True ,com=1,wi=path)formatManager.popRenderGlobals()# Note 刷新 - 避免影响到拍屏操作cmds.refresh() 效果总结 最后和徐思建他们对接之后 就不再需要 Arnold 渲染的部分只需要拍屏出视频即可，比之前还要简单 模型穿插检查 昨天我开始开发模型穿插相关的工具原本 Maya 是有 cleanup 工具 ，已经非常全面地涵盖了很多检查相关的内容但是如果模型有穿插的情况是无法检测出来的 虽然上面的截图稍微极端了不过这种效果是无法通过 cleanup 解决的 于是我在网上查找 intersect 相关的解决方案，查了很多也没有好的idea虽然我找到了一篇关于 intersect 的说明文章，但是实现的效果似乎和我们预期的大相径庭于是我尝试自己研究经过我昨晚的不懈努力，我研究出了一个方案，遍历物体所有的边，并从边上选取点发射射线，如果边与模型其他的面有交点，那就可以说明这条边和模型是由穿插了。我认为思路是正确的，然而问题在于射线的方向无法确定我将这个问题反馈给师兄，师兄建议我用叉乘来解决角度经过我的测试，我发现问题并不在这个地方。 OpenMaya 有 AllIntersecions 命令 通过定义 光线发射源和光线方向 来定义碰撞我从 MItMeshEdge 获取的迭代器 可以获取到边相连的两个顶点然而这两个顶点的次序是没有办法判断，我每次都是固定 第一个点的坐标 减去 第二个点坐标 获取方向然而发射源有可能导致这个方向完全相反我思考了很长时间也没有结果，于是亲自找师兄解决问题，不过还是无果。最后我想到了可以获取边上的中点来辅助判断方向，用一个点减去中点获取方向那么发射源就必然是另一个点]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】 2019年2月回顾 | 3月学习计划]]></title>
    <url>%2Fposts%2F6f4e3164.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;有一个月过去，从这个月开始，我在博客下搭建了Journal来记录自己的生活日常。&emsp;&emsp;然而能够感觉到收效甚微，最近感觉自己有点太浮躁了。&emsp;&emsp;做事也没有条理，没有进行过规划，虽然一直想致力于开发出一个任务管理的APP让自己的生活步入正轨。&emsp;&emsp;然而不如意之事十有八九。&emsp;&emsp;最近研究了Flutter ,然而Flutter文章却一直托更了，甚是惭愧。&emsp;&emsp;如今真的感受到了考验，最初更新博客的热情也逐渐被生活磨平，想来也是个悲伤的故事。。&emsp;&emsp;正因为这些种种的原因，所以才会有那么多的Hexo博客只有寥寥无几的文章。&emsp;&emsp;我希望自己还是不忘初心，整理这个博客吧。 二月份总结过年回家 &emsp;&emsp;过年前凑巧有亲戚结婚，刚好2月1日是公司的年会，于是当晚参加完公司的年会之后，我就随同父母一起去了梅州。&emsp;&emsp;那段时间其实自己挺闲的，但是也没干啥，就是妥妥当当跟着走流程而已，也杨辉哥聊了自己的情况。&emsp;&emsp;然后我们就离开了，顺路回广州接上哥哥，然后一家人会家过年。 &emsp;&emsp;过年期间，也没有做好什么，感觉去年努力学习Houdini的经历要更充实一些。&emsp;&emsp;大年初二我终于花了钱去电影院看了 《流浪地球》&emsp;&emsp;作为上映之前就开始关注的科幻电影，这次我终于为自己的信仰充值了，就是害怕这部电影扑街。&emsp;&emsp;万万没想到，这电影口碑甚好，如今已经破40亿了……&emsp;&emsp;另外大年初六的时候和高中的两位老同学去看了 《飞驰的人生》&emsp;&emsp;由于没有看过韩寒之前的作品，这一部给我的感觉很一般，而且结尾对我路人来说很突兀。&emsp;&emsp;最后到了2月13日，我就会深圳干活了。 移动端开发 &emsp;&emsp;在年前的时候我就想学习安卓APP，开发一个任务管理的APP&emsp;&emsp;因为自己已经在这方面迟到了苦头了。&emsp;&emsp;这个问题也和自己的自控力有关，有时候因为没有规划，导致整天的时间浪费。&emsp;&emsp;因此我是十分想开发一个任务管理APP，将游戏的机制引入其中的，然而实现起来也似乎挺庞大的。&emsp;&emsp;为此我开始在过年的时间抽空开始看Android相关的开发教程。&emsp;&emsp;然而看到半路的时候，却发现半路杀出了 React Native ，基于前端框架，同时兼容 ios 和 Android 的神器。&emsp;&emsp;于是我立刻放弃了Android的原生开发，以至于为了学习 React Native 而去学习了 React&emsp;&emsp;当然 React 也只是摸了几个教程，最近的文章都有提到相关的情况。 观看笔记 - Pluralsight React:The Big Picture React - React 两日游有感&emsp;&emsp;最后最后我又发现2018年谷歌宣布的新技术，Flutter，于是我又去搞Flutter去了。&emsp;&emsp;最近弄 Flutter 确实让我搞得有点怀疑人生，毕竟 Flutter 还是新技术，注定会有很多的坑。&emsp;&emsp;所以我也经常会怀疑要不要学习一下 React Native ，最后我还是决定先把Flutter 相关的技术攻克了先。毕竟我还是很清楚自己的，自己太想依赖别人做好的东西直接调用了。 &emsp;&emsp;为了弄好 Flutter App 开发，我决定开始模仿一些现有的APP去制作高仿效果，我相信这样才能将 Flutter 用得得心应手，目前还是使用不足，只是开发了个简单的 todo App，而且这个过程中的数据交互管理还一塌糊涂，我用了非常不优雅的方式强行将所有的BUG修复了，但是我觉得整个APP的开发简直是一场灾难。 gitLab_hook &emsp;&emsp;年后回到公司之后，我自己就逐渐淡出了 Ziva的研究与开发。&emsp;&emsp;一方面是我自己没有动力了，另一方面有同事接手了这方面的工作。&emsp;&emsp;另外公司内部也和动漫公司展开了Ziva的交流会，发现动漫公司虽然吹嘘得很厉害。&emsp;&emsp;其实他们的试验作品以及对Ziva的研究深度，还远远不如我们的深入。 &emsp;&emsp;年后回到公司之后，我主要负责了 gitLab_hook 钩子的开发。&emsp;&emsp;其实公司想要弄的东西并不算复杂，但是后面我和胡盼的交流之后就弄得异常复杂。&emsp;&emsp;过程中还牵扯到了公司的服务器、路由。 &emsp;&emsp;苏老板年前的时候就已经将相关的脚本代码交给了我，也和我讲解了一些实现原理。&emsp;&emsp;年前我弄明白了本地钩子（在服务器的Linux系统上）的作用，其实就是 git checkout 代码，实现将当前 git 的 push 复制到另一个目录下。&emsp;&emsp;然而苏老板还同时配置了 网页钩子 ，这个网页钩子的用法，我之前一直没有搞懂。&emsp;&emsp;年后回来弄了一下才清楚，原来是要在一台windows的电脑上利用Python开一个socket进行长连接的监听。&emsp;&emsp;而网页钩子正是将信息数据发送到了长连接之下，实现了数据的交互。&emsp;&emsp;通过长连接的监听可以对 本地钩子 复制目录下的文件进行预处理。&emsp;&emsp;而苏老板想要智能地实现将py脚本的pyc以及pyd自动编译处理到远程的终端上。 &emsp;&emsp;最开始遇到的问题，git checkout 下的路径无法进行文件修改，而该路径就在 linux 系统上，为此我多次请教了胡盼。&emsp;&emsp;一开始我还以为监听的脚本问题，直到胡盼过来我才发现，我根本就没有权限对该目录进行任何编辑修改，然而 git 却做到了。&emsp;&emsp;虽然问题不明，我和胡盼都在查找资料，我很明显对 Linux 一无所知，根本无从下手。&emsp;&emsp;一开始怀疑是 Linux samba 共享文件管理系统的问题，但是根据网上的操作还是无法解决问题。&emsp;&emsp;于是经过一番摸索之后，发现是 Linux 的用户权限问题被限制了。&emsp;&emsp;于是一波三折之后总算是完成了最终还是解决了这个问题。&emsp;&emsp;后面还遇到了坑爹的网络问题，然后有经过了修改IP地址等一大通的操作之后才总算解决了。 &emsp;&emsp;最后胡盼希望我能够实现将编译的信息输出到git终端上，胡盼提出建议让我去研究epoll相关的端口监听方案。&emsp;&emsp;于是为了实现这个效果，我又在网上弄来了python的socket和epoll并发监听方案。&emsp;&emsp;最后我是成功实现了epoll并发监听的处理，从而在 git push 的过程中触发linux的网页监听。&emsp;&emsp;如果是单次的上传的话，监听处理还算完美，可以实现在 git 终端上显示出编译的结果。&emsp;&emsp;但是如果是并发的 push ，那么监听端口需要多开epoll来确保信息的获取，而端口地址又必须保证 windows 和 linux 是一致的。&emsp;&emsp;最后发现了对同一个端口多开监听却不会造成报错的方法，但是信息的截取却是随机的，那么就可能造成并发处理的信息回馈混乱。&emsp;&emsp;最后胡盼说这堆这种情况只能去研究进程之间的通信，将相关的信息处理好。&emsp;&emsp;然而这么一大圈下来弄得实在是过于复杂了。&emsp;&emsp;最后苏老板说不必那么复杂，直接就沿用最开始的方案，发邮件去解决好了。&emsp;&emsp;于是我又花了一些时间将发送邮件的功能给实现了。 摄像机曲线显示 &emsp;&emsp;在年前的时候，我给公司写了 Cam_Route_Manager 的插件，最后因为过于复杂而简化了。&emsp;&emsp;其实那个时候我还开发了 speed_visualizer 的插件。&emsp;&emsp;这个插件的原理是受到了蚂蚁教程的启发的。&emsp;&emsp;教程的第8集制作了坐标轴来可视化显示了 noise 函数的效果。&emsp;&emsp;原本我就打算这么实现的，不过苏老板说不能采用粒子发射的方案，必须要让曲线事先生成好，因为要看到后续的运动效果。&emsp;&emsp;因此我改变了制作思路，通过给 locator 添加表达式实现曲线的运动。&emsp;&emsp;表达式的实现原理也很简单，y轴的高度变化和相关属性绑定在一起，和X轴就加入一个固定的偏移值，那么 locator 的运动路径就是属性的运动曲线。&emsp;&emsp;于是通过记录 locator 每一帧的运动路径就可以获取到曲线所有的点。&emsp;&emsp;再次在 Stackoverflow 上找到了根据运动位置生成曲线的方法，从而实现曲线的预先生成。&emsp;&emsp;接下来就只是给曲线添加表达式，让其反方向偏移即可。&emsp;&emsp;如此一来整个坐标系以及曲线的运动都制作完成了。&emsp;&emsp;我还转么针对这个坐标系的定位而写了代码，实现自动定位到摄像机前的位置，并且带有父子约束而可以跟随摄像机的位置。&emsp;&emsp;后面摄像机那边还要求我添加上 位移速度 位移加速度 旋转速度 旋转加速度 四个属性。&emsp;&emsp;我查了物理上的运动公式，通过 mel 表达式实现每一帧取样计算，还专门添加了采样精度，来控制前后采样帧的阈值（越小越精确，但是太小为让数值变为零无法计算) &emsp;&emsp;上述的工作其实都是我1月份做的事情，而这个二月，摄像机小组希望能够一次过将四个属性的曲线同时生成出来。&emsp;&emsp;于是我有埋头开始改良自己的脚本。&emsp;&emsp;经过测试，我发现脚本的运行效率堪忧，原因是生成曲线的过程和拍屏一样。&emsp;&emsp;使用 cmds.currentTime( frame ,u= 1) 具体可以查询 cmds 的命令库，主要是开启 update 模式，导致每一帧都跑，严重降低了效率。&emsp;&emsp;我发现曲线的生成代码采用 xform 的方法来获取 locator 的坐标，这在复杂曲线的生成上是很有必要的。&emsp;&emsp;但是我运动的只是 locator ，这个过程没有层级关系的干扰，根本就不需要每一帧去换算它的世界坐标位置。&emsp;&emsp;于是我将 xform 的获取方法改为了 getAttr 的方法，而且 getAttr 有 time 属性可以指定到具体的帧数，连 currentTime 函数都省了。&emsp;&emsp;于是换了新的方案之后，曲线的生成速度快了无数倍。 &emsp;&emsp;除此之外，我之前的插件是需要导入 visualizer 的ma文件来实现坐标系的生成，但是这么一来，每一次生成都需要导入一次文件，或者至少也需要将导入的文件进行复制。&emsp;&emsp;我在想有没有办法让ma文件以代码的形式加载进来。&emsp;&emsp;我想到ma文件的本质其实就是 mel 代码，于是我尝试复制 ma 的代码放到 脚本编辑器去运行。&emsp;&emsp;我首先先排除了一些肯定不需要的代码（比如开头生成摄像机的部分）&emsp;&emsp;然而经过我多次尝试，有一部分核心代码却总是报错。&emsp;&emsp;我的坐标系文件是由 曲线 locator 刻度模型 三个部分组成的。&emsp;&emsp;经过我层层剥离，我发现曲线层级之类的可以通过ma的代码生成出来，但是模型却做不多，而且模型相关的代码一执行就报错。&emsp;&emsp;而我发现报错的原因恐怕是 setAttr 中的多重面信息的读取出问题了。&emsp;&emsp;我尝试用一个最简单的三角面进行测试，却发现代码没有报错，却无法生成出可以看得见的模型，只有大纲类表中的空壳。&emsp;&emsp;我很无奈，于是在网上搜了如何通过代码来生成模型的方法。&emsp;&emsp;找了很多文章也没有好的方法，最后我发现靠谱的方案还是和我做 Ziva Panel 时边界面片的生成方案一样。&emsp;&emsp;都是采用一个面一个面生成，最后将所有的面合并并且将点缝合的方案。&emsp;&emsp;虽然我觉得这个非常愚蠢，但是我的确没有更好的选择了。&emsp;&emsp;我上提供了一种方法，可以根据三角面的点与面的信息对应生成出模型的方案。&emsp;&emsp;于是我又研究了好久来弄出 点 和 面 相互对应的信息的方法。&emsp;&emsp;原本想着模型不算太复杂，就数千个面而已，应该用cmds命令就可以轻松解决。&emsp;&emsp;没想到这样生成也需要卡顿数秒的时间，于是还是采用了 OpenMaya 的方案。&emsp;&emsp;幸好网上的答案将两个方案都提供了出来，我就不必又去手动实现了。&emsp;&emsp;最后效果是令人兴奋的，visualizer可以通过代码自动生成，不再需要导入这个繁琐的步骤了。 &emsp;&emsp;另外因为刻度模型是固定的，无法显示大于5和小于-5的数值，所以我想出了缩放系数来缩放坐标系。（其实刻度模型也可以不固定，但是想到2017和2015的type不一样，感觉实现起来未必靠谱）&emsp;&emsp;于是通过修改 locator 的表达式来加入缩放因素。&emsp;&emsp;另外还专门为实现四个属性一次跑完写了一套代码。 月末回校 &emsp;&emsp;月底的时候开学了，于是我决定回校上一个星期的课，顺便和老师说说情况什么的。&emsp;&emsp;结果没想到说了还麻烦了，后面就干脆不怎么和老师说了。&emsp;&emsp;后面就全靠自己自学了。&emsp;&emsp;在这段期间基本有空就在弄 Flutter 的代码，但是可以深刻感觉到自己学习的浮躁，完全没有当初PyQt的时候耐心。&emsp;&emsp;完全没有循序渐进，只是囫囵吞枣地看教程而已。 二月总结 &emsp;&emsp;这个二月感觉自己过得很浮躁，虽然在公司的时候还算踏实。&emsp;&emsp;但是一旦是自己的自由时间状态就比较混乱，过年的时候看Android教程的时候也是差不多，只有 react 的学习还算让我满意，但是我也只是了解得很粗浅而已，况且最重要的路由我自己还没有亲手实现&emsp;&emsp;三月初我依然没能摆脱这样的状态，这让我意识到任务管理的APP的迫在眉睫，除此之外还真没有太好的想法了。&emsp;&emsp;我不清楚为什么在工作室和在公司的时候我可以放空自己专心学习。&emsp;&emsp;可能也只能说是环境的影响吧，无形的监督让我能够更加安心地学习。 三月学习计划 Flutter 开发 百度脑图链接]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - Publish工具开发]]></title>
    <url>%2Fposts%2F237316ce.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;过年那段时间，自学了 React 框架一段时间&emsp;&emsp;然后张峥前辈给我安排了这个基于 XML 配置的检查界面开发。&emsp;&emsp;其实不使用 XML 用 Json 配置也是完全可行的。&emsp;&emsp;当时我考虑到 XML 可以实现类似于 HTML 的组件化效果，因此在开发的过程中夹带了很多私货。 FTDY_UI_Library目前初步的框架已经搭建完成 根据XML 配置文件进行 UI 生成，便于快速搭建窗口进行修改。 框架的层级结构 所有的控件都保持类名和文件名一致的形式， 这样就可以通过xml的标签获取到相关的组件。 通过读取 Component_UI 中相同名称的 ui 文件 生成对应的界面。 可以在 py 文件加入代码来扩展组件的功能 ui 文件都配图说明相关的控件的名称 便于后面进行调用 用于定义页面的布局 检查函数可以通过xml定义的路径获取 路径自动索引到 Publish_Check 文件夹下 检查函数的类名固定为 Check 函数 固定调用 run 函数进行检查 fix 函数进行修正操作 组件 检查功能触发 全部检查功能触发 翻页功能 img picker 加载单个图片和目录 右键删除图片路径 img picker 拖拽加载图片 tag 控件功能 左键切换位置 双击修改标签 右键删除标签 +号标按钮添加新的标签 2019-03-12Python UI 库开发装饰器开发 改良触发效果 添加消息 print 以及数据输效果 数据链接 根据当前的 check_item 状态 实现下一页按钮功能冻结 链接当前复选框勾选的 check_item 用于全部检查按钮的触发 将当前数据状态在主界面中进行管理(这种管理方式并不好) 构思 XMLParser 文件 制作解析文件触发的思维导图 目前效果 2019-03-14Python UI 库开发XML_Parser 开发完成 分类触发task交互 output - 输出 attrname - 自定义变量的输出 input - 输入 BUG修复 将task传入到 Check 和 Process 相关的执行函数中 给所有控件 添加了initAttrib函数来初始化部分共同属性的处理 添加了 getPublishWin 函数来获取当前界面的 PublishWin 实例过去采用的方案是通过 self.window() 来获取当前页面但是在Maya2015下无法获取相同的控件直接导致无法进行数据交互于是我通过递归遍历的方法专门查找窗口的 PublishWin 实例获取数据 改良的了parse的解析方法，支持self函数扩展功能 2019-03-16优化 XML_Parser 开发完成 分类触发task交互 input - 输入 界面生成时调用 output - 输出 界面销毁时调用 attrname - 自定义task属性输出 输出方案和output一样 generating - xml生成过程中的调用 complete - xml生成完成调用 取消了控件对 XMLParser 和 PublishWin 的代码依赖通过 parse 属性传入配置进行相关调用,避免库文件被多次同时地修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445self.parse = &#123; # 可填写5种不同的状态类型 "generating" : &#123; # generating 可以定义 complete 中的参数 # 传入的控件 # self代表当前控件函数 "self": [&#123; "method":"getItemList", # 执行的函数 "return":"check_item_list", # 返回值将会赋予到 XMLParser.check_item_list 中 &#125;] &#125;, "complete" : &#123; # complete 实现对多个控件之间的交互管理 "self": &#123; "method":"setCheckButton", "param":"check_item_list,check_button_list,next_button_list", &#125; &#125;, "output" : &#123; # output 界面销毁时执行相关的函数 # 也可以是ui文件中定义的其他Qt控件 并且直接调用 Qt 已有的方法 "Submit_ComboBox": &#123; "method":"currentText", "return":"task.type", &#125;, "Mode_ComoBox": &#123; "method":"currentText", "return":"task.mode", &#125;, &#125;, "input" : &#123;# input 界面生成时执行相关的函数 "self": [ &#123; "method":"submitLoad", "param":"task.type", &#125;, &#123; "method":"modeLoad", "param":"task.mode", &#125; ] &#125;, "attrname" : &#123;# attrname 将在xml定义的属性传入到 task 的属性中 此处执行return无效 "self": &#123; "method":"getImgList", &#125; &#125;&#125; 上图简单概括了 parse 属性的填写方法通过字典(json)的形式存储类的parse配置parse字典可以填写触发的5种类型来完成不同的调用(对应上面的五种状态) “input” - 输入类型 “output” - 输出类型 “attrname” - 自定义属性类型 “generating” - xml生成类型 “complete” - xml完成类型这五个属性之下可以填下相关的控件，通常填写 self ，这样可以在当前控件代码下扩展调用的函数。控件之下有 method param return 三个可定义值。 “method” - 执行当前控件的方法 “param” - 当前执行方法传入的属性 “return” - 当前方法返回值的接受属性 注意：generating complete 指向 XMLParserinput output attrname 指向 PublishWin 2019-3-15 字符串输出报错问题 &emsp;&emsp;昨天晚上我和前辈研究了为什么字符串没有办法打印却有可以输出的问题。&emsp;&emsp;经过我今天早上的研究，我发现问题是在读取的文件上，文件上按照utf-8的格式存储的。所以读取出来也是utf-8字符，控制台打印需要decode(“utf-8”)才可以正常输出。这也解释了为什么直接输出字符串反而不会报错。 PyDoc 开发 PyDoc Python 文件 正则表达式提取 &emsp;&emsp;今天研究了 正则表达式 提取方案，让我对python正则运用有了全新的认识。&emsp;&emsp;不过今天也被正则的思路所固化了，让我走了很多弯路。&emsp;&emsp;我希望通过正则表达式来提取文件中所有的类，但是遇到的问题是如果类的声明是连在一起的。&emsp;&emsp;那么上一个类的结束匹配会占用下一个类的关键字，从而影响到下一个类的匹配。&emsp;&emsp;我一直试图通过正则表达式来解决这个问题，所有在这条路上专研了很久也没有好的想法。&emsp;&emsp;最后我突然想到可以通过字符串的处理将文件中的类切割出来。&emsp;&emsp;那么可以通过字符串的split处理，来讲相关的内容存到数组当中呢。&emsp;&emsp;最后通过正则表达式来匹配单个类中的文件就可以完美实现类的提取。 &emsp;&emsp;同样的，我也想将文件中的函数声明提取出来，我原以为只需要将正则表达式的关键字修改即可。&emsp;&emsp;然而这样会将类当中的函数声明也牵连了。&emsp;&emsp;所以这里需要类提取的内容移除之后再进行相关的匹配。&emsp;&emsp;然而如何将字符串的特定内容清理掉呢，想来想去我一直以为用remove方法，其实remove是数组的处理。&emsp;&emsp;经过网上查了之后，我发现可以使用replace函数，将匹配的内容替换为空即可。 &emsp;&emsp;目前已经完成了，class和def的提取，下面还需要开发 对 class 和 def 的特定内容的提取。 2019-03-18控件 parse 属性 分类触发task交互 input - 输入 界面生成时调用 output - 输出 界面销毁时调用 attrname - 自定义task属性输出 输出方案和output一样 message - 信息输出控件 generating - xml生成过程中的调用 complete - xml生成完成调用 1234567891011121314151617181920212223242526272829303132333435363738self.parse = &#123; # 可填写4种不同的状态类型 "output" : &#123; # output 界面销毁时执行相关的函数 # 也可以是ui文件中定义的其他Qt控件 并且可以直接调用 PyQt 已有的方法 "Submit_ComboBox": &#123; "method":"currentText", "return":"task.type", &#125;, "Mode_ComoBox": &#123; "method":"currentText", "return":"task.mode", &#125;, &#125;, "input" : &#123;# input 界面生成时执行相关的函数 "self": [ &#123; "method":"submitLoad", "param":"task.type", &#125;, &#123; "method":"modeLoad", "param":"task.mode", &#125; ] &#125;, "attrname" : &#123;# attrname 将在xml定义的属性传入到 task 的属性中 此处return属性无效(根据xml属性固定传入) "self": &#123; "method":"getImgList", &#125; &#125;, "message" : &#123;# message 装饰器输出的信息 传递到的控件 "self": &#123; # 固定 get &amp; set 属性 传入相关可执行的方法 "get":"toPlainText",# 装饰器需要获取控件已有的内容避免新的信息覆盖旧的信息 "set":"setText", &#125; &#125;&#125; 上图简单概括了 parse 类型的填写方法通过字典(json)的形式存储类的parse配置parse字典可以填写触发的5种类型来完成不同的调用(对应上面的四种状态) “input” - 输入类型 “output” - 输出类型 “attrname” - 自定义属性类型 “message” - 信息输出类型这四个类型之下可以填下相关的控件，通常填写 self ，这样可以在当前控件代码下扩展调用的函数。 input output attrname 这三种类型下有 method param return 三个可定义值。 “method” - 执行指定控件的方法 “param” - 当前执行方法传入的属性 “return” - 当前方法返回值的接收属性 message 类型下有 get set 两个可定义值。 “get” - 获取方法 - return 字符串信息 “set” - 输出方法 - 传入输出的字符串信息 注意：input output attrname 三种类型的参数和返回值都指向 PublishWin 中的属性 2019-03-19完成 PyDoc 开发 抓取Py文件中的数据 通过 Qt 的 filewatcher 实时抓取数据 todo - 后续可以按照前辈的说法做成git钩子 改良 docsify 文档显示效果 改用 dark 主题 通过jq实现目录上的扩展按钮功能 通过 sessionstorage 将数据存储到浏览器当中，实现跳转调用相关数据，提高交互友好度]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React - 两日游有感]]></title>
    <url>%2Fposts%2Fde2ca4c2.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;过年过节拖更了很久，最近回到了深圳，终于又爆发了学习的力量。&emsp;&emsp;正如上一篇文章提到的，我想要开发安卓应用。&emsp;&emsp;学习了原生的Java开发之后，感觉不是特别感冒。&emsp;&emsp;尽管学起来和Pyqt差不多，包括使用XML布置布局等等，都有诸多相似之处。&emsp;&emsp;但是想到Ios的开发之后就脑阔疼。 &emsp;&emsp;于是经过一番调查之后，发现 React Native 可以实现 Android IOS 双兼容。&emsp;&emsp;于是我就兴致盎然地开始查找 React Native 的资料。&emsp;&emsp;再然后，我终于理解为啥 React 那么受欢迎了，因为 React Native 是完全基于React的设计思路的。&emsp;&emsp;于是为了学习 React Native 我就入了 React 的坑。 React 学习概况 &emsp;&emsp;这两天看了好几个 React 的教程，感觉挺有意思。 18年9月React+React-router4.x+Ant Design+Flux视频教程–【IT营大地】 Pluralsight React:The Big Picture Pluralsight A Practical Start with React &emsp;&emsp;还有一些教程囫囵吞枣地看了一下。&emsp;&emsp;看完这些教程我觉得React还是挺有趣的，不愧是前端的三大框架。&emsp;&emsp;(今天也因为研究学习强国的API，对于 VUE 颇感兴趣，也看了几集入门教程，发现三大框架都很相似，但是和传统的开发完全不一样) React 使用 &emsp;&emsp;其实React也只是试着开发了个Todo-Demo，自己的说法也仅仅代表初学者的一家之言。 React 运作 &emsp;&emsp;React对DOM操作进行了优化，A Practical Start with React 教程当中有详细的演示。&emsp;&emsp;传统的JS处理DOM会对相关的DOM进行全面更新，但是ReactDOM只会针对特定被修改的标签进行更新，从而极大优化了运行性能。&emsp;&emsp;为了实现这个效果，ReactDOM的API使用是复杂的，简直可以说是反人类的。&emsp;&emsp;于是JSX由此诞生了。&emsp;&emsp;JSX 就是 HTML 与 JS 的混写模式。&emsp;&emsp;上图就是 React 的运作流程 React JSX &emsp;&emsp;JSX虽然基本和HTML一致，但是也在一些地方进行了修改。&emsp;&emsp;上面就是 JSX 和 Html 不同的地方。&emsp;&emsp;其他的地方的不同更多的是来自于 JS 的逻辑处理带来的不同。 &emsp;&emsp;另外React 完全是组件化的，并且是基于ES6来写的。&emsp;&emsp;当讲 Class Export 出来之后，就可以在其他页面引入写好的组件。&emsp;&emsp;这个组件名可以当成 JSX 标签来使用，因为这样，React的开发流程以控件开发为主的。 React 组件开发 生命周期 交互方式 &emsp;&emsp;组件和安卓开发一样也是有声明周期的，通过API提供的声明周期函数，可以实现在一些特定情况下进行函数回调。&emsp;&emsp;至于组件之间的交互方式，基本是离不开的 JS 的开发逻辑。 React router &emsp;&emsp;通过 React 的路由机制 就可以实现过去开发的多页面跳转。&emsp;&emsp;而这个在 React 中的跳转和传统开发的跳转完全不一样。&emsp;&emsp;过去开发的跳转就意味着到一个全新的HTML文件上。&emsp;&emsp;而 React 路由实现了对组件的切换。&emsp;&emsp;所以这就是单页面应用开发的利器。 结语 &emsp;&emsp;React 相较于传统的开发做了大量的优化，总算是明白为什么前端三大框架这么必要。&emsp;&emsp;特别是在多人开发团队的情况，框架的应用可以极大提高开发效率，并且维护起来更方便。 &emsp;&emsp;原本是想学习 React Native ，今天查了一下，Google官方推出了 Flutter，而且 Flutter 也是支持多平台开发的。&emsp;&emsp;虽然 Flutter 这个东西很新，但是毕竟是 Google 大佬的东西， Flutter 的未来就几乎是原生开发了。&emsp;&emsp;所以我最后还是决定放下 React ，学习 Flutter]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡁReat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Pluralsight React:The Big Picture]]></title>
    <url>%2Fposts%2Fd8bf85b3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;因为最近想要学 React Native ,所以也没想到自己最终还是接触了前端的三大框架。&emsp;&emsp;更加出乎我的意料的是，我原以为我最先接触的是Vue，没想到最后选择了React&emsp;&emsp;不过现在对我来说都无所谓了，毕竟现在不是靠前端吃饭了(/ω╲)&emsp;&emsp;当然，这个教程看完之后，React给我的印象也是极好的。&emsp;&emsp;Learn Once，Write Everywhere 的开发理念也让React不拘束在前端本身，而可以打破前端的次元壁，触碰更更多领域。 Why React?React的历史 React的使用缘由 FlexibilityReact的使用领域 React的设计理念 React的三个渲染内核 分别对应网页、移动端、VR三个平台领域 React支持多种浏览器 Developer ExperienceReact API 依附于JavaScript React并不是框架，API没有自己的使用规范，而是沿用JavaScript的使用逻辑 Coporate InvestmentReact 由 Facebook 的全职员工维护 React CodeMode 可以轻松将React迁移到高版本上 CommunityStackoverflow 的问题非常多 便于寻找解决方案 大量公司使用React 大量基于React的控件 React 的生态系统 Performance使用 Virtual DOM 优化DOM操作 提高性能 优化DOM操作的好处 React性能测试列表 TestabilityReact 相较于传统测试的优势 Framework VS LibraryReact 与框架之间的对比 React侧重在Component上，额外的功能都通过其他的框架来实现。 Concise VS Explicit 因为我两边都没有学过，其实看着没啥感觉(简约和明了的对比) Template-centric vs JavaScript-centric Separate vs Single File 传统功能区分通过 HTML CSS JavaScript 进行区分React 通过 Component 将功能进行区分 总结 &emsp;&emsp;React 的理念是非常强大，尽管现在也不是唯一的选择，谷歌开发了Flutter，也可以实现跨平台APP开发。&emsp;&emsp;但是React可以实现的领域将更加广泛，这也让我更加深刻明白为什么三大框架最热的就是React。]]></content>
      <categories>
        <category>前端</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>࠷JavaScript</tag>
        <tag>ࡁReat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】 2019年1月回顾 | 2月学习计划]]></title>
    <url>%2Fposts%2F642ecb99.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;又好久没有更新博客，最近感觉自己逐渐开始失去更新博客的动力。&emsp;&emsp;今天大年初一，抓紧时间将文章写好。&emsp;&emsp;最近想学习的东西6越来越多，但是真正去学习的时间却越来越少。&emsp;&emsp;1月份大多数时间都是在测试Ziva插件，这个过程遇到了很多的坑，走了很多的弯路，感觉自己的经验还是严重匮乏。&emsp;&emsp;当然这个过程中也有承担一些其他开发的任务。 一月份总结VertexConstraintDeformer &emsp;&emsp;这个插件是我第一次尝试利用OpenMaya的API来开发Maya的变形器。&emsp;&emsp;也是为了给Ziva的流程添砖加瓦的产物。&emsp;&emsp;弄这个东西花费了我一个多星期的时间，到头来就是本末倒置了。&emsp;&emsp;不过我觉得研究出来也是成就感满满的事情。 &emsp;&emsp;当时我们研究Ziva插件要如何才能更好地结合到真实的使用当中，经过追光大神的指点，我们认为需要对Ziva骨架肌肉进行切分，分段模拟比较适合。&emsp;&emsp;然而切分模型会弄乱模型的点序号，导致Blendshape无法正常起作用。&emsp;&emsp;而这里我要开发的就是独立于点序号之上的Blendshape效果，更详细的文章内容可以参观我的博文。 &emsp;&emsp;虽然最后这个开发并没有发挥多大的用处，不过这个过程学习到的东西真的是受益匪浅。&emsp;&emsp;另外也为我后面进一步的开发OpenMaya相关的用法奠定了基础。 Cam_Route_Manager &emsp;&emsp;这个插件的开发是针对于摄像机那边的工作所做的。&emsp;&emsp;具体的详情其实我也写在了公司的花木马当中，还需要年后将相关的内容搬运出来。&emsp;&emsp;其实开发这个东西的时候，我正好也在开发自己的 UI2CG 2.0 工具。&emsp;&emsp;我所想要的开发效果就是能够开发出可以点选的面板，为此进行尝试。&emsp;&emsp;针对Item进行多重信息的绑定。 &emsp;&emsp;这么说可能有点复杂，到时候有图有真相，其实就和maya的ChannelBox差不多。&emsp;&emsp;点选Item的时候可以在属性面板上面显示Item的相关属性。&emsp;&emsp;当然这次开发也遇到不少的坑，特别是复选框勾选需要BlockSingal的支持，真的让我大开眼界。&emsp;&emsp;另外还是要吹一波Stackoverflow，很多问题都是在上面解决的。 Ziva_Panel &emsp;&emsp;这个东西其实是讲Ziva相关的功能全部集成到一起的界面而已。&emsp;&emsp;本质上很多代码我们先前就已经写好了，只是调用起来，开发难度也不是很大。&emsp;&emsp;不过我为了让它的功能更加强大，又在各个方面做了很多努力。 &emsp;&emsp;为了加快皮肤的制作效率，我想到可以通过获取外层模型和紧身衣模型的边界，然后通过边界来生成边界模型。&emsp;&emsp;然而在边界线的选择上研究好长一段时间，最后我发现polyselect当中有相关的选择过滤功能。&emsp;&emsp;另外选中边界之后是模型所有的边界，还需要将它们逐一过滤成单个循环边的边界。&emsp;&emsp;过滤出各个边界模型之后就可以通过他们之间的边序号对应来生成单个面。&emsp;&emsp;最后就是将生成的面逐一合并即可。 &emsp;&emsp;另外为了更好的给模型添加Attachment，我还想到了通过体积去选择相关的点。&emsp;&emsp;再次感谢强大的Stackoverflow，我再次通过这个平台找到了相关的解决方案。&emsp;&emsp;其实说来也很神奇，空间上点在一个模型的内部的时候，只要这个模型是封闭模型。&emsp;&emsp;那么这个空间上点在任意位置发射射线都必定与封闭模型产生奇数个交点。&emsp;&emsp;倘若是在模型之外发射射线的话则必定是偶数个交点。&emsp;&emsp;一开始我还没接受过来，在脑海里想了一下，似乎这个东西就是那么神奇。&emsp;&emsp;利用这个方法可以遍历模型上所有的点来进行过滤，从而筛选出在另一个模型上顶点。&emsp;&emsp;遗憾的是遍历所有的顶点始终是个头疼的效率问题。 一月总结 &emsp;&emsp;一月份感觉自己做了很多东西，也感觉自己没做什么。&emsp;&emsp;最主要还是没有好好管理好自己的安排，为此我在某一天看了个视频之后心血来潮，要拿起软件来管理好自己的时间。&emsp;&emsp;然而我重新去翻找相关的时间管理工具，感觉市面上没有一款是完美贴合自己的需求的。&emsp;&emsp;这个过程中也是找到了几款不错的APP，比如说Trello，这种看板模式我是非常喜欢的。&emsp;&emsp;而且这个APP可以线上使用，VScode也有部分extension,只是功能限制还是有点大的。&emsp;&emsp;我希望最后可以开发出一个APP，既可以支持看板、也可以支持todoList、以及四象限分区等等各种功能，另外还要有统计功能。&emsp;&emsp;在这之上，我还想要有类似于LifeRPG等任务APP，有个人属性成长功能，就像游戏一样。&emsp;&emsp;最后就是要制作一个VScode Extension 来无缝将所有的功能衔接到IDE上。&emsp;&emsp;因此市面上根本就不可能存在一款如此贴合自己需求的应用，为此只能自己研究Android开发。&emsp;&emsp;我知道这个道路是漫长的。&emsp;&emsp;但是我还是希望自己能够将相关的东西做好。 &emsp;&emsp;一月份虽然测试Ziva感觉自己快要圆寂了，不过也没有那么糟糕。&emsp;&emsp;整体而言，没有太过振奋人心的东西，平平淡淡才是真。&emsp;&emsp;这个月准备过年，当中也无数次期待一月份赶紧结束。&emsp;&emsp;这个月公司也开了年会，感觉浩大得很。 &emsp;&emsp;至于反省，还是有的。&emsp;&emsp;这个月的时间管理依旧是不合格的，虽然自己有自己开发时间管理软件的想法，但是路漫漫其修远兮。&emsp;&emsp;当下我需要拿起现有的软件走起来，否则时间就白白流失了。 二月学习计划 Android 开发 React Native 学习 &emsp;&emsp;最近深刻体会到自己需要一款APP来追踪自己的任务进度。 &emsp;&emsp;正如上面提到的，市面上已有的APP并不能很好满足我目前需要的用户体验，因此，我才打算自学APP开发。&emsp;&emsp;反正程序员学多点东西总该是好的。&emsp;&emsp;甚至后面可以考虑一下小程序的开发。&emsp;&emsp;最近发现利用前端知识也可以开发APP甚至是基于 Electron 开发桌面应用，因此也打算学一波。]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - 镜头路线管理器]]></title>
    <url>%2Fposts%2Ff6caaeeb.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个工具是根据摄像机处理的需求进行制作的。&emsp;&emsp;摄像机的Maya制作遇到了这样的一个问题。&emsp;&emsp;首先这里的摄像机是针对于乐园的缆车运作所制作的Maya摄像机场景，主要目的是观测缆车所带动的摄像机运动是否符合预期的效果。&emsp;&emsp;当前已经有一个制作好的在轨道上能加速减速的人眼摄像机，而另外有18个镜头则是针对于单个银幕运动的摄像机（其实最开始还不清楚的）&emsp;&emsp;当前需要做的就是讲18个摄像机相关的关键帧提取出来，然后将关键帧覆盖到人眼摄像机上。&emsp;&emsp;然而这18个摄像机的情况却很复杂。&emsp;&emsp;首先路径的坐标不一致，另外所有的曲线关键帧都被偏移到1000帧左右的地方开始。&emsp;&emsp;所以我还需要将相关的关键帧重新偏移到正确的位置。&emsp;&emsp;并且想办法让人眼摄像机逐一跟随单一场景的摄像机来完成整一段的动画。 任务对接 &emsp;&emsp;和我对接的是专门负责摄像机模块的李城佑。&emsp;&emsp;或许因为主要弄摄像机的缘故，他对Maya这方面的操作还不太熟悉，因此在开发的需求上也让我很难把握到位。&emsp;&emsp;刚开始的时候，我和沟通要完成这个工作，需要做些什么，哪些步骤是我可以协助完成的。&emsp;&emsp;至于我自己也确实对相机这方面不太熟悉，虽然苏老板已经事先给我说明了大体的情况，但是更多的细节还是得和李城佑对接好。&emsp;&emsp;因此我对于这一块的疑问也是很多的，所以就在咨询的过程中，我们两个人都开始不断蒙逼。&emsp;&emsp;最让我困惑的地方在于交接过来的相机文件时间都是在1000帧左右开始的。&emsp;&emsp;当时我们都对于这个数据感到巨大的困惑,这些数据怎么才能匹配到人眼摄像机呢？人眼摄像机可是有上万帧的。&emsp;&emsp;于是我们围绕这个讨论很长时间，以至于我们两个人都蒙逼了。&emsp;&emsp;后面我自己拿出这些相机与人眼摄像机进行匹配，发现他们的位置对应的时间都是不一致的，因此我就更加混乱了。 &emsp;&emsp;后面我向李城佑求解，他也糊涂了，所以最后向摄像机方面的大佬李宸前辈求解了。&emsp;&emsp;前辈说这个摄像机其实比不是对应到人眼摄像机上，毕竟这里有前跟踪段和后跟踪段。&emsp;&emsp;所以这里的时间具体是指公园里荧幕上所投放视频的时间长度。&emsp;&emsp;前跟踪段是进入镜头的时间，后跟踪段是从镜头出去的时间。&emsp;&emsp;从场景文件可以看到，镜头与镜头之间是存在交错的，&emsp;&emsp;这番理论瞬间仿佛点醒了梦中人。&emsp;&emsp;不过前辈认为，所有镜头只是偏移了时间，偏移时间的目的是为了方便调整，那么理论上镜头的所有运动应该都是相互匹配的。&emsp;&emsp;然而我们当着他的面去匹配之后，发现还是会有错位的情况。&emsp;&emsp;因此前辈说这个就不对了，赶紧测试一下哪些镜头是有偏差的，向上面汇报。&emsp;&emsp;于是恍惚间，我似乎就不需要开发插件了，李城佑对好有问题的摄像机向上面汇报即可。 &emsp;&emsp;然而万万没想到，事情远远没有那么简单，第二天李城佑又找到我，重申了开发的需求，还是需要将所有的运动效果对到人眼摄像机上。&emsp;&emsp;于是我就开始了我的开发。 &emsp;&emsp;然而其实我并没有完全理解清楚需求，我只是知道尽然要偏移关键帧，那么需要在每个摄像机文件中提取出 motionPath 的节点。上面有对应的关键帧可以供我偏移进行参考。&emsp;&emsp;于是我看到了这些 MotionPath 的关键帧是这样的。&emsp;&emsp;经过代码偏移之后，我发现这些 MotionPath 的关键帧都是有些不同的。&emsp;&emsp;那个时候我才真正明白，这个些镜头可能都是在人眼摄像机的关键帧信息上面修改的，所以正确的信息只有文本所提到的部分。&emsp;&emsp;我要根据文本所提到的时间提取出相关的关键帧，随后将影响关键帧的motionPath偏移到1开始的地方，从而提取出正确的部分。 &emsp;&emsp;在我研究的过程中，李城佑也没有闲着，他手动将所有的关键帧偏移并且放到了合适的位置。&emsp;&emsp;我拿到了他的新的文件的时候还没有弄懂这些关键帧为什么是偏移的，反而让我蒙逼了。&emsp;&emsp;于是我又跟他讨论了好久，我认为他的locator很可能都是不对的，因为对不上MotionPath的位置（毕竟他偏移过了，只是我当时不知道）&emsp;&emsp;所以我要求他以导入的MotionPath坐标为基准，也就是导入的摄像机为基准，Locator的坐标很可能某些操作的原因而不对的。&emsp;&emsp;不过我当时也发现这个逻辑似乎有点问题的，如果是导入错误导致了偏移，那么locator应该不会只是在曲线上错位的。&emsp;&emsp;李城佑也似乎被我给说糊涂了，所以就接受了我的观点，不过如此一来，他之前做的大量工作似乎都白费力气了。 &emsp;&emsp;这个时候李宸前辈出来了，他指出这里导入的摄像机都是没有意义的，一切还是以Locator为基准，并且提供了一个神奇的解决方案。&emsp;&emsp;只要让人眼摄像机和相关的镜头摄像机的MotionPat一一对应就可以实现效果了。&emsp;&emsp;确实这样可以完成任务，而且还插件还不太好搞了。&emsp;&emsp;但是如此操作，locator似乎就没有存在的意义了，于是我虽然理解意思，但是对这样操作反而愈发的感到混乱。&emsp;&emsp;经过了解才知道，locator是为了方便约束而弄出来的东西。&emsp;&emsp;不过经过我这一番折腾，李城佑也对开发失去了信心吧，他坚持要手动将这个工作做好。&emsp;&emsp;而我还是觉得用约束的方案可能调整起来会更加便利一点，于是我又开始了插件的制作。 插件开发 &emsp;&emsp;在开发的时候,其实苏老板的意思很简单。&emsp;&emsp;只要做出一个面板方便约束就可以了。&emsp;&emsp;但是我考虑后面的相机制作的情况，还是决定开发一个可扩展使用的插件。&emsp;&emsp;于是就有了现在插件的雏形。&emsp;&emsp;我开发计划是左边是可以添加镜头的区域，而右边则是属性面板。&emsp;&emsp;因为最近搞Ziva的空隙之余，我就在弄自己的 UI2CG 2.0 插件。&emsp;&emsp;当时就研究了 item 的概念，也就是可以增加减少的控件，这样可以大大增加插件的灵活性。&emsp;&emsp;这里我将这个概念再发挥一下，将属性面板也开发出来。&emsp;&emsp;为了实现这个效果，我将界面拆分成四个模块。&emsp;&emsp;MainWindow是包含下面的下拉菜单的部分。&emsp;&emsp;左边是摄像机面板，右边是属性面板，而滚动区域则是摄像机item的区间。&emsp;&emsp;这个三个东西都通过 QSplitter 放到了有下拉菜单的主界面下。 镜头Item &emsp;&emsp;其实刚开始觉得添加这种可以增加减少的UI会很复杂。&emsp;&emsp;其实并没有想象中那么困难。&emsp;&emsp;用不同的ui文件就是为了让UI文件对应不同的类，从而实现实例化的多个item效果。&emsp;&emsp;当点击添加镜头的时候，就实例化一个镜头对象而已。&emsp;&emsp;至于删除也是相当简单的，给item对象添加删除功能，点击删除按钮触发删除自身就好了。&emsp;&emsp;清空镜头则稍微复杂了一点点。&emsp;&emsp;需要先获取 scrollArea 中的 chilren，然后遍历所有的chilren来删除。&emsp;&emsp;上面这些都不难，反而比较困难的是如何给每个对象合理安排编号和名称。 &emsp;&emsp;我在编号的问题上卡了一段时间，一开始我认为编号应该依附在对象上的，所以保存导出之后还要读取编号。&emsp;&emsp;但是由于Json的导入是无序的（当然后面上网查了之后就是有序导入了），所以编号还是根据当前存在的chilren数量来生成。&emsp;&emsp;另外当删除的时候如何确保后续的编号都是正确的还需要经过遍历，并且让后续的编号逐个减1，这个也是研究好一会才做好的。 点击事件管理 &emsp;&emsp;由于这次用了自定义的Item对象，所以点击触发事件就不是简单的信号槽可以实现的。&emsp;&emsp;这次是给左边的摄像机面板添加了mousePressEvent事件，这样就实现点击任意区域实现触发。&emsp;&emsp;当然这个过程还需要检索是否点击在合适的区域，因此还需要进行判断。&emsp;&emsp;幸好Qt的Geometry函数提供了 Contains 的碰撞检测，这样就可以通过点击的坐标是否和item存在关联进行过滤。&emsp;&emsp;然而这个点击触发的坐标其实是不准的，在纵坐标上存在偏移，经过手动的测试，我发现90的偏移值就是刚刚好不偏不倚的。&emsp;&emsp;通过这个偏移就可以实现点击Item将信息显示到属性面板上。&emsp;&emsp;然而当我将Item的数量加多了之后，ScrollArea 的偏移也会影响到这里的坐标。&emsp;&emsp;最后我给ScrollArea添加了检测时间，当滚动触发的时候记录滚动的偏移值来加入到这里的碰撞检测当中。 点击显示效果 &emsp;&emsp;其实我原本只是想，当点击了Item之后可以有一个效果反馈，说明点中了这个区域。&emsp;&emsp;实现原理也不复杂，就是使用样式表就可以了。&emsp;&emsp;然而却在这里栽了跟头。&emsp;&emsp;首先这里的样式表不能单纯的setStylesheet填写CSS字符串，因为这样的话整个Item包括所有的子对象都会受到样式表的影响。&emsp;&emsp;所以这里需要通过 # selector 来只影响到Item最外层的区域。&emsp;&emsp;然而我这么操作却始终看不到效果。&emsp;&emsp;经过了一大轮的测试之后，我发现问题的原因居然是QWidget。&emsp;&emsp;我在Qt Designer 上输入样式表是可以看到红色的轮廓的，但是Maya里面却显示不出来。&emsp;&emsp;后面我尝试着将 QWidget 换成 QFrame ，就实现了我想要的效果了。 属性管理 &emsp;&emsp;相对来说，比较复杂的部分是设置面板的部分。&emsp;&emsp;因为点击每一个Item都需要属性面板获取相关的数据从而呈现不同。&emsp;&emsp;所以这里还要给Item类添加上和属性面板关联的属性。&emsp;&emsp;如此一来就可以点击这些Item的时候可以读取到这些属性，从而显示到属性面板上。 Json 导入导出记录 &emsp;&emsp;其实这个部分并不复杂，却十分重要。&emsp;&emsp;最重要是需要将Item中所有属性全部读取出来，后续再读取回来。&emsp;&emsp;主要遇到的问题就是 Json 读取写入都是无序的。&emsp;&emsp;经过 stackOverflow 的搜索 找到了解决方法。 约束 Checkbox &emsp;&emsp;其实我原以为这个功能非常简单。&emsp;&emsp;但是在这种可扩展的Item类中却成了棘手的问题。&emsp;&emsp;原本约束复选框是想实现点击复选框之后当前Item对应的约束属性改为1，其他属性改为0。同样的这里其他的复选框选项也要去掉。&emsp;&emsp;所以我的思路就是点击复选框的时候，遍历chilren 取消所有的复选框选择，最后再勾上当前选择的复选框。&emsp;&emsp;然而直接这么操作的话，在取消选择过程中，也会触发复选框的 Signal&emsp;&emsp;最后会导致复选框之间产生递归，我操作不当还造成了死循环。&emsp;&emsp;这个问题很棘手，经过在stackoverflow的一番查找之后，我总算是解决了问题。&emsp;&emsp;主要需要用到 blocksignal 函数来屏蔽掉 信号槽之间的互相触发。 使用流程 &emsp;&emsp;打开插件的默认状态是这样的。 基准镜头获取 &emsp;&emsp;点击基准镜头，获取相关的数据。&emsp;&emsp;选择方法，选中相关的物体，点击按钮进行获取。 &emsp;&emsp;镜头组 - 轨道小车（约束的目标物体）&emsp;&emsp;locator - 轨道小车的MotionPath Locator&emsp;&emsp;曲线 - 获取轨道小车的路径&emsp;&emsp;MotionPath - 获取运动路径（选择曲线自动获取） 添加镜头 &emsp;&emsp;点击添加镜头可以生成镜头Item。&emsp;&emsp;右侧的属性面板可以获取相关的摄像机属性。&emsp;&emsp;选中相关的镜头组获取即可自动获取相关的子对象。 按钮功能 &emsp;&emsp;选择所有MotionPath可以选中相关MotionPath 节点&emsp;&emsp;批量偏移实现上面截图显示的偏移效果。&emsp;&emsp;镜头匹配可以对镜头的位置进行匹配。 &emsp;&emsp;批量添加约束会将镜头组下的locator批量对基准镜头进行点约束和旋转约束。&emsp;&emsp;同时会解锁开启约束和设置约束关键帧。 &emsp;&emsp;这一步之后可以移动面板的splitter，隐藏不必要的控件。 &emsp;&emsp;点击开启约束就会自动设置到约束节点的相关属性上。&emsp;&emsp;如果什么都不选就会约束到基准镜头上。 &emsp;&emsp;点击设置约束关键帧就会对相关的约束属性进行关键帧设置]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Ziva 设置参考]]></title>
    <url>%2Fposts%2F332f70b.html</url>
    <content type="text"><![CDATA[紧身衣模拟 注：紧身衣英文原文是fasica，意指皮肤和肌肉之间的夹层 第零步 将肌肉和骨骼全部转换为 Ziva Bone 注：肌肉也添加Bone，这里是为了制作紧身衣而不是模拟 将肌肉和骨骼全部转换为 给模拟的角色模型添加 Attachment 第一步zMaterial Rest scale &emsp;&emsp; 0.8 Pressure &emsp;&emsp; 60 zSolver Enable &emsp;&emsp; off (ChannelBox) 先设置这个参数 StartFrame &emsp;&emsp; 1 (ChannelBox) Collision Detection &emsp;&emsp; on Substeps &emsp;&emsp; 4 Max Newten Iterations &emsp;&emsp; 2 Gravity Y &emsp;&emsp; 0 zCloth - 设置关键帧第0帧 Rest Scale Envelope &emsp;&emsp; 0 Pressure Envelope &emsp;&emsp; 0 第20帧 Rest Scale Envelope &emsp;&emsp; 1 Pressure Envelope &emsp;&emsp; 1 由于 Zsolver 的 Envelope 属性不可以设置关键帧，可以退而求其次，禁用 Zcloth 的属性 第二步zSolver Enable &emsp;&emsp; on (ChannelBox) 第三步 开启播放 模拟紧身衣如果效果不理想 可以看到紧身衣的效果很混乱不堪，包裹效果不理想 zSolver Collision Point Spacing &emsp;&emsp; 0.003 可以调整这里的数值来使模拟的效果更精确，确保更多点呈现绿色，绿色说明是正确的碰撞 zCloth Contact stiffness Exp &emsp;&emsp; 10^6 如果衣服后崩塌或者错乱，可以降低这个数值 zBone Contact stiffness Exp &emsp;&emsp; 10^6 如果衣服后崩塌或者错乱，可以降低这个数值 理想效果 第四步 处理局部问题 可以看到紧身衣在局部区域没有包裹住模型 添加多一个Material层 zMaterial2 Rest scale &emsp;&emsp; 0.9 Pressure &emsp;&emsp; 300 zSolver Enable off (ChannelBox) 关掉演算可以提高绘制效率 zMaterial的权重根据节点顺序覆盖 先绘制需要的区域，然后可以平滑权重 在当前Ziva版本，zCloth尚不支持自我碰撞，紧身衣呈现效果有些许问题属于正常情况 第五步 手动修缮模型 最后可以将紧身衣复制出来，用雕刻工具去修复有问题的区域也可以用平滑工具来修缮紧身衣的表面 当上述操作完成之后，可以进行重拓扑步骤 第六步 模型重拓扑 官方使用了Mudbox 完成操作 重拓扑效果 第七步 通过zBuilder传递属性 导入重拓扑模型 zBuilder将信息重建到重拓扑的模型上（只要改掉名称就可以实现）zBuilder 不会重建关键帧，需要注意之前设置的关键帧要重新设置 第八步 对重拓扑模型再次模拟紧身衣效果 再次启动模拟一次，将新的模型复制，再用zBuilder重建一次 以上紧身衣就做好了 皮肤厚度模型制作 导出紧身衣模型到Wrap3官方由于Wrap3的软件问题跳过了该步骤(:зゝ∠)官方指出Maya也可以完成这个步骤，Wrap3效果更好，效率更高 Wrap3 处理之后合并模型呈现的效果 我所理解的大致操作思路 打开Wrap3 导入原先的外层模型 导入紧身衣模型 通过映射将紧身衣模型映射成原先外层模型的大小 将新的模型导回 Maya 复制一个新的紧身衣模型 （旧的紧身衣有Ziva的属性，后续还有用） 将外层模型和新的紧身衣模型桥接合并成皮肤模型 Ziva 皮肤模拟 记得重新K帧 两个Envelope通道 给皮肤模型添加Tissue 默认情况这个精度太大了，不够细 zTet &nbsp; =&gt; Tet Size &emsp; 3 &emsp;&emsp;降低 Tet size 提高精度 选择紧身衣模型再选择皮肤模型，进行attachment操作 zMaterial &nbsp; =&gt; Mass Density &emsp; 106 &emsp;&emsp; 给重力设置关键帧zSolver &emsp; =&gt; Gravity &emsp; 0 &emsp;第1帧zSolver &emsp; =&gt; Gravity &emsp; -9.8 &emsp;第5帧 zSolver &emsp; =&gt; Substeps &emsp; 2 &emsp; 删除 zMaterial2 节点zMaterial &emsp; =&gt; Pressure &emsp; 1500 &emsp; 确保Tissue可以紧贴在紧身衣上 提高这个部分的网格精度 皮肤模拟流程第零步 预先见肌肉的动态效果模拟出来，并通过Blendshape传递做成Ziva Bone效果 第一步 给skin创建多一个Material用来区分内层和外层参数。 两个Material分别命名为 skin_baseMaterial 和 skin_innerMaterial skin_baseMaterial Mass Density &emsp;&emsp; 106 &emsp;&emsp; 注：其实是在原先的基础上除以10，目的是减少大范围移动的错位 skin_innerMaterial Mass Density &emsp;&emsp; 106 &emsp;&emsp; 注：其实是在原先的基础上除以10，目的是减少大范围移动的错位 将 skin_innerMaterial 的权重刷给内层的点可以通过内层的模型，用脚本获取皮肤上的点 第二步skin_baseMaterial Surface Tension &emsp;&emsp; 45 Pressure &emsp;&emsp; -2500 （根据法线方向定正负） skin_zTissue Surface Tension Envelope &emsp;&emsp; 给它设置一个从零开始的关键帧，确保一开始不会因为效果过于激烈而错误。 Pressure Envelope &emsp;&emsp; 给它设置一个从零开始的关键帧，确保一开始不会因为效果过于激烈而错误。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenMaya - VertexConstraint插件开发]]></title>
    <url>%2Fposts%2Ff62b6398.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近这段时间根据公司的安排，一直研究Ziva插件要怎么用，如何才能更好更快地匹配到产线的使用上。&emsp;&emsp;为此我们一直绞尽脑汁想流程方案。&emsp;&emsp;虽然前路漫漫，不过我也确实得出了一些不错的方案可以参考使用。&emsp;&emsp;为了配合产线使用，大神指点我们，一定要让Ziva插件模块化，要实现各个身体可以切分的效果。&emsp;&emsp;尽管这样的操作十分复杂，但是建议确实是有用的。 &emsp;&emsp;于是我们根据切分制定了流程方案，但是却遇到了难题。&emsp;&emsp;切分出来的模型需要制作厚度，然后进行模拟，然后又要讲模拟的动态效果传递回最初的模型上面。&emsp;&emsp;这个操作无法使用Blendshape来实现，因为这个过程会导致点的ID发生变化。&emsp;&emsp;即便模型的拓扑是部分一致的，也无法将动态效果模拟过去。&emsp;&emsp;所以开发的目标很明确，我们需要改变Blendshape的算法，实现寻找模型上最近的点进行Blendshape对应的效果。 OpenMaya 研究 &emsp;&emsp;由于开发之前，我并不有深入使用过OpenMaya API，所以我只好从头开始学起。&emsp;&emsp;而且给我的时间也不多，毕竟这个开发的不确定因素实在是太大了，如果浪费过多的时间，会得不偿失的。&emsp;&emsp;因此我硬着头皮，顶着压力把这个东西开发出来了。 &emsp;&emsp;其实能有这样的成果，也多亏了之前绑定那边发了一个让我们去研究的OpenMaya插件。&emsp;&emsp;这个国外的插件开发者居然将这门神奇的插件开源了，真是万分感谢。&emsp;&emsp;这个插件就是 jlcolliderDeformer &emsp;&emsp;最开始了解到原来 OpenMaya API 有两个版本。&emsp;&emsp;那么首先想到纠结的就是用哪一个了，只是我在Autodesk的文档里面找来找去也找不到 OpenMaya API 1.0 的文档，无奈只好去学OpenMaya 2.0了。（其实1.0的文档就是 C++ API的文档，用法完全一致的，甚至说明里都提到有些函数无法用Python调用(:зゝ∠)）&emsp;&emsp;而且我看到国外的文章还是很推崇 2.0 的API，因为它是 pythonic 的，比较起 1.0 会容易接受很多。&emsp;&emsp;而且由于直接对接Maya C++ 的底层API，在运行效率上也非常可观。&emsp;&emsp;其实从这个角度完全可以吊打pymel了，pymel的优点就是pythonic，缺点就是运行效率太糟糕了。 &emsp;&emsp;所以我就开始从这个方向切入去研究学习。&emsp;&emsp;针对于如何找到距离模型的点最近的点的这个问题，我开始在 Bing 上面进行大量的搜索。&emsp;&emsp;特别是 VertexID ComponentID 更是我搜索的重中之重。&emsp;&emsp;最后我并没有找到太多合适的脚本，但是有一些OpenMaya 1.0 的脚本还是很值得参考的。ComponentID &emsp;&emsp;于是我就尝试深入研究这些代码是怎么运作。 MIt 命令 | 算法复杂度的思考 &emsp;&emsp;后面发现原来有一堆 MIt 开头的命令，这些命令都是 iterator 来的。&emsp;&emsp;最开始我并不理解为什么要使用这个东西来进行遍历，不过这个东西我在研究 C++ SFML 的时候也见到过，也不是什么稀罕的东西了。&emsp;&emsp;直到我看了 Maya Python API 教程之后我才清楚认识到，原来在数据结构的遍历中这个东西还是非常重要的。&emsp;&emsp;毕竟数据结构的遍历更多的不是for循环的线性结构了。&emsp;&emsp;很多都是树形结构了（学过数据结构真好，可以学以致用了）&emsp;&emsp;所以这个时候遍历就会用到 数据结构典型的 Next() 操作。 &emsp;&emsp;那么这个MIt结构优势在哪里呢？&emsp;&emsp;很明显就是直接接触底层代码，遍历很明确，那么执行速度就很快。OpenMaya 的执行效率基本就是体现在这个地方&emsp;&emsp;毕竟根据数据结构课程可以知道 for 循环越多，那么算法的复杂度就越高。&emsp;&emsp;但是算法的复杂度其实也是有前提条件的，我一直忽视了，那就是在大量数据进行比较的情况下。&emsp;&emsp;其实如果只是普通的操作，比如说添加一两个按钮，修改几个特定的参数。在数据量很少的情况下，是不需要考虑执行效率的。&emsp;&emsp;也就是代码越少越好，可读性越高越好，复用性越方便越好，可以减少大量的冗余的代码。&emsp;&emsp;但是如果考虑到大量数据的操作，那精简未必是好事，精简意味着很多底层调用通过别的API执行了。&emsp;&emsp;那么经过一层又一层才能到达最底层，这过程的算法复杂度可想而知，那么数据量一大，算法复杂度的问题就体现出来了。 &emsp;&emsp;以后在写Maya脚本的时候，遇到大量数据的处理操作可以考虑使用MIt进行遍历，而不是cmds库&emsp;&emsp;pymel可能写起来简洁，但是案例比较少，我这个人就是懒(:зゝ∠)，不想手写代码，容易错。 OpenMaya 2.0 坑爹之处 &emsp;&emsp;后面在研究OpenMaya 2.0 的如何获取最近点。&emsp;&emsp;发现 Maya2017 的文档里面有intersector 的构建说明。&emsp;&emsp;根据文档， intersector 需要执行 create 命令才可以正确操作。&emsp;&emsp;然而 create 函数我无论怎么传入变量，最后Maya2017都会报错，也不知道是什么原因。&emsp;&emsp;报错的显示似乎是我传入的参数不对，参数的个数多了，但是我少一个多一个参数都是很明显的传参错误。&emsp;&emsp;但是两个参数穿进去报的错就有点莫名其妙的参数不对，真的是让我头大。&emsp;&emsp;后来我决定用 1.0 去试试。&emsp;&emsp;这个时候我去查 C++ 的文档，打算死马当活马医了，没想到发现 C++ 文档就是 1.0 的文档了。&emsp;&emsp;于是经过重写之后，就可以运作了。 &emsp;&emsp;那就很奇怪了，随后我去查了2015的文档看看 2.0 的API是怎么写的。&emsp;&emsp;结果没想到2015的文档居然压根就不存在这个函数，没错就是没有intersector函数。&emsp;&emsp;那么答案感觉呼之欲出了，恐怕2017的时候 2.0 内部还有Bug 或者说还没有完善好。&emsp;&emsp;真是巨大的坑，而且一个不完善的API就无法做到向前兼容，那对兼用2015的公司流程来说是非常不好的。&emsp;&emsp;所以最后我决定不再弄 2.0 API，还是老老实实研究 1.0 去了&emsp;&emsp;而且看了 C++ 文档之后发现，C++ 有大量的案例，而 1.0 的使用本质和 C++ 差不多，只是用Python调用而已。&emsp;&emsp;所以从便于学习的角度来说，还是 1.0 真香。 VertexConstarint 开发 &emsp;&emsp;经过上面一波瞎折腾，我终于开始了 VertexConstraint 插件的开发。&emsp;&emsp;中途还速看了教程 Maya Python API ,我看得很快，特别是写代码的部分，感觉特别啰嗦，所以干脆直接看源码算了。&emsp;&emsp;后面还得总结一波这个教程，整体感觉还是非常非常不错的。 &emsp;&emsp;我拿了教程的 Ripple 插件观摩学习，在结合 jlcolliderDeformer 融会贯通。&emsp;&emsp;大致摸清楚了插件几个重要的点。 &emsp;&emsp;Maya插件必须包含注册、解注册函数，还要有 插件 id 插件名称等等。&emsp;&emsp;不过这些上面的脚本都提供了良好的模板供我复制修改。 &emsp;&emsp;通过上面两个脚本结合，我想到要实现这种类似Blendshape的效果，必须使用 变形器Deformer 来实现。&emsp;&emsp;在看文档的过程中也发现了一个地方介绍了Maya最基础的几种变形器方案。http://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__files_Writing_a_Deformer_Node_htm &emsp;&emsp;其中 Example 里面提到了四种不错的操作方案，没有想到既然有设置好的 Blendshape 方案 和 SkinCLuster 方案&emsp;&emsp;因此我产生疑惑了，我到底是用 MPxDeformerNode 还是用 MPxBlendShap 去实现&emsp;&emsp;最后我还是打算先用Deformer的方案，毕竟这个方案有参考呀。 &emsp;&emsp;按照这个思路我开始写代码，但是在如何将模型的点ID传入到变形器节点的问题上犯难了。&emsp;&emsp;我查阅了 C++ 的文档，官方确实提供了 ComponentList 这种数据类型传入。&emsp;&emsp;但是没有任何调用的参考，不知道1.0的 Python 代码要怎么写了&emsp;&emsp;没办法，只好找 C++ Example 参考了，没先到相关的参考居然是 BasicBlendshape&emsp;&emsp;就是官方提供的 Blendshape 参考案例。http://help.autodesk.com/view/MAYAUL/2018/ENU/?guid=__cpp_ref_basic_blend_shape_2basic_blend_shape_8cpp_example_html &emsp;&emsp;既然如此，一不做二不休，直接去研究 MPxBlendShap 方案吧 MPxBlendShape 研究 &emsp;&emsp;花了不少的时间去研究 BasicBlendshape 案例，一开始将这个案例编译成 mll 去看看Maya的调用效果&emsp;&emsp;看起来也是一脸懵逼，因为它实现的效果不是和 Blendshape 一个样吗？&emsp;&emsp;看不出这个代码的优化在哪里呀，而且既然它本身就继承了 MPxBlendShap ，能够实现Blendshape的效果不是理所当然的吗？&emsp;&emsp;直到后面我将内部的代码修改了之后，发现 Blendshape 不灵了，这个时候我才知道，可能这代码就是Blendshape的实现方法吧。 &emsp;&emsp;后面继续注释研究 BasicBlendshape 的代码，不过有一段自己实在是无法理解。 1234567// inputPointsTarget is computed on pull,// so can't just read it out of the datablockMPlug plug( thisMObject(), inputPointsTarget );plug.selectAncestorLogicalIndex( multiIndex, inputTarget );plug.selectAncestorLogicalIndex( w, inputTargetGroup );// ignore deformer chains here and just take the first oneplug.selectAncestorLogicalIndex( 6000, inputTargetItem ); &emsp;&emsp;特别是上面的6000，完全不知道是哪里冒出来的数字……&emsp;&emsp;而且由于C++编译极其不方便的缘故，测试代码也非常麻烦。&emsp;&emsp;有些注释的地方也不知道自己的理解是否是正确的。&emsp;&emsp;于是，为了加深代码的理解，也为了方便后续测试。我决定将整个 C++ 转成 1.0 来写。（感觉自己的坑越开越大(:зゝ∠)） 2019-5-25 更新 &emsp;&emsp;现在我已经大概看得懂这部分的C++代码是什么原理了。&emsp;&emsp;这里是获取了 inputPointsTarget 属性 (blendshape 路径可以用 pymel 获取出来 blendShape1.inputTarget[-1].inputTargetGroup[-1].inputTargetItem[-1].inputPointsTarget)&emsp;&emsp;selectAncestorLogicalIndex 就是跳转到当前属性的序号。 &emsp;&emsp;通过截图就很清楚明白 6000 数字是怎么来的了。 2019-5-25 更新 &emsp;&emsp;重写的过程才发现，C++的有些代码特别奇怪。 1MArrayDataHandle inputTargetGroupMH = inputTargetH.child( inputTargetGroup ); &emsp;&emsp;查文档可以发现，这种情况的Child 应该返回的是 MDataHandle 而不是 MArrayDataHandle&emsp;&emsp;结果我在重写的过程中又在这两种方案中纠结了一段时间。&emsp;&emsp;最后测试发现，如果过完全不用Array的话 1.0 无法再现 C++ 的效果。&emsp;&emsp;所以 1.0 的代码之后写成这样了。 12from maya import OpenMayainputTargetGroupMH = OpenMaya.MArrayDataHandle(inputTargetH.child( self.inputTargetGroup )) &emsp;&emsp;看起来怪怪的，至少能用吧。&emsp;&emsp;搞了那么一大轮之后，我总算是把 BasicBlendshape 用 1.0 改写了。&emsp;&emsp;效果都可以实现，但是我发现Blendshape似乎并不适合实现我先要的效果。&emsp;&emsp;Blendshape的获取点属性内部截取的变量，而且不知道怎么定义哪些顶点跟哪些顶点进行对应&emsp;&emsp;（其实现在想了一下，也未不能实现，只是要加个plug来获取最近的顶点数据而已） OpenMaya 获取最近的顶点 &emsp;&emsp;所以经过一大轮的折腾之后，我最后还是决定回到最初的方案，用 MPxDeformerNode 的方案&emsp;&emsp;但是折腾了那么久我连最重要的功能都还没有实现呢？&emsp;&emsp;于是赶紧重新研究了一下，其实在搞C++之前，一直都在研究这个，只是那个时候见识还很肤浅而已。&emsp;&emsp;首先那个时候研究确定了两个方案，一个是 jlcolliderDeformer 里面使用的 intersector 方案。&emsp;&emsp;另一个则是我在网上搜索下来的方案。http://www.djx.com.au/blog/2013/07/07/get-closest-vertex-in-maya-using-python/&emsp;&emsp;两个方案我都测试过，intersector 的方案可能会麻烦一点，还需要矩阵支持。&emsp;&emsp;于是我就使用了后者的方案。 &emsp;&emsp;其实在研究OpenMaya之前，对于如何获取最近的点也是有方案的，只是计算量可怕得吓人。&emsp;&emsp;没错最简单的想法就是选一个模型的顶点，获取它的世界坐标。然后遍历另一个模型所有的点，获取每个点的坐标，计算和一开始顶点的距离，然后算出最近的点。&emsp;&emsp;这种方案也和上面提到 MIt 一样，如果不用OpenMaya的话，只要模型的点一多，算法复杂度的可怕就体现出来了，那就得等很长时间了。&emsp;&emsp;所以弄懂了 MIt 之后，使用 MIt 遍历就成了不二之选了。&emsp;&emsp;然而通过上面两个方案的提点，其实我发现遍历所有的点的计算量也是大得惊人的。&emsp;&emsp;所以发射射线去碰撞的方案才是比较节省资源的方案。（既然是三维数据，为啥还要以看不见数据的角度对待它，当然是用三维空间去搞它啦） &emsp;&emsp;所以方案2采用的就是 MFnMesh 的 getCloestPoint 方法&emsp;&emsp;一开始我没有理解清楚两个传入的点信息的含义，直到后面才搞懂了。&emsp;&emsp;第一个点是外部的点，因为我先要计算两个模型之间最近的点组成对，所以我这里的情况当然是另一个模型上的点。&emsp;&emsp;第二个点则是射线击中的当前模型的点，其实这个不重要，以为这个点不是 vertex 而是 point。也就是可以在模型的任何位置的点。&emsp;&emsp;最重要的是第四个参数可以获取当前模型被击中的面ID&emsp;&emsp;没错，第二个方案就是遍历这个面ID上的点来比较和目标点的距离，这样遍历就从整体缩小到了局部，计算量瞬间就少了很多。&emsp;&emsp;不过呢，第二个方案使用了pymel去遍历点，我个人来说还是懒得去学习它，既然 OpenMaya 效率更高就用 OpenMaya 写吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667from maya import OpenMayafrom maya import cmdssel = OpenMaya.MSelectionList()OpenMaya.MGlobal.getActiveSelectionList(sel) selList = cmds.ls(sl=1,tr=1)if len(selList) == 2: # Note 冻结变换 cmds.makeIdentity( selList[0],apply=True, t=1, r=1, s=1, n=0,pn=1) cmds.makeIdentity( selList[1],apply=True, t=1, r=1, s=1, n=0,pn=1) # Note 选择对应的顶点 nodeDagPath = OpenMaya.MDagPath() comp = OpenMaya.MObject() sel.getDagPath(0, nodeDagPath,comp) # Note 初始化变量 space = OpenMaya.MSpace.kWorld TargetNodeDagPath = OpenMaya.MDagPath() sel.getDagPath(1, TargetNodeDagPath) TargetMfnMesh = OpenMaya.MFnMesh(TargetNodeDagPath) # Note 获取 iterator itr = OpenMaya.MItMeshVertex(nodeDagPath, comp) # Note 定义变量 vertexList = OpenMaya.MSelectionList() faceList = OpenMaya.MSelectionList() TargetPoint = OpenMaya.MPoint() util = OpenMaya.MScriptUtil() util.createFromInt(0) idPointer = util.asIntPtr() while not itr.isDone(): # Note 获取最近的poly面序号 TargetMfnMesh.getClosestPoint(itr.position(), TargetPoint, space, idPointer) idx = OpenMaya.MScriptUtil(idPointer).asInt() # Note 将获取的面转为顶点 verticesList = OpenMaya.MIntArray() TargetMfnMesh.getPolygonVertices(idx,verticesList) closestVert = None minLength = None # Note 遍历顶点找出最靠近的顶点 for i in range(verticesList.length()): vertexPoint = OpenMaya.MPoint() TargetMfnMesh.getPoint(verticesList[i],vertexPoint) thisLength = vertexPoint.distanceTo(itr.position()) if minLength is None or thisLength &lt; minLength: minLength = thisLength closestVert = verticesList[i] # Note 通过序号获取面 faceName = "%s.f[%s]" % (TargetNodeDagPath.fullPathName(),idx) faceList.add(faceName) # Note 通过序号获取点 vertexName = "%s.vtx[%s]" % (TargetNodeDagPath.fullPathName(),closestVert) vertexList.add(vertexName) itr.next()# OpenMaya.MGlobal.setActiveSelectionList(faceList)OpenMaya.MGlobal.setActiveSelectionList(vertexList) &emsp;&emsp;终于经过这么长时间的折腾，插件最原本的开发终于步入正轨了。&emsp;&emsp;至于采用的方案也决定是 deformer 了。&emsp;&emsp;鉴于实现的效果并不复杂，于是我就直接将 Ripple 的脚本复制过来进行修改了。 节点生成 &emsp;&emsp;因为变形器还需要获取其他节点的信息，而且执行之前还需要获取出最近点的信息才可以。&emsp;&emsp;所以不可以直接就生成节点。&emsp;&emsp;根据 jlcolliderDeformer 的实现方法，他是将代码写在 Mel 中，通过GLobal proc 来进行全局调用。&emsp;&emsp;但是这样的实现方案没有办法直接迁移到 使用了 OpenMaya 的情况。&emsp;&emsp;于是我想到了 Ripple 节点的 AccesoryNodeSetup 函数&emsp;&emsp;这个函数可以在生成了节点之后在执行相关连接节点的操作。&emsp;&emsp;然而我在生成 MIt 遍历点的时候出错了，原因不明，毕竟这是插件内部的函数。&emsp;&emsp;因此只能在节点外部实现效果。&emsp;&emsp;既然如此，就得想办法让 Python 的函数声明全局调用了，就像MEL 的 global proc 一样。&emsp;&emsp;可是这个简单的想法却难以实现。&emsp;&emsp;网上搜了一下，基本上Python是没有全局函数的，只能是 导入相关的模块，或者加到一些 builtin 模块。&emsp;&emsp;经过了好多测试之后，最后我发现最好的是 Python 的 sys 模块。&emsp;&emsp;Maya不需要导入这个模块，而且每次重新打开Maya之后，相关的函数就会消失，没有污染。 数据传递 &emsp;&emsp;数据传递又算是回到了我之前开发卡壳的地方了。&emsp;&emsp;如何将获取到的顶点合适地传入到变形器节点中。&emsp;&emsp;其实最初的时候没有想到 cmds 的 setAttr ，我到这里的时候想到了 setAttr ，那么理论上是可以将数据传进去的。&emsp;&emsp;但是我先后尝试了componentArray int64Array stringArray 获取都失败了。&emsp;&emsp;按理来说数据类型是Array的话，那么获取的handle inputArrayvalue 才对的，然而这么获取就报错了。&emsp;&emsp;然而使用 inputValue 获取就是空数据。&emsp;&emsp;最后很无奈，只好将问题简化，直接将点数组的字符串传进去。&emsp;&emsp;反正在Python 有 eval 函数可以激活数组。&emsp;&emsp;最后的操作总算是成功了。&emsp;&emsp;只是每一次都会报出 EOF 的错误。&emsp;&emsp;于是我又在网上搜了一大轮，一直以为是传入的字符串有问题，需要改为raw的形式，可是各种尝试都无济于事。&emsp;&emsp;直到最后才偶然发现，这个报错只有第一次生成节点的时候才会发生，后面的代码都是正常的。&emsp;&emsp;我突然明白第一次生成节点的时候并没有传入任何字符串，也就是eval了空的字符串，所以才会报错。&emsp;&emsp;后面加入异常处理就好了。 使用效果 &emsp;&emsp;这个文件是我用来测试的插件的文件。&emsp;&emsp;这个文件是生成一个小球，然后复制一个小球，在删除其他面只留下一小部分的制作出来的。&emsp;&emsp;经过删除历史的操作之后，这个第二个小球的面和与原&emsp;&emsp;如果直接使用Blendshape &emsp;&emsp;会发生点的错落。 &emsp;&emsp;我这里的变形器则可以解决这个问题&emsp;&emsp;首先先选择小的模型再选择大的模型进行匹配&emsp;&emsp;加载插件之后就可以直接执行脚本编辑器上的函数，函数会检测是否选择了两个物体。&emsp;&emsp;运行之后可以看到节点编辑器里面，会多出一个 VertexConstraint 的变形器节点。&emsp;&emsp;这个时候大模型上点的运动就会带动小模型上的点。由于是根据最近的点进行匹配，没有点ID混乱的情况&emsp;&emsp;变形器也加入了权重处理，可以简单刷它的权重效果。 总结 &emsp;&emsp;研究OpenMaya API 对我而言机具挑战性，最后能够开发出来我还是很满足的。&emsp;&emsp;这次研究感觉自己发现了新大陆，并且感觉Maya的C++也并没有那么深奥。&emsp;&emsp;最后的最后，还是非常非常不喜欢 C++ 的编写 (:зゝ∠)&emsp;&emsp;其实有一个将 Maya C++ API 的教程提到了两者的区别。 C++ Python 执行效率高 Maya多版本兼容 闭源开发 Debug方便 &emsp;&emsp;总的来说，我个人还是更喜欢Python的编写，而且可以很方便地结合cmds的库一起使用，编写效率贼高。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - 外包检查工具开发]]></title>
    <url>%2Fposts%2F41495e54.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;在开发完TSM镜像工具不久之后，苏老板（技术部部长）就让我对接外包检查工具的开发。&emsp;&emsp;并且将开发的过程记录在内网的gitlab上面。&emsp;&emsp;这里部长给我推荐了 smartGit 软件，作为可视化的git工具，可以极大简化了git命令行操作的繁琐。&emsp;&emsp;也幸亏自己弄网页的时候有研究过git的使用方法，用起来问题不大。 开发目的 &emsp;&emsp;其实公司内部就已经有一套做好的检查工具，可以让产线的制作人员进行检查，确保制作的流程都是符合规范的。&emsp;&emsp;但是这次开发是为了给外面的外包公司对接用的，我要做的是在确保闭源的同时，还要保证插件的主要功能可以顺利运行。 界面开发 &emsp;&emsp;接到这个任务的时候，我已经将 UI2CG 的2.0版本做好了，所以界面开发完全不是问题。&emsp;&emsp;完全就是在之前的TSM镜像工具的界面上进行修改，所以基本就是套皮制作。&emsp;&emsp;现在唯一的难点就是需要将相关的检查信息输入到 Qt Designer 里面而已 插件开发 &emsp;&emsp;检查功能需要调用已经写好的 fantabox 里面的检查代码，里面的代码着实是够混乱的(/ω╲)&emsp;&emsp;所以后面我就是和徐思建进行对接，将工作做好。&emsp;&emsp;对我来说，这个插件的开发难度甚至还要低于TSM镜像工具，毕竟关键的检查功能不需要我去弄了。&emsp;&emsp;我主要是怎么将界面的信息显示好就可以了。&emsp;&emsp;上面就是最终的信息呈现效果&emsp;&emsp;这是之前的显示效果，确实之前的方法不好。&emsp;&emsp;之前最初的想法只是想将信息罗列出来，所以我是同过批量生成单行 textFiled 实现的。&emsp;&emsp;这样的实现第一个是无法选择，第二个是生成过程很慢，场景复杂要等待很久。&emsp;&emsp;为此我还特地给生成过程加了进度条，不爽了可以取消生成。&emsp;&emsp;当然这样是通不过上面的要求的。&emsp;&emsp;为了便于选择，在 textFiled 前面加上了按钮进行选择。&emsp;&emsp;结果还是没通过，因为这样只能单选而不能多选。&emsp;&emsp;于是徐思建给我提到用 cmds.textScrollList() 的功能可以实现多选的效果。&emsp;&emsp;于是我进一步开发就有了上面看到的效果 &emsp;&emsp;根据徐思建那边的要求，我也加入了检查设置的切换功能。&emsp;&emsp;为此还折腾了好久他们之前写的json格式&emsp;&emsp;最后总算是弄明白了这个json配置的运作原理。&emsp;&emsp;想到了这个是闭源的工具，如果json配置被修改了就很麻烦，但是如果写在代码里面就更加麻烦了。&emsp;&emsp;毕竟这些配置我们也是会修改的。&emsp;&emsp;所以最后我打算对这个文件加密，所以更具我之前所知道的加密方法，开发了 CHR_Encrypter ，加密操作可以查看我相关的文章&emsp;&emsp;最后实现的效果是这样的。&emsp;&emsp;我们这边可以通过我开发的 CHR_Encrypter 进行解密修改。 &emsp;&emsp;另外苏老板给出了意见，希望我这个工具可以见信息记录一份到摄像机上，另外本地又保留一份。&emsp;&emsp;log 文件本地记录功能&emsp;&emsp;将检查的问题记录在 log 信息中&emsp;&emsp;Maya 透视摄像机 Note&emsp;&emsp;其实这个过程开发也遇到了一些小坑&emsp;&emsp;最主要是摄像机的信息记录问题。&emsp;&emsp;一开始以为note属性就在摄像机当中，直接进行setAttr处理。&emsp;&emsp;后面才发现，原理新场景的摄像机都是不带note属性的，而且每当我将note的信息清空了之后，note属性就没了。&emsp;&emsp;所以我执行的时候必须确保要note属性来进行属性的修改。&emsp;&emsp;通过 Echo All Command 可以找到上面的Mel可以生成摄像机的note属性。&emsp;&emsp;这是一段外部的Mel脚本，不是内置的mel命令，所以无法通过Python去调用。 打包 &emsp;&emsp;毕竟这个插件是要闭源的，所以后面所有的代码都要统一打包成pyd的形式进行调用。&emsp;&emsp;我还要提取出fantabox相关的检查代码，统统打包起来。&emsp;&emsp;打包Pyd就需要技术部的邓志恒的帮忙，专门研究C++的人才，果然不同凡响。&emsp;&emsp;最初我的旧电脑不知道什么原因安装Visaul Studio 失败了，没办法用 cython 来编译文件，&emsp;&emsp;所以最初的测试我都得麻烦他给我打包。&emsp;&emsp;而我自己打包之后也遇到了 __file__ 路径的问题，经过好几种方案的测试之后，最后只好生成空文件，导入空文件的路径的方法了。&emsp;&emsp;后面我将检查工具相关的代码统统提取了出来，代码量有点多，而且这些代码又存在一些问题，再加上我的新电脑有了。&emsp;&emsp;于是就重新再新电脑上配置好所有的环境，我自己将所有的代码打包好了。&emsp;&emsp;中间虽然也遇到了些编码问题，不过我都妥善处理好了。 总结 &emsp;&emsp;原本这个东西的工作量不算太大，不过辗转反侧，还是干了差不多10多天吧，&emsp;&emsp;后续就是Ziva插件的研究，我需要重点突破 Python Maya API 的功能，实现点对点绑定的 Deformer]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - TSM镜像工具]]></title>
    <url>%2Fposts%2F50d67130.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个工具源于动画产线上的需求，需要制作一个工具实现TSM绑定的完全镜像。&emsp;&emsp;最初绑定部部长丸子给我了指出了大概的思路，然而我其实并没有完全弄明白。&emsp;&emsp;丸子指出Autodesk的Bounus工具里面有一个针对动画的镜像工具，然而这个工具用起来很是不方便。&emsp;&emsp;于是，让我想办法将工具的效果集成到TSM的绑定系统中。 &emsp;&emsp;那个工具的确可以实现动画镜像的效果，但是实现的过程让我有点迷，无非就是选中相关的轴向，然后对特定的变换通道反向赋值。 &emsp;&emsp;于是我照着葫芦画瓢做了第一版的镜像效果。&emsp;&emsp;由于我并没有完全理解产线需要的镜像效果，所以我完全按照镜像工具的原理镜像的效果是牛头不对马嘴的。 &emsp;&emsp;因此后面我和丸子再度沟通，丸子给我看了以前写好的ADV镜像工具，我才真正了解到产线的需求。&emsp;&emsp;产线需要做的就是让TSM角色左右对称的完美镜像，其实也不太难理解。 插件原理 &emsp;&emsp;需求明白了就好办了，接下来的工作就是撸起袖子干了。&emsp;&emsp;根据ADV镜像工具演示的效果，具体就是左右手和左右脚的控制器位置互换&emsp;&emsp;所以说我之前做的根本就是牛头不对马嘴，因为我只是在原先的位置信息上面变相反数而已，这样是达不到最终效果的，因为所有控制器不是以世界坐标的为原点的，况且要交换位置，单纯负值无法实现的 &emsp;&emsp;由于丸子给我演示的ADV镜像工具只能支持单帧镜像，我就打算开发个可以按照时间轴时间快速镜像的功能。&emsp;&emsp;然而正因为这个想法，一开始就把自己带到沟里去了。&emsp;&emsp;有时间范围的镜像固然是好的，但是如果连简单的单帧镜像方案都没有理顺的话，那么Debug的时间就被大大延长了。 &emsp;&emsp;所以到后来才吸取了教训。 插件界面 &emsp;&emsp;按照惯例，首先需要开发插件的界面&emsp;&emsp;看到这个界面是不是很熟悉，没错，这个就是在开发完了藤蔓生长工具之后，基于UI2CG功能快速生成的界面。&emsp;&emsp;原本是想着极大扩展插件的灵活性，如果插件的自动获取出问题了，也可以让产线手动去拾取正确的控制器的。&emsp;&emsp;但是这个界面交到丸子手里的时候就被否决了。&emsp;&emsp;原因是界面太复杂了，而且上面的标签切换也很容易让人误解，交互非常不友好(:зゝ∠)&emsp;&emsp;产线需要越简单越好的插件，最好就是只有一个按钮，点击就能完成工作。&emsp;&emsp;产线上的人不会去研究插件背后的原理，也不会去思考插件出问题自己解决，插件出问题了就会返工给我了(/ω＼)&emsp;&emsp;所以后面我就将界面大改，并且根据新的需求制作出了 UI2CG -ver 2.0.0 版本&emsp;&emsp;这个就是最终的界面设置，在制作这个界面的过程中也遇到了巨大的坑。&emsp;&emsp;编辑设置这个三个工能迁移够来其实没有多大的难度，而且后面通过重新整理 UI2CG 可以完美自动实现效果。&emsp;&emsp;至于另一个窗口切换的功能，这个就足足折腾了我四天时间，周六日都过来加班，就是为了能够让这个功能能够顺利实现。&emsp;&emsp;这其中最大的坑就是，直接使用Qt的 QAction 去实现Maya的界面切换会导致Maya全面崩溃。&emsp;&emsp;然而当时是什么原因我又一直弄不清楚，这才是最最最坑爹的地方。&emsp;&emsp;结果我需要打开一堆Maya。不断打开插件去测试到底是哪一行代码出问题了。&emsp;&emsp;因为一开始没有掌握到问题的规律，有时候点击 QAction 没有出现问题，有时候又出现问题，这增加了我无数的Debug时间。 &emsp;&emsp;经过反复测试之后，我发现workspace状态切换是没有问题的，但是其他状态的切换就会导致莫名其妙的崩溃。&emsp;&emsp;最最最让我无语的是，点击Maya的工具架按钮是不会出现问题的，或者用以前的按钮触发也是不会出现任何的问题的。&emsp;&emsp;于是我又去查Maya的错误日志，发现是Qt的动态链接库出问题了，但是看不懂日志上的问题根源。&emsp;&emsp;不过通过上面的点击现象，我联想到了之前网页开发的异步问题，我猜测问题就出在了弹出的菜单QMenu上。&emsp;&emsp;于是我又制作了一个测试用的插件，这次QMenu不集成在工具的上面，而是改用了右键触发的效果。&emsp;&emsp;不过在切换的过程中果然出现了相同的问题，更加印证了我之前的猜想。&emsp;&emsp;于是我想肯定是因为QMenu没有执行到删除命令，然而窗口的删除命令已经执行了，这个过程可能会到导致Qt崩溃。&emsp;&emsp;终于，在兜兜转转之后感觉自己靠近了问题的答案了。 &emsp;&emsp;于是我尝试通过在Python构建延时操作，类似于 JavaScript 的 settimeout 函数。&emsp;&emsp;在执行关闭命令之前先延时操作，让其他操作先执行。&emsp;&emsp;我首先想到的就是 Python 的 time 模块下的 time.sleep() 函数。&emsp;&emsp;然而这个操作让我失望了，它的延时的结果是导致Maya整体都冻结了。&emsp;&emsp;也就是执行切换命令，Maya和插件都无法动弹，等到冻结的时间过去之后 Maya 再崩溃。&emsp;&emsp;于是我又猜想，可能是因为 time.sleep() 函数 是单线程的缘故。&emsp;&emsp;于是我尝试了多线程的延时操作，又在网上查了一轮，也确实在multithread的模块下有多线程的延时方案。&emsp;&emsp;但是经过尝试还是导致了Maya的崩溃。 &emsp;&emsp;走到这里，我开始萌生退意了，兜兜转转的测试本身就和插件功能毫不相干，没有必要为了细节而牺牲了全部。&emsp;&emsp;但是最后我还是心有不甘，那么多时间的付出岂是说放下就放下的。&emsp;&emsp;于是我咬着牙在周日继续Debug。&emsp;&emsp;我打算重新整理思路，先找出到底是具体在哪一行的代码上出现了错误，能否通过一些方法对那行代码进行改良，甚至去掉。&emsp;&emsp;于是我重新投入到了崩溃循环中。&emsp;&emsp;终于功夫不负有心人，我最后发现是窗口重建过程中 cmds.deleteUI() 出问题了。&emsp;&emsp;而且问题还是限定在删除 dockControl 和 普通窗口上出问题。&emsp;&emsp;于是我就想，既然这样删除不可以，难道我就没有替代方案吗？&emsp;&emsp;没错，就是用Qt的deleteLater来删除这里窗口。&emsp;&emsp;果然,这个方案是完全没有问题的，唯一需要注意的是 dockControl 需要删除Parent才能完全删除而已&emsp;&emsp;折腾了那么久，总算是把自己想要的效果实现了，心情激动真的是难以言喻。&emsp;&emsp;于是我就继续开始优化切换窗口的显示效果。&emsp;&emsp;我发现DockControl的交互比较糟糕，经常切换完之后并没有显示在最上面，而是在右侧多了个标签。&emsp;&emsp;在这里我又想起了 ADV 插件，它就可以实现让 DockControl Dock在最上面的效果，于是我又翻开它的代码进行查询。&emsp;&emsp;虽然我的重点应该是在 dockControl 的那段代码上。&emsp;&emsp;但是看到前面那个命令，我简直不淡定了。Deferred这个单词我可是在研究JQuery异步的时候看到过的。&emsp;&emsp;这个东西不就是我之前想要实现异步的Maya提供的方案吗？&emsp;&emsp;于是我赶紧查了 evalDeferred 的文档，果然是针对我之前遇到的情况开发的异步接口。&emsp;&emsp;于是我将Qt的删除代码替换为 异步处理的 cmds.deleteUI()&emsp;&emsp;结果就再也没有报错了……&emsp;&emsp;兜兜转转的坑都是经验不足的锅呀，这么难的问题解决了，后续的问题都不太大。&emsp;&emsp;后面对UI的显示的一些优化也没有太大的问题，都可以轻松解决。 功能开发 &emsp;&emsp;终于经过了这么长时间的摸索之后，终于正式开始了功能上的开发了，说来真是让人惭愧(/ω＼)&emsp;&emsp;首先在 init 函数中 先将先关的TSM空间名称初始化。&emsp;&emsp;这样就可以简化大量的代码&emsp;&emsp;所以将相关的函数记录到数组中，一键获取的函数就几行代码就可以实现了。 &emsp;&emsp;下面就是重头戏，单帧镜像的实现。&emsp;&emsp;我的思路是先记录左右控制器的位置到相关的数组中，然后在将相关的数组赋值到对应的控制器上。&emsp;&emsp;不过由于中间的控制器只需要翻转数值就可以了，所以获取的过程可以顺便对中间的控制器进行镜像。&emsp;&emsp;至于哪些数值需要镜像哪些是不需要的，那就很难说清楚了，基本就是通过大量的时间测试出来的。（所以没有通用性）&emsp;&emsp;后续的代码都是镜像左右手脚上各个控制器的镜像。&emsp;&emsp;通过前面获取到的字典，一一将信息对应赋值。&emsp;&emsp;这个部分我初次开发是没有的，是到后来产线那边提出要求，也的确，只是左手右手的镜像还不够，其他相关属性的镜像也非常重要的。&emsp;&emsp;这里开发的最大难关在于 for 循环太多了，学过数据结构的我非常担心过多的for循环会不会大大增加运算的时间。&emsp;&emsp;但是为了实现效果，我也没有更好的方法了。想到后面还要对关键帧进行镜像，就能想像这要花费很长的时间来完成效果了。 &emsp;&emsp;先获取关键帧的镜像范围，后面还需要制作进度条来显示镜像进度&emsp;&emsp;其实这里的镜像操作和单帧镜像一致的，但是要加入关键帧的处理，就复杂了很多很多。 总结 &emsp;&emsp;其实功能开发也很坎坷，最主要是要理顺各个镜像物体的对应关系，花了不少的时间。&emsp;&emsp;不过付出是值得，当我看到TSM绑定在我的插件下完全镜像，真是满满的自豪感o(∩_∩)o]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】 2018年12月回顾 | 1月学习计划]]></title>
    <url>%2Fposts%2F4c4a3e97.html</url>
    <content type="text"><![CDATA[2018-12-21 写在前面 &emsp;&emsp;最近说来有点惭愧，来到华强方特一个多月了，一直没能找准学习与工作的平衡，以至于最近的博客一致更新缓慢(:з」∠)&emsp;&emsp;明明有一大堆东西想要更新，确实始终未能如愿。&emsp;&emsp;直到这几天，我才慢慢找到了一些平衡。&emsp;&emsp;或许也是因为自己天天加班，所以没时间更新，不过我自认为更多的却是没能把握好回到家里的时间。&emsp;&emsp;最近有了很多新的学习和制作方向，人工智能、atom形式的动画导出格式、绑定插件等等。&emsp;&emsp;每一样都非常具有挑战性，原本我指定计划还打算学习maya的API，恐怕计划要变更了。 &emsp;&emsp;这个月入职了追光大神，大我十岁的大神，在这行也算是摸爬滚打的元老人物了。&emsp;&emsp;我有幸和他一起参加新员工培训，从他身上学到东西，真的感到无比的幸运。&emsp;&emsp;虽然自己的能力表现出来了，部长和大神都挺看好我的，但是我还是时刻叮嘱自己要学习，戒骄戒躁。&emsp;&emsp;大神进来华强一方面是追光的工作太累了想找份安稳的工作，一方面是想改善华强这边的落后的流程。&emsp;&emsp;我希望自己能够进一步成长，能够在给他的工作添一份力。 &emsp;&emsp;所以我的学习计划不得不又进行修改了(:з」∠)&emsp;&emsp;不过还好，教程都已经准备好了，剩下的就是肝而已。&emsp;&emsp;人工智能确实复杂，但是倘若能将这个东西引入到CG的流程上的话，我觉得也是一项伟大的工作。&emsp;&emsp;或许自己的能力在同龄人中已经所向披靡了，但是我不够，我的目标不应该局限在国内，而是世界。 &emsp;&emsp;这么说下去，感觉确实有点中二了(/ω╲)&emsp;&emsp;怎么说呢？最近确实感觉自己有点飘飘然，实话实说吧，pyqt其实学了也不过2、3个也而已。&emsp;&emsp;但是能够那么快地落地，开发出很多有用的小工具，自己的成就感确实满满。&emsp;&emsp;最重要的是，自己开发的工具得到别人的认可，感觉贼棒。&emsp;&emsp;但是越是这样，我总觉得越不妙(:з」∠)&emsp;&emsp;所以最近一直在加班（其实进来华强之后基本都在加班了），也希望自己能够保持自己的学习动力，不断往前迈进。&emsp;&emsp;确实大公司的视野以及实战经验会是很不错的收获，但是如果止步不前，混吃等死的话是肯定完蛋的。 &emsp;&emsp;其实之前一直有种紧迫感，总能感觉到莫名的压力。&emsp;&emsp;直到最近终于在晚上加班的时候看教程才渐渐释然了，这个紧迫归纳或许是因为自己荒废了学习。&emsp;&emsp;其实有时候自己有不明白学那么多是为了什么，感兴趣吧就去学咯。&emsp;&emsp;原本高中的时候是怀揣着梦想去学的，感觉上了大学之后就幻灭了，估计是现实让梦破碎了吧。&emsp;&emsp;但是这样应该很颓废才对，我想大概自己也只不过是换了个方式颓废而已。。。 2019-1-11 写在后面 &emsp;&emsp;坚持写博客真的难，最近搞了个log，希望都给生活做些小记录（更多是为了应付公司的绩效考核(:з」∠)）&emsp;&emsp;最近看了一些教程也没有时间认真去总结一波教程的操作了额。&emsp;&emsp;明后两天就是周末，希望自己能够抽空更新一下博客，勿忘初心吧。 12月份总结 &emsp;&emsp;说来12月份我到底做了些什么呢？现在想来确实有点想不起来了。&emsp;&emsp;不过也还好，之前写绩效的时候有特别写了自己在12月份干了什么，总算还是有点印象的。 TSM 镜像工具 &emsp;&emsp;这个工具是我11月末到12月初制作的工具了，我还很清楚，那个时候追光大佬还没来公司呢!&emsp;&emsp;至于这个工具其实原理倒不复杂，但是想要制作好就不简单了。&emsp;&emsp;我这个插件也是根据之前开发的 Cap2Con 绑定约束插件模板进行开发的。&emsp;&emsp;只是丸子那边看到这个插件之后觉得过于复杂了，所以要就要简化，这些部分我都有在公司写博文的，后面发布出来。 Suport Partner 工具 &emsp;&emsp;这个工具也是花费我大量时间开发的东西，其实在最近的博文 CHR文件加密器中也可以找到这个工具的蛛丝马迹。&emsp;&emsp;这个工具就是外包检查工具，专门给外面的公司来使用我们公司已经写好的插件功能。&emsp;&emsp;这个部分的详细内容也写在公司的博文里面，以后有机会就发布出来。 龙IKFK绑定切换工具 &emsp;&emsp;这个东西我还花了两三天去开发插件，没想到最后居然理解错了绑定那边的意思，搞到后面就很尴尬，后果很严重。&emsp;&emsp;后面才发现原来功能都还没有呢？开发插件又有和意义，然后就投入到龙的IKFK的功能研究上。&emsp;&emsp;反正为了搞这个东西，那几天也是相当的痛苦，搞得我痛不欲生的，因为一直没有实际的成果。&emsp;&emsp;后面甩锅给绑定的部长，也算是了一件烦心事。 Ziva 插件研究 &emsp;&emsp;12月末接手的，那个时候刚完成了外包检查工具不久。&emsp;&emsp;到目前1月上旬，我都在为这个插件的开发而研究。&emsp;&emsp;而且为了弄好这个工具还专门去研究变形器去解决一些操作的难题。&emsp;&emsp;结果追光大神说其实我们完全跑偏了，部长是要我们测试这套插件适不适合投入到产线当中，然而我们一直都在纠结这套东西插线要怎么用。&emsp;&emsp;我们想到虽然很好，但是如果没有产线上通过的前提的话，这一切的研究都是无意义的。&emsp;&emsp;所以很无奈，直到最近才开始又不步入到烦人又繁琐的Ziva效果模拟当中。&emsp;&emsp;而且还要模拟各种动作的，最近都要忙着事情，希望可以在过年前有个成果。 1月计划 &emsp;&emsp;其实吧，这个1月我是没有什么计划的。&emsp;&emsp;快要过年了，想着表哥结婚，不免得有些期待（想到自己找到工作炫耀一番的意淫吧）&emsp;&emsp;哎，反正也是人之常情吧，总之好像快点到春节呀。&emsp;&emsp;至于1月份的计划，最近追光大佬让我去研究Alembic API 以及 Clariesse 在产线上的应用，后面要做针对性的开发。&emsp;&emsp;很好，我也正有此意，也希望自己的能力能够更快地提升，早日走向海外吧。]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Ziva 初步探索]]></title>
    <url>%2Fposts%2Fe3d81e44.html</url>
    <content type="text"><![CDATA[前言 Ziva是一款肌肉仿生插件，可以再 Maya 里面结算肌肉的碰撞，模拟出真实的肌肉效果。 今天我和吴智博商量有了初步的解决方案，方案有些复杂。我们采用模块化的解决方案以下是我们的操作流程 模型截取 导入我们设置好的肌肉组件 （截图效果仅供参考） 放置到模型合适的位置上 选择模型需要参与的面 截取这部分面 将截取的部分复制一个新的出来 制作皮肤模型 给这个面片赋予Ziva布料效果，调整参数模拟出收缩的紧身衣模型^1 复制一个紧身衣面片，并将其与原先截取出来的面片结合桥接出有厚度的皮肤模型^2 皮肤模型 Blendshape 再次选择皮肤模型上有厚度的表面进行提取复制（可以借助Ziva提供的插件完成选择工作） 这样就生成了两套外层皮肤模型，一个有厚度的皮肤模型，一个没有厚度的表层模型，厚度模型可以 Blendshape 到没厚度的模型上 再复制一个 表层模型 作为 中介模型 ，将 表层模型 和 截取外的皮肤合并回到一起^3 皮肤模型 可以 Blendshape 到 中介模型 上，再通过 中介模型 Blendshape 表层模型 上 ^4 ^5 表层模型模型上的接缝可以通过平滑法线来解决 驱动表层模型 将现在做好的表层模型再复制一个作为 渲染模型^6,同样地通过Blendshape链接到表层模型 给渲染模型添加 Ziva Tissue 效果 给 绑定模型 添加 Ziva Bone 效果 将两个模型 attachment 到一起 （世界坐标重合） 通过 attachment 可以实现 绑定模型 驱动 渲染模型^7 ^1: 创建紧身衣模型在于包裹住模型，从而更好地与肌肉碰撞^2: 紧身衣模型模型与原模型有很大差异，因此将两者何必为有厚度的模型通过 Ziva 的 Tissue 效果来达到更好的皮肤还原效果^3: 表层模型合并需要先选择表层模型再选择另外一部分的皮肤，这样操作是确保表层模型的点信息与中介模型一致,从而让Blendshape正常运作^4: 创建中介模型的目的在于确保 Blendshape 能够传递正确的驱动信息，因为厚度模型上的拓扑结构不一致，中介模型可以过滤掉这一层的影响^5: 截图上为了方便演示将三套东西分开了，理论上是合在一起的^6: 创建渲染模型的原因与中介模型一样，是为了避免历史造成的影响^7: Ziva的Attachment属于动力学范畴，需要播放进度条才能看到效果]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - CHR_Encrypter CHR文件加密器]]></title>
    <url>%2Fposts%2Fc5dbea3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近总算是找到自己的平衡时间了，所以开坑把自己一些东西记录一下。&emsp;&emsp;这个工具可谓是新鲜出炉，今天才刚刚弄好。&emsp;&emsp;其实原理一点也不复杂，具体的原理都是基于PLB下载器加密制作的。&emsp;&emsp;那么今天为啥突然来开发这么一个工具呢？&emsp;&emsp;其实完全自己没事找事弄出来的。&emsp;&emsp;公司需要给外包公司提供一个Maya的检查工具，公司内部是有一套的，但是又不想要把源码交给别人。&emsp;&emsp;所以就委托我把这个事情干了。&emsp;&emsp;我自己干得还行吧，虽然中途磕磕碰碰出了些许差错，但是还是出色地将工作落地了。&emsp;&emsp;在这个过程中涉及到了json的读写操作，json是明文文件，会被别人修改，或者说是将代码的一些核心暴露。&emsp;&emsp;这样确实不太好，于是我自己就基于PLB下载器的基础上延伸了加密方法，写了这次的加密工具。 加密原理 &emsp;&emsp;原理是相当简单， ASCII 和 unicode 都有一套编码系统来对应相关的字符。&emsp;&emsp;其实 ASCII 就属于 unicode 的子集，两者是完全不冲突的。&emsp;&emsp;那么感觉这个原理，如果将字符转换为对应的编号，然后对编号进行偏移，那么所有字符都自然成了乱码了。&emsp;&emsp;其实这个原理就和ABCD对应数字1234的加密是一样的。&emsp;&emsp;因此了解这个加密原理之后，就可以开始敲代码了。&emsp;&emsp;不过在此之前，如果获取到编号以及如何通过编号获取字符呢？&emsp;&emsp;这就需要介绍 Python 的 ord() 和 chr() 两个函数 Python ord() 函数 &emsp;&emsp; ord() 函数可以获取字符的编号 Python chr() 函数 &emsp;&emsp; chr() 函数可以将相关编号对应到字符上 自己定义的加密规则 获取当前时间 - 将时间以数字的形式相加 (年+月+日+时+分+秒) 这个值定义为 时间权重获取随机数 - 从 0 到 10000 范围的随机整数 这个值定义为 随机权重 加密信息存储如下：文件内容 - + 字符序号 + 时间权重 + 随机权重 偏移加密随机权重 - + 时间权重 偏移加密文件后缀 - + 时间权重 偏移加密时间权重 - + 1000 偏移加密备注信息 (可随意修改) 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143from PyQt4.QtCore import *from PyQt4.QtGui import *from PyQt4 import uicimport sysimport timeimport osimport tracebackimport randomdirname = os.path.dirname(__file__)UI_PATH = os.path.join(dirname,"ui",'CHR_Encrypter.ui')form_class , base_class = uic.loadUiType(UI_PATH)class CHR_Encrypter(base_class,form_class): def __init__(self): super(CHR_Encrypter,self).__init__() self.setupUi(self) self.Encrypt_Path_BTN.clicked.connect(self.Input_Browse) self.Decrypt_Path_BTN.clicked.connect(self.Output_Browse) self.Encrypt_BTN.clicked.connect(self.Encrypt_Fn) self.Decrypt_BTN.clicked.connect(self.Decrypt_Fn) def Input_Browse(self): File_Path = QFileDialog.getOpenFileName(self, caption="获取文件", directory=".") self.Encrypt_Path_LE.setText(QDir.toNativeSeparators(File_Path)) def Output_Browse(self): File_Path = QFileDialog.getOpenFileName(self, caption="保存文件到", directory=".") self.Decrypt_Path_LE.setText(QDir.toNativeSeparators(File_Path)) def Encrypt_Fn(self): Encrypt_Path = self.Encrypt_Path_LE.text() if Encrypt_Path == "": QMessageBox.information(self, "Information", "请输入文件路径") return File_Encrypt = "" RandEncrypt = "" TimeStampEncrypt = "" FileExtensionEncrypt = "" with open(Encrypt_Path,'r', encoding='UTF-8') as f: Data = f.read() rand = random.randint(1,10000) # 获取当前 年月日 时间戳 date = time.strftime('%Y-%m-%d-%H-%M-%S',time.localtime(time.time())).split("-") timeStamp = 0 for d in date: timeStamp += int(d) print (timeStamp) count = 0 for letter in Data: count += 1 File_Encrypt += chr(ord(letter)+rand+count+timeStamp) for letter in str(rand): RandEncrypt += chr(ord(letter)+timeStamp) for letter in str(timeStamp): TimeStampEncrypt += chr(ord(letter)+1000) for letter in Encrypt_Path.split(".")[1]: FileExtensionEncrypt += chr(ord(letter)+timeStamp) try: with open(Encrypt_Path+"_CHR",'w', encoding='UTF-8') as f: f.write(File_Encrypt+"\n"+RandEncrypt+ "\n" + FileExtensionEncrypt + "\n" + TimeStampEncrypt + "\n文件已经加密，请勿擅自修改\n如需解密请联系 820472580@qq.com") except: QMessageBox.information(self, "Information", "写入失败\n检查当前路径是否正确") return QMessageBox.information(self, "Information", "数据写入完成") def Decrypt_Fn(self): Decrypt_Path = self.Decrypt_Path_LE.text() if Decrypt_Path == "": QMessageBox.information(self, "Information", "请输入文件路径") return rand = "" Extension = "" File_Decrypt = "" timeStamp = "" count = 0 # createTime = os.path.getctime(Decrypt_Path) # timeStruct = time.localtime(createTime) # timeFeedback = time.strftime('%Y-%m-%d-%H-%M-%S',timeStruct) # for d in timeFeedback.split("-"): # timeStamp += int(d) # print (timeStamp) with open(Decrypt_Path,'r',encoding='UTF-8') as f: DataEncrypt = f.read() try: for letter in DataEncrypt.split('\n')[3]: timeStamp += chr(ord(letter)-1000) timeStamp = int(timeStamp) print (timeStamp) for letter in DataEncrypt.split('\n')[1]: rand += chr(ord(letter)-timeStamp) print (rand) for letter in DataEncrypt.split('\n')[2]: Extension += chr(ord(letter)-timeStamp) print (Extension) for letter in DataEncrypt.split('\n')[0]: count += 1 File_Decrypt += chr(ord(letter)-int(rand)-count-timeStamp) except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "文件解密失败") return try: with open(Decrypt_Path.split(".")[0]+"." + Extension,'w', encoding='UTF-8') as f: f.write(File_Decrypt) except: QMessageBox.information(self, "Information", "写入失败\n检查当前路径是否正确") return QMessageBox.information(self, "Information", "数据写入完成") app = QApplication(sys.argv)dl = CHR_Encrypter()dl.show()app.exec_() 运行效果 遇到的坑 &emsp;&emsp;其实开发这个插件并没有坑&emsp;&emsp;最大的坑在于插件使用Python3开发的，而在maya运行的时候是在Python2&emsp;&emsp;没想到 chr() 函数居然还有版本差异&emsp;&emsp;Python3 支持 65536 位 而 Python2 只支持 256 位&emsp;&emsp;结果就是Maya没办法执行解密操作(:з」∠)&emsp;&emsp;想到是版本差异造成的，也是我就一直试图让Python3的加密配合Python2&emsp;&emsp;于是我的解决方案改为编号求256的模，从而确保所有的编号都在256的区间中。&emsp;&emsp;那么解密就很麻烦，需要进行求模的逆运算。&emsp;&emsp;256应该是 ASCII 编号数，那应该求编号的时候也应该在 0 到 255 区间&emsp;&emsp;从而可以知道 x 的取值范围&emsp;&emsp;通过不等式并且y是整数的条件可以求出y的值&emsp;&emsp;回代方程可以求出x的值&emsp;&emsp;上述就是我想到的解决方案。&emsp;&emsp;然而我折腾了一个下午之后，发现解码是这样的&emsp;&emsp;其实可以看到非中文字符都已经还原了，没错非 ASCII 全部是乱码&emsp;&emsp;因为我上面的方法统统将它们转成了以 ASCII 码的形式显示了&emsp;&emsp;其实我最初的假设是错误的，也就是 ord() 获取的编号是会超过 256 的取值范围&emsp;&emsp;所以这种方法没办法还原其他字符 (:з」∠) &emsp;&emsp;后面我思来想去，决定让Python2的代码去兼容Python3的效果&emsp;&emsp;但是 chr() 的函数完全不一样了，难道还有什么替代方案了&emsp;&emsp;于是上网找呀找&emsp;&emsp;后面才发现，为什么 Python3 的 chr() 取值范围大了那么多。&emsp;&emsp;因为 Python3 默认的编码格式 unicode 而 Python2 的默认编码格式 ASCII&emsp;&emsp;更好就有了对应关系。&emsp;&emsp;如此一来，只要 Python2 也有 unicode 的处理方案 应该就可以了。&emsp;&emsp;没想到这一找还真有，Python2 有 unichr() 函数，可以实现unicode的字符获取&emsp;&emsp;功夫不负有心人，得来全不费工夫。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - 藤蔓生长快速绑定工具]]></title>
    <url>%2Fposts%2Fdc7fc7b9.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;开发藤蔓生长工具可谓是我进入方特一来第一项工作。&emsp;&emsp;难度也是有的，但是并非是无法做到的程度。&emsp;&emsp;当时设置部部长丸子找到我，让我尝试开发这个东西，并且当时给我看了他们当时绑定好的一些设置文件。&emsp;&emsp;其实这种绑定方法我已经很模糊了，但是大一的绑定教程还是有点印象的。&emsp;&emsp;于是我就兴高采烈的拿来进行研究。&emsp;&emsp;我发现这套绑定本质上和脊椎绑定基本相同，而神奇的地方在于设置了骨骼的缩放，从而实现了生长的效果。&emsp;&emsp;那么下面我就要去思考，如何通过插件来快速完成这个步骤。 UI界面开发 &emsp;&emsp;这次依旧是试用 Qt Designer 进行界面开发。&emsp;&emsp;在Maya上的显示效果。 UI功能开发 &emsp;&emsp;在之前开发好的 Alembic 导入导出助手的基础上，我继续加入自己所想要的功能。&emsp;&emsp;师兄建议如果界面的开发代码太多的话，希望能将界面的功能和按钮功能分开写。&emsp;&emsp;这样更加有条理，也让人更容易看懂。 Dockable Window &emsp;&emsp;使用ADV的时候，我偶然发现ADV是有Dock按钮的。&emsp;&emsp;如果window是可以Dock的话那么插件就可以随心所欲地摆放了。&emsp;&emsp;我觉得这种交互是非常人性化的，所以无论如何都要加到自己的插件当中。&emsp;&emsp;通过ADV我后面了解到 workspace 按钮是在 Maya2017之后才加入的全新工作区按钮&emsp;&emsp;在Maya2017以前的版本都是不支持的，在过去都是使用Dock方案&emsp;&emsp;在背后调用的 Maya cmds 是不一样的。&emsp;&emsp;因此我还要去研究如何获取Maya当前的版本，不过幸好ADV就是最棒的参考。&emsp;&emsp;所以后面我需要去研究 Maya 的 dockControl 和 workspaceControl 而已&emsp;&emsp;但是具体要怎么操作呢？又要如何和将这些东西和Qt界面结合在一起呢？ &emsp;&emsp;首先毋容置疑的，先解析 Qt Designer 生成的 ui 文件，具体的操作方法可以参照这里&emsp;&emsp;后面解析了ui文件就可以通过 setupUi 函数来生成 ui 文件的内容。&emsp;&emsp;但是这样生成的界面有个缺点，那就是它与Maya的主界面完全没有关联。&emsp;&emsp;当你点击一下Maya的窗口，Maya的窗口就会将其盖在下面，交互就很不人性化。&emsp;&emsp;不过幸好 Python For Maya Artist Friendly Programming 这个教程有提到过解决方案&emsp;&emsp;(我当时一直以为这样将教程的代码全部整理出来是很愚蠢的行为，现在真正干活的时候才体会到真香定律(:з」∠))&emsp;&emsp;那里提供了workspace的解决方案，原理就是通 OpenMaya API 获取到Maya窗口的元素，然后用Qt进行包裹调用。&emsp;&emsp;于是我就有样学样地整理出dockControl的写法。&emsp;&emsp;当然这个过程也查阅了不少的代码，最后三合一写法如下 123456789101112131415161718192021222324252627282930313233343536373839404142def Dock_Win_Management(self): Title_Name = u"藤蔓生长快速绑定工具" # Maya窗口转Qt的万能函数，网上搜罗出来的 def mayaToQT( name ): # Maya -&gt; QWidget ptr = omui.MQtUtil.findControl( name ) if ptr is None: ptr = omui.MQtUtil.findLayout( name ) if ptr is None: ptr = omui.MQtUtil.findMenuItem( name ) if ptr is not None: return wrapInstance( long( ptr ), QWidget ) if self.DOCK == "undock": # undock 窗口 # 这里判断是因为 在Maya2015测试的时候 cc（closeCommand）不起作用 if mel.eval("getApplicationVersionAsFloat;")&gt;=2017: self.undockWindow = cmds.window( title=Title_Name,cc=partial(self.closeEvent,self.event)) else: self.undockWindow = cmds.window( title=Title_Name,rc=partial(self.closeEvent,self.event)) # 给Maya窗口添加一个 Layout 防止后面获取不到 cmds.paneLayout() cmds.showWindow(self.undockWindow) ptr = mayaToQT(self.undockWindow) return ptr elif self.DOCK == "dock": # dock 窗口 window = cmds.window( title=Title_Name) cmds.paneLayout() self.dockControl = cmds.dockControl( area='right', content=window, label=Title_Name,floatChangeCommand=self.Win_Size_Adjustment,vcc=self.closeEvent) dock = mayaToQT(window) return dock elif self.DOCK == "workspace": # workspace 窗口 name='VineGrowDock' if cmds.workspaceControl(name,query=True,exists=True) : cmds.deleteUI(name) self.workspaceCtrl = cmds.workspaceControl(name,fl=True,label=Title_Name,vcc=self.closeEvent) cmds.paneLayout() workspace = mayaToQT(self.workspaceCtrl) return workspace &emsp;&emsp;如此一来，在初始化函数里面就可以调用这个函数来完成界面创建 1234567891011121314151617181920def __init__(self,dock="dock"): self.DOCK = dock # 读取当前DOCK属性 if os.path.exists(GUI_STATE_PATH): GUI_STATE = &#123;&#125; with open(GUI_STATE_PATH,'r') as f: GUI_STATE = json.load(f) self.DOCK = GUI_STATE["DOCK"] # 如果2017以下的版 将workspace转换为dock if mel.eval("getApplicationVersionAsFloat;")&lt;2017: if self.DOCK == "workspace": self.DOCK = "dock" self.ptr = self.Dock_Win_Management() super(Interface,self).__init__(parent=self.ptr) self.parent().layout().addWidget(self) self.setupUi(self) &emsp;&emsp;这样确实可以通过传入不同的参数来实现不同窗口的创建。&emsp;&emsp;然而我遇到了让我很头疼的问题，那就是如何去关闭窗口。&emsp;&emsp;如何实现像ADV那样，点击按钮之后自动重新打开我们想要的窗口类型。&emsp;&emsp;然而ADV是用MEL写的，是全局函数来的，而我这里是用Python的Class写的，如何才能实现在外部关闭窗口并且重新打开新的窗口就成了我最大的挑战。&emsp;&emsp;首先我需要在类里面写一个切换函数，但是切换函数又会调用到类本身来创建窗口，此处的类引用变量就无法在类外调用了。&emsp;&emsp;为了确保点击窗口之后不会创建一个全新的窗口，我需要确保类引用变量是一个全局变量，那么就不会在类里面创建调用自己而产生第二窗口。&emsp;&emsp;（想通这点可着实花了我好长时间，最主要是这里类里类外的，逻辑有点绕，写出来之后其实并没有那么复杂）&emsp;&emsp;方法是如此，但是因为我将UI界面和功能函数分开写，但是我又要调用功能函数去生成界面，所以就不得不把这部分的代码写在功能函数的脚本里面(:з」∠)&emsp;&emsp;(现在想来自己似乎有点傻，其实用UI界面去生成就完事了。) 1234567891011121314151617181920212223242526272829303132def Dockable_Window_Fun(self,dock="undock",save=True): # 保存当前UI界面 if save == True: self.DOCK = dock self.closeEvent(self.event) # 检测不同的UI 全部删除 try: if cmds.window(self.undockWindow,query=True,exists=True) : cmds.deleteUI(self.undockWindow) except: pass try: if cmds.dockControl(self.dockControl,query=True,exists=True) : cmds.deleteUI(self.dockControl) except: pass try: if cmds.workspaceControl(self.workspaceCtrl,query=True,exists=True) : cmds.deleteUI(self.workspaceCtrl) except: pass # 重置json 重置按钮调用的功能 if save == False: os.remove(GUI_STATE_PATH) global Vine_Grow_UI Vine_Grow_UI = Vine_Grow(dock=dock) Vine_Grow_UI.show() &emsp;&emsp;另外在外部调用则是写一个Main函数，这样也可以解决插件之间的冲突问题。 123456789101112131415161718192021222324def main(): # 检测不同的UI 全部删除 global Vine_Grow_UI try: if cmds.window(Vine_Grow_UI.undockWindow,query=True,exists=True) : cmds.deleteUI(Vine_Grow_UI.undockWindow) except: pass try: if cmds.dockControl(Vine_Grow_UI.dockControl,query=True,exists=True) : cmds.deleteUI(Vine_Grow_UI.dockControl) except: pass try: if cmds.workspaceControl(Vine_Grow_UI.workspaceCtrl,query=True,exists=True) : cmds.deleteUI(Vine_Grow_UI.workspaceCtrl) except: pass Vine_Grow_UI = Vine_Grow(dock="undock") Vine_Grow_UI.show() &emsp;&emsp;这样完整写下来就可以完美实现ADV的Dock功能，不管是按shelf Button 还是点击插件提供的按钮，都可以完美实现界面窗口的切换。 Json 加载保存重置功能 &emsp;&emsp;这次参考着之前开发出来的 PLB Downloader ，也打算弄成 json 可以导入导出，那样插件的所有设置的可控性会更强。&emsp;&emsp;开发的原理和 PLB Downloader 如出一辙的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263def Save_Json_File(self,path=GUI_STATE_PATH): GUI_STATE = &#123;&#125; # 判断物体是否存在，存在就存储 try: GUI_STATE['Rig_Obj_Text'] = self.Rig_Obj_Text.text() if len(cmds.ls(self.Rig_Obj_Text.text()))&gt;0 else "" except: return GUI_STATE['Start_JNT_Text'] = self.Start_JNT_Text.text() if len(cmds.ls(self.Start_JNT_Text.text()))&gt;0 else "" GUI_STATE['End_JNT_Text'] = self.End_JNT_Text.text() if len(cmds.ls(self.End_JNT_Text.text()))&gt;0 else "" GUI_STATE['Main_JNT_Num'] = self.Main_JNT_Num.text() GUI_STATE['IK_JNT_Num'] = self.IK_JNT_Num.text() GUI_STATE['Curve_Span_Num'] = self.Curve_Span_Num.text() GUI_STATE['IK_CTRL_ColorSlider'] = self.IK_CTRL_ColorSlider.value() GUI_STATE['Start_Ctrl_ColorSlider'] = self.Start_Ctrl_ColorSlider.value() GUI_STATE['End_IK_ColorSlider'] = self.End_IK_ColorSlider.value() GUI_STATE['Character_Ctrl_ColorSlider'] = self.Character_Ctrl_ColorSlider.value() GUI_STATE['Geo_Name_Text'] = self.Geo_Name_Text.text() GUI_STATE['Main_JNT_Name_Text'] = self.Main_JNT_Name_Text.text() GUI_STATE['Curve_Name_Text'] = self.Curve_Name_Text.text() GUI_STATE['IK_JNT_Name_Text'] = self.IK_JNT_Name_Text.text() GUI_STATE['IK_CTRL_Name_Text'] = self.IK_CTRL_Name_Text.text() GUI_STATE['Start_Ctrl_Text'] = self.Start_Ctrl_Text.text() GUI_STATE['End_IK_Text'] = self.End_IK_Text.text() GUI_STATE['Character_Ctrl_Text'] = self.Character_Ctrl_Text.text() GUI_STATE['X_RadioButton'] = self.X_RadioButton.isChecked() GUI_STATE['Y_RadioButton'] = self.Y_RadioButton.isChecked() GUI_STATE['Z_RadioButton'] = self.Z_RadioButton.isChecked() GUI_STATE['Delete_CheckBox'] = self.Delete_CheckBox.isChecked() GUI_STATE['Rig_Obj_Toggle_Check'] = self.Rig_Obj_Toggle_Check GUI_STATE['Loc_Generate_Toggle_Check'] = self.Loc_Generate_Toggle_Check GUI_STATE['JNT_Setting_Toggle_Check'] = self.JNT_Setting_Toggle_Check GUI_STATE['Rig_Generate_Toggle_Check'] = self.Rig_Generate_Toggle_Check GUI_STATE['Namespace_Toggle_Check'] = self.Namespace_Toggle_Check GUI_STATE['Window_Setting_Toggle_Check'] = self.Window_Setting_Toggle_Check GUI_STATE['Tab_Widget'] = self.Tab_Widget.currentIndex() styleSheet = self.IK_CTRL_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0]) g = float(styleSheet[1]) b = float(styleSheet[2].split(")")[0]) color = (r,g,b) GUI_STATE['IK_CTRL_ColorBtn'] = (color[0],color[1],color[2]) styleSheet = self.Start_Ctrl_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0]) g = float(styleSheet[1]) b = float(styleSheet[2].split(")")[0]) color = (r,g,b) GUI_STATE['Start_Ctrl_ColorBtn'] = (color[0],color[1],color[2]) styleSheet = self.End_IK_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0]) g = float(styleSheet[1]) b = float(styleSheet[2].split(")")[0]) color = (r,g,b) GUI_STATE['End_IK_ColorBtn'] = (color[0],color[1],color[2]) styleSheet = self.Character_Ctrl_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0]) g = float(styleSheet[1]) b = float(styleSheet[2].split(")")[0]) color = (r,g,b) GUI_STATE['Character_Ctrl_ColorBtn'] = (color[0],color[1],color[2]) GUI_STATE['DOCK'] = self.DOCK try: with open(path,'w') as f: json.dump(GUI_STATE,f,indent=4) return True except: QMessageBox.warning(self, "Warning", "保存失败") return Falsedef Load_File(self,path=GUI_STATE_PATH,load=False): if os.path.exists(path): GUI_STATE = &#123;&#125; with open(path,'r') as f: GUI_STATE = json.load(f) self.X_RadioButton.setChecked(GUI_STATE['X_RadioButton']) self.Y_RadioButton.setChecked(GUI_STATE['Y_RadioButton']) self.Z_RadioButton.setChecked(GUI_STATE['Z_RadioButton']) # 获取上次打开的text信息 self.Rig_Obj_Text.setText(GUI_STATE['Rig_Obj_Text']) self.Start_JNT_Text.setText(GUI_STATE['Start_JNT_Text']) self.End_JNT_Text.setText(GUI_STATE['End_JNT_Text']) self.Main_JNT_Slider.setValue(int(GUI_STATE['Main_JNT_Num'])) self.Main_JNT_Num.setText(GUI_STATE['Main_JNT_Num']) self.IK_JNT_Slider.setValue(int(GUI_STATE['IK_JNT_Num'])) self.IK_JNT_Num.setText(GUI_STATE['IK_JNT_Num']) self.Curve_Span_Slider.setValue(int(GUI_STATE['Curve_Span_Num'])) self.Curve_Span_Num.setText(GUI_STATE['Curve_Span_Num']) self.Tab_Widget.setCurrentIndex(int(GUI_STATE['Tab_Widget'])) self.Geo_Name_Text.setText(GUI_STATE['Geo_Name_Text']) self.Main_JNT_Name_Text.setText(GUI_STATE['Main_JNT_Name_Text']) self.Curve_Name_Text.setText(GUI_STATE['Curve_Name_Text']) self.IK_JNT_Name_Text.setText(GUI_STATE['IK_JNT_Name_Text']) self.Delete_CheckBox.setChecked(GUI_STATE['Delete_CheckBox']) self.IK_CTRL_Name_Text.setText(GUI_STATE['IK_CTRL_Name_Text']) self.Start_Ctrl_Text.setText(GUI_STATE['Start_Ctrl_Text']) self.End_IK_Text.setText(GUI_STATE['End_IK_Text']) self.Character_Ctrl_Text.setText(GUI_STATE['Character_Ctrl_Text']) if self.Rig_Obj_Text.text() != "": try: cmds.select(self.Rig_Obj_Text.text()) except Exception: pass self.Get_Rig_Obj() cmds.select(cl=True) if self.Start_JNT_Text.text() != "": try: cmds.select(self.Start_JNT_Text.text()) except Exception: pass self.Get_Start_JNT() cmds.select(cl=True) if self.End_JNT_Text.text() != "": try: cmds.select(self.End_JNT_Text.text()) except Exception: pass self.Get_End_JNT() cmds.select(cl=True) self.Rig_Generate_Check() # 设置颜色滑竿 self.IK_CTRL_ColorSlider.setValue(int(GUI_STATE['IK_CTRL_ColorSlider'])) self.Start_Ctrl_ColorSlider.setValue(int(GUI_STATE['Start_Ctrl_ColorSlider'])) self.End_IK_ColorSlider.setValue(int(GUI_STATE['End_IK_ColorSlider'])) self.Character_Ctrl_ColorSlider.setValue(int(GUI_STATE['Character_Ctrl_ColorSlider'])) # 设置按钮颜色 if mel.eval("getApplicationVersionAsFloat;")&gt;=2017: r = GUI_STATE['IK_CTRL_ColorBtn'][0] g = GUI_STATE['IK_CTRL_ColorBtn'][1] b = GUI_STATE['IK_CTRL_ColorBtn'][2] self.IK_CTRL_ColorBtn.setStyleSheet('background-color:rgb(%s,%s,%s)'%(r,g,b)) r = GUI_STATE['Start_Ctrl_ColorBtn'][0] g = GUI_STATE['Start_Ctrl_ColorBtn'][1] b = GUI_STATE['Start_Ctrl_ColorBtn'][2] self.Start_Ctrl_ColorBtn.setStyleSheet('background-color:rgb(%s,%s,%s)'%(r,g,b)) r = GUI_STATE['End_IK_ColorBtn'][0] g = GUI_STATE['End_IK_ColorBtn'][1] b = GUI_STATE['End_IK_ColorBtn'][2] self.End_IK_ColorBtn.setStyleSheet('background-color:rgb(%s,%s,%s)'%(r,g,b)) r = GUI_STATE['Character_Ctrl_ColorBtn'][0] g = GUI_STATE['Character_Ctrl_ColorBtn'][1] b = GUI_STATE['Character_Ctrl_ColorBtn'][2] self.Character_Ctrl_ColorBtn.setStyleSheet('background-color:rgb(%s,%s,%s)'%(r,g,b)) else: # 设置滑竿颜色 self.Slider_Change_Color(self.IK_CTRL_ColorBtn,self.IK_CTRL_ColorSlider.value()) self.Slider_Change_Color(self.Start_Ctrl_ColorBtn,self.Start_Ctrl_ColorSlider.value()) self.Slider_Change_Color(self.End_IK_ColorBtn,self.End_IK_ColorSlider.value()) self.Slider_Change_Color(self.Character_Ctrl_ColorBtn,self.Character_Ctrl_ColorSlider.value()) # 根据上次打开的记录expand 或者 collapse 标签 self.Rig_Obj_Toggle_Check = GUI_STATE['Rig_Obj_Toggle_Check'] self.Loc_Generate_Toggle_Check = GUI_STATE['Loc_Generate_Toggle_Check'] self.JNT_Setting_Toggle_Check = GUI_STATE['JNT_Setting_Toggle_Check'] self.JNT_Setting_Toggle_Check = GUI_STATE['JNT_Setting_Toggle_Check'] self.Rig_Generate_Toggle_Check = GUI_STATE['Rig_Generate_Toggle_Check'] self.Namespace_Toggle_Check = GUI_STATE['Namespace_Toggle_Check'] self.Window_Setting_Toggle_Check = GUI_STATE['Window_Setting_Toggle_Check'] self.Window_Setting_Toggle_Fun() self.Rig_Obj_Toggle_Fun() self.Loc_Generate_Toggle_Fun() self.JNT_Setting_Toggle_Fun() self.Rig_Generate_Toggle_Fun() self.Namespace_Toggle_Fun() self.Window_Setting_Toggle_Fun() self.Rig_Obj_Toggle_Fun() self.Loc_Generate_Toggle_Fun() self.JNT_Setting_Toggle_Fun() self.Rig_Generate_Toggle_Fun() self.Namespace_Toggle_Fun() return True else: if load==True: QMessageBox.warning(self, "Warning", "加载失败\n检查路径是否正确") return False # 设置默认属性 self.IK_JNT_Slider.setValue(5) self.Main_JNT_Slider.setValue(20) self.Curve_Span_Slider.setValue(15) self.Slider_Change_Color(self.IK_CTRL_ColorBtn,17) self.Slider_Change_Color(self.Start_Ctrl_ColorBtn,18) self.Slider_Change_Color(self.End_IK_ColorBtn,13) self.Slider_Change_Color(self.Character_Ctrl_ColorBtn,14)def Save_File_Fun(self): Save_Path = self.Save_Path_Text.text() check = self.Save_Json_File(path=Save_Path) if check == True: QMessageBox.information(self, "保存成功", "保存成功")def Load_File_Fun(self): Load_Path = self.Load_Path_Text.text() check = self.Load_File(path=Load_Path,load=True) if check: QMessageBox.information(self, "加载成功", "加载成功") def Browse_Save_File_Path(self): save_file = QFileDialog.getSaveFileName(self, caption=u"保存文件到", directory=".",filter="json (*.json)") if type(save_file) is tuple: save_file = save_file[0] self.Save_Path_Text.setText(QDir.toNativeSeparators(save_file)) self.Save_Path_Label.setVisible(False) self.Save_Path_GetBtn.setVisible(True) try : self.Save_Path_GetBtn.clicked.disconnect() except: pass self.Save_Path_GetBtn.clicked.connect(partial(self.Open_Directory,self.Save_Path_Text))def Browse_Load_File_Path(self): save_file = QFileDialog.getOpenFileName(self, caption=u"保存文件到", directory=".",filter="json (*.json)") if type(save_file) is tuple: save_file = save_file[0] self.Load_Path_Text.setText(QDir.toNativeSeparators(save_file)) self.Load_Path_Label.setVisible(False) self.Load_Path_GetBtn.setVisible(True) try : self.Load_Path_GetBtn.clicked.disconnect() except: pass self.Load_Path_GetBtn.clicked.connect(partial(self.Open_Directory,self.Load_Path_Text))def Open_Directory(self,LineEdit): Save_Location = LineEdit.text() if Save_Location == "": Save_Location = os.getcwd() else: Save_Location_temp = Save_Location.split('.')[0] if Save_Location_temp != Save_Location: Save_Location = os.path.split(Save_Location)[0] if os.path.exists(Save_Location): subprocess.call("explorer %s" % Save_Location, shell=True) else: QMessageBox.warning(self, "警告", "路径不存在\n检查路径是否正确") &emsp;&emsp;这个就是json记录加上导入导出的功能，其实并不复杂，导入导出就是参考 PLB Downloader 改写的。&emsp;&emsp;至于存储和载入功能就更为简单，基本上 Alembic 导入导出工具一致&emsp;&emsp;在这个过程中最繁琐的是要写这些UI保存的代码，极度花费时间，所以这个也促成了我开发UI2CG软件的意图。 颜色按钮处理 &emsp;&emsp;这个插件的其他UI功能都不算是太复杂，位移复杂一点的地方就是参考节点的对调按钮。&emsp;&emsp;但是也不过是让获取的参考对调而已，其实底层就和变量交换一样。&emsp;&emsp;所以让我最头疼的开发是 颜色按钮 的开发。&emsp;&emsp;不过幸好 Python For Maya Artist Friendly Programming 这个教程也有相关的解决方案。&emsp;&emsp;但是不幸的是教程的解决方案是针对灯光颜色的控制，而我需要的是对曲线进行着色。&emsp;&emsp;在不同的Maya版本中，颜色控制也不大一样。&emsp;&emsp;在Maya2015测试的时候，颜色控制制选择滑竿提供的颜色。&emsp;&emsp;而在Maya2017测试的时候则可以选择任意的颜色控制。&emsp;&emsp;因此我需要想办法模拟出Maya这种滑竿改变颜色的效果同时又可以启用颜色编辑器来编辑颜色的效果。&emsp;&emsp;本来我是想用Maya自带的颜色组合GUI的，但是这样按钮的颜色就没有办法启用颜色编辑器来修改了。&emsp;&emsp;所以我想了一个办法来模拟滑竿改变颜色的效果，那就是将滑竿颜色的数据记录成json数据，滑动滑竿的时候再次调用写好的json数据。&emsp;&emsp;原理既然如此，后面实现就相对简单了。 123456789101112131415161718192021222324252627282930def setColor(self,Btn=None): # 获取灯光的颜色 styleSheet = self.IK_CTRL_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0])/255 g = float(styleSheet[1])/255 b = float(styleSheet[2].split(")")[0])/255 Btn_Color = (r,g,b) cursor = QCursor() # 打开 Maya 的颜色编辑器 color = cmds.colorEditor(rgbValue=Btn_Color,m=True,pos=[cursor.pos().x(),cursor.pos().y()]) # Maya 返回了字符串 # 我们需要手动将其转换为可用的变量 r,g,b,a = [float(c) for c in color.split()] # 设置新的颜色值 Btn.setStyleSheet('background-color:rgb(%s,%s,%s)'%(r*255,g*255,b*255)) self.Save_Json_File()def Slider_Change_Color(self,Btn,Index): COLOR_INDEX = &#123;&#125; with open(COLOR_INDEX_PATH,'r') as f: COLOR_INDEX = json.load(f) r = COLOR_INDEX[str(Index)][0] g = COLOR_INDEX[str(Index)][1] b = COLOR_INDEX[str(Index)][2] Btn.setStyleSheet('background-color:rgb(%s,%s,%s)'%(r,g,b)) self.Save_Json_File() 藤蔓生长制作 &emsp;&emsp;经历上面各种UI的苦难，我们终于可以回归到插件本身的功能来了。&emsp;&emsp;藤蔓生长的原理是怎样的，其实我最初是一脸茫然的，幸好绑定部门给我提供了一个样品。&emsp;&emsp;基于这个样品，我才研究出方法。 &emsp;&emsp;藤蔓生长不过是使用了线性IK，也就是带曲线的IK控制器，并且将每根骨头的缩放值链接到控制器上。&emsp;&emsp;通过控制器的数值来调整骨骼的缩放值。&emsp;&emsp;另外也要在曲线上蒙皮一套驱动骨骼，用来更方便地控制曲线（这个方法就是当初我入门绑定的时候的脊椎的绑定方法，影响深刻）&emsp;&emsp;实现起来不难，难在如何更具两个参考物体，生成固定数量的骨骼。&emsp;&emsp;经过一番摸索之后，我发现可以根据两个坐标的差值，求平均然后循环递增，就可以求出两个坐标之间的距离。&emsp;&emsp;通过平均可以求出每个骨骼的位置，从而实现藤蔓的根骨骼。&emsp;&emsp;随后就是控制器的创建了，如果骨骼是偏移的，又如何才能求出控制器的旋转值呢？&emsp;&emsp;幸好Circle命令提供了根据曲线方向旋转的方法，如此一来，只要输入坐标差值，曲线就会自动沿着曲线方向了。 &emsp;&emsp;后面，最大的问题就是要整理藤蔓生长绑定的层级，公司有制定了一套完整的命名规则。&emsp;&emsp;不过经过问题不大，毕竟绑定部门提供的样品就是最好的范例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358# 一键生成按钮def Rig_Generate(self): ############################################## ########## 检查物体是否存在 ############ ############################################## if self.Rig_Obj_Check(): return # 开启还原按钮 self.Rig_Back_Btn.setEnabled(True) ############################################## ############# 获取变量 ############### ############################################## # 获取数值 Main_JNT_Num = int(self.Main_JNT_Num.text()) if self.Main_JNT_Num.text() != "" else 20 IK_JNT_Num = int(self.IK_JNT_Num.text()) if self.IK_JNT_Num.text() != "" else 20 Curve_Span_Num = int(self.Curve_Span_Num.text()) if self.Curve_Span_Num.text() != "" else 20 # 获取命名 Geo_Name_Text = self.Geo_Name_Text.text() if self.Geo_Name_Text.text() != "" else "TengMan" Main_JNT_Name_Text = self.Main_JNT_Name_Text.text() if self.Main_JNT_Name_Text.text() != "" else "gan_joint" IK_JNT_Name_Text = self.IK_JNT_Name_Text.text() if self.IK_JNT_Name_Text.text() != "" else "ganJoint" Curve_Name_Text = self.Curve_Name_Text.text() if self.Curve_Name_Text.text() != "" else "gan" IK_CTRL_Name_Text = self.IK_CTRL_Name_Text.text() if self.IK_CTRL_Name_Text.text() != "" else "gan_ctrl" Start_Ctrl_Text = self.Start_Ctrl_Text.text() if self.Start_Ctrl_Text.text() != "" else "main2" End_IK_Text = self.End_IK_Text.text() if self.End_IK_Text.text() != "" else "main" Character_Ctrl_Text = self.Character_Ctrl_Text.text() if self.Character_Ctrl_Text.text() != "" else "Character" # 获取按钮颜色 styleSheet = self.IK_CTRL_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0])/255 g = float(styleSheet[1])/255 b = float(styleSheet[2].split(")")[0])/255 IK_CTRL_ColorBtn = (r,g,b) styleSheet = self.Start_Ctrl_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0])/255 g = float(styleSheet[1])/255 b = float(styleSheet[2].split(")")[0])/255 Start_Ctrl_ColorBtn = (r,g,b) styleSheet = self.End_IK_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0])/255 g = float(styleSheet[1])/255 b = float(styleSheet[2].split(")")[0])/255 End_IK_ColorBtn = (r,g,b) styleSheet = self.Character_Ctrl_ColorBtn.styleSheet().split("(")[1].split(",") r = float(styleSheet[0])/255 g = float(styleSheet[1])/255 b = float(styleSheet[2].split(")")[0])/255 Character_Ctrl_ColorBtn = (r,g,b) ############################################## ############### 绑定 ############### ############################################## # 获取起始节点和结束节点坐标 cmds.select(self.Start_JNT) Start_JNT_Coordinate = cmds.xform(q=True,a=True,ws=True,piv=True) cmds.select(self.End_JNT) End_JNT_Coordinate = cmds.xform(q=True,a=True,ws=True,piv=True) cmds.select(cl=True) # 批量生成主关节 Xdistance = End_JNT_Coordinate[0] - Start_JNT_Coordinate[0] Ydistance = End_JNT_Coordinate[1] - Start_JNT_Coordinate[1] Zdistance = End_JNT_Coordinate[2] - Start_JNT_Coordinate[2] # 主控制器 cmds.circle( nr=(Xdistance, Ydistance, Zdistance), c=(End_JNT_Coordinate[0], End_JNT_Coordinate[1], End_JNT_Coordinate[2]),n=End_IK_Text,r=1) Main_Ctrl = cmds.ls(sl=True)[0] cmds.setAttr(Main_Ctrl + ".overrideEnabled",1) if mel.eval("getApplicationVersionAsFloat;")&gt;=2017: cmds.setAttr(Main_Ctrl + ".overrideRGBColors",1) cmds.setAttr(Main_Ctrl + ".overrideColorRGB",End_IK_ColorBtn[0],End_IK_ColorBtn[1],End_IK_ColorBtn[2]) else: cmds.setAttr( Main_Ctrl +".overrideRGBColors",0) cmds.setAttr( Main_Ctrl +".overrideColor",self.End_IK_ColorSlider.value()) cmds.setAttr(Main_Ctrl+".visibility",lock=True,keyable=False,channelBox=False) cmds.setAttr(Main_Ctrl+".sx",lock=True,keyable=False,channelBox=False) cmds.setAttr(Main_Ctrl+".sy",lock=True,keyable=False,channelBox=False) cmds.setAttr(Main_Ctrl+".sz",lock=True,keyable=False,channelBox=False) cmds.addAttr(ln="show_mod",at="double",min=0,max=1,dv=1) cmds.setAttr(Main_Ctrl+".show_mod",edit=True,keyable=True) cmds.addAttr(ln="grow",at="double",min=0,max=10,dv=10) for Main_JNT in range(Main_JNT_Num): x = Xdistance * Main_JNT / (Main_JNT_Num-1) + Start_JNT_Coordinate[0] y = Ydistance * Main_JNT / (Main_JNT_Num-1) + Start_JNT_Coordinate[1] z = Zdistance * Main_JNT / (Main_JNT_Num-1) + Start_JNT_Coordinate[2] JNT = cmds.joint( p=(x, y, z), n = Main_JNT_Name_Text + str(Main_JNT+1)) cmds.setAttr( JNT + ".tx", k=False,cb=True ) cmds.setAttr( JNT + ".ty", k=False,cb=True ) cmds.setAttr( JNT + ".tz", k=False,cb=True ) cmds.setAttr( JNT + ".rx", k=False,cb=True ) cmds.setAttr( JNT + ".ry", k=False,cb=True ) cmds.setAttr( JNT + ".rz", k=False,cb=True ) cmds.setAttr( JNT + ".sx", k=False,cb=True ) cmds.setAttr( JNT + ".sy", k=False,cb=True ) cmds.setAttr( JNT + ".sz", k=False,cb=True ) cmds.setAttr( JNT + ".visibility", k=False,cb=True ) cmds.expression( s=JNT + ".sx = "+ Main_Ctrl +".grow/10/"+str(Main_JNT+1) ) cmds.expression( s=JNT + ".sy = "+ Main_Ctrl +".grow/10/"+str(Main_JNT+1) ) cmds.expression( s=JNT + ".sz = "+ Main_Ctrl +".grow/10/"+str(Main_JNT+1) ) if Main_JNT == 0: Start_Main_JNT = cmds.ls(sl=True)[0] # 生成IK控制器 End_Main_JNT = cmds.ls(sl=True) cmds.select(Start_Main_JNT) cmds.select(End_Main_JNT,tgl=True) ikList = cmds.ikHandle(sol="ikSplineSolver" ) # 生成控制器 cmds.select(cl=True) CtrlList = [] for IK_JNT in range(IK_JNT_Num): x = Xdistance * IK_JNT / (IK_JNT_Num-1) + Start_JNT_Coordinate[0] y = Ydistance * IK_JNT / (IK_JNT_Num-1) + Start_JNT_Coordinate[1] z = Zdistance * IK_JNT / (IK_JNT_Num-1) + Start_JNT_Coordinate[2] cmds.joint( p=(x, y, z), n = IK_JNT_Name_Text + str(IK_JNT+1)) Curent_JNT = cmds.ls(sl=True)[0] IK_JNT_Coordinate = cmds.xform(q=True,ws=True,t=True) cmds.circle( nr=(Xdistance, Ydistance, Zdistance), c=(IK_JNT_Coordinate[0], IK_JNT_Coordinate[1], IK_JNT_Coordinate[2]),n=IK_CTRL_Name_Text+str(IK_JNT+1),r=0.4) IK_Ctrl = cmds.ls(sl=True)[0] cmds.setAttr( IK_Ctrl +".overrideEnabled",1) if mel.eval("getApplicationVersionAsFloat;")&gt;=2017: cmds.setAttr( IK_Ctrl +".overrideRGBColors",1) cmds.setAttr( IK_Ctrl +".overrideColorRGB",IK_CTRL_ColorBtn[0],IK_CTRL_ColorBtn[1],IK_CTRL_ColorBtn[2]) else: cmds.setAttr( IK_Ctrl +".overrideRGBColors",0) cmds.setAttr( IK_Ctrl +".overrideColor",self.IK_CTRL_ColorSlider.value()) cmds.CenterPivot() # 冻结变换 cmds.makeIdentity( apply=True, t=1, r=1, s=1, n=2 ) CtrlList.append(cmds.ls(sl=True)[0]) cmds.parentConstraint( CtrlList[IK_JNT] , Curent_JNT ) cmds.select(Curent_JNT) cmds.setAttr( Curent_JNT + ".tx", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".ty", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".tz", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".rx", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".ry", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".rz", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".sx", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".sy", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".sz", k=False,cb=True ) cmds.setAttr( Curent_JNT + ".visibility", k=False,cb=True ) if IK_JNT == 0: Start_IK_JNT = cmds.ls(sl=True)[0] # 将IK关节蒙皮到曲线上 cmds.select(ikList[2]) cmds.rebuildCurve( rt=0, s=Curve_Span_Num ) cmds.select(Start_IK_JNT,hi=True) cmds.select(ikList[2],tgl=True) # 绑定设置 cmds.optionVar(iv=('bindTo',2)) cmds.optionVar(iv=('skinMethod',1)) cmds.optionVar(iv=('multipleBindPosesOpt',1)) cmds.optionVar(iv=('bindMethod',1)) cmds.optionVar(iv=('removeUnusedInfluences',0)) cmds.optionVar(iv=('colorizeSkeleton',0)) cmds.optionVar(iv=('maxInfl',3)) cmds.optionVar(iv=('normalizeWeights',2)) cmds.optionVar(iv=('obeyMaxInfl',2)) cmds.SmoothBindSkin() # 绑定主物体 cmds.select(Start_Main_JNT,hi=True) cmds.select(self.Rig_Obj,tgl=True) cmds.SmoothBindSkin() ############################################## ############# 管理层级 ############### ############################################## # 删除参考 if self.Delete_CheckBox.isChecked(): cmds.delete(self.Start_JNT) cmds.delete(self.End_JNT) # 模型打组 cmds.select(self.Rig_Obj) Geo_Grp = cmds.group(n=Geo_Name_Text+"_geo") # 控制器打组 CtrlList = list(reversed(CtrlList)) Grp = "" for Ctrl in CtrlList: cmds.select(Ctrl) cmds.group(n=Ctrl+"_C") IKFKC_Grp = cmds.group(n=Ctrl+"_IKFKC") if Grp != "": cmds.parent( Grp, IKFKC_Grp ) cmds.select(IKFKC_Grp) Grp = cmds.group(n=Ctrl+"_G") # MotionSystem 打组 cmds.select(Start_IK_JNT) temp = cmds.group(n=Start_IK_JNT+"_G") cmds.setAttr(temp+".visibility",0) cmds.setAttr(temp+".visibility",lock=True) cmds.setAttr( temp + ".tx", lock=True ) cmds.setAttr( temp + ".ty", lock=True ) cmds.setAttr( temp + ".tz", lock=True ) cmds.setAttr( temp + ".rx", lock=True ) cmds.setAttr( temp + ".ry", lock=True ) cmds.setAttr( temp + ".rz", lock=True ) cmds.setAttr( temp + ".sx", lock=True ) cmds.setAttr( temp + ".sy", lock=True ) cmds.setAttr( temp + ".sz", lock=True ) cmds.select(Grp,tgl=True) MotionSystem_Grp = cmds.group(n="MotionSystem") # DeformationSystem 打组 cmds.select(Start_Main_JNT) Start_Main_JNT_Grp = cmds.group(n=Start_Main_JNT+"_G") cmds.setAttr( Start_Main_JNT_Grp+".visibility",0) cmds.setAttr( Start_Main_JNT_Grp+".visibility",lock=True) cmds.setAttr( Start_Main_JNT_Grp + ".tx", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".ty", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".tz", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".rx", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".ry", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".rz", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".sx", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".sy", lock=True ) cmds.setAttr( Start_Main_JNT_Grp + ".sz", lock=True ) DeformationSystem_Grp = cmds.group(n="DeformationSystem") # 主控制器打组 cmds.circle( nr=(Xdistance, Ydistance, Zdistance), c=(Start_JNT_Coordinate[0], Start_JNT_Coordinate[1], Start_JNT_Coordinate[2]),n=Start_Ctrl_Text,r=1) Main2_Ctrl = cmds.ls(sl=True)[0] cmds.setAttr(Main2_Ctrl + ".overrideEnabled",1) if mel.eval("getApplicationVersionAsFloat;")&gt;=2017: cmds.setAttr(Main2_Ctrl + ".overrideRGBColors",1) cmds.setAttr(Main2_Ctrl + ".overrideColorRGB",Start_Ctrl_ColorBtn[0],Start_Ctrl_ColorBtn[1],Start_Ctrl_ColorBtn[2]) else: cmds.setAttr( Main2_Ctrl +".overrideRGBColors",0) cmds.setAttr( Main2_Ctrl +".overrideColor",self.Start_Ctrl_ColorSlider.value()) cmds.setAttr(Main2_Ctrl+".visibility",lock=True,keyable=False,channelBox=False) cmds.setAttr(Main2_Ctrl+".sx",lock=True,keyable=False,channelBox=False) cmds.setAttr(Main2_Ctrl+".sy",lock=True,keyable=False,channelBox=False) cmds.setAttr(Main2_Ctrl+".sz",lock=True,keyable=False,channelBox=False) cmds.select(DeformationSystem_Grp) cmds.select(MotionSystem_Grp,tgl=True) cmds.select(Main2_Ctrl,tgl=True) cmds.parent() cmds.pickWalk( direction='up' ) Main2_Ctrl = cmds.ls(sl=True)[0] Main2_Ctrl_C = cmds.group(n=Main2_Ctrl+"_C") Main2_Ctrl_G = cmds.group(n=Main2_Ctrl+"_G") Main2_Ctrl = cmds.ls(sl=True)[0] cmds.setAttr(Main_Ctrl+".grow",edit=True,keyable=True) cmds.connectAttr(Main_Ctrl+".show_mod",Geo_Grp+".visibility") cmds.parent(Main2_Ctrl,Main_Ctrl) cmds.pickWalk( direction='up' ) cmds.group(n=Main_Ctrl+"_C") cmds.group(n=Main_Ctrl+"_G") Main_Ctrl_G = cmds.ls(sl=True)[0] cmds.curve(d=1, p=[(-1, 0,-1), (-1, 0,1), (1, 0, 1), (1,0, -1), (-1, 0,-1)], k=[0,1,2,3,4] ,n=Character_Ctrl_Text) Character = cmds.ls(sl=True)[0] cmds.setAttr(Character + ".overrideEnabled",1) if mel.eval("getApplicationVersionAsFloat;")&gt;=2017: cmds.setAttr(Character + ".overrideRGBColors",1) cmds.setAttr(Character + ".overrideColorRGB",Character_Ctrl_ColorBtn[0],Character_Ctrl_ColorBtn[1],Character_Ctrl_ColorBtn[2]) else: cmds.setAttr( Character +".overrideRGBColors",0) cmds.setAttr( Character +".overrideColor",self.Character_Ctrl_ColorSlider.value()) cmds.setAttr(Character+".visibility",lock=True,keyable=False,channelBox=False) cmds.xform(a=True,ws=True,t=(End_JNT_Coordinate[0], End_JNT_Coordinate[1], End_JNT_Coordinate[2])) cmds.parent(Main_Ctrl_G,Character) cmds.pickWalk( direction='up' ) cmds.group(n=Character+"_C") cmds.group(n=Character+"_G") Grp = cmds.group(n=Geo_Name_Text+"_rig") # 设置 other_G 中的属性 cmds.setAttr(ikList[2]+".visibility",0) cmds.setAttr(ikList[2]+".visibility",lock=True,keyable=False,channelBox=False) cmds.setAttr(ikList[0]+".visibility",0) cmds.setAttr(ikList[0]+".visibility",lock=True) cmds.setAttr( ikList[0] + ".tx", lock=True ) cmds.setAttr( ikList[0] + ".ty", lock=True ) cmds.setAttr( ikList[0] + ".tz", lock=True ) cmds.setAttr( ikList[0] + ".rx", lock=True ) cmds.setAttr( ikList[0] + ".ry", lock=True ) cmds.setAttr( ikList[0] + ".rz", lock=True ) cmds.setAttr( ikList[0] + ".sx", lock=True ) cmds.setAttr( ikList[0] + ".sy", lock=True ) cmds.setAttr( ikList[0] + ".sz", lock=True ) cmds.setAttr( ikList[0] + ".poleVectorX", lock=True ) cmds.setAttr( ikList[0] + ".poleVectorY", lock=True ) cmds.setAttr( ikList[0] + ".poleVectorZ", lock=True ) cmds.setAttr( ikList[0] + ".offset", lock=True ) cmds.setAttr( ikList[0] + ".roll", lock=True ) cmds.setAttr( ikList[0] + ".twist", lock=True ) cmds.setAttr( ikList[0] + ".ikBlend", lock=True ) # 重命名曲线 cmds.rename(ikList[2],Curve_Name_Text) # other_G 打组 cmds.select(ikList[0]) cmds.select(Curve_Name_Text,tgl=True) cmds.group(n="IK_G") cmds.group(n="other_G") cmds.pickWalk( direction='up' ) cmds.select(Grp,tgl=True) cmds.parent() Other_Grp = cmds.pickWalk( direction='up' ) cmds.select(Geo_Grp) self.Main_Grp = cmds.group(n=Geo_Name_Text+"_all") cmds.select(Other_Grp) cmds.select(self.Main_Grp,tgl=True) cmds.parent() 总结 &emsp;&emsp;这个藤蔓生长工具可谓上煞费苦心，其实实现功能并不苦难，但是我想要在基础功能的基础上，搭建出属于自己的UI形式，不仅可以导入导出插件的所有设置，还可以切换不同的窗口风格，这些虽然不是公司要求我去弄的，但是却是我在开发过程中的一道坎，可能开到ADV实现的效果，自己不甘心甘拜下风吧。&emsp;&emsp;所以这个开发，耗费的时间几乎有一个星期了，但是最后能够开发出来，我还是非常开怀的。&emsp;&emsp;也是因为这个插件的启发，我才有了后面UI2CG软件开发的想法，后面一定会写一篇文章详细说说这个自动完成基础代码的软件的。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - ALembic导入导出助手]]></title>
    <url>%2Fposts%2Fce6b2154.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;Abc助手其实最开始是师兄跟我提的。&emsp;&emsp;我记得刚到公司的第一天，师兄就让我去研究如何实现批量将材质信息上到每个面上。&emsp;&emsp;这就为这个插件的诞生慢下了伏笔。 &emsp;&emsp;其实就我自己而言，我当时并不太理解师兄想要实现的效果。&emsp;&emsp;不过就是这么凑巧的，我们的三维动画实训也遇到了Alembic导出到Houdini的材质问题。&emsp;&emsp;当时咨询了师兄之后才知道，原来问题都是一样的。&emsp;&emsp;而这些信息从模型信息写为模型的面信息就是出于这个考虑。 &emsp;&emsp;师兄提供了一篇很好的推文，上面详细地说明了这个导出的解决方案。&emsp;&emsp;我就是基于这篇推文的思路进行开发的。 界面开发 &emsp;&emsp;这次是首次尝试使用 Qt Designer 来开完整的插件，不过之前也用PyQt开发软件也积累了不少的经验。&emsp;&emsp;下面就是首次使用 Qt Designer 开发的插件界面&emsp;&emsp;在Maya打开的界面是这个样子的&emsp;&emsp;其实 Qt Designer 大大减低了界面开发的难度 UI功能开发 &emsp;&emsp;这次我不仅开发出了可折叠式的UI按钮界面，还开发了可以存储最后一次设置的json功能。 折叠式UI开发 &emsp;&emsp;其实原理很简单，我当时在制作PLB下载器的时候就有做过类似的效果。&emsp;&emsp;原理就是点击按钮的时候将QWidget的setvisibled函数设置为False&emsp;&emsp;如此一来按钮折叠式的内容就会消失。&emsp;&emsp;然而因为消失的区域，会导致内容空缺，会导致按钮变得非常松散。&emsp;&emsp;因此我想到的解决方案就是，每一次点击按钮都重置界面大小，如此一来就可以解决这个问题。 1234567891011121314151617181920class Interface(base_class,form_class): def __init__(self): """ 初始化相关的代码 """ self.NameSapce_Toggle_Check = True self.NameSpace_Toggle.clicked.connect(self.NameSapce_Toggle_Fun) def NameSapce_Toggle_Fun(self): if self.NameSapce_Toggle_Check: self.NameSpace_Btn.setVisible(False) self.NameSapce_Toggle_Check = False self.NameSpace_Toggle.setText(u"■命名空间 - 修正") else: self.NameSpace_Btn.setVisible(True) self.NameSapce_Toggle_Check = True self.NameSpace_Toggle.setText(u"▼命名空间 - 修正") self.adjustSize() json存储记录功能 &emsp;&emsp;我的出发点就是能够让插件记录上一次设置的选项。&emsp;&emsp;于是我参考了 Python For Maya Artist Friendly Programming 教程的写法&emsp;&emsp;每一次关闭窗口时候都会触发json数据的存储记录&emsp;&emsp;而每一次打开窗口的时候都会读取相关的json，如果没有json数据就跳过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Interface(base_class,form_class): def __init__(self): """ 初始化相关的代码 """ # 判断当前路径是否存在json数据可以读取 if os.path.exists(GUI_state_PATH): GUI_state = &#123;&#125; with open(GUI_state_PATH,'r') as f: GUI_state = json.load(f) # 按照存储的json数据设置插件 self.Verbose_CheckBox.setChecked(GUI_state['Verbose_CheckBox']) self.NM__CheckBox.setChecked(GUI_state['NM__CheckBox']) self.Render_CheckBox.setChecked(GUI_state['Render_CheckBox']) self.Namespace_CheckBox.setChecked(GUI_state['Namespace_CheckBox']) self.UV_CheckBox.setChecked(GUI_state['UV_CheckBox']) self.Color_CheckBox.setChecked(GUI_state['Color_CheckBox']) self.Render_CheckBox.setChecked(GUI_state['Render_CheckBox']) self.WS__CheckBox.setChecked(GUI_state['WS__CheckBox']) self.Vis__CheckBox.setChecked(GUI_state['Vis__CheckBox']) self.NameSapce_Toggle_Check = GUI_state['NameSapce_Toggle_Check'] self.Export_Toggle_Check = GUI_state['Export_Toggle_Check'] self.Convert_Toggle_Check = GUI_state['Convert_Toggle_Check'] # 切换到正确的按钮方式 self.NameSapce_Toggle_Fun() self.Export_Toggle_Fun() self.Convert_Toggle_Fun() self.NameSapce_Toggle_Fun() self.Export_Toggle_Fun() self.Convert_Toggle_Fun() # 关闭窗口时保存当前视窗选择 def closeEvent(self, event): # 存储当前界面选择 GUI_state = &#123;&#125; GUI_state['Verbose_CheckBox'] = self.Verbose_CheckBox.isChecked() GUI_state['NM__CheckBox'] = self.NM__CheckBox.isChecked() GUI_state['Render_CheckBox'] = self.Render_CheckBox.isChecked() GUI_state['Namespace_CheckBox'] = self.Namespace_CheckBox.isChecked() GUI_state['UV_CheckBox'] = self.UV_CheckBox.isChecked() GUI_state['Color_CheckBox'] = self.Color_CheckBox.isChecked() GUI_state['WS__CheckBox'] = self.WS__CheckBox.isChecked() GUI_state['Vis__CheckBox'] = self.Vis__CheckBox.isChecked() GUI_state['NameSapce_Toggle_Check'] = self.NameSapce_Toggle_Check GUI_state['Export_Toggle_Check'] = self.Export_Toggle_Check GUI_state['Convert_Toggle_Check'] = self.Convert_Toggle_Check with open(GUI_state_PATH,'w') as f: json.dump(GUI_state,f,indent=4) 主功能开发按面给材质 &emsp;&emsp;正如推文所说的，Houdini的Alembic需要保留Maya的面组信息来记录材质。&emsp;&emsp;只要面组信息是对的，场景中有相关的材质，导入Alembic的时候，Maya会自动连接起来。&emsp;&emsp;问题在于，如果某些材质是对物体进行着色的话，那么导入Maya是没有面组信息的。&emsp;&emsp;因此解决方案就是将物体着色转为对物体的每个面进行着色。 12345678910111213141516171819202122232425262728293031323334353637383940def Convert_Fun(self): # 获取当前选择 sel = cmds.ls(sl=True,fl=True) # 循环当前选择 for obj in sel: # 获取SG节点 shapeNode = cmds.listRelatives(obj,children=True,shapes=True) SGNodeList = cmds.listConnections(shapeNode[0],type="shadingEngine") SGNodeList = list(set(SGNodeList)) # 循环SG节点 for SGNode in SGNodeList: # 通过SG节点获取材质球 shader = cmds.listConnections(SGNode + ".surfaceShader") cmds.select(cl=True) # 选择材质球赋予的物体 cmds.hyperShade( objects=shader[0] ) # 将当前选择转换为面 cmds.ConvertSelectionToFaces() faceList = cmds.ls(sl=True,fl=True) cmds.sets(cl=(shader[0]+"SG")) # 循环材质上的面重新赋予材质 for face in faceList : if obj == face.split('.')[0]: cmds.select(face) cmds.sets(add=(shader[0]+"SG")) mel.eval("maintainActiveChangeSelectMode " + sel[-1] + ";") cmds.select(cl=True) cmds.headsUpMessage( u'转换成功' ) 模型材质传递 &emsp;&emsp;这个功能是给现有的完全相同的来个物体传递两者的材质&emsp;&emsp;这个写法其实参照公司之前写好的脚本修改的。 123456789101112131415161718192021222324252627282930def Transfer_Fun(self): sel = cmds.ls(sl=True,fl=True) shapeNode = cmds.listRelatives(sel[0],children=True,shapes=True) SGNodeList = cmds.listConnections(shapeNode[0],type="shadingEngine") SGNodeList = list(set(SGNodeList)) for each in SGNodeList: cmds.hyperShade(objects=each) sel_mat_face=cmds.ls(sl=True) ##剔除不是本物体的面 （按材质组选的面，有可能选择其他物体） mat_face_use=[] for each_face in sel_mat_face: if each_face.find(sel[0])!=-1: ##没有找到就返回-1 print each_face mat_face_use.append(each_face) print mat_face_use ##改为目标物体的面 mat_face_obj=[] for each_new in mat_face_use: mat_face_obj.append( each_new.replace(sel[0],sel[1]) ) cmds.select( mat_face_obj , r=True ) cmds.hyperShade( assign = each ) cmds.select(cl=True) cmds.headsUpMessage( u'传递成功' ) Alembic 勾选相关参数导出 &emsp;&emsp;要设置选项中的参数其实我是完全没有头绪的。&emsp;&emsp;毕竟这个东西的勾选是没有任何命令回显的，所以最初完全没有头绪。&emsp;&emsp;但是想起ADV5绑定的时候确实是可以设置相关的数据的。&emsp;&emsp;于是我就参考了ADV5绑定设置中的源码，找到了蛛丝马迹。 12345678910111213141516171819202122232425262728293031def Alembic_Export_Fun(self): check = self.Check_CheckBox(self.UV_CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportUVWrite',check)) check = self.Check_CheckBox(self.Face_CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportWriteFaceSets',check)) check = self.Check_CheckBox(self.Verbose_CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportVerbose',check)) check = self.Check_CheckBox(self.Color_CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportWriteColorSets',check)) check = self.Check_CheckBox(self.Render_CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportRenderableOnly',check)) check = self.Check_CheckBox(self.WS__CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportWorldSpace',check)) check = self.Check_CheckBox(self.NM__CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportNoNormals',check)) check = self.Check_CheckBox(self.Vis__CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportWriteVisibility',check)) check = self.Check_CheckBox(self.Namespace_CheckBox.isChecked()) cmds.optionVar(iv=('Alembic_exportStripNamespaces',check)) # 触发 Alembic 导出 cmds.AlembicExportSelection() &emsp;&emsp;使用 cmds.optionVar(l=True) 可以查看optionVar相关的属性变量 install.mel 的搭建 &emsp;&emsp;鉴于对ADV5的安装方法的好奇，我也想开发出这种方便的安装方式。&emsp;&emsp;本来我是想尝试直接将开发好的py文件扔进Maya，看看能不能如我所愿地执行插件。&emsp;&emsp;经过测试，Maya2017是完全没问题的，但是Maya2015就无法这样直接执行了。&emsp;&emsp;所以参考了ADV5的方法，我发现它是通过Mel来实现的&emsp;&emsp;于是，对ADV5的install.mel进行魔改，成功实现了好ADV5差不多的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364string $subDir = "abc_helper/";string $scriptName="main";string $scirptExt = "py";string $ImagePath = "/icon/alembic_logo" ;global string $gShelfTopLevel;string $currentShelf = `tabLayout -query -selectTab $gShelfTopLevel`;setParent $currentShelf;string $asInstallScriptLocation=`asInstallScriptLocation`;string $command="import sys\nsys.path.append(\"" + $asInstallScriptLocation + $subDir + "\")\nimport " + $scriptName + "\nreload(" + $scriptName + ") ";string $sourceFile=$asInstallScriptLocation+ $subDir + $scriptName+"."+$scirptExt;string $iconExt="jpg";if (`asMayaVersionAsFloat`&lt;2012) $iconExt="xpm";string $icon=$asInstallScriptLocation + $subDir + $ImagePath + "."+$iconExt;if (!`file -q -ex $sourceFile`) error ("Something went wrong, can not find: \""+$sourceFile+"\"");shelfButton -command $command -annotation $scriptName -label $scriptName -image $icon -image1 $icon -sourceType "python";global proc asInstallScriptLocator ()&#123;&#125;global proc string asInstallScriptLocation ()&#123;string $whatIs=`whatIs asInstallScriptLocator`;string $fullPath=`substring $whatIs 25 999`;string $buffer[];string $slash="/";if (`gmatch $whatIs "*\\\\*"`)//sourced from ScriptEditor $slash="\\";int $numTok=`tokenize $fullPath $slash $buffer`;int $numLetters=size($fullPath);int $numLettersLastFolder=size($buffer[$numTok-1]);string $scriptLocation=`substring $fullPath 1 ($numLetters-$numLettersLastFolder)`;return $scriptLocation;&#125;global proc float asMayaVersionAsFloat ()&#123;float $version=2012;if (`exists getApplicationVersionAsFloat`) return `getApplicationVersionAsFloat`;string $versionString=`about -v`;string $tempString[];string $char;tokenize $versionString $tempString;//default to 2012, if versionString is not all numbersfor ($i=0;$i&lt;size($tempString[0]);$i++) &#123; $char=`substring $tempString[0] ($i+1) ($i+1)`; if (!`gmatch $char "[0-9]"`) return 2012; &#125;$version=$tempString[0];return $version;&#125; 总结 &emsp;&emsp;以上就是 Alembic导入导出助手 的核心源码了。&emsp;&emsp;原理其实一点都不复杂，整个制作过程中最困难的是想出按面给材质的方法以及最后怎么实现设置导出选项。&emsp;&emsp;这个插件开发奠定自己的插件开发风格，为后面的藤蔓生长工具的开发奠定了坚实的基础。 2018-11-30 更新 &emsp;&emsp;借助UI2CG工具更新了基础界面和功能&emsp;&emsp;这次删除了命名空间修改的功能，因为我发现Maya自带命名空间编辑器，比我自己的开发的小功能强多了。&emsp;&emsp;这次当然也加入了UI2CG所带来的所有特性。]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】 2018年11月回顾 | 12月学习计划]]></title>
    <url>%2Fposts%2F568b8654.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;好久没有更新博客，近期会将11月份开发的插件全部更新文章。&emsp;&emsp;总结一下自己的感受和想法。 &emsp;&emsp;11月9日开始正式入职华强方特，开始了不断奔波的11月。&emsp;&emsp;从深圳赶往广州需要两个小时的车程，幸好仲予师兄推荐了AA巴士让我省了不少的时间和钱。&emsp;&emsp;原本我的计划是做城轨往返的。&emsp;&emsp;虽然城轨没有那么颠簸，但是票价高达79元多，而且去到深圳的客运站之后还要坐很长时间的地铁。&emsp;&emsp;我预估过了，从广州到深圳几乎要3个小时有多。&emsp;&emsp;而师兄推荐的AA巴士，不仅中途不停站，速度快，时间只需2个小时，而且非常便宜，只需要30元即可。&emsp;&emsp;不过每个星期都差不多要来回，奔波的辛劳还是有的。 &emsp;&emsp;入驻方特之后，其实之前也写下了一篇一周的感想，些许的失望溢于言表。&emsp;&emsp;不过其实也倒没什么，除了技术之外，大公司的风范基本上在各方面也都是无可挑剔的了。&emsp;&emsp;哥哥说的没错，毕业之后最好去大公司，因为起步的平台是很重要的，&emsp;&emsp;在大公司积累的项目和经验更是很多小公司都是无法比拟的。&emsp;&emsp;说来，我感到失望的果然还是因为技术水平没有达到我的预期吧，后面也听仲予师兄说技术部走了一批人。&emsp;&emsp;从高中以来就一直期待，能够在CG的道路上认识一些大神，和大神请教，交流，学习。&emsp;&emsp;然而一路走来，至始至终我都是孤零零的，我一直认为，技术上去了，自然缘分就到了。&emsp;&emsp;其实仲予师兄的实力也是很不错的，只是我和他专研的领域有些区别而已。&emsp;&emsp;我期待能够有师傅带我上去，结果一路带我走的是教程以及我自己。&emsp;&emsp;不过作为 problem solver ，我也非常乐意去为大家解决问题，为了解决问题而刻苦学习。 &emsp;&emsp;我觉得自己很庆幸，TD真的是我的DreamJob了。&emsp;&emsp;以前大一的时候还在摸索，但是经过了绑定的学习之后，我觉得技术性较强的领域才是最适合自己的。&emsp;&emsp;估计当时也是因为建模的学习过程中受了太大的打击吧(:з」∠)&emsp;&emsp;后面我定下的方向是 特效 ！！！ 是 Houdini 的&emsp;&emsp;可能自己也迷惑过，为什么不选择TD作为自己的追求。&emsp;&emsp;究其原因，估计也是因为国内的行情，TD的需求实在是太少了，只有少数的大公司才需要TD开发的。&emsp;&emsp;这么说来特效其实也不相上下吧，不过需求总是比TD高的，只要技术在身，找工作是不成问题的。&emsp;&emsp;所以去年认识仲予师兄的时候感觉自己是非常幸运了。（虽然给我的指导不多，也算是我所期待的恩师了）&emsp;&emsp;只是没想到了后面学前端去了，这些点滴之前的总结里面也有写过，就不提了。 &emsp;&emsp;现在我觉得Houdini的学习非常重要的，我很认同仲予师兄说的，Houdini是未来的发展趋势。&emsp;&emsp;不过最近估计还是安排不上时间了(/ω╲)&emsp;&emsp;Anyway,先见步行步吧，Houdini的学习安排可以改变一下策略了。&emsp;&emsp;因为不用担心找工作的问题，我可以按照需求和感兴趣的模块进行学习。 11月份回顾学校 &emsp;&emsp;11月份中，学校里发生的事情真是惊险刺激的。&emsp;&emsp;其中有交互设计的开题报告，我就是被组员推着上去演讲的，只是在演讲前开了10分钟的ppt，然后就只能硬着头皮去讲，不过最后老师还是对我们提出的角度感到很满意，真是好的开头。&emsp;&emsp;另外也参加了星耀工大的创业之星评选（被学院逼着去的），创业之星的竞争异常不激烈(:з」∠)，10选8，只要自己的发言足够让人印象深刻，基本就毫无压力了。自己也确实做到了，还被评为说成微笑的坚韧(/ω╲)&emsp;&emsp;另外，最让我印象深刻的就是三维动画实训的结课了，我们小组的野心很大，原本也确实想做出恢弘浩瀚的作品出来，但是一方面是我自己去方特实习了，9月份说的豪言有点下不了台了，另一方面老师给的时间也确实不多。所以我面临的问题就是如何将我们零碎的作品整合成看起来很强大的作品。&emsp;&emsp;在我们原先的设想中，我们是要做一个有对白的动画的，不仅要配乐还要有剧情，但是我们的进度实在是太慢了，很多动画都没有时间做，特效部分也完全交给了扎哥去负责了。最后一些很重要的特效镜头也没能完成，扎哥能够做好自动城市和非常冲破仓库的这些镜头就实属是不容易了。另外我们小组有一个人全程打酱油，也实在奈何不了他了(:з」∠)。&emsp;&emsp;面对我们还没完成，零零碎碎的半成品，如何才能糊弄老师，蒙混过关呢？这个真的让我很是头疼。最后还是舍友的一席话，解决了额所有的难题。那就是将动画片改成宣传片，时间不够宣传效果来凑，剧情零散，宣传片就是要这种效果，有足够的精彩镜头，加上宏伟的配乐就可以做出很不错的宣传片。&emsp;&emsp;于是直到终期报告当天，我才开始找AE模板(:з」∠)，然后下午开始汇报了，才开始将所有的素材汇总，开始AE剪辑。&emsp;&emsp;当我们将成片合成出来的时候已经5点多了，汇报都快要结束了。&emsp;&emsp;不过最后我们还是赶上了汇报，虽然有两个镜头还没有渲染完成，但是AE模板强大的配乐，成功震慑住了什么多不懂的老师，最后能够过这一关还是让我很欣慰的，因为最重要的陨石撞飞船的镜头都还没能做好。&emsp;&emsp;除了三维实训之外，我还回来参加了党会，也就是前天的事情，结果还为了聪哥的项目去到他朋友的公司通宵了一夜，这当中着实发生了写有趣的事情。聪哥把我吹嘘得很是牛逼，又说我是花多少钱聘请过来的，但是我过去了就穿帮了，聪哥就很担心这个，所以最后我只好伪造出一个大神的存在，就说自己只是大神的小跟班，结果大神溜了，就过来接手救急(/ω╲)&emsp;&emsp;最后确实通宵了一晚上，害得我昨晚回深圳的时候，坐车睡过了头，不过差不多吧事情多弄好了，也算是知足了。 方特开发 Abc_helper Alembic导入导出助手 Vine_Grow 藤蔓生长工具 UI2CG UI文件自动编译工具 Cap2Con 动捕数据约束转换 11月份反省 &emsp;&emsp;这个月或许是很忙，但是对于自己的懈怠，自己还是很清楚的。&emsp;&emsp;最近一直沉迷在听小说中，再加上工作的繁忙，看教程的时间基本就没了。&emsp;&emsp;虽然说完成了不了预期的教程计划其实自己早就心知肚明了。然而没能完成任务总归还是得好好思考一下。&emsp;&emsp;这个月我将更多的时间投在实战当中，从藤蔓生长工具的开发开始，我就不断尝试制作带自己的风格的插件。&emsp;&emsp;而UI2CG的这个工具的诞生更是从藤蔓生长工具的开发等到灵感制作出来的，这个东西我还当做是自己给自己的20岁生日礼物(/ω╲)&emsp;&emsp;虽然实战做了一点成绩，其实自己能够少听点小说，晚上回去好好地看教程，我觉得也不至于把进度拖到这种情况。&emsp;&emsp;所以12月份我打算制定一个规则，那就是晚上11点前不许听小说，工作时间也不许听小说，万一听上瘾了，就乱套了。&emsp;&emsp;我要充分利用好自己的时间，为此我需要一个更为切实的目标。&emsp;&emsp;在技术的攻坚上，我也确实有几个东西想要解决，这也将是我看教程的动力。 双重约束插件 拓扑结构识别插件 动态改变拓扑的绑定尝试 计划安排11月制定的计划 11月计划执行的情况 12月计划安排表]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华强方特 实习 第一周]]></title>
    <url>%2Fposts%2F57d6cbdb.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;又好长一段时间没有更新博客了。&emsp;&emsp;不知不觉中，我已经入职华强方特一个星期有多了。&emsp;&emsp;月薪3000的实习工资算是非常非常不错的待遇了。&emsp;&emsp;仲予师兄也直言这样的待遇简直让人眼红。&emsp;&emsp;我最初还不清楚这算是到了什么程度，直到上周周末去参加师兄的部门聚会，我才知道自己的起步着实很高了。&emsp;&emsp;师兄的特效部门，很多人入行只有1千多的工资，而且这还是正职的工资。&emsp;&emsp;所以能够进入如此大的公司，我还是深感幸运的。 方特入职情况 &emsp;&emsp;其实我入职的时候还是非常仓促的。&emsp;&emsp;可能是因为我不是正规渠道进来的，人事部那边的手续还有很多没有处理好。&emsp;&emsp;我本来6号就正式开始在公司干活的，但是拖到了9号才正式办理了手续（其实8号就可以办理了，但是我回学校去了）&emsp;&emsp;我以流程TD的身份安排进了技术部。&emsp;&emsp;赶进来被苏老板部长安排与另一个刚入职的同事一起负责绑定的工作。&emsp;&emsp;没想到刚入职的同事竟然是今年毕业的动画专业的师兄，真的是让我大为吃惊（暗自幸运，哪里都有人罩着）&emsp;&emsp;由于苏老板很忙，而且我们的工作主要是辅助设置部门的绑定工作&emsp;&emsp;因此，我们主要是对设置部部长丸子负责。 &emsp;&emsp;干活其实并没有想象中那么复杂，主要还是围绕绑定和脚本开发上面。&emsp;&emsp;绑定部门也会提出很逗超出我能力范围的需求，比如说模型自主碰撞之类的。&emsp;&emsp;但是总体来说周围的人技术并没有我想象中的高(:з」∠)&emsp;&emsp;技术部门并不是所有人都在干TD的活，包括软件开发、后台开发、前端开发甚至是摄像机影棚搭建的人员。&emsp;&emsp;因此其实真正做TD开发的人并不多，比我想象中的要少得多。&emsp;&emsp;另外我实在没想到会Qt designer 已经算是很强的存在了(:з」∠)&emsp;&emsp;我开发的时候都没有人可以指导我，最后的状态其实还是自己专研，自己解决问题。&emsp;&emsp;好吧，其实问题不大，反正和之前的状态差不多。 入职感想 &emsp;&emsp;师兄后面又和我说，其实我的技术水平算是很不错了。&emsp;&emsp;我现在年轻，缺少的是制作经验、流程经验、项目经验。（总结起来就是工作经验）&emsp;&emsp;不过作为TD，其实制作的经验的要求没有制作人员的要求那么高。&emsp;&emsp;更多的是给制作人员提供解决方案，我只要清楚制作的原理和代码编写即可。&emsp;&emsp;当然，制作也能做好，那就更好了。 &emsp;&emsp;其实我能进方特实习着实是幸运了，几乎就等于进腾讯、阿里的程度了。&emsp;&emsp;上周周末的时候和师兄的部门一起聚餐，我才发现大家入行的时候是如此的困难。&emsp;&emsp;大家普遍都是从小公司入行，而且起步工资都是很苦的那种，大家都是从五湖四海过来的，来到这么大的公司还是很不错的。&emsp;&emsp;虽然自己的技术还行，其实提升的空间还很多。&emsp;&emsp;而且师兄说的工作经验还是非常重要的，我好需要加快学习进度。&emsp;&emsp;另外我觉得Houdini 的思想，特效还是非常有意思的，有空还是得多加专研。 总结 &emsp;&emsp;最近事情很多，各种忙，教程暂时都搁置了。&emsp;&emsp;我需要将PyQt的教程补完，后面继续深入Maya Python API]]></content>
      <categories>
        <category>华强方特</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python - PLB downloader 开发完成]]></title>
    <url>%2Fposts%2F7c31db18.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间开发完成了Pluralsight下载器，然后还痛苦地呻吟Lynda没法破解。&emsp;&emsp;功夫不负有心人，经过了长达一周的测试，甚至到最后是推倒重做，我终于解决了Lynda的token获取问题。&emsp;&emsp;兴不兴奋、想不想学 &lt;(￣▽￣)&gt;&emsp;&emsp;直到今天总算完成了，快2000行的代码，而且很可能还有些BUG，真是累死我了。 Lynda问题解决 &emsp;&emsp;Lynda的问题一直是因为我的form表单传错了。&emsp;&emsp;Lynda并非使用传统的form表单，而是使用urlencoded的表单。&emsp;&emsp;这个在头文件中写得很清楚，然而我又傻乎乎地以为没有问题（被Pluralsight的顺利给误导了）错误的form表单正确的form表单 &emsp;&emsp;另外比较坑爹的是，Lynda的登录比Pluralsight复杂许多。&emsp;&emsp;登录需要获取到隐藏在登录界面的验证码&emsp;&emsp;通过验证码和生成的不含登录信息的token值进行匹配。&emsp;&emsp;匹配成功之后token值会长了许多。seasurf值&emsp;&emsp;登录成功后可以看到form表单的处理&emsp;&emsp;另外这里额外再提一下，Content-Type已经提示了这个form表单是 urlencoded 处理的&emsp;&emsp;另外再翻到上面可以看到有token的set-cookie值&emsp;&emsp;但是我当时在postman一直测试不出这个结果。&emsp;&emsp;但是偶尔postman会返回出正确的token值，这让我非常不解。 &emsp;&emsp;后面我利用python测试代码。&emsp;&emsp;思路是首先获取一次页面的 seasurf 的值。&emsp;&emsp;后面将相关的用户信息输入获取token值&emsp;&emsp;通过这个代码的测试，我才发现，token值已经在header里面更新了，而不是通过set-cookie&emsp;&emsp;另外运行的时候偶尔还会发生没有更换token的值的情况&emsp;&emsp;所以Lynda的处理比Pluralsight要麻烦得多。 &emsp;&emsp;顺利获取到token值之后一切都好办了，后面就应该和Pluralsight一样一马平川了。&emsp;&emsp;然而我大错特错了。&emsp;&emsp;Lynda使用了最纯粹的动态网页技术，居然不使用接口API&emsp;&emsp;而是将数据写在html页面里面，这样我就无法找到相关的接口来直接抓取数据了。&emsp;&emsp;后面只好通过正则表达式强行获取了。 &emsp;&emsp;后面也还算顺利。&emsp;&emsp;虽然有不少数据需要在页面中获取，不过也还是有一些可以获取数据的接口的。&emsp;&emsp;（没能找到教程列表信息，无奈只能在网页中获取） https://www.lynda.com/ajax/player/conviva?courseId=758611&amp;videoId=775845&emsp;&emsp;这个地址输入教程的courseId 和 videoID 就可以获取到详细的信息&emsp;&emsp;通过VScode排版可以看到获取到的json数据 https://www.lynda.com/ajax/course/382570/418615/play&emsp;&emsp;这个地址就是获取视频下载链接的部分&emsp;&emsp;当然如果是锁住的教程就需要带登录的token信息才能获取到数据了。&emsp;&emsp;这个就是下载视频的核心地址。 https://www.lynda.com/player/oembed?url=https://www.lynda.com/Flask-tutorials/course-overview/521200/533057-4.html&emsp;&emsp;这个地址则是非常偶然在网页的链接中发现的&emsp;&emsp;通过这个可以获取到教程每一集的封面，不过有些教程就没有设置这个封面。 https://www.lynda.com/ajax/player/transcript?courseId=521200&amp;videoId=533057&emsp;&emsp;这个地址算是了解了大一的字幕下载心愿了。&emsp;&emsp;想当初我还付费50元购买了个字幕下载器，现在自己也开发出了字幕下载器了。 PLB downloader 整合 &emsp;&emsp;在Lynda下载器的开发过程中，我就在想是否可以三个下载器整合到一起，&emsp;&emsp;于是当前的 PLB downloader 就诞生了。&emsp;&emsp;其实我只是取了三个机构首字母命名的。&emsp;&emsp;比起最初版本的Pluralsight downloader 我加入了许多功能。&emsp;&emsp;基本上就是通过最上面三个状态按钮识别当前是什么下载模式。&emsp;&emsp;然后通过调整UI布局，匹配出最适合的界面。&emsp;&emsp;这个过程其实非常繁琐，也没有什么太高深的技术含量，就是改改UI的位置，隐藏和禁用一些UI而已。 &emsp;&emsp;目前下载器最大的问题依然是下载稍微大一点的文件就会陷入无响应的状态，&emsp;&emsp;需要看控制台打印的信息才能知道当前的执行情况。 &emsp;&emsp;在不断的测试也遇到了每次都要按一堆按钮的烦恼，&emsp;&emsp;于是我还加了个json文件，记录上次打开的按钮界面。 总结 &emsp;&emsp;这个下载器开发完了，感觉也算是了结了自己的心愿。&emsp;&emsp;从最初青年之声爬虫里面提到自己想弄出教程的下载，到如今实现心愿。&emsp;&emsp;前路漫漫不堪回首。&emsp;&emsp;近两千行的代码就是努力的见证。&emsp;&emsp;11月的心头大计划完成了，目前也顺利进入方特实习了，感觉心情特别好。 &emsp;&emsp;11月因为开发这个下载器的缘故，教程都搁置了。&emsp;&emsp;三维动画作业又在月底需要完工，我还需要花不少时间去制作，估计有些教程得鸽了。&emsp;&emsp;另外今天正式进入方特实习，过几天写一下自己的见闻。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】 2018年10月回顾 | 11月学习计划]]></title>
    <url>%2Fposts%2F4323d1ae.html</url>
    <content type="text"><![CDATA[10月梗概 &emsp;&emsp;一晃眼10月份就结束了，感觉这个月过得五味杂陈。&emsp;&emsp;10月初是国庆，是个喜庆的日子。&emsp;&emsp;10月2日从广州回家，休息整顿三天。&emsp;&emsp;下午帮新屋搬东西，在满是灰尘的房子里劳累，有轻度的过敏反应。&emsp;&emsp;从那天开始鼻涕直流，不过病情倒是停滞，不温不火。&emsp;&emsp;那个时候我就继续利用闲暇的时间看 Python For Maya Artist Friendly Programming 的课程&emsp;&emsp;后面回学校，带了不少零食月饼。&emsp;&emsp;我还很清楚10月7号的时候和哥哥在食堂吃麻辣烫，那个时候感觉良好。&emsp;&emsp;接下来的情况就每况愈下了，我记得10月9日或是10日的时候发烧，整个人累得要死。 &emsp;&emsp;后面我在看B站的时候看到逍遥散人推荐 嘣神纪 这个游戏。&emsp;&emsp;我还很记得那天不舒服，晚上很晚就起来了，但是睡不着，就在玩这个游戏。&emsp;&emsp;于是我就入坑了，从此每天晚上回到宿舍就是玩这个游戏，充满了期待。&emsp;&emsp;直到两周之后游戏更新，我的号被官方永久封禁了，从此退坑。&emsp;&emsp;（为什么被禁了，可能是我玩得太狂热了，用了两周打到排行榜前十，不过都是肝出来的） &emsp;&emsp;这14天的时间里，也一直在工作室看PyQt相关的课程。&emsp;&emsp;写了一些总结，下一个部分我总结一下。&emsp;&emsp;后面学有所成之后就开始写青年之声的爬虫软件，终于又拾回了当时开发SFML的那种狂热感觉。&emsp;&emsp;满脑子都是这个事情，不断优化代码达到我想要的效果。 &emsp;&emsp;直到最近10月下旬开始基于青年之声爬虫的基础上开发 Pluralsight 下载器。&emsp;&emsp;开发成功之后打算开发 Lynda 下载器，遇到了不可解决的问题卡到现在放弃了。 &emsp;&emsp;十月下旬还参加了星耀工大的创业之星评选，同时还组织了党支部生活会议，事情真的是多。&emsp;&emsp;直到最近这两天终于远赴深圳，完成方特实习和租房子的对接手续。&emsp;&emsp;这两天回家休养前参加了体侧，跑了1000米，累得我半死，并且又恢复了10月初的流鼻涕状态。&emsp;&emsp;因为身体状态不好，于是我又开始找游戏消遣，最近这两天在家里休养和去深圳都在玩 我的塔防 手游。&emsp;&emsp;再次陷入沉迷状态（真的是日了狗了） 十月份回顾花城汇 网页项目 &emsp;&emsp;这个项目真的是日了狗了，本来期待尽快结束的，结果是甲方不慌不忙不去给他们的甲方做验收。&emsp;&emsp;直到10月下旬的时候验收出问题了，又要我们去修改，真的是…….&emsp;&emsp;最大的问题是需要修改流花展馆的外部模型，直到目前为止也没有一个好的修改方案（毕竟建模团队罢工了）&emsp;&emsp;这边技术上要解决的问题不难，我研究了一晚上就OK了。&emsp;&emsp;一个是花城汇模型文字显示的调整，客户觉得最初的方案看起来太low了（好想爆粗），要求修改好看点，并且希望做成三维的文字。&emsp;&emsp;Three.js可以制作三维文字，但是默认字体不支持中文，还需要用fontface.js进行字体转换。&emsp;&emsp;结果我把微软雅黑转成json之后居然20多M，这大小是不能接受的，于是我想尽量用原先的canvas方案解决问题，目前已经有了初步的效果。&emsp;&emsp;另外要加入的还有 闪烁报警 、 海心沙box模型 、 海心沙接口对接&emsp;&emsp;这些都是最近很心烦的事情，还好这些问题都不打，最大的问题还是流花展馆的修改意见上。 观看的教程 &emsp;&emsp;虽然这个月玩游戏有点凶，不过还是基本完成了10月初制定的Maya编程学习计划。&emsp;&emsp;（Houdini17新功能摸索 和 破碎效果探索 都是预估没时间的部分(:з」∠)，以后有机会再去研究）&emsp;&emsp;有的教程通过4倍加速看的，所以有作弊的嫌疑。 10月初定的计划 10月计划的落实 10月教程详解&emsp;&emsp;看起来似乎看了很多教程，关键还是得看消化效果吧。&emsp;&emsp;另外 Python For Maya Artists - Volume 1 和 Beginning Python for Maya with Chris Zurbrigg 都是四倍速甚至手动加速过完的。&emsp;&emsp;毕竟讲解的内容基本和 Python For Maya Artist Friendly Programming 教程一致。&emsp;&emsp;同样都涉及到Python的一些基础应用教学，讲解内容大同小异，所以只是大概看一下哪些不同之处而已。&emsp;&emsp;Beginning Python for Maya with Chris Zurbrigg 这套教程比较特殊，是用 charcoal Editor（Maya的编辑器插件 - 似乎就是教程作者开发的）进行讲解，不过除了这个也没啥不一样的。&emsp;&emsp;其他有点意思的教程都有写博客进行记录。&emsp;&emsp;另外还有四套教程没有完全看完，尚未写博客进行记录。&emsp;&emsp;Maya白话教程是难得的非常棒的中文教程，主要讲解了Maya的C++插件编写，内容太深，看了前面的部分之后打算先放一放。&emsp;&emsp;PyQt4 Model View Programming Tutorials是师兄推荐的PyQt教程，应该是Youtube上的教程，讲解PyQt的MVC框架，内容也略深，自己打算再深入学习PyQt，巩固好基础先，所以也放一放。&emsp;&emsp;Python For Maya Artists - Volume 2 这套是在快速看完 volume 1 之后也是快速看了看，内容结合Maya，还是比较好看懂的，只是看到前半部分有点绕，那天晚上也有点浮躁就点到为止了。&emsp;&emsp;最近主要在看 pyqt5视频教程全集 python GUI开发 教程，从B站上下载下来的，前面讲解也比较浅，主要针对软件开发，所以和CG领域没太大关系，前面部分也是加速看过去的，难度不大。&emsp;&emsp;10月份看得教程基本上就是这些。 11月学习计划 &emsp;&emsp;主要的学习安排还是围绕着PyQt去展开的，主要是补足之前还没学完的部分。&emsp;&emsp;另外这个月另一个很重的任务是要解决三维动画实训的问题，这个也需要尽快去解决。&emsp;&emsp;三个PyQt软件开发也非常迫在眉睫，当然这些都是自己想弄出来而已。&emsp;&emsp;下周一也就是11月5日要去方特入职了，到时候工作上的问题会更多，所以本月的PyQt计划得延后，毕竟三维动画实训更加重要。]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - 用 PyQt 写 Pluralsight 下载器]]></title>
    <url>%2Fposts%2Fccdac3f3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;好几天没有写博客了，最近事情也有点多，又要准备党员之星的评选，花城汇的项目还有很多未完成的工作。&emsp;&emsp;其实Pluralsight下载器只用了三天就做好了，采用和青年之声爬虫相同的方法。&emsp;&emsp;先找到相应的接口地址，然后爬取需要的数据。&emsp;&emsp;如此一来就解决了之前的遗憾，那么既然那么早就做好了，为什么不尽早记录下来呢？&emsp;&emsp;都是Lynda下载器的锅，到目前为止也没成功用Python获取出相关的登录信息，因此搞了好几天。&emsp;&emsp;事到如今我佛了，我放弃了。 爬取方法 &emsp;&emsp;以前没有办法爬取Pluralsight，关键原因在于我认为需要爬取网页而不是爬取接口数据。&emsp;&emsp;但是网页上的数据都是动态生成的，或是经过php甚至是js进行了动态处理。&emsp;&emsp;如此一来，如果无法模拟用户去浏览网页，就无法让一些特定的脚本运行。&emsp;&emsp;青年之声爬虫也遇到了相关的情况。&emsp;&emsp;青年之声的评论是通过瀑布流生成的，那么滚动网页数据就不会继续加载，那就无法爬取出网页中的内容了。&emsp;&emsp;但是接口地址就不同，全部都是后台调出的数据库数据，这就直接跳过了js的处理，获取了最原始的数据。 &emsp;&emsp;Pluralsight也是使用相同的思路进行爬取。&emsp;&emsp;首先就是要找到相关的接口地址。 &emsp;&emsp;方法也和青年之声的时候是一样的，我就不在进行截图了。&emsp;&emsp;打开浏览器调试窗口，找到network相关的链接，找xhr的链接地址&emsp;&emsp;xhr即时动态网页ajax数据地址传输的方式，通常数据都是用js的ajax来获取。 https://app.pluralsight.com/library/courses/python-desktop-application-development/table-of-contents&emsp;&emsp;这个就是Pluralsight一般情况下的课程地址，无需登录，任何用户都可以进行访问。&emsp;&emsp;在这里可以看到它首先链接一个很重要的地址https://app.pluralsight.com/learner/content/courses/python-desktop-application-development&emsp;&emsp;这个地址会返回课程相关的json数据，当然也是无需登录的，毕竟课程的界面就是让js处理这些数据生成的。&emsp;&emsp;可以看到网页返回的json数据并没有经过排版，但是没关系VScode可以很方便地进行排版。&emsp;&emsp;一般来说就是先 ctrl + a 全选所有内容，在按 ctrl + k 和 ctrl + f，就可以自动排版内容。&emsp;&emsp;如果需要相关的插件，VScode会提醒。&emsp;&emsp;json可是VScode默认就可以进行排版。&emsp;&emsp;这样看前来就舒服多了。&emsp;&emsp;json数据还有一个好处就是可以用Python的json包处理数据，获取数据更加方便准确。(最重要的是不需要用正则表达式) &emsp;&emsp;后面获取数据的道路就非常艰辛了。&emsp;&emsp;最大的困难在于如何才能获取出用户登录的验证信息。&emsp;&emsp;当然这部分就是先登录，然后打开视频，在看后台的数据反馈。&emsp;&emsp;在这里我找打了关键链接https://app.pluralsight.com/player/api/graphql&emsp;&emsp;然而这个链接连接了好几次，返回的数据也是截然不同。&emsp;&emsp;这就让我非常困惑。&emsp;&emsp;经过postman的测试，直接访问链接是获取不到任何数据的。&emsp;&emsp;那就需要找到链接之间的不同之处。&emsp;&emsp;我首先留意到了reqeust payload 的不同之处。&emsp;&emsp;经过一番搜查，我才知道如何在 postman 中添加相关的数据处理。&emsp;&emsp;但是可以出图片看到，并没有获取到想要的数据，而是返回了403。&emsp;&emsp;这又是为啥呢？&emsp;&emsp;经过了好一番的研究，我发现加入了cookie中的信息就可以获取到数据了&emsp;&emsp;所有的视频链接就获取出来了。&emsp;&emsp;那cookie当中肯定隐含了用户登录的信息验证，从而让服务器通过验证返回相关的数据。&emsp;&emsp;经过我删除cookie的数据进行测试，最后我发现了关键值 PsJwt-production&emsp;&emsp;那么只要获取到这个值，我就可以获取到所有的视频链接地址，从而实现下载。&emsp;&emsp;想到是用户信息的值所以想必也是在用户登录界面中获取的。&emsp;&emsp;于是去到登录界面，找到登录相关的地址https://app.pluralsight.com/id/&emsp;&emsp;可以看到用户登录的用户名和密码是通过 form 表单传输的&emsp;&emsp;在cookie中可以看到看到服务器返回的cookie信息&emsp;&emsp;那么我只需要用python截取这个信息就可以下载所有的教程。 &emsp;&emsp;后来软件写得七七八八之后，我才想起来字幕也是可以获取的。&emsp;&emsp;那是我大一的时候梦寐以求的东西啊。&emsp;&emsp;因此决心已定要弄出可以用的字幕信息出来。&emsp;&emsp;同样在视频链接的地方可以找到相关的地址https://app.pluralsight.com/transcript/api/v1/caption/json/5be6c21d-4d43-48b5-ad80-20cf9e0504c5/zh&emsp;&emsp;通过后缀可以获取不同翻译版本的字幕，具体后缀信息可以通过https://app.pluralsight.com/player/api/graphql 链接查询不同的数据返回出来。&emsp;&emsp;具体操作方法和上面一样，只是获取不同的payload就不再赘述&emsp;&emsp;最大的问题是字幕上的编号，经过对比查询这个编号是clipID，课程信息上面可以获取出来。&emsp;&emsp;如此一来就可以获取相关的字幕信息。&emsp;&emsp;问题是字幕是以json的形式返回的，没有办法导入的视频软件中。&emsp;&emsp;需要将它转换成srt格式。&emsp;&emsp;其实这样转换也不是不行，毕竟json的数据还是非常好获取的。&emsp;&emsp;关键是要将秒转换为小时分钟秒的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requestsimport jsonimport reimport osDownloadURL = "https://app.pluralsight.com/library/courses/angular-fundamentals/table-of-contents"reg = r'courses/(.*)'courseIdReg = re.compile(reg)courseId = re.findall(courseIdReg,DownloadURL)[0].split('/')[0]url = "https://app.pluralsight.com/learner/content/courses/%s" % courseIdheaders = &#123; 'Cache-Control': "no-cache", 'Postman-Token': "ca8bb1e7-99b7-4b41-b7d2-2813bf834e2f" &#125;response = requests.request("GET", url, headers=headers)jsonFile = json.loads(response.text) url = "https://app.pluralsight.com/transcript/api/v1/caption/json/%s/zh" % jsonFile['modules'][3]['clips'][8]['clipId']url = "" % jsonFile['modules'][3]['clips'][8]['clipId']headers = &#123; 'content-type': "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW", 'Cache-Control': "no-cache", 'Postman-Token': "9a592511-4c25-4a31-879b-eb3ae0ac6cca" &#125;response = requests.request("GET", url, headers=headers)CaptionFile = json.loads(response.text)captionCount = 0srtFIle = ""for caption in CaptionFile: # 如果当前获取到的是数字 if type(caption['displayTimeOffset']).__name__ == 'float': m, s = divmod(caption['displayTimeOffset'], 60) else: # 如果当前获取的不是数字 就将获取前后数字的平均值 duration = (CaptionFile[captionCount-1]['displayTimeOffset'] + CaptionFile[captionCount+1]['displayTimeOffset'])/2 m, s = divmod(duration, 60) h, m = divmod(m, 60) startTime = "%02d:%02d:%02d" % (h, m, s) # 如果是最后一个时间（json数据没有返回视频结束时间） # 截取视频的长度，让字幕一致延伸到结束 if len(CaptionFile) == captionCount+1: duration = float(re.findall(r"\d+\.?\d*",jsonFile['modules'][3]['clips'][8]['duration'])[0]) m, s = divmod(duration, 60) else: # 如果下一个时间是空的，进行相同的平均值处理 if type(CaptionFile[captionCount+1]['displayTimeOffset']).__name__ == 'float': m, s = divmod(CaptionFile[captionCount+1]['displayTimeOffset'], 60) else: duration = (CaptionFile[captionCount]['displayTimeOffset'] + CaptionFile[captionCount+2]['displayTimeOffset'])/2 m, s = divmod(duration, 60) h, m = divmod(m, 60) endTime = "%02d:%02d:%02d" % (h, m, s) srtFIle += "%s\n" % captionCount srtFIle += "%s --&gt; %s\n" % (startTime,endTime) srtFIle += "%s\n\n" % caption['text'] captionCount += 1dirname = os.path.dirname(__file__)SRT_PATH = os.path.join(dirname, 'test.srt')with open(SRT_PATH,'w', encoding='UTF-8') as f: f.write(srtFIle)print("complete") &emsp;&emsp;本来代码不应该如此复杂的，但是获取的过程中发现居然有些字幕有BUG。&emsp;&emsp;返回的时间居然有null值，可能是官方的BUG吧，这个问题将整个下载截停了。&emsp;&emsp;为了解决这个问题有写了好多代码进行判断取平均值才最终完成了结果。&emsp;&emsp;上面只是字幕下载Demo，下面是下载器的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590from PyQt4.QtCore import *from PyQt4.QtGui import *from PyQt4 import uicimport sysimport reimport xlwtimport requestsimport timeimport osimport tracebackimport randomimport jsonimport subprocessdirname = os.path.dirname(__file__)UI_PATH = os.path.join(dirname, 'PluralsightDownloader.ui')TOKEN_PATH = os.path.join(dirname, 'token.verify')form_class , base_class = uic.loadUiType(UI_PATH)class PluralsightDownloader(base_class,form_class ): def __init__(self): super(PluralsightDownloader,self).__init__() self.setupUi(self) # self.Save_Location.setText(dirname) self.Login_Btn.clicked.connect(self.login) self.Svae_Btn.clicked.connect(self.browse_file) self.Download_Btn.clicked.connect(self.download) self.OpenDirectory_Btn.clicked.connect(self.openDirectory) self.DownloadComboBox.currentIndexChanged.connect(self.changeDownLoad) self.CaptionWidget.setVisible(False) self.DownloadWidget.setVisible(True) def changeDownLoad(self): self.Save_Location.setText("") type = self.DownloadComboBox.currentIndex() if type == 0: self.DownloadWidget.setVisible(True) self.CaptionWidget.setVisible(False) elif type == 3: self.DownloadWidget.setVisible(False) self.CaptionWidget.setVisible(True) else: self.DownloadWidget.setVisible(False) self.CaptionWidget.setVisible(False) def openDirectory(self): Save_Location = self.Save_Location.text() if Save_Location == "": Save_Location = os.getcwd() else: Save_Location = os.path.split(Save_Location)[0] if os.path.exists(Save_Location): subprocess.call("explorer %s" % Save_Location, shell=True) else: QMessageBox.warning(self, "Warning", "路径不存在\n检查路径是否正确") def login(self): Username = self.Username.text() Password = self.Password.text() url = "https://app.pluralsight.com/id/" payload = "------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"Username\"\r\n\r\n%s\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW\r\nContent-Disposition: form-data; name=\"Password\"\r\n\r\n%s\r\n------WebKitFormBoundary7MA4YWxkTrZu0gW--" % (Username,Password) headers = &#123; 'content-type': "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW", 'Cache-Control': "no-cache", 'Postman-Token': "cb0555f3-21dc-4833-8511-a64ee304df32" &#125; response = requests.request("POST", url, data=payload, headers=headers) try: PsJwt = response.request.headers['Cookie'].split('; ')[1] except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "数据获取失败\n检查用户名和密码是否输入正确") return PsJwtEncrypt = "" randEncrpt = "" rand = random.randint(1,10000) for letter in PsJwt: PsJwtEncrypt += chr(ord(letter)+rand) for letter in str(rand): randEncrpt += chr(ord(letter)+100) with open(TOKEN_PATH,'w', encoding='UTF-8') as f: f.write(PsJwtEncrypt+"\n"+randEncrpt+"\n文件已经加密，请勿擅自修改") QMessageBox.information(self, "Information", "数据写入完成") def browse_file(self): type = self.DownloadComboBox.currentIndex() # 根据当前选择切换保存方案 if type == 0: save_file = QFileDialog.getExistingDirectory(self, caption="保存文件到", directory=".") elif type == 1: save_file = QFileDialog.getSaveFileName(self, caption="保存文件到", directory=".",filter="jpg (*.jpg)") elif type == 2: save_file = QFileDialog.getSaveFileName(self, caption="保存文件到", directory=".",filter="Excel (*.xls)") elif type == 3: save_file = QFileDialog.getExistingDirectory(self, caption="保存文件到", directory=".") self.Save_Location.setText(QDir.toNativeSeparators(save_file)) def download(self): type = self.DownloadComboBox.currentIndex() PsJwtEncrypt = [] try: with open(TOKEN_PATH,'r',encoding='UTF-8') as f: for line in f.readlines(): PsJwtEncrypt.append(line.strip('\n')) except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "秘钥文件打开失败\n请先在登录设置获取秘钥") return PsJwt = "" rand = "" try: for letter in PsJwtEncrypt[1]: rand += chr(ord(letter)-100) for letter in PsJwtEncrypt[0].split('\n')[0]: PsJwt += chr(ord(letter)-int(rand)) except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "秘钥文件解码失败\n请重新生成新的秘钥") return Save_Location = self.Save_Location.text() DownloadURL = self.DownloadURL.text() if DownloadURL == "": QMessageBox.warning(self, "Warning", "请输入网页URL") return reg = r'courses/(.*)' courseIdReg = re.compile(reg) courseId = re.findall(courseIdReg,DownloadURL)[0].split('/')[0] url = "https://app.pluralsight.com/learner/content/courses/%s" % courseId headers = &#123; 'Cache-Control': "no-cache", 'Postman-Token': "ca8bb1e7-99b7-4b41-b7d2-2813bf834e2f" &#125; response = requests.request("GET", url, headers=headers) jsonFile = json.loads(response.text) if type == 0: self.Download_Speed.setText("") Save_Location = self.Save_Location.text() self.File_Path.setText(Save_Location) # 根据教程的名称创建根目录 rstr = r"[\/\\\:\*\?\"\&lt;\&gt;\|]" # '/ \ : * ? " &lt; &gt; |' courseTitle = re.sub(rstr, "_", jsonFile['title']) # 替换为下划线 courseTitle = courseTitle.strip() directory = os.path.join(Save_Location,courseTitle) if not os.path.exists(directory): os.mkdir(directory) # 获取教程图片 ImgCheckBox = self.ImgCheckBox.isChecked() if ImgCheckBox: courseImageUrl = jsonFile['courseImageUrl'] ImgDirectory = os.path.join(directory,courseTitle+".jpg") self.File_Name.setText(courseTitle+".jpg") self.ImgWrite(courseImageUrl,ImgDirectory) # 获取Excel信息 ExcelCheckBox = self.ExcelCheckBox.isChecked() if ExcelCheckBox: ExcelDirectory = os.path.join(directory,courseTitle+".xls") self.File_Name.setText(courseTitle+".xls") self.ExcelWrite(jsonFile,PsJwt,ExcelDirectory) # 获取教程字幕 ZH_Caption = self.ZH_Caption.isChecked() EN_Caption = self.EN_Caption.isChecked() if ZH_Caption or ZH_Caption: self.CaptionWrite(jsonFile,directory,EN=EN_Caption,ZH=ZH_Caption) modules = jsonFile['modules'] count = 0 moduleCount = 0 clipCount = 0 print("开始下载") for module in modules: # 创建模块文件夹 rstr = r"[\/\\\:\*\?\"\&lt;\&gt;\|]" # '/ \ : * ? " &lt; &gt; |' moduleTitle = re.sub(rstr, "_", modules[moduleCount]['title']) # 替换为下划线 moduleTitle = moduleTitle.strip() moduleDirectory = os.path.join(directory,"%s_%s" % (moduleCount+1,moduleTitle)) if not os.path.exists(moduleDirectory): os.mkdir(moduleDirectory) clipCount = 0 clips = module['clips'] for clip in clips: start_time= time.time() count += 1 rstr = r"[\/\\\:\*\?\"\&lt;\&gt;\|]" # '/ \ : * ? " &lt; &gt; |' clipTitle = re.sub(rstr, "_", clip['title']).strip() # 替换为下划线 clipName = "%s_%s%s" % (count,clipTitle,".mp4") self.File_Name.setText(clipName) fileDirectory = os.path.join(moduleDirectory,clipName) if not os.path.exists(fileDirectory): # 解析真实下载地址 courseName = jsonFile['modules'][moduleCount]['id'].split('|')[0] author = jsonFile['modules'][moduleCount]['id'].split('|')[1] moduleName = jsonFile['modules'][moduleCount]['id'].split('|')[2] clipIndex = jsonFile['modules'][moduleCount]['clips'][clipCount]['ordering'] # 获取 视频链接 url = "https://app.pluralsight.com/player/api/graphql" # cookie 存放账号信息 headers = &#123; 'Content-Type': "application/json", 'Cookie': PsJwt, 'Cache-Control': "no-cache", 'Postman-Token': "6609e6d1-132d-4f7c-b4ab-d8b392f39f9b" &#125; payload = "&#123;\"query\":\"\\n query viewClip &#123;\\n viewClip(input: &#123;\\n author: \\\"%s\\\", \\n clipIndex: %s, \\n courseName: \\\"%s\\\", \\n includeCaptions: false, \\n locale: \\\"en\\\", \\n mediaType: \\\"mp4\\\", \\n moduleName: \\\"%s\\\", \\n quality: \\\"1024x768\\\"\\n &#125;) &#123;\\n urls &#123;\\n url\\n cdn\\n rank\\n source\\n &#125;,\\n status\\n &#125;\\n &#125;\\n \",\"variables\":&#123;&#125;&#125;" % (author,clipIndex,courseName,moduleName) try: response = requests.request("POST", url, data=payload, headers=headers) except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "链接失败") return urlList = json.loads(response.text) DownLoadChannel = self.DownLoadChannelComboBox.currentIndex() r = requests.get(urlList['data']['viewClip']['urls'][DownLoadChannel]['url'],stream=True) content_size = int(r.headers['content-length']) # 内容体总大小 downloadCount = 0 chunk_size = 1024 with open(fileDirectory, "wb") as video: for chunk in r.iter_content(chunk_size=chunk_size): if chunk: downloadCount += 1 dural_time= round(time.time() - start_time,2) speed = downloadCount * (chunk_size/1024)/dural_time video.write(chunk) percent = downloadCount * chunk_size/content_size * 100 print(int(percent)) self.Download_Progress.setValue(int(percent)) self.Download_Speed.setText(str(round(speed,2))+"kb/s") clipCount += 1 print("%s - 下载完成" % clipName) else: print("%s 视频文件已存在- 跳过" % clipName) moduleCount += 1 QMessageBox.warning(self, "Warning", "下载完成") print("下载完成") # 下载教程图片 elif type == 1: Save_Location = self.Save_Location.text() self.File_Path.setText(os.path.split(Save_Location)[0]) self.File_Name.setText(os.path.split(Save_Location)[1]) courseImageUrl = jsonFile['courseImageUrl'] self.ImgWrite(courseImageUrl,Save_Location) QMessageBox.warning(self, "Warning", "下载完成") # 保存教程信息到xls中 elif type == 2: Save_Location = self.Save_Location.text() self.Download_Speed.setText("") self.File_Path.setText(os.path.split(Save_Location)[0]) self.File_Name.setText(os.path.split(Save_Location)[1]) self.ExcelWrite(jsonFile,PsJwt,Save_Location) QMessageBox.information(self, "Information", "数据写入完成") # 下载教程字幕 elif type == 3: Save_Location = self.Save_Location.text() ZH_Caption_1 = self.ZH_Caption_1.isChecked() EN_Caption_1 = self.EN_Caption_1.isChecked() if ZH_Caption_1 == False and EN_Caption_1 == False: QMessageBox.information(self, "Information", "请选择一种字幕进行下载") return self.CaptionWrite(jsonFile,Save_Location,EN=EN_Caption_1,ZH=ZH_Caption_1) QMessageBox.information(self, "Information", "数据写入完成") def ImgWrite(self,courseImageUrl,Save_Location): if not os.path.exists(Save_Location): r = requests.get(courseImageUrl,stream=True) start_time = time.time() content_size = int(r.headers['content-length']) # 内容体总大小 count = 0 chunk_size = 1024 print("开始下载") with open(Save_Location, "wb") as img: for chunk in r.iter_content(chunk_size=chunk_size): if chunk: count += 1 dural_time= round(time.time() - start_time,2) speed = count * (chunk_size/1024)/dural_time img.write(chunk) percent = count * chunk_size/content_size * 100 print(int(percent)) self.Download_Progress.setValue(int(percent)) self.Download_Speed.setText(str(round(speed,2))+"kb/s") print("下载完成") else: print("%s 图片文件已存在 - 跳过"%Save_Location) def ExcelWrite(self,jsonFile,PsJwt,Save_Location): if not os.path.exists(Save_Location): print("开始写入") # 设置字体样式 font0 = xlwt.Font() font0.name = '微软雅黑' alignment = xlwt.Alignment() alignment.horz = xlwt.Alignment.HORZ_CENTER alignment.vert = xlwt.Alignment.VERT_CENTER style0 = xlwt.XFStyle() style0.font = font0 style0.alignment = alignment # 创建 excel 对象 book = xlwt.Workbook(encoding='utf-8', style_compression=0) # 创建 excel 表 sheet = book.add_sheet('test', cell_overwrite_ok=True) row = 0 column = 0 sheet.write(row, column , "序号" , style0 ) sheet.write(row, column + 1 , "视频标题" , style0 ) sheet.write(row, column + 2 , "序号加视频标题" , style0 ) sheet.write(row, column + 3 , "视频播放地址" , style0 ) sheet.write(row, column + 4 , "模块标题" , style0 ) sheet.write(row, column + 5 , "下载通道1" , style0 ) sheet.write(row, column + 6 , "下载通道2" , style0 ) sheet.write(row, column + 7 , "下载通道3" , style0 ) sheet.write(row, column + 8 , "下载通道4" , style0 ) # 取消居中 alignment = xlwt.Alignment() style0.alignment = alignment modules = jsonFile['modules'] count = 0 for module in modules: clips = module['clips'] for clip in clips: count += 1 totalCount = count count = 0 moduleCount = 0 clipCount = 0 for module in modules: clipCount = 0 clips = module['clips'] for clip in clips: count += 1 sheet.write(row + count, column , count , style0 ) sheet.write(row + count, column + 1 , clip['title'] , style0 ) sheet.write(row + count, column + 2 , "%s_%s" % (count,clip['title']) , style0 ) sheet.write(row + count, column + 3 , "https://app.pluralsight.com/%s" % clip['playerUrl'] , style0 ) sheet.write(row + count, column + 4 , clip['moduleTitle'] , style0 ) # 解析真实下载地址 courseName = jsonFile['modules'][moduleCount]['id'].split('|')[0] author = jsonFile['modules'][moduleCount]['id'].split('|')[1] moduleName = jsonFile['modules'][moduleCount]['id'].split('|')[2] clipIndex = jsonFile['modules'][moduleCount]['clips'][clipCount]['ordering'] # 获取 视频链接 url = "https://app.pluralsight.com/player/api/graphql" # cookie 存放账号信息 headers = &#123; 'Content-Type': "application/json", 'Cookie': PsJwt, 'Cache-Control': "no-cache", 'Postman-Token': "6609e6d1-132d-4f7c-b4ab-d8b392f39f9b" &#125; payload = "&#123;\"query\":\"\\n query viewClip &#123;\\n viewClip(input: &#123;\\n author: \\\"%s\\\", \\n clipIndex: %s, \\n courseName: \\\"%s\\\", \\n includeCaptions: false, \\n locale: \\\"en\\\", \\n mediaType: \\\"mp4\\\", \\n moduleName: \\\"%s\\\", \\n quality: \\\"1024x768\\\"\\n &#125;) &#123;\\n urls &#123;\\n url\\n cdn\\n rank\\n source\\n &#125;,\\n status\\n &#125;\\n &#125;\\n \",\"variables\":&#123;&#125;&#125;" % (author,clipIndex,courseName,moduleName) try: response = requests.request("POST", url, data=payload, headers=headers) except Exception: traceback.print_exc() # book.save(Save_Location) QMessageBox.warning(self, "Warning", "链接失败 跳过当前项") break urlList = json.loads(response.text) sheet.write(row + count, column + 5 , urlList['data']['viewClip']['urls'][0]['url'] , style0 ) sheet.write(row + count, column + 6 , urlList['data']['viewClip']['urls'][1]['url'] , style0 ) sheet.write(row + count, column + 7 , urlList['data']['viewClip']['urls'][2]['url'] , style0 ) sheet.write(row + count, column + 8 , urlList['data']['viewClip']['urls'][3]['url'] , style0 ) percent = count * 100 / totalCount self.Download_Progress.setValue(int(percent)) print(int(percent)) clipCount += 1 moduleCount += 1 book.save(Save_Location) print("写入完成") else: print("%s Excel文件已存在 - 跳过" % Save_Location) def CaptionWrite(self,jsonFile,Save_Location,EN=True,ZH=False): # 根据教程的名称创建根目录 CaptionDirectory = os.path.join(Save_Location,"EN_caption") if not os.path.exists(CaptionDirectory): os.mkdir(CaptionDirectory) count = 0 modules = jsonFile['modules'] for module in modules: clips = module['clips'] for clip in clips: rstr = r"[\/\\\:\*\?\"\&lt;\&gt;\|]" # '/ \ : * ? " &lt; &gt; |' clipTitle = re.sub(rstr, "_", clip['title']).strip() # 替换为下划线 SRT_PATH = os.path.join(CaptionDirectory, '%s_%s.srt' % (count+1,clipTitle)) # 判断文件是否存在 if not os.path.exists(SRT_PATH): url = "https://app.pluralsight.com/transcript/api/v1/caption/json/%s" % clip['clipId'] headers = &#123; 'content-type': "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW", 'Cache-Control': "no-cache", 'Postman-Token': "c491c561-8e66-4cb8-b717-2bfd9b5b0d9a" &#125; if EN == True: EN_url = url + "/en" try: EN_response = requests.request("GET", EN_url, headers=headers) EN_CaptionFile = json.loads(EN_response.text) except Exception: traceback.print_exc() print ("链接超时，跳过当前下载") break captionCount = 0 srtFIle = "" for caption in EN_CaptionFile: typeName = type(caption['displayTimeOffset']).__name__ if typeName == 'float' or typeName == 'int': m, s = divmod(caption['displayTimeOffset'], 60) else: duration = (EN_CaptionFile[captionCount-1]['displayTimeOffset'] + EN_CaptionFile[captionCount+1]['displayTimeOffset'])/2 m, s = divmod(duration, 60) h, m = divmod(m, 60) startTime = "%02d:%02d:%02d" % (h, m, s) if len(EN_CaptionFile) == captionCount+1: duration = float(re.findall(r"\d+\.?\d*",clip['duration'])[0]) m, s = divmod(duration, 60) else: typeName = type(EN_CaptionFile[captionCount+1]['displayTimeOffset']).__name__ if typeName == 'float' or typeName == 'int' : m, s = divmod(EN_CaptionFile[captionCount+1]['displayTimeOffset'], 60) else: duration = (EN_CaptionFile[captionCount]['displayTimeOffset'] + EN_CaptionFile[captionCount+2]['displayTimeOffset'])/2 m, s = divmod(duration, 60) h, m = divmod(m, 60) endTime = "%02d:%02d:%02d" % (h, m, s) srtFIle += "%s\n" % captionCount srtFIle += "%s --&gt; %s\n" % (startTime,endTime) srtFIle += "%s\n\n" % caption['text'] captionCount += 1 with open(SRT_PATH,'w', encoding='UTF-8') as f: f.write(srtFIle) print ('%s_%s.srt - 写入完成' % (count+1,clip['title'])) if ZH == True: ZH_url = url + "/zh" try: ZH_response = requests.request("GET", ZH_url, headers=headers) ZH_CaptionFile = json.loads(ZH_response.text) except Exception: traceback.print_exc() print ("链接超时，跳过当前下载") break captionCount = 0 srtFIle = "" for caption in ZH_CaptionFile: typeName = type(caption['displayTimeOffset']).__name__ if typeName == 'float' or typeName == 'int': m, s = divmod(caption['displayTimeOffset'], 60) else: duration = (ZH_CaptionFile[captionCount-1]['displayTimeOffset'] + ZH_CaptionFile[captionCount+1]['displayTimeOffset'])/2 m, s = divmod(duration, 60) h, m = divmod(m, 60) startTime = "%02d:%02d:%02d" % (h, m, s) if len(ZH_CaptionFile) == captionCount+1: duration = float(re.findall(r"\d+\.?\d*",clip['duration'])[0]) m, s = divmod(duration, 60) else: typeName = type(ZH_CaptionFile[captionCount+1]['displayTimeOffset']).__name__ if typeName == 'float' or typeName == 'int': m, s = divmod(ZH_CaptionFile[captionCount+1]['displayTimeOffset'], 60) else: duration = (ZH_CaptionFile[captionCount]['displayTimeOffset'] + ZH_CaptionFile[captionCount+2]['displayTimeOffset'])/2 m, s = divmod(duration, 60) h, m = divmod(m, 60) endTime = "%02d:%02d:%02d" % (h, m, s) srtFIle += "%s\n" % captionCount srtFIle += "%s --&gt; %s\n" % (startTime,endTime) srtFIle += "%s\n\n" % caption['text'] captionCount += 1 # 根据教程的名称创建根目录 CaptionDirectory = os.path.join(Save_Location,"ZH_caption") if not os.path.exists(CaptionDirectory): os.mkdir(CaptionDirectory) rstr = r"[\/\\\:\*\?\"\&lt;\&gt;\|]" # '/ \ : * ? " &lt; &gt; |' clipTitle = re.sub(rstr, "_", clip['title']).strip() # 替换为下划线 SRT_PATH = os.path.join(CaptionDirectory, '%s_%s.srt' % (count+1,clipTitle)) with open(SRT_PATH,'w', encoding='UTF-8') as f: f.write(srtFIle) print ('%s_%s.srt - 写入完成' % (count+1,clip['title'])) else: print("%s srt文件已存在 - 跳过" % SRT_PATH) count += 1 app = QApplication(sys.argv)dl = PluralsightDownloader()dl.show()app.exec_() &emsp;&emsp;软件界面是这样的，当你输入账号密码之后会生成一个 token.verify 文件&emsp;&emsp;文件已经经过加密，存储的就是PsJwt的值&emsp;&emsp;加密方法可以参考我的源码，我就不再赘述。加密参考&emsp;&emsp;生成之后软件就会自动读取文件，然后进行下载。 总结 &emsp;&emsp;最近一直尝试攻克Lynda，制作Lynda下载器，然而却一直不成功。&emsp;&emsp;Lynda的验证信息已经找到了，是token的值&emsp;&emsp;但是我却无法通过Python获取到相关的token值，已经测试了很多方法，依旧无能为力。&emsp;&emsp;毕竟Python的方法是依托于图书馆之下的账号，而不是Pluralsight那样的个人账号，验证更加繁琐。&emsp;&emsp;经过了差不多三天的研究，我放弃了。 &emsp;&emsp;下周就要去深圳，很快就迎来我的实习岗位了，有点小激动。&emsp;&emsp;希望自己再接再厉，努力取得公司的认可。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - PyQt & Qt Designer 三套教程]]></title>
    <url>%2Fposts%2Fef451c1b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;之前制作青年之声爬虫界面的时候就在看PyQt相关的教程。&emsp;&emsp;目前为止看了三部教程。 Pluralsight - Python Desktop Application Development Pluralsight - Python Desktop Application Development Part 2 - Design Digital-Tutors Creating Custom User Interfaces in Maya and Qt Designer &emsp;&emsp;为了开发青年之声爬虫的界面，我先从桌面应用相关的两套教程看起。&emsp;&emsp;现在看来我的决定是对的，这两套教程通俗易懂，由浅入深，就是没有太多深奥的功能。&emsp;&emsp;反而是DT的那套教程让我无言以对，循环打脸…… Pluralsight - Python Desktop Application Development &emsp;&emsp;这两部桌面开发的教程我我认为可以看做一部了。&emsp;&emsp;第一部主要讲解PyQt用纯代码实现界面的过程。&emsp;&emsp;第二部则使用 Qt Designer 开发更高逼格的界面。&emsp;&emsp;我是真的没想到 Qt 居然用CSS样式，看来一年前端的历练真的没有白学。 &emsp;&emsp;第一部教程其实真的没有什么难度，特别是看过了 Python For Maya Artist Friendly Programming 教程之后。&emsp;&emsp;无非就是从依赖于Maya界面变成独立的界面。&emsp;&emsp;其实也就是加多两行代码的事情。 123456789# 写完界面代码后 在生成界面前加入这两行代码app = QApplication(sys.argv)# 生成界面dl = mayaDemo()dl.show()# 生成结束app.exec_() &emsp;&emsp;在Maya中加入这两行会报错并提示QApplication已经存在。&emsp;&emsp;因此第一部分的界面开发我已经相当熟悉，所以后面我就顺理成章地将相关的代码框架拿来开发 青年之声爬虫 爬虫界面了。 &emsp;&emsp;第二部分就是 Qt Designer 的介绍了。&emsp;&emsp;教程分析了Qt Designer的优劣&emsp;&emsp;Qt Designer的设计思路和Netbean一类的软件是一样的，所见即所得&emsp;&emsp;缺点是输出ui文件，还需要Python进行处理&emsp;&emsp;我个人觉得 Qt Designer 还是非常适合流程开发的，毕竟比起写代码效率高太多了。 &emsp;&emsp;另外教程还着重提到了如何将ui文件compile成py文件进行调用。&emsp;&emsp;只是鉴于py文件会涉及到 PyQt 和 PySide 调用的问题，为了保证这个步骤不出错，在Maya中我还是建议直接编译ui文件比较好。&emsp;&emsp;另外教程也提到资源打包手动生成qrc文件的方法。 &emsp;&emsp;整套教程下来难度不大，而且还有不少软件开发的黑科技涉及其中。&emsp;&emsp;比如任务栏上的图标、信息提示，打开软件先显示加载界面的图片等等。 Digital-Tutors Creating Custom User Interfaces in Maya and Qt Designer &emsp;&emsp;这部教程真的让我抓狂和无语。&emsp;&emsp;制作教程的制作者估计也没有做好充分的准备，从一开始就打脸不断，一堆代码问题不停出现。&emsp;&emsp;然后教程就陷入了浪费时间的Debug time。&emsp;&emsp;一次两次就算了，这个问题居然一直伴随到教程结束。。。 &emsp;&emsp;当然教程一开始提到的 Qt Designer 接入到Maya的方法还是非常有用的。&emsp;&emsp;然而这里我遇到了PyQt的问题。&emsp;&emsp;Maya2018不再支持 PySide 和 PyQt4，然而不知道为什么PyQt5 似乎默认也是不支持的。&emsp;&emsp;教程毕竟是老教程，使用的是PyQt4，所以我要想办法让ui文件在PySide2中使用起来。&emsp;&emsp;然而使用PyQt4的方法遇到了问题。&emsp;&emsp;PyQt4有个方法是 loadUiType 可以返回两个可以调用的Class。 &emsp;&emsp;经过网上搜索，最终还是找到了解决方法。 https://stackoverflow.com/questions/4442286/python-code-generation-with-pyside-uic&emsp;&emsp;根据教程的第一个案例演示，跟着完成制作一个按钮生成方块的过程。&emsp;&emsp;下面就是运行的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from PySide2.QtCore import *from PySide2.QtGui import *from PySide2.QtWidgets import *import sysimport pyside2uicimport xml.etree.ElementTree as xmlfrom cStringIO import StringIOdef loadUiType(uiFile): """ Pyside "loadUiType" command like PyQt4 has one, so we have to convert the ui file to py code in-memory first and then execute it in a special frame to retrieve the form_class. """ parsed = xml.parse(uiFile) widget_class = parsed.find('widget').get('class') form_class = parsed.find('class').text with open(uiFile, 'r') as f: o = StringIO() frame = &#123;&#125; pyside2uic.compileUi(f, o, indent=0) pyc = compile(o.getvalue(), '&lt;string&gt;', 'exec') exec pyc in frame # Fetch the base_class and form class based on their type # in the xml from designer form_class = frame['Ui_%s'%form_class] base_class = eval('%s'%widget_class) return form_class, base_class UI_PATH = "C:\Users\Administrator\Desktop\makeCube.ui"form_class , base_class = loadUiType(UI_PATH)class Interface(base_class,form_class): def __init__(self): super(Interface,self).__init__() self.setupUi(self) self.makeCube_btn.clicked.connect(self.makeCubeWin) def makeCubeWin(self): mel.eval('CreatePolygonCube;') print "hello" if __name__ == "__main__": global ui ui = Interface() ui.show() &emsp;&emsp;教程的后半部分并没有什么干货，作者也是个手残，我加到4倍速还是觉得代码编写慢(:з」∠)&emsp;&emsp;作者无非就是将mel在Python上面运行而已，而且中途还几次翻车。&emsp;&emsp;最让我无语的是 07. The secret of spin box 这集&emsp;&emsp;他意思是制作长宽为零的 spinbox 可以更方便去调用combobox，而且不影响界面。&emsp;&emsp;然而真相是作者后面的代码出错了，所以最后压根就没有使用spinbox，而是直接索引combobox&emsp;&emsp;我感觉自己第7集就是智障呀。 &emsp;&emsp;另外后面作者不知道怎么拉出分割线，隔开各个UI，居然将lineEdit调小做成分割线。&emsp;&emsp;不过结果看起来还不错。。。。。。真香。。。。。。 总结 &emsp;&emsp;最近打算继续深入学习Qt Designer，另外师兄推荐的youtube教程 PyQt4 Model View Programming Tutorials 我正在看。&emsp;&emsp;感觉这套教程很强，很复杂，毕竟涉及到MVC框架，而且很多函数都是在继承Qt类的基础上进行功能重写。&emsp;&emsp;这让我有点懵逼。&emsp;&emsp;最近也试图尝试开发一些桌面应用来加深Qt的理解和运用，最近遇到的一些桌面程序开发的坑相信很快又可以写成一篇文章发布了。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠆQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python - 用 PyQt 写爬虫界面]]></title>
    <url>%2Fposts%2F5b9053f9.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;昨天总结了一下爬虫的抓取方法，并提到一定要通过PyQt写一个桌面软件。链接&emsp;&emsp;今天通过不断修改，已经完美地将所有功能实现了。 使用说明 &emsp;&emsp;打开压缩包会看到四个文件。&emsp;&emsp;使用说明已经简单交代了软件的用法。&emsp;&emsp;templete.xls 和 data.txt 文件可以先忽视，后续会交代这两个文件的作用。&emsp;&emsp;先打开 pyYouthExcel-ver2.0.exe &emsp;&emsp;初次打开软件会看到两个窗口。&emsp;&emsp;左边黑乎乎的窗口是控制台&emsp;&emsp;当程序出错或者无响应的时候，可以通过控制台看到反馈的信息。&emsp;&emsp;右边的窗口就是程序的主界面。 &emsp;&emsp;这个界面就是软件主界面&emsp;&emsp;最上面是数据获取设置，清除掉输入框中的文本可以看到输入提示。&emsp;&emsp;没错，这里获取的就是文件夹中的两个文件信息。&emsp;&emsp;当然也可以自己创建相关的文件，点击选择可以选到相关的路径中&emsp;&emsp;获取完之后，界面会出现完整的路径&emsp;&emsp;这个路径和之前的 data.txt 路径有什么不同效果吗？&emsp;&emsp;其实两个路径都实现了相同的功能。&emsp;&emsp;路径很长的称之为绝对路径，从盘符开始索引。&emsp;&emsp;路径很对的称之为相对路径，从当前程序所在的目录开始索引。 &emsp;&emsp;下面就是 输入网页URL 的区域了&emsp;&emsp;这里可以将青年之声的提问链接输入进去&emsp;&emsp;当然也可以输入多条链接，链接之间用回车分行即可&emsp;&emsp;再下面就是选择文件保存路径&emsp;&emsp;基本操作相信也不用说明了，直接输入文件名称则以相对路径保存到当前程序启动目录中。&emsp;&emsp;确认输入无误之后，点击一键统计。&emsp;&emsp;执行完毕之后可以在目录中看到多了两个文件&emsp;&emsp;其实只是多出了生成文件， qt.conf 文件在打开程序之后自动生成，不影响使用。&emsp;&emsp;下面打开 test.xls 文件&emsp;&emsp;所有的统计操作都通过程序完成了。 &emsp;&emsp;程序操作讲解完毕，重点来看看配置文件都是什么吧&emsp;&emsp; data.txt 存储的是同学的相关信息&emsp;&emsp;另外有一个快捷的操作，务必使用此方法。&emsp;&emsp;在Excel上复制同学们的信息&emsp;&emsp;可以直接粘贴到txt文档中&emsp;&emsp;代码背后会识别这个间隔，输入正确才能让程序正确运行。&emsp;&emsp;手动输入这个间隔 不是按空格 而是按键盘 Tab 键&emsp;&emsp;！！！ 这里输入的姓名是指 青年之声用户名 ！！！&emsp;&emsp;如果用户名与真实姓名不一致 请输入 青年之声用户名 ！！！&emsp;&emsp;程序会根据 输入的用户名进行匹配 ！！！&emsp;&emsp;输入不匹配就不会输出 合格 ！！！&emsp;&emsp;请务必检查清楚 ！！！ &emsp;&emsp;最后就是 templete.xls 了&emsp;&emsp;其实这个文件只是获取它的基础板式&emsp;&emsp;如果不想要这个基础板式，可以去掉配置文件的索引。&emsp;&emsp;这样子生成的就是配置文件部分的 Excel 文档 代码分析 &emsp;&emsp;这个部分与软件使用无关，只是个人总结一下代码编写的过程。&emsp;&emsp;下面贴出软件的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272from PyQt4.QtCore import *from PyQt4.QtGui import *import sysimport reimport xlwtimport xlrdimport xlutils.copyimport requestsimport timeimport osimport tracebackclass Downloader(QDialog): def __init__(self): QDialog.__init__(self) # 创建窗口 self.resize(750,300) layout = QGridLayout() self.infoTitle = QLabel("&lt;center&gt;&lt;b&gt;数据获取设置&lt;/b&gt;&lt;/center&gt;") self.title = QLabel("&lt;center&gt;&lt;b&gt;输入网页URL&lt;/b&gt;&lt;/center&gt;") self.url = QPlainTextEdit() self.save_location = QLineEdit() self.DB_location = QLineEdit() self.templete_location = QLineEdit() self.progress = QProgressBar() download = QPushButton("一键统计") browse = QPushButton("选择") DB_browse = QPushButton("选择") templete_browse = QPushButton("选择") self.save_location.setPlaceholderText("文件保存路径") self.DB_location.setPlaceholderText("青年之声用户名信息存储文本") self.templete_location.setPlaceholderText("Excel模板文件") self.progress.setValue(0) self.progress.setAlignment(Qt.AlignHCenter) num = 1 layout.addWidget(self.infoTitle,num-1,0,1,4) layout.addWidget(self.DB_location,num,0,1,3) layout.addWidget(DB_browse,num,3,1,1) layout.addWidget(self.templete_location,num+1,0,1,3) layout.addWidget(templete_browse,num+1,3,1,1) layout.addWidget(self.title,num+2,0,1,4) layout.addWidget(self.url,num+3,0,1,4) layout.addWidget(self.save_location,num+4,0,1,3) layout.addWidget(browse,num+4,3,1,1) layout.addWidget(self.progress,num+5,0,1,4) layout.addWidget(download,num+6,0,1,4) self.setLayout(layout) self.setWindowTitle("青年之声统计神器 - 制作者：16级数字媒体技术2班梁伟添") self.DB_location.setText("data.txt") self.templete_location.setText("templete.xls") self.setFocus() download.clicked.connect(self.download) browse.clicked.connect(self.browse_file) DB_browse.clicked.connect(self.browse_DB) templete_browse.clicked.connect(self.browse_templete) def browse_file(self): save_file = QFileDialog.getSaveFileName(self, caption="保存文件到", directory=".",filter="Excel (*.xls)") self.save_location.setText(QDir.toNativeSeparators(save_file)) def browse_DB(self): DB_file = QFileDialog.getOpenFileNames(self, caption="获取青年之声用户名信息", directory=".",filter="txt (*.txt)") # 空数组处理 if not DB_file: return self.DB_location.setText(QDir.toNativeSeparators(DB_file[0])) def browse_templete(self): templete_file = QFileDialog.getOpenFileNames(self, caption="获取模板Excel文件", directory=".",filter="Excel (*.xls)") # 空数组处理 if not templete_file: return self.templete_location.setText(QDir.toNativeSeparators(templete_file[0])) def download(self): url = self.url.toPlainText() save_location = self.save_location.text() DB_location = self.DB_location.text() templete_location = self.templete_location.text() print("开始写入") if DB_location == "": QMessageBox.warning(self, "Warning", "用户数据不能为空") return try: with open(DB_location,'r') as f: info = f.read() except Exception: QMessageBox.warning(self, "Warning", "青年之声用户名信息获取失败\n检查文件路径是否正确") return reg = r'(.*)' studentReg = re.compile(reg) self.studentName = re.findall(studentReg,info) # 清除空字符串 self.studentName = [x for x in self.studentName if x != ''] # 遍历获取 url 输入框中的所有链接 reg = r'(http.*)' urldReg = re.compile(reg) urlList = re.findall(urldReg,url) # 创建 excel 对象 和 excel 表 if templete_location != "": try: rb = xlrd.open_workbook(templete_location,formatting_info=True) book = xlutils.copy.copy(rb) sheet = book.get_sheet(0) except Exception: QMessageBox.warning(self, "Warning", "Excel模板获取失败\n检查文件路径是否正确") return else: book = xlwt.Workbook(encoding='utf-8', style_compression=0) sheet = book.add_sheet('青年之声统计', cell_overwrite_ok=True) # 设置字体样式 font0 = xlwt.Font() font0.name = '微软雅黑' alignment = xlwt.Alignment() alignment.horz = xlwt.Alignment.HORZ_CENTER alignment.vert = xlwt.Alignment.VERT_CENTER style0 = xlwt.XFStyle() style0.font = font0 style0.alignment = alignment try: az = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" column = 4 r = 0 for name in self.studentName: userClass = name.split('\t')[0] userNum = name.split('\t')[1] userName = name.split('\t')[2] sheet.write(r+2, 0, r+1 ,style0) sheet.write(r+2, 1, userClass ,style0) sheet.write(r+2, 2, userNum ,style0) sheet.write(r+2, 3, userName ,style0) r += 1 # 分离处理 url 链接 for originUrl in urlList: # 获取url reg = r'quId=(.*?)&amp;' quIdReg = re.compile(reg) quId = re.findall(quIdReg,originUrl)[0] url = "https://api.12355.net/pc/service/getReplysByQuestionId?quId=%s&amp;page=1&amp;rows=500" % quId askUrl = "https://api.12355.net/pc/service/getQuesDetail?quId=%s" % quId try: # 获取html页面 response = requests.get(url) html = response.text response = requests.get(askUrl) askHtml = response.text except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "网络连接失败") return if html == "": break # 获取提问时间 reg = r'"askTime":"(.*?)"' askReg = re.compile(reg) askList = re.findall(askReg,askHtml) # 获取用户名 reg = r'"creatorName":"(.*?)"' nameReg = re.compile(reg) nameList = re.findall(nameReg,html) # 获取回复信息 reg = r'"replyContent":"(.*?)"' contentReg = re.compile(reg) contentList = re.findall(contentReg,html) # 获取回复时间 reg = r'"replyTime":"(.*?)"' timeReg = re.compile(reg) timeList = re.findall(timeReg,html) row = 0 # 批量生成超链接 sheet.write(1, column, xlwt.Formula('HYPERLINK("%s";"问题%s")' % (originUrl,column-3)),style0) for name in self.studentName: index = 0 # 检测回复是否符合条件 for creatorName in nameList: # 检测回复是否匹配 用户名 if name.split('\t')[2] == creatorName: # 检测是否是问题当天的时间进行回复 if askList[0].split(' ')[0] == timeList[index].split(' ')[0]: # 去除标点 检测回复是否超过5个字 reg = r"(?u)\w" textReg = re.compile(reg) textList = re.findall(textReg,contentList[index]) if len(textList) &gt;= 5: sheet.write(row+2, column , "合格" ,style0) break index += 1 row += 1 # 进度条加载 percent = (column-3) * 100 / len(urlList) self.progress.setValue(int(percent)) print(str(int(percent))+"%") # 纵向求和 判断数组是否越界的情况 if column &lt; 26: sheet.write(row+2, column , xlwt.Formula("COUNTIF(%s3:%s%s,\"合格\")" % (az[column],az[column],row+2)) ,style0) else: letter = "%s%s" % (az[int(column/26-1)],az[column%26]) sheet.write(row+2, column , xlwt.Formula("COUNTIF(%s3:%s%s,\"合格\")" % (letter,letter,row+2)) ,style0) column += 1 # 横向求和 r = 0 column -= 1 sheet.write(r+1, column+1 , "合计" ,style0) # 判断数组是否越界的情况 if column &lt; 26: for name in self.studentName: sheet.write(r+2, column+1 , xlwt.Formula("COUNTIF(%s%s:%s%s,\"合格\")" % (az[4],r+3,az[column],r+3)) ,style0) r += 1 sheet.write(r+2, column+1 , xlwt.Formula("SUM(%s%s:%s%s)" % (az[4],r+3,az[column],r+3)) ,style0) else: letter = "%s%s" % (az[int(column/26-1)],az[column%26]) for name in self.studentName: sheet.write(r+2, column+1 , xlwt.Formula("COUNTIF(%s%s:%s%s,\"合格\")" % (az[4],r+3,letter,r+3)) ,style0) r += 1 sheet.write(r+2, column+1 , xlwt.Formula("SUM(%s%s:%s%s)" % (az[4],r+3,letter,r+3)) ,style0) book.save(save_location) except Exception: traceback.print_exc() QMessageBox.warning(self, "Warning", "数据写入失败") return print("完成写入") QMessageBox.information(self, "Information", "数据写入完成") self.progress.setValue(0) # # 清空输入 # self.url.setText("") # self.save_location.setText("")app = QApplication(sys.argv)dl = Downloader()dl.show()app.exec_() &emsp;&emsp;这次观看了 Pluralsight - Python Desktop Application Development 教程&emsp;&emsp;参照了文件下载器的开发源码进行开发的。&emsp;&emsp;因为教程是采用 Python3 的 我上次写的怕从是基于 Python2 写的。&emsp;&emsp;所以这次重新用 Python3 的方法重写获取网页的方法，其实也不复杂。&emsp;&emsp;需要安装 requests 模块 &emsp;&emsp;这次开发中遇到最大的坑就是处理 Excel 表格数据&emsp;&emsp;Python操作 Excel 需要安装很多额外的库 可以参照网上的帖子和博文&emsp;&emsp;操作Excel的时候，for循环的很多输出需要不断运行程序来检验正确，这些都还好，花些时间还是可以制作出来的。&emsp;&emsp;最大的问题在于求和表达式的输出上&emsp;&emsp;表达式需要根据Excel表格的列序号进行输出，然而列序号是英文字母ABCD，如何通过数字来对应ABCD就让人很头疼。&emsp;&emsp;特别是超过了26个字母的时候会编程 AA AB AC 的格式，输出正确的求和公式就更加复杂。&emsp;&emsp;不过最后还是通过求模的方式解决了这个问题。 &emsp;&emsp;最后的问题就是如何将 py 脚本输出成 exe 可执行文件了&emsp;&emsp;这个可以安装 pyinstaller 模块&emsp;&emsp;Python可以通过这个模块将 py 脚本自动封装&emsp;&emsp;方便而且逼格满满！ 总结 &emsp;&emsp;Python开发比起C++简单很多，想起C++的MFC框架就很难受。&emsp;&emsp;之前我也用过基于C++的SFML框架，同样也没有PyQt来得便利，毕竟PyQt就是专门针对界面开发的，SFML只是基于OpenGL开发游戏的。&emsp;&emsp;PyQt的学习还不够，而且还有Qt Designer等着我。&emsp;&emsp;近期继续攻克PyQt的教程，另外 Pluralsight - Python Desktop Application Development 也可以写一波笔记了。]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>ࠆQt/PyQt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫 - 抓取 青年之声 数据]]></title>
    <url>%2Fposts%2F7d4ea2e3.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;昨天继任团支书向我抱怨说，青年之声的问题收到了很多人的答复，问题还成为了热门问题。&emsp;&emsp;想必到时候统计将会非常麻烦。&emsp;&emsp;回想起去年我苦逼的团支书生涯，我就对这个统计的痛苦感同身受。&emsp;&emsp;不过经过了一年Python以及前端的学习，我觉得自己可以通过爬虫来解决这个令人痛苦的难题了。 代码编写 &emsp;&emsp;暑假的时候有看过Python的入门教程，教程中就有讲到如何使用Python抓取页面的一些讯息。（就是爬虫）&emsp;&emsp;于是我从新把代码拿出来进行操作。 12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-import reimport urllibfrom urllib import requestdef getHtml(url): values = &#123;'name': 'voidking','language': 'Python'&#125; data = urllib.parse.urlencode(values).encode(encoding='utf-8',errors='ignore') headers = &#123; 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0' &#125; offer = request.Request(url=url, data=data,headers=headers,method='GET') page = request.urlopen(offer) html = page.read().decode('utf-8') return (html)def getVideoUrl(html): reg = r'src="(.*?\.js)"' imgReg = re.compile(reg) imglist = re.findall(imgReg,html) fnew = open('worm/data.txt','w') x=0 for imgurl in imglist: # request.urlretrieve(imgurl,'%s.png' %x) fnew.write(imgurl + "\n") x+=1 fnew.close()html = getHtml("https://www.12355.net/wechat/view/find_consult/find_consult_question_detail.html?quId=10087550&amp;username=25133106") print (getVideoUrl(html)) &emsp;&emsp;代码其实并不复杂，但是之前写好的代码运行却是发生错误。&emsp;&emsp;主要是 from urllib import request 这行报错了&emsp;&emsp;为了解决这个问题，我又查了很多资料，还涉及到 Python2 和 Python3 的坑 12345678import urllib2def getHtml(url): request = urllib2.Request(url) #模拟Mozilla浏览器进行爬虫 request.add_header("user-agent","Mozilla/5.0") response2 = urllib2.urlopen(request) html = response2.read().decode('utf-8') return (html) &emsp;&emsp;这样子执行代码就可以定位获取到html页面&emsp;&emsp;然而定好规则之后我却无法获取到相关的评论信息。&emsp;&emsp;这个问题我卡了很久，因为用浏览器链接是可以看到评论的。&emsp;&emsp;我在猜测莫非是我没有模拟出浏览器访问页面的效果吗？&emsp;&emsp;于是我用postman再次尝试访问页面。 &emsp;&emsp;然而懵逼的情况出现了。&emsp;&emsp;postman也是返回了全空的html页面&emsp;&emsp;这个情况我没有遇到过，也不清楚问题出在哪里。&emsp;&emsp;我猜测可能是因为访问页面没有模仿出浏览器访问的效果，可能还是缺少了某些头文件吧。&emsp;&emsp;于是我尝试着将页面中一些相关的头文件输入到postman中，然并卵。 &emsp;&emsp;最后我只好将postman中返回的页面复制到VScode中，在和原页面中比对，那里的html出问题了。&emsp;&emsp;经过自己的一番对比，我发现了问题的关键所在。 &emsp;&emsp;没错，评论的加载类似于瀑布流。&emsp;&emsp;只有拖动到相应的位置才会加载出更多的评论。&emsp;&emsp;于是我在网上搜索如何抓取动态页面的内容。下面这个网站给了我很大的启发。&emsp;&emsp;https://blog.csdn.net/dawn_yue/article/details/78352335&emsp;&emsp;动态页面是通过接口地址获取的json解析出来的。&emsp;&emsp;那我直接截取json数据就好了。 &emsp;&emsp;于是当我打开接口页面即可获取到相关的json数据。&emsp;&emsp;但是这样只能获取到部分的评论数据，如何才能获取所有的评论呢？&emsp;&emsp;稍微修改一些地址上的参数，就可以获取相应的所有评论数据。 &emsp;&emsp;于是我将路径的地址修改为接口的地址。&emsp;&emsp;成功获取到了所需要的json数据。 &emsp;&emsp;后续的操作都不是大问题，遇到的坑是decode有关的。&emsp;&emsp;使用 decode(‘utf-8’) 在cmd中不会输出乱码 ，但是读写文件的时候报错。&emsp;&emsp;所以最后我没有使用 decode 12345678910111213141516171819202122232425262728293031323334353637383940# -*- coding: utf-8 -*-import reimport urllib2studentName = ["张三","李四"]def getHtml(url): request = urllib2.Request(url) #模拟Mozilla浏览器进行爬虫 request.add_header("user-agent","Mozilla/5.0") response2 = urllib2.urlopen(request) html = response2.read() return (html)def getVideoUrl(html): reg = r'"creatorName":"(.*?)"' nameReg = re.compile(reg) nameList = re.findall(nameReg,html) with open('worm/data.txt','w') as fnew: for name in studentName: fnew.write("%s " % name) for creatorName in nameList: if name == creatorName: fnew.write("合格\n") break else: fnew.write("\n") return studentNamequId = "10087550"url = "https://api.12355.net/pc/service/getReplysByQuestionId?quId=%s&amp;page=1&amp;rows=500" % quIdhtml = getHtml(url) getVideoUrl(html) &emsp;&emsp;如此执行完之后，会输出这个txt文档&emsp;&emsp;后面就是将相关的数据输入到excel表格即可。 总结 &emsp;&emsp;学了一年的前端，感觉之前的学习都没有白费，充分体会到知识积累的重要性。&emsp;&emsp;爬虫并没有想象中的艰难&emsp;&emsp;（其实很困难，之前尝试过抓取Pluralsight视频链接，结果失败了）&emsp;&emsp;最近其实状态不是十分好，硬着头皮看 Pluralsight - Procedural Cities with Houdini and Python 教程&emsp;&emsp;虽然霆宇也在研究，不过自己也想学，但是这套教程还是挺复杂的，目前看了40多集，思路还没有完全理清楚。&emsp;&emsp;很快就要去华强方特那边实习了，所以师兄在催促我加快学习Qt的进度。&emsp;&emsp;正好我也想给这个爬虫开发个GUI界面，简化爬虫的复杂程度。&emsp;&emsp;自动城市的教程得先搁置了，Qt，我来也！！！]]></content>
      <categories>
        <category>Python</category>
        <category>工具开发</category>
      </categories>
      <tags>
        <tag>ࠕPython</tag>
        <tag>࠴编程/前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maya Python - 自动生成序号插件]]></title>
    <url>%2Fposts%2F19cb914e.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;再次地我又来提供花城汇项目相关的解决方案了。&emsp;&emsp;这一次要解决的是将模型的编号输出到box上。&emsp;&emsp;因为我们需要制作出编号图给甲方。&emsp;&emsp;这个图的编号是根据模型的名称输入的。&emsp;&emsp;但是这需要配合PS手动输入，这个过程繁琐而且累。&emsp;&emsp;这一次我们做的图是流花展馆，因为流花展馆的装修还没有完成，租户信息尚不完整&emsp;&emsp;甲方要求我们按照CAD上的房间编号进行制作&emsp;&emsp;这次我们编号有两千多个，这个工作量足以干死人了&emsp;&emsp;为此我需要想办法让Maya输出文字模型，从而简化大量的工作。 思路 注：这里解决方案是针对Maya2018新版文字实现的 在Maya中创建文字 修改文字模型的参数 截取模型名称上的编号 输入到文字节点中 复制模型 将复制的模型转换为boundingbox 给文字模型添加最小分段的晶格 将晶格的点和boundingbox的点逐一匹配 选择文字模型 删除历史 居中枢轴 稍微缩放一下文字 &emsp;&emsp;实现的思路并不复杂，代码量也不多。&emsp;&emsp;核心想法是晶格模型和碰撞盒的匹配。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import maya.cmds as cmdstargets = cmds.ls(selection=True)Text = []for target in targets: # 创建文字 cmds.CreatePolygonType() # 获取文字的 Transform 节点 TypeTransform = cmds.ls(selection=True)[0] # 获取 Type 节点 TypeNode = cmds.listConnections(TypeTransform , c=True)[1] TypeExtrudeNode = cmds.listConnections(TypeNode , t='typeExtrude')[0] # 设置字体 Generator 为 Python 模式 cmds.setAttr( '%s.generator' % TypeNode, 9 ) # 设置 Python 字符串 传入当前对象的名称 从而实现修改文字 cmds.setAttr( '%s.pythonExpression' % TypeNode, "\"%s\"" % target.split('_')[1] , type="string" ) # 注： textInput 可以修改文字 但是格式为unicode 不太方便 # 设置字体居中 cmds.setAttr( '%s.alignmentMode' % TypeNode, 2) # 曲线精度 降低为2 cmds.setAttr( '%s.curveResolution' % TypeNode, 2) # 不使用挤出 cmds.setAttr( '%s.enableExtrusion' % TypeExtrudeNode, 0) # 给文字 添加晶格 latticeList = cmds.lattice( dv=(2, 2, 2), oc=True ) ffdLatticeNode = latticeList[1] ##################################### # 复制当前对象 temp = cmds.duplicate( target, rr=True ) # 选择复制物体 cmds.select(temp) # 转换为碰撞盒 cmds.GeometryToBoundingBox() # 获取碰撞盒 BBox = cmds.ls(selection=True)[0] # 获取碰撞盒的点数 vertexNum = cmds.polyEvaluate( BBox , v=True ) # 获取碰撞盒每个点的世界坐标 存入数组中 vertexPos = [] for index in range(vertexNum): vertexPos.append(cmds.xform( "%s.vtx[%d]" % (BBox,index), q=True,t=True, ws=True)) # 匹配碰撞盒位置 cmds.select("%s.pt[0][1][1]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[0]) cmds.select("%s.pt[1][1][1]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[1]) cmds.select("%s.pt[1][0][1]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[2]) cmds.select("%s.pt[0][0][1]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[3]) cmds.select("%s.pt[0][1][0]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[4]) cmds.select("%s.pt[0][0][0]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[5]) cmds.select("%s.pt[1][0][0]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[6]) cmds.select("%s.pt[1][1][0]" % ffdLatticeNode ) cmds.xform( a=True, ws=True , t=vertexPos[7]) # 删除碰撞盒 cmds.delete(BBox) # 选择文字 cmds.select(TypeTransform) # 删除历史 cmds.DeleteHistory() # 居中枢轴 cmds.CenterPivot() # 缩放 cmds.scale(.7,.7,.7,r=True) ##################################### 遇到的坑 &emsp;&emsp;上面代码是针对Maya2018的新版的字体工具写的。&emsp;&emsp;刚开始我一直不知道如何才能将获取的box序号输入的文本中。&emsp;&emsp;最开始是希望通过命令回显来看文字输入的命令的&emsp;&emsp;然而文字输入并没有任何命令回显出来。&emsp;&emsp;于是我打开echo all command 来查看所有回显的命令&emsp;&emsp;结果只是一段不知其所以然，执行然并卵的代码 &emsp;&emsp;打开节点编辑器可以看到 type 节点下有 textInput 的端口&emsp;&emsp;但是由于没有命令回显，不知道如何操作它。&emsp;&emsp;于是我尝试着运行相关的命令&emsp;&emsp;首先可以确定的是，命令是可以执行的。&emsp;&emsp;但是执行报错了，提示说需要添加 -type 标志&emsp;&emsp;添加之后虽然可以执行但是并没有任何效果。&emsp;&emsp;于是我就没有继续研究这是什么情况。 &emsp;&emsp;经过一波三折的摸索，我发现 Generator 中的 Python 也可以生成相关的文字。&emsp;&emsp;但是无法回显不出操作命令&emsp;&emsp;于是我只好又一次硬着头皮去试着输入属性了&emsp;&emsp;没想到这一次也可以了，只是还是要添加这个type标签。&emsp;&emsp;于是我去查了 setAttr 相关的帮助文档&emsp;&emsp;原来type标签需要输入 “string” 来输入字符串&emsp;&emsp;于是我尝试操作了一下&emsp;&emsp;成功了，我将PythonExpression的属性修改了&emsp;&emsp;那么 textInput 也可以同理进行操作了&emsp;&emsp;然而 textInput 翻车了，通过Python执行可以知道，这个操作会将输入的数据进行 unicode 操作&emsp;&emsp;反而是输出了我预想之外的字母了。&emsp;&emsp;这个涉及到编码问题，相当复杂，于是我我就用python更为简单的方案了。 &emsp;&emsp;解决这个问题之后就没有太大的坑了，无非就是控制type节点的属性，基本上都是可以回显命令的。&emsp;&emsp;另外的难点就在于 晶格 和 boundingbox 的匹配上。&emsp;&emsp;这个需要自己去匹配相关的点。 &emsp;&emsp;最后的问题是 删除历史&emsp;&emsp;我想删除文字的历史&emsp;&emsp;让大纲列表看起来没那么混乱&emsp;&emsp;但是一旦这样就会爆出很多错误&emsp;&emsp;我猜测原因可能是因为文字节点创建还需要与很多其他的节点进行交互&emsp;&emsp;但是代码还没有执行到那里，删除历史就已经执行了，结果就导致很多节点找不到连接的目标。&emsp;&emsp;不过目前上述的报错并没有造成任何影响，可能会生成一些多余的节点，优化场景可以解决。 总结 &emsp;&emsp;这次开始尝试使用Python写脚本，本次和MEL没有太大的区别&emsp;&emsp;不过是将MEL转成Python而已，但是这一小步是为了以后的一大步。 &emsp;&emsp;到今天为止，前今天的感冒已经好了很多，后续问题不大。&emsp;&emsp;考虑到动画实训的缘故，我打算去研究一下如何利用Houdini实现城市自动生成的效果。&emsp;&emsp;这个不在我的10月计划中，但是我希望近期能够攻克这个难关。&emsp;&emsp;因此 Houdini17 测试延后。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Houdini - 计算模型体积 过滤问题模型]]></title>
    <url>%2Fposts%2F8150782b.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近花城汇项目又遇到了小小的问题（拖到现在，面目全无）&emsp;&emsp;3dsMax挤出的盒子并不是全部都是盒子，有部分只是面片，如何检测出这些多余的部分呢？&emsp;&emsp;我想了一下，想起了Houdini的measure节点，直接计算模型体积进行过滤就OK了 measure节点 &emsp;&emsp;然而事情并没有我想象的那么顺利。&emsp;&emsp;我们这边的模型是一堆box&emsp;&emsp;如果直接连接measure节点，会根据模型上的每个面进行体积计算 &emsp;&emsp;我需要的是对单个模型进行计算。&emsp;&emsp;然而如此循环遍历单个模型呢？&emsp;&emsp;我最开始是想用类似破碎的方案，直接加入assemble节点打包，&emsp;&emsp;循环遍历所有的物体。&emsp;&emsp;然而这样根本就计算不出体积。 &emsp;&emsp;因此我想到所有的box都丢进循环中&emsp;&emsp;最开始也不知道怎么操作，测试了一下就是弄好出来了&emsp;&emsp;添加connective节点将所有的模型面编号统一输出一个class属性，Houdini 16.5 的foreach节点自带相关操作了。 &emsp;&emsp;后面就是怎么计算体积了&emsp;&emsp;毕竟总不能去计算每一个面&emsp;&emsp;这里我想起了voronoi的时候的isoOffset节点&emsp;&emsp;通过那个节点可以将模型转成雾&emsp;&emsp;如此一来就可以计算体积了 &emsp;&emsp;但是这样输出没有模型&emsp;&emsp;过滤就没办法操作&emsp;&emsp;于是我想到使用attribute transfer将体积属性传递给原模型&emsp;&emsp;最后再用delete节点对模型进行过滤，就可以找到box模型中有问题的部分。 总结 &emsp;&emsp;其实很简单的操作，本来还想着用Maya Python实现的，想到Houdini Measure节点就懒得写了。&emsp;&emsp;最后发现Houdini的坑也不少。&emsp;&emsp;不过目前也攻克了。&emsp;&emsp;后面我找了一下，发现Maya可以使用 computePolysetVolume 命令计算体积&emsp;&emsp;但是这个命令只能用MEL执行&emsp;&emsp;于是又在网上查了一下，原来Python也可以执行MEL，那就不必担心。链接 2018-10-12 根据面数过滤模型 &emsp;&emsp;关于寻找问题模型的方法，又有了新的思路&emsp;&emsp;鉴于问题模型一般都是一个到两个面的面片，我可以计算片面数对模型进行过滤。&emsp;&emsp;思路是很清晰的，但是我却被 connective 节点生成的class属性给难住了。&emsp;&emsp;我是希望通过计算class数字相同的情况出现的次数，如果出现次数比较少，就进行过滤。&emsp;&emsp;但是这个操作非常难以实现，最主要的原因在于 wrangle 节点&emsp;&emsp;wrangle 中的primitive遍历会注意遍历每一个面片执行wrangle中的代码&emsp;&emsp;这样根本就没有办法将相关的变量累加起来。&emsp;&emsp;于是在这个死循环中写了很多无谓的代码进行测试。 &emsp;&emsp;最后我发现，用foreach节点可以有效地将所有的模型分离出来。&emsp;&emsp;这样只要直接根据面数过滤相关的模型即可。]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Creating an Animated Paper Folding Effect in Maya]]></title>
    <url>%2Fposts%2F68d818a2.html</url>
    <content type="text"><![CDATA[.center_iframe{ width:80%; height:30rem; margin:auto; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center; } @media screen and (max-width:600px){ .center_iframe{ height:12rem; } } 前言 &emsp;&emsp;十月初的时候有制定计划要会会这部炫酷的Maya特效教程。&emsp;&emsp;本来这不是什么重要教程，近期也不应该安排看这部教程，但是我看了第一集之后这部教程就深深吸引了我。&emsp;&emsp;我很好奇，如何使用Maya实现折纸的效果，这让我联想到了 Houdini 的 SOP 操作。&emsp;&emsp;我在猜测莫非这套教程也有什么利用特效操作模型的黑科技。&emsp;&emsp;于是我抱着这样的心情去看这套教程，特别是选修课没事干的时候。 制作分析 &emsp;&emsp;看完这部教程之后，并没有任何的黑科技，而且实现原理也是繁琐而简单的。&emsp;&emsp;作者的电影镜头切得真是一流，平平无奇的效果通过镜头的运动凸显了它的细微之处，这是值得更定的。 &emsp;&emsp;折纸效果原理 首先处理模型给模型添加厚度 然后使用ncloth演算模型倒下去的过程 ncloth有折纸效果的预设 后面是在ncloth的相关参数上设置关键帧，力求还原纸片折叠掉落的效果。 将模型以缓存的新式输出出来 导入模型缓存，然后将模型动画反转。 &emsp;&emsp;如此一来折纸成型的效果就大功告成了，鉴于教程历时原因，渲染采用mentalRay，我完全跳过了。&emsp;&emsp;不过教程中最吸引我的两个点还没有提到制作过程呢 车身折叠 折纸抖动 车身折叠 &emsp;&emsp;首先是印象最深刻的车身折叠覆盖成型的效果，我以为是通过动力学演算出来的效果，让我震惊不已&emsp;&emsp;没想到看完教程之后，我都不知道如何评价了&emsp;&emsp;这个效果居然给点设置关键帧做出来的&emsp;&emsp;点关键帧动画&emsp;&emsp;虽然效果非常棒，但是制作耗时，非常不实际(:з」∠) 折纸抖动 &emsp;&emsp;这个效果更是简单得一批。&emsp;&emsp;只需要在缓存的动画上添加 Jiggle 抖动节点，再稍稍调整一下参数就有了。 总结 &emsp;&emsp;另外教程也涉及到重拓扑车辆的过程，但是作者可能因为Maya2015的缘故，居然没有使用Maya自带的从重拓扑工具&emsp;&emsp;就在使用缓慢的建模命令来完成所有操作&emsp;&emsp;很可惜这套教程的制作并不符合我的预期，所以觉得它很令我失望。&emsp;&emsp;近期估计也不会再看Maya特效相关的教程了，尽管我之前准备了很多相关的教程。&emsp;&emsp;如今Houdini特效才是未来。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>特效</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠒ视频教程/pluralsight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Python For Maya Artist Friendly Programming]]></title>
    <url>%2Fposts%2F5c26d29c.html</url>
    <content type="text"><![CDATA[.center_iframe{ width:80%; height:30rem; margin:auto; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center; } @media screen and (max-width:600px){ .center_iframe{ height:12rem; } } 前言&emsp;&emsp;这篇教程也算是千呼万唤始出来，之前的观看进度挺快的，没想到最后两个案例如此晦涩难懂，以至于我花了很多的时间。&emsp;&emsp;最可怕的是听不懂，所以就很困，进入不了状态。&emsp;&emsp;有时候真的觉得，编程教程好像没有什么意义，看源代码的逻辑就可以学到不少东西了，毕竟注释也很充足。（感觉像Three.js的学习历程）&emsp;&emsp;无论如何，现在是我学习 Python 最难受的时候了，很多东西都不懂，很多东西都需要查资料，心很累。&emsp;&emsp;国庆这几天的状态也不是很好，特别是回家干活了之后就有点感冒，难受。 &emsp;&emsp;这部教程没有太多的Python基础教学，因此先看Pluralsight那套入门教程搭建好基础，再看这一套能构建一个比较完整的学习框架。&emsp;&emsp;不过这套教程自身也是由浅入深的过程，我觉得零基础也完全可以学，就是学习到后面会比较痛苦。 01 Introduction 解析前期说明&emsp;&emsp;教程开始最重要的事情是交代相关代码的链接。&emsp;&emsp;作者已经将所有的代码以及注释全部上传在Github上。 链接&emsp;&emsp;学习编程更重要的是看代码，基本上依靠上面的代码注释，其实是不需要看这个教程的大部分案例视频的。&emsp;&emsp;视频案例的好处在于让你感受从零开始编程的流程和思路，比起一个完整结构的代码，逻辑性会更加清晰。&emsp;&emsp;需要注意的是作者使用的是Maya2017 IDE使用Pycharm Maya 脚本编辑器 &amp; 简单的Python代码&emsp;&emsp;交代 Maya 脚本编辑器的使用方法，并且讲解最简单的 Python hello World 命令。&emsp;&emsp;后面是交代如何执行Maya的命令 123456789101112131415161718192021# 导入 Maya python 库 from maya import cmds# 创建方块cube = cmds.polyCube()cubeShape = cube[0]# 创建圆圈曲线circle = cmds.circle()circleShape = circle[0]# 添加父子关系cmds.parent(cubeShape,circleShape)# 冻结对象cmds.setAttr(cubeShape + ".translate" , lock = True)cmds.setAttr(cubeShape + ".rotate" , lock = True)cmds.setAttr(cubeShape + ".scale" , lock = True)# 选择对象cmds.select(circleShape) &emsp;&emsp;另外这里讲解了 Maya 中的一个很重要的概念。&emsp;&emsp;Maya中最简单的模型也是由 shape 节点 和 Transform 节点 组合的。&emsp;&emsp; shape 节点记录物体的形状布线&emsp;&emsp; Transform 节点记录物体的位置&emsp;&emsp;上面的代码可以创建一个方块和环形曲线，并且将方块冻结 并作为子对象添加到曲线上。 Maya开发可以使用的库&emsp;&emsp;下面这种图分析了Maya可以用来开发的库，以及它们之间的优劣。&emsp;&emsp;这个分析在上一个Pluralsight入门教程中也有，其实讲得差不多。 Maya 节点的概念&emsp;&emsp;讲解Maya的节点概念 可以实现可视化编程（Houdini的节点式会更加好用）&emsp;&emsp;Maya 的内核 和 Houdin 一样都是使用节点式追踪历史实现所有的模型效果。&emsp;&emsp;只是 Maya 的节点比 Houdin 的难用很多。 Python2 VS Python3&emsp;&emsp;Python3 的情况 （不能向前支持 Python2 的代码）&emsp;&emsp;Maya 使用 Python 的历史&emsp;&emsp;目前CG行业都是用 Python 2.7 版本 保存脚本&emsp;&emsp;Load Script 将脚本加载到当前 脚本编辑器 当中&emsp;&emsp;Source Script 将立即执行脚本 02 Object Renamer&emsp;&emsp;第二章的内容基本和 Pluralsight 的那套入门教程相同，用一个相对简单的案例涵盖了Python的基础教学，我就不在赘述了。&emsp;&emsp;另外这段代码 作者的英文注释非常详尽 我这里选重点进行中文注释 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#coding:utf-8from maya import cmds# 设置后缀的字典SUFFIXES = &#123; "mesh": "geo", "joint": "jnt", "camera": None,&#125;# 默认添加字符串DEFAULT = "grp"def rename(selection=False): """ Renames objects by adding suffixes based on the object type Args: selection (bool): Whether we should use the selection or not. Defaults to False Raises: RuntimeError: If nothing is selected Returns: list: A list of all the objects renamed """ # Our function has an input called selection. # This is used to let it know if we should use the selection or not # 获取当前选择 objects = cmds.ls(selection=selection, dag=True) # 如果没有选择任何东西 就报错并停止代码 if selection and not objects: raise RuntimeError("You don't have anything selected") # 根据长度对选中的物体由长到短进行排序 objects.sort(key=len, reverse=True) # 遍历所有的物体 for obj in objects: # 根据 '|' 分割字符串 并且获取最后一个字符串(物体名称) shortName = obj.split('|')[-1] # 检查是否还有子对象 # 如果有的话获取 当前对象类型 children = cmds.listRelatives(obj, children=True) or [] if len(children) == 1: child = children[0] objType = cmds.objectType(child) else: objType = cmds.objectType(obj) # 根据对象类型获取后缀名称 如果没有则获取默认名称 suffix = SUFFIXES.get(objType, DEFAULT) # 如果 suffix 为空 跳过当前循环对象 if not suffix: continue # 如果当前对象已经有相同的后缀 跳过当前循环对象 if shortName.endswith('_'+suffix): continue # 重新命名对象 newName = '%s_%s' % (shortName, suffix) cmds.rename(shortName, newName) # 获取当前对象循环的序号 index = objects.index(obj) # 将当前循环的对象的数组 替换为 新命名的名称 objects[index] = obj.replace(shortName, newName) # 返回数组 从而可以从外部获取到重命名的对象 return objects 03 The Gear Creator&emsp;&emsp;这个脚本的原理并不复杂 生成一个圆环 获取圆环外侧的面 （Python 通过 Range 可以获取间隔的数列） 对选择的面进行挤出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#coding:utf-8import maya.cmds as cmdsclass Gear(object): def __init__(self): # 构造函数 self.shape = None self.transform = None self.constructor = None self.extrude = None def create(self, teeth=10, length=0.3): # 根据生成的齿数计算分段数 spans = teeth * 2 # 执行创建圆环命令 self.createPipe(spans) # 执行挤压函数 创建齿轮 self.makeTeeth(teeth=teeth, length=length) def createPipe(self, spans): # 创建圆环 并且获取它的 Transform 节点和 shape 节点 self.transform, self.shape = cmds.polyPipe(subdivisionsAxis=spans) # 找到生成 圆环的历史节点 （后面调整分段需要用到） for node in cmds.listConnections('%s.inMesh' % self.transform): if cmds.objectType(node) == 'polyPipe': self.constructor = node break def makeTeeth(self, teeth=10, length=0.3): # 清空选择 cmds.select(clear=True) # 获取需要选择的面 faces = self.getTeethFaces(teeth) # 选择这部分的面 for face in faces: cmds.select('%s.%s' % (self.transform, face), add=True) # 接入挤出节点 self.extrude = cmds.polyExtrudeFacet(localTranslateZ=length)[0] cmds.select(clear=True) def changeLength(self, length=0.3): # 改变挤出节点的深度 cmds.polyExtrudeFacet(self.extrude, edit=True, ltz=length) def changeTeeth(self, teeth=10, length=0.3): # 改变圆环的分段数 cmds.polyPipe(self.constructor, edit=True, sa=teeth * 2) # 重新调成挤出的序号 self.modifyExtrude(teeth=teeth, length=length) def getTeethFaces(self, teeth): # 获取需要生成的面的序号 spans = teeth * 2 sideFaces = range(spans * 2, spans * 3, 2) # 将相关面的信息放到数组中 faces = [] for face in sideFaces: faces.append('f[%d]' % face) return faces def modifyExtrude(self, teeth=10, length=0.3): # 获取相关的面 faces = self.getTeethFaces(teeth) # 修改挤出的面序号 cmds.setAttr('%s.inputComponents' % self.extrude, len(faces), *faces, type='componentList') # 修改挤出的深度 self.changeLength(length) 04 The Animation Tweener&emsp;&emsp;在这个章节中介绍Qt（并没有使用） 并且提出了 UI 和功能分离的概念。&emsp;&emsp;主要还是介绍使用原生的 cmds 创建插件的过程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#coding:utf-8from maya import cmdsdef tween(percentage, obj=None, attrs=None, selection=True): # 如果没有参数 同时 没有选择对象的话 报错 if not obj and not selection: raise ValueError("No object given to tween") # 如果没有参数传入 获取当前选择对象 if not obj: obj = cmds.ls(sl=1)[0] # 如果没有属性列表 获取可以设置关键帧的属性 if not attrs: attrs = cmds.listAttr(obj, keyable=True) # 获取当前时间 currentTime = cmds.currentTime(query=True) # 循环遍历参数列表 for attr in attrs: # 获取参数的全名 attrFull = '%s.%s' % (obj, attr) # 查询是否有关键帧 keyframes = cmds.keyframe(attrFull, query=True) # 如果没有关键帧就忽略当前对象 if not keyframes: continue # 创建变量存储 当前时间以前的关键帧 previousKeyframes = [] # 循环所有的关键帧 获取当前时间以前所有的关键帧 for k in keyframes: if k &lt; currentTime: previousKeyframes.append(k) # 这是Python的简化写法 实现和上面一样的效果 获取当前时间后面的关键帧 laterKeyframes = [frame for frame in keyframes if frame currentTime] # 如果前面 或者 后面没有关键帧 则跳过 if not previousKeyframes and not laterKeyframes: continue # 如果有前面的关键帧序列 寻找帧数最大的那个（最靠近当前时间的） if previousKeyframes: previousFrame = max(previousKeyframes) else: previousFrame = None # 这个是上面的的简化版 nextFrame = min(laterKeyframes) if laterKeyframes else None # 如果没有 前一帧就是下一帧 if previousFrame is None: previousFrame = nextFrame nextFrame = previousFrame if nextFrame is None else nextFrame # 获取前后帧的关键帧信息 previousValue = cmds.getAttr(attrFull, time=previousFrame) nextValue = cmds.getAttr(attrFull, time=nextFrame) # 分析特殊情况 如果不是则获取两者之间的值进行过渡 if nextFrame is None: currentValue = previousValue elif previousFrame is None: currentValue = nextValue elif previousValue == nextValue: currentValue = previousValue else: difference = nextValue - previousValue biasedDifference = (difference * percentage) / 100.0 currentValue = previousValue + biasedDifference # 将识别的值 设置到属性上 cmds.setAttr(attrFull, currentValue) # 给属性设置关键帧 cmds.setKeyframe(attrFull, time=currentTime, value=currentValue)class TweenerWindow(object): # 窗口名字 windowName = "TweenerWindow" def show(self): # 检查窗口是否存在 如果存在先删除 if cmds.window(self.windowName, query=True, exists=True): cmds.deleteUI(self.windowName) # 创建窗口 命名为 TweenerWindow cmds.window(self.windowName) # 创建UI self.buildUI() # 显示窗口 cmds.showWindow() def buildUI(self): # 创建柱状布局 column = cmds.columnLayout() # text注释说明 cmds.text(label="Use this slider to set the tween amount") # 一行两个柱子 分别给滑竿和按钮 row = cmds.rowLayout(numberOfColumns=2) # 创建滑竿 在变化时执行tween函数 self.slider = cmds.floatSlider(min=0, max=100, value=50, step=1, changeCommand=tween) # 重置按钮 cmds.button(label="Reset", command=self.reset) # 给 layout 设置父对象 cmds.setParent(column) # 添加关闭按钮 cmds.button(label="Close", command=self.close) # *args 允许传入任意参数 全部保存在args变量中 def reset(self, *args): # 获取滑竿 设置为50% cmds.floatSlider(self.slider, edit=True, value=50) def close(self, *args): # 点击关闭按钮 删除窗口 cmds.deleteUI(self.windowName) 05 The Controller Library&emsp;&emsp;这一个章节重点介绍了利用Qt实现的文件加载器 介绍Qt&emsp;&emsp;Qt英文读作cute&emsp;&emsp;PyQt 和 PySide 是Qt语言在Python中实现的库，正如QtQucik是用JavaScript实现的一样。&emsp;&emsp;要注意的是PyQt的license是禁止商用且必须开源的，PySide才是Qt的亲儿子。&emsp;&emsp;Maya不同版本使用的Qt不同 Qt VS cmds&emsp;&emsp; 教程推荐尽可能使用Qt书写应用界面，以下是优缺点分析 Duck Typing&emsp;&emsp;Duck Typing 不要求给函数的参数输入类型。&emsp;&emsp;只要传入的参数可以进行操作，那么就不会报错。&emsp;&emsp;如此一来就不用考虑传参的类型。 Qt.py&emsp;&emsp;可以到https://github.com/mottosso/Qt.py网页去下载Qt.py脚本&emsp;&emsp;这个脚本可以自动导入适合运行的Qt库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#coding:utf-8from maya import cmdsimport osimport json import pprint# 获取我的文档的Maya路径USERAPPDIR = cmds.internalVar(userAppDir = True)# 在该路径下添加controllerLibrary路径（python使用这种方法可以自动适配不同系统的路径斜杠）DIRECTORY = os.path.join(USERAPPDIR,'controllerLibrary') # 默认路径# 创建路径def creatDirectory(directory=DIRECTORY): # 如果路径中的文件夹不存在就创建一个新的文件夹 if not os.path.exists(directory): os.mkdir(directory) class ControllerLibrary(dict): """ # ControllerLibrary 字典保存格式 [ (u'test', &#123; 'name': u'test', 'path': u'C:/Users/Administrator/Documents/maya/controllerLibrary\\test.ma', u'screenshot': u'C:/Users/Administrator/Documents/maya/controllerLibrary\\test' &#125;), (u'sphere', &#123; 'name': u'sphere', 'path': u'C:/Users/Administrator/Documents/maya/controllerLibrary\\sphere.ma', u'screenshot': u'C:/Users/Administrator/Documents/maya/controllerLibrary\\sphere' &#125;) ] """ def save(self,name,directory=DIRECTORY,screenshot=True,**info): # 调用路径创建函数 creatDirectory(directory) # 默认路径下添加ma文件路径 path = os.path.join(directory,'%s.ma' % name) # 默认路径下添加json文件路径 infoFile = os.path.join(directory,'%s.json' % name) # 官方用法 重命名文件 cmds.file(rename = path) # 判断如果当前场景有选中 就保存选中 无选中就保存整个场景 if cmds.ls(selection=True): cmds.file( save=True , type='mayaAscii',exportSelection=True) else: cmds.file(save=True,type='mayaAscii',force=True) # 如果开启截图 就执行截图函数 if screenshot: info['screenshot'] = self.saveScreenshot(name,directory=directory) # 将相关的信息存入json文件中，用于后面读取 # with as语法通常用于打开文件 它可以在执行scope代码前打开相关的文件 并在执行后关闭文件 # info存储相关的dictionary f是filestream indent是缩进字符 with open(infoFile,'w') as f: json.dump(info,f,indent=4) # 保存路径 self[name] = path return path def find(self,directory=DIRECTORY): # 清空自己（字典） self.clear() # 如果路径不存在 退出函数 if not os.path.exists(directory): return # 获取路径中的所有文件名称 （不包含路径） files = os.listdir(directory) # 找到.ma结尾的文件 以f变量返回 mayaFiles = [f for f in files if f.endswith('.ma')] # 在.ma的基础上找到json文件 for ma in mayaFiles: # 分离文件后缀和文件名 name , ext = os.path.splitext(ma) path = os.path.join(directory,ma) # 找到相关的json文件 infoFile = '%s.json' % name # 读取json文件 if infoFile in files: # 获取json文件相应的路径 infoFile = os.path.join(directory,infoFile) # 打开json文件进行读取 with open(infoFile,'r') as f: info = json.load(f) else: # 如果不存在json文件则变量为空 info = &#123;&#125; # 截图命名 screenshot = '%s.jpg' % name # 保存截图路径 if screenshot in files: info['screenshot'] = os.path.join(directory,name) # 保存相关信息到info变量中 info['name'] = name info['path'] = path self[name] = info # pprint.pprint(self) # 加载文件 def load(self,name): # self[name]等于对应info，在调用path获取文件加载路径 path = self[name]['path'] # i为import usingNamespaces是让导入的文件没有前缀 cmds.file(path,i=True,usingNamespaces=False) # 保存截图 def saveScreenshot(self,name,directory=DIRECTORY): # 图片保存路径 path = os.path.join(directory,'%s.jpg' % name) # 聚焦到所有物体 cmds.viewFit() # 设置图片保存的格式 8为jpg格式 cmds.setAttr('defaultRenderGlobals.imageFormat',8) # 使用playblast的方式保存截图 cmds.playblast(completeFilename=path,forceOverwrite=True,format='image',width=200,height=200,showOrnaments=False,startTime=1,endTime=1,viewer=False) return path 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#coding:utf-8import maya.cmds as cmdsimport pprintimport controllerLibraryreload(controllerLibrary)from PySide2 import QtWidgets, QtCore, QtGuiclass ControllerLibraryUI(QtWidgets.QDialog): # 构建函数 def __init__(self): # 调用QtWidgets.QDialog的init方法 super(ControllerLibraryUI, self).__init__() # 设置Qt窗口名称 self.setWindowTitle('Controller Library UI') # 调用功能函数 self.library = controllerLibrary.ControllerLibrary() # 创建窗口UI self.buildUI() # 刷新调用 self.populate() def buildUI(self): # 创建master垂直的布局容器 layout = QtWidgets.QVBoxLayout(self) """ 保存相关的容器 """ # 保存相关的widget容器 saveWidget = QtWidgets.QWidget() # 保存相关的水平布局容器 （add到saveWidget中） saveLayout = QtWidgets.QHBoxLayout(saveWidget) # 将相关的容器添加到主布局中 layout.addWidget(saveWidget) # 输入框 self.saveNameField = QtWidgets.QLineEdit() # 将输入框添加到saveLayout中 saveLayout.addWidget(self.saveNameField) # save按钮 saveBtn = QtWidgets.QPushButton('save') # 触发save按钮功能 saveBtn.clicked.connect(self.save) saveLayout.addWidget(saveBtn) # 列表控件 size = 64 buffer = 12 self.listWidget = QtWidgets.QListWidget() self.listWidget.setViewMode(QtWidgets.QListWidget.IconMode) # 开启图标模式 self.listWidget.setIconSize(QtCore.QSize(size, size)) # 设置图标大小 self.listWidget.setResizeMode( QtWidgets.QListWidget.Adjust) # 设置调整窗口的时候自动换行 self.listWidget.setGridSize(QtCore.QSize( size+buffer, size+buffer)) # 设置图标之间的间距 layout.addWidget(self.listWidget) # 横向按钮容器 btnWidget = QtWidgets.QWidget() btnLayout = QtWidgets.QHBoxLayout(btnWidget) layout.addWidget(btnWidget) # 导入按钮 importBtn = QtWidgets.QPushButton('Import') importBtn.clicked.connect(self.load) btnLayout.addWidget(importBtn) # 刷新按钮 refreshBtn = QtWidgets.QPushButton('Refresh') refreshBtn.clicked.connect(self.populate) btnLayout.addWidget(refreshBtn) # 关闭按钮 closeBtn = QtWidgets.QPushButton('Close') # 通过点击触发signal，connect链接close函数，close函数继承于QtWidgets.QDialog closeBtn.clicked.connect(self.close) btnLayout.addWidget(closeBtn) def populate(self): # 清理列表的内容 以免重复加载 self.listWidget.clear() # 执行功能函数中的find功能 self.library.find() # self.library是功能函数返回的字典 # items会遍历字典中的所有元素 for循环可以调用到字典相关的元素 for name, info in self.library.items(): # 添加item到list组件中 显示name名称 item = QtWidgets.QListWidgetItem(name) self.listWidget.addItem(item) # 获取截图路径 screenshot = info.get('screenshot') # 如果截图存在 if screenshot: # item设置图标 icon = QtGui.QIcon(screenshot) item.setIcon(icon) # 显示item的提示框内容 item.setToolTip(pprint.pformat(info)) # 加载按钮功能函数 def load(self): # 获取当前选中的item currentItem = self.listWidget.currentItem() # 如果没有选中的item 终止 if not currentItem: return # 获取item的名称 name = currentItem.text() # 执行加载函数 self.library.load(name) # 保存按钮功能函数 def save(self): # 获取输入框的文本内容 name = self.saveNameField.text() # 如果文本为空，就警告并且不进行任何操作 if not name.strip(): cmds.warning("You must give a name!") return # 执行保存功能 self.library.save(name) # 刷新 self.populate() # 清空输入框 self.saveNameField.setText('')def showUI(): ui = ControllerLibraryUI() ui.show() return ui 06 The Light Manager&emsp;&emsp; PyMel 介绍 &emsp;&emsp;为什么一开始不用 PyMel 很多工具都是使用 cmds 写的，更多公司流程更希望用 cmds 来写 PyMel 有时候运行得很慢 PyNode的数据非常多，循环遍历的效率会很低。 PyMel 是第三方插件 不是官方负责更新 &emsp;&emsp;PyMel的优点可以参考官方文档的说明 使用更方便 简洁 代码指向更清晰 利于维护 Debug更方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440# from Qt import QtWidgets,QtCore,QtGuifrom PySide2 import QtWidgets, QtCore, QtGuiimport pymel.core as pmfrom functools import partialimport osimport jsonimport timefrom maya import OpenMayaUI as omuiimport logging # 初始化logging系统logging.basicConfig()# 设置名称 可以针对当前工具进行记录logger = logging.getLogger('LightingManager')# 设置信息反馈的模式logger.setLevel(logging.DEBUG)import Qt# 识别当前的使用的Qt库 从而导入正确的库if Qt.__binding__.startswith('PyQt'): logger.debug('Using sip') from sip import wrapinstance as wrapInstance from Qt.QtCore import pyqtSignal as Signalelif Qt.__binding__ == 'PySide': logger.debug('Using shiboken') from shiboken import wrapInstance from Qt.QtCore import Signalelse: logger.debug('Using shiboken2') from shiboken2 import wrapInstance from Qt.QtCore import Signal# 获取Maya的主窗口 用于 dock 窗口def getMayaMainWindow(): # 通过OpenMayaUI API 获取Maya主窗口 win = omui.MQtUtil_mainWindow() # 将窗口转换成Python可以识别的东西 这里是将它转换为QMainWindow ptr = wrapInstance(long(win),QtWidgets.QMainWindow) return ptrdef getDock(name='LightingManagerDock'): # 首先删除重名的窗口 deleteDock(name) # 生成可以dock的Maya窗口 # dockToMainWindow 将窗口dock进右侧的窗口栏中 # label 设置标签名称 ctrl = pm.workspaceControl(name,dockToMainWindow=('right',1),label="Lighting Manager") # 通过OpenMayaUI API 获取窗口相关的 Qt 信息 qtCtrl = omui.MQtUtil_findControl(ctrl) # 将 qtCtrl 转换为Python可以识别的形式 ptr = wrapInstance(long(qtCtrl),QtWidgets.QWidget) return ptrdef deleteDock(name='LightingManagerDock'): # 查询窗口是否存在 if pm.workspaceControl(name,query=True,exists=True) : # 存在即删除 pm.deleteUI(name)class LightManager(QtWidgets.QWidget): # 用来显示下拉菜单 lightTypes = &#123; "Point Light": pm.pointLight, "Spot Light": pm.spotLight, "Direction Light": pm.directionalLight, # partial 类似于 lambda 函数 # 可以将 partial 转换为函数的形式 # def createAreaLight(self): # pm.shadingNode('areaLight', asLight=True) # partial 和 lambda 的区别在于 lambda 的运行传入参数 partial是创建传入 "Area Light":partial(pm.shadingNode,'areaLight',asLight=True), "Volume Light":partial(pm.shadingNode,'volumeLight',asLight=True), &#125; def __init__(self,dock=True): # parent = getMayaMainWindow() # 如果设置 dock 窗口 执行 getdock 函数 if dock: parent = getDock() else: # 删除dock窗口 deleteDock() try: # 删除窗口 如果窗口本身不存在 用try可以让代码不会停止运行并报错 pm.deleteUI('lightingManager') except: logger.debug('No previous UI exists') # 获取Maya主窗口 并将窗口负载在Qt窗口上 parent = QtWidgets.QDialog(parent=getMayaMainWindow()) # 设置名称 可以在后面找到它 parent.setObjectName('lightingManager') parent.setWindowTitle('Lighting Manager') layout = QtWidgets.QVBoxLayout(parent) # 执行父对象，并且设置parent super(LightManager,self).__init__(parent=parent) self.buildUI() self.populate() # 将自己添加到父对象中 self.parent().layout().addWidget(self) # 如果没有dock窗口 则显示窗口 if not dock: parent.show() def populate(self): # count() 获取 scrollLayout 的 item 个数 while self.scrollLayout.count(): # 获取 scrollLayout 第一个元素 widget = self.scrollLayout.takeAt(0).widget() if widget: # 隐藏元素 widget.setVisible(False) # 删除元素 widget.deleteLater() # 循环场景中所有的灯光元素 for light in pm.ls(type=["areaLight","spotLight","pointLight","directionalLight","volumeLight"]): # 添加相关的灯光 self.addLight(light) def buildUI(self): # 创建 QGridLayout 可以快速将元素添加到网格位置中 layout = QtWidgets.QGridLayout(self) # QComboBox 为下拉菜单 self.lightTypeCB = QtWidgets.QComboBox() # 将 lightTypes 的元素添加到 QComboBox 中 for lightType in sorted(self.lightTypes): self.lightTypeCB.addItem(lightType) # 添加到(0,0)的位置 占用1行2列 layout.addWidget(self.lightTypeCB,0,0,1,2) # 创建按钮 createBtn = QtWidgets.QPushButton('Create') createBtn.clicked.connect(self.createLight) layout.addWidget(createBtn,0,2) # 滚动用的组件 scrollWidget = QtWidgets.QWidget() # 设置滚动组件固定大小 scrollWidget.setSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Maximum) # 横向排布 self.scrollLayout = QtWidgets.QVBoxLayout(scrollWidget) # 滚动区域 scrollArea = QtWidgets.QScrollArea() scrollArea.setWidgetResizable(True) scrollArea.setWidget(scrollWidget) layout.addWidget(scrollArea,1,0,1,3) # 保存按钮 saveBtn = QtWidgets.QPushButton('Save') saveBtn.clicked.connect(self.saveLights) layout.addWidget(saveBtn,2,0) # 导入按钮 importBtn = QtWidgets.QPushButton('Import') importBtn.clicked.connect(self.importLights) layout.addWidget(importBtn,2,1) # 刷新按钮 refreshBtn = QtWidgets.QPushButton('Refresh') refreshBtn.clicked.connect(self.populate) layout.addWidget(refreshBtn,2,2) def saveLights(self): # 将数据保存为 json properties = &#123;&#125; # 寻找 LightWidget 类的对象 for lightWidget in self.findChildren(LightWidget): # 获取灯光的Transform节点 light = lightWidget.light transform = light.getTransform() # 将相关的数据存入 properties 变量中 properties[str(transform)] = &#123; 'translate' : list(transform.translate.get()), 'rotate' : list(transform.rotate.get()), 'lightType' : pm.objectType(light), 'intensity' : light.intensity.get(), 'color' : light.color.get() &#125; # 获取数据的存储路径 directory = self.getDirectory() # 设置存储文件的名称 lightFile = os.path.join(directory , 'lightFile_%s.json' % time.strftime('%m%d')) # 写入数据 with open(lightFile,'w') as f: json.dump(properties,f,indent=4) logger.info('Saving file to %s' % lightFile) def getDirectory(self): # 获取文件保存路径 directory = os.path.join( pm.internalVar(userAppDir=True) , 'lightManager') if not os.path.exists(directory): os.mkdir(directory) return directory # json数据的保存格式 # &#123; # "pointLight1": &#123; # "color": [ # 1.0, # 1.0, # 1.0 # ], # "intensity": 1.0, # "translate": [ # 0.0, # 7.269212547848552, # 0.0 # ], # "rotate": [ # 0.0, # 0.0, # 0.0 # ], # "lightType": "pointLight" # &#125;, # "pointLight3": &#123; # "color": [ # 0.03610000014305115, # 0.580299973487854, # 0.0 # ], # "intensity": 470.0, # "translate": [ # 10.703503890939462, # 17.997132841447666, # 0.0 # ], # "rotate": [ # 0.0, # 0.0, # 0.0 # ], # "lightType": "pointLight" # &#125; # &#125; def importLights(self): # 读取 json 数据 # 获取存储路径 directory = self.getDirectory() # 打开一个获取文件的 file browser 窗口 获取相关的json文件 fileName = QtWidgets.QFileDialog.getOpenFileName(self,"light Browser",directory) # 读取 json 数据 with open(fileName[0],'r') as f: properties = json.load(f) # 根据 json 数据处理 生成相关的灯光和属性 for light,info in properties.items(): # 获取灯光类型 lightType = info.get('lightType') # 循环遍历灯光类型 for lt in self.lightTypes: # lightTypes 中的类型 需要提取出前半部分与Light结合 进行匹配 if ('%sLight' % lt.split()[0].lower()) == lightType: break else: # for 循环 也有else语句 当循环没有被 break 时执行 logger.info('Cannot find a corresponding light type for %s (%s)' % (light,lightType)) continue # 创建当前lt类型的灯光 light = self.createLight(lightType=lt) # 设置 json 的数据到具体对象中 light.intensity.set(info.get('intensity')) light.color.set(info.get('color')) transform = light.getTransform() transform.translate.set(info.get('translate')) transform.rotate.set(info.get('rotate')) # 刷新 self.populate() def createLight(self,lightType=None,add=True): # 创建灯光 如果没有类型参数传入 就属于点击创建按钮的情况 获取下拉菜单的类型 if not lightType: lightType = self.lightTypeCB.currentText() # 去到 lightTypes 的字典中 找到相关的函数进行调用 func = self.lightTypes[lightType] # 返回灯光的 pymel 对象 light = func() # 添加灯光到滚动区域中 if add: self.addLight(light) return light def addLight(self,light): # 添加滚动区域的组件 widget = LightWidget(light) self.scrollLayout.addWidget(widget) # 链接组件的 onSolo Signal 触发 onSolo 方法 widget.onSolo.connect(self.onSolo) def onSolo(self,value): # 找到 LightWidget 类的对象 lightWidgets = self.findChildren(LightWidget) # 遍历所有的组件 for widget in lightWidgets: # signal 的数据会通过 sender() 返回 # 如果返回是 True 则是不需要 disable 的对象 if widget != self.sender(): widget.disableLight(value)class LightWidget(QtWidgets.QWidget): # 灯光组件 放置在滚动区域中 # 注册 onSolo 信号 onSolo = QtCore.Signal(bool) def __init__(self,light): super(LightWidget,self).__init__() # 如果灯光是字符串 可以将它转换为 pymel 的对象 if isinstance(light,basestring): logger.debug('Converting node to a PyNode') light = pm.PyNode(light) # 如果获取的是 Transform 节点 就转而获取它的形状节点 if isinstance(light,pm.nodetypes.Transform): light = light.getShape() # 存储 shape 节点 self.light = light self.buildUI() def buildUI(self): # 创建 grid 布局 layout = QtWidgets.QGridLayout(self) # 创建 复选框 用来设置可视化属性 self.name = QtWidgets.QCheckBox(str(self.light.getTransform())) self.name.setChecked(self.light.visibility.get()) self.name.toggled.connect(lambda val: self.light.getTransform().visibility.set(val)) layout.addWidget(self.name,0,0) # 隔离显示按钮 soloBtn = QtWidgets.QPushButton('Solo') soloBtn.setCheckable(True) soloBtn.toggled.connect(lambda val:self.onSolo.emit(val)) layout.addWidget(soloBtn,0,1) # 删除按钮 deleteBtn = QtWidgets.QPushButton('X') deleteBtn.clicked.connect(self.deleteLight) deleteBtn.setMaximumWidth(10) layout.addWidget(deleteBtn,0,2) # 强度滑竿 intensity = QtWidgets.QSlider(QtCore.Qt.Horizontal) intensity.setMinimum(1) intensity.setMaximum(1000) intensity.setValue(self.light.intensity.get()) intensity.valueChanged.connect(lambda val:self.light.intensity.set(val)) layout.addWidget(intensity,1,0,1,2) # 颜色按钮 self.colorBtn = QtWidgets.QPushButton() self.colorBtn.setMaximumWidth(20) self.colorBtn.setMaximumHeight(20) self.setButtonColor() self.colorBtn.clicked.connect(self.setColor) layout.addWidget(self.colorBtn,1,2) def setButtonColor(self,color=None): # 设置按钮颜色 # 如果没有传入颜色参数 就获取灯光的颜色 if not color: color = self.light.color.get() # 类似于 lambda 函数 可转换为 # if not len(color) == 3: # raise Exception("You must provide a list of 3 colors") # 可以用来检测输入是否正确 assert len(color) ==3 , "You must provide a list of 3 colors" # 获取相关的颜色数值到 r,g,b 变量中 r,g,b = [c*255 for c in color] # 给按钮设置CSS样式 self.colorBtn.setStyleSheet('background-color:rgba(%s,%s,%s,1)'%(r,g,b)) def setColor(self): # 点击颜色按钮设置颜色 # 获取灯光的颜色 lightColor = self.light.color.get() # 打开 Maya 的颜色编辑器 color = pm.colorEditor(rgbValue=lightColor) # Maya 返回了字符串 # 我们需要手动将其转换为可用的变量 r,g,b,a = [float(c) for c in color.split()] # 保存新的颜色值 color = (r,g,b) # 设置新的颜色值 self.light.color.set(color) self.setButtonColor(color) def disableLight(self,value): # self.name 为复选框 # 设置复选框的状态 self.name.setChecked(not bool(value)) def deleteLight(self): # 删除灯光组件 self.setParent(None) self.setVisible(False) self.deleteLater() # 删除灯光 pm.delete(self.light.getTransform()) 07 Finishing Up&emsp;&emsp;本次案例是脱离 Maya 写一个 Python 命令行执行的程序&emsp;&emsp;最后展望了可以用来写Python的IDE，这里就不赘述了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# 用来创建commandLine 的库import argparse# 导入用于正则表达式的库import re# 用来交互进行系统的交互import os# 用于复制文件调用的库import shutildef main(): """ 主函数默认情况下会被执行 """ # 创建参数获取器 获取相关的参数 parser = argparse.ArgumentParser(description="This is a simple batch renaming tool to rename sequences of files", usage="To replace all files with hello wtih goodbye: python renamer.py hello goodbye") # 添加参数处理的帮助文档 parser.add_argument('inString', help="The word or regex pattern to replace") parser.add_argument('outString',help="The word or regex pattern to replace it with") parser.add_argument('-d', '--duplicate', help="Should we duplicate or write over the original files", action='store_true') parser.add_argument('-r', '--regex', help="Whether the inputs will be using regex or not", action='store_true') parser.add_argument('-o', '--out', help="The location to deposit these files. Defaults to this directory") # 读取上面的参数 args = parser.parse_args() # 通过获取的参数来执行重命名函数 rename(args.inString, args.outString, duplicate=args.duplicate, outDir=args.out, regex=args.regex)def rename(inString, outString, duplicate=True, inDir=None, outDir=None, regex=False): """ A simple function to rename all the given files in a given directory Args: inString: the input string to find and replace outString: the output string to replace it with duplicate: Whether we should duplicate the renamed files to prevent writing over the originals inDir: what the directory we should operate in outDir: the directory we should write to. regex: Whether we should use regex instead of simple string replace """ # 如果没有提供输入路径 那么就获取当前脚本的路径 if not inDir: inDir = os.getcwd() # 如果没有提供输出路径 那么就获取当前脚本的路径 if not outDir: outDir = inDir # 将路径转换为绝对路径 outDir = os.path.abspath(outDir) # 如果输入输出路径还是不存在 就报错 if not os.path.exists(outDir): raise IOError("%s does not exist!" % outDir) if not os.path.exists(inDir): raise IOError("%s does not exist!" % inDir) # 遍历路径文件夹的文件 for f in os.listdir(inDir): # 以.开头的文件为隐藏的文件 不进行操作 if f.startswith('.'): continue # 如果设置了正则表达式 就用正则表达式的方法进行替换 否则就直接替换 if regex: name = re.sub(inString, outString, f) else: name = f.replace(inString, outString) # 如果名字相同就无需重命名了 if name == f: continue # 创建新文件的路径 src = os.path.join(inDir, f) # 创建新文件的名称 dest = os.path.join(outDir, name) # 如果是复制文件则执行复制 否则执行重命名的函数 if duplicate: shutil.copy2(src, dest) else: os.rename(src, dest)# 我们希望main函数理科执行 但是不希望 import 的时候执行 判断函数可以管理好这个问题if __name__ == '__main__': main() 总结&emsp;&emsp;这篇教程是我目前看过最棒的TD教程。&emsp;&emsp;所有 Maya TD 要用到的工具和库都娓娓道来，而且难度由浅入深，很适合初学者学习。&emsp;&emsp;最重要的是，他不是仅仅进行教学，也解释了背后为什么要这样做的逻辑，让我受益匪浅。 &emsp;&emsp;最近患上了重感冒，这篇文章也拖了一小段时间才差不都完成。&emsp;&emsp;写这篇总结真的花了我好多无谓的时间，特别是截图和给所有的代码进行个人注释。&emsp;&emsp;我猜测以后估计不会再干这么无谓的事情了。&emsp;&emsp;注释代码、理顺教程思路固然好，但是编程的核心是自己动手写代码，最重要的是要跳出原作者的思维逻辑，自己去构思代码的编写。&emsp;&emsp;当然作者的思路也有值得借鉴的地方，但是如此细致入微地写总结就显得文章很琐碎，找不到重点。 &emsp;&emsp;最近会继续重点学习 Python cmds 的库，不过本质上和MEL相差不大。&emsp;&emsp;另外PyQt也是近期的重头戏，不过我打算先消化一下近期的学习先。&emsp;&emsp;另外感冒了也想好好休息一下身体(:з」∠)]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠒ视频教程/pluralsight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Pluralsight - Python for Maya Fundamentals]]></title>
    <url>%2Fposts%2F13d1de85.html</url>
    <content type="text"><![CDATA[.center_iframe{ width:80%; height:30rem; margin:auto; display: -webkit-box; -webkit-box-orient: horizontal; -webkit-box-pack: center; display: -moz-box; -moz-box-orient: horizontal; -moz-box-pack: center; display: -o-box; -o-box-orient: horizontal; -o-box-pack: center; display: -ms-box; -ms-box-orient: horizontal; -ms-box-pack: center; display: box; box-orient: horizontal; box-pack: center; } @media screen and (max-width:600px){ .center_iframe{ height:12rem; } } 前言 &emsp;&emsp;本来我是想先看Udemy的Python For Maya - Artist Friendly Programming，不过看到那套教程使用pycharm 之后，我就迫不及待地想了解一下pluralsight最新的Python教程使用哪一个IDE&emsp;&emsp;没想到pluralsight这套居然使用了VScode，果断转来看这套了。&emsp;&emsp;不过看了一下才发现，原来两套教程的作者是同一个人(:з」∠)&emsp;&emsp;后面还是觉得这套新教程讲得比较浅，先看完在说吧。 教程分析 &emsp;&emsp;如果将这套教程和Delano出的Python三教程比较的话，这套教程更加偏向编程本身。 Python三教程 &emsp;&emsp;Digital-Tutors Getting Started with Python Scripting in Maya&emsp;&emsp;Digital-Tutors Artist’s Guide to Python Scripting in Maya&emsp;&emsp;Digital Tutors - Enhancing Maya Toolsets with Python &emsp;&emsp;delano的教程更多的是针对于Maya自身提供的Python API进行教学，不过年代受限，使用的方法也是比较老。&emsp;&emsp;这套教程不仅仅分析了Maya自身的代码编辑器，也从Python的多个角度进行拓展展望。 相关概念讲解 开头讲解如何使用Maya脚本编辑器 分析了Maya中可以使用的三种编程语言 MEL Python C++ 比较了三门语言在 Maya 的优劣 MEL上手容易，但是执行效率低，只能开发脚本，无法开发插件。 Python覆盖面很广，上手容易，能够胜任各种情况。 C++比较复杂，上手困难，执行效率高。 演示如何讲MEL转成Python代码 Maya编辑器可以快速通过网络查询相关函数的文档 下面就是Python的基础概念 变量(variable)的概念 节点(node)的概念 Python2 VS Python3 Python基础教学 Maya Python语言基础教学 for 循环 while 循环 if/else getAttr &amp; setAttr function selection string Scope 域 reload函数 方便外部修改 外部编辑器使用 使用外部编辑器 - 指出为什么使用VScode 搭建VScode autocomplete 链接 如何让VScode和Maya联动使用 UI搭建 Maya新的界面组成 - Qt 在Maya中创建UI 可以选择的方案 编程实战前 - 讲解分析 &emsp;&emsp;搭建 Randomizer 和 Alinger 两个插件，演示Python插件的制作流程。&emsp;&emsp;本教程只使用了Maya的cmd创建窗口，非常适合新手入门。&emsp;&emsp;Maya cmd 提供的窗口布局&emsp;&emsp;中间也穿插了Python CLass的概念(学过面向对象的都知道,过于复杂的部分也很少会用到) class的概念 实例的概念 self的作用 继承 内置Magic方法 超类继承 编程实战 文件组成架构 &emsp;&emsp;classdemo.py 的内容只是代码演示 不再赘述&emsp;&emsp;我将英文注释去掉，加入自己的理解 （面向对象相关的知识建议看其他教程，这个教程的篇幅受限，讲得很浅） randomizer Python 代码分析baseWindow.py12345678910111213141516171819202122from maya import cmdsclass Window(object): # 构造函数 实例化的时候调用 def __init__(self, name): # 如果窗口已经存在 则删除存在的窗口 if cmds.window(name, query=True, exists=True): cmds.deleteUI(name) # 创建窗口 并且窗口名为name变量 cmds.window(name) # 执行BuildUI 构建窗口相关内容 self.buildUI() # 显示当前窗口（如果buildUI没有执行构建，就是一个空的窗口） cmds.showWindow() def buildUI(self): print "No UI is defined" randomizer.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134from maya import cmds# 导入random库 从而可以调用random函数import random# 导用上面写的 baseWindow（务必放在 文档-&gt;maya版本-&gt;script 文件夹）import baseWindow# RandomizerUI 继承 baseWindow的Window类class RandomizerUI(baseWindow.Window): # 创建构造函数 def __init__(self, name='Randomizer'): # 执行Window的构造函数 父类有执行BuildUI函数 因此执行此函数可以执行buildUI函数 super(RandomizerUI, self).__init__(name) # 重写buildUI函数 def buildUI(self): # 标题分区 column = cmds.columnLayout() cmds.frameLayout(label="Choose an object type") # 复选框 cmds.columnLayout() self.objType = cmds.radioCollection("objectCreationType") cmds.radioButton(label="Sphere") cmds.radioButton(label="Cube", select=True) cmds.radioButton(label="Cone") # 个数输入框 self.intField = cmds.intField("numObjects", value=3) # 标题分区 cmds.setParent(column) frame = cmds.frameLayout("Choose your max ranges") # 网格布局 cmds.gridLayout(numberOfColumns=2, cellWidth=100) # for循环生成 XYZ 输入 for axis in 'xyz': cmds.text(label='%s axis' % axis) cmds.floatField('%sAxisField' % axis, value=random.uniform(0, 10)) # 设置 cmds.setParent(frame) # 横向布局 柱子分段为2 用于容纳两个复选框 cmds.rowLayout(numberOfColumns=2) cmds.radioCollection("randomMode") cmds.radioButton(label='Absolute', select=True) cmds.radioButton(label='Relative') cmds.setParent(column) # 和上面一样 容纳两个按钮 cmds.rowLayout(numberOfColumns=2) # 指定按钮的名称和调用的函数 cmds.button(label="Create", command=self.onCreateClick) cmds.button(label="Randomize", command=self.onRandomClick) # 点击 Create 调用的函数 # *args 是因为Maya cmd 无法让函数的参数为零 def onCreateClick(self, *args): # 获取插件窗口的选项 radio = cmds.radioCollection(self.objType, query=True, select=True) mode = cmds.radioButton(radio, query=True, label=True) # 获取生成的个数 numObjects = cmds.intField(self.intField, query=True, value=True) # 传入变量 执行生成物体函数 createObjects(mode, numObjects) # 顺带执行随机位置函数 onRandomClick() # 随机位置函数 def onRandomClick(self, *args): # 获取插件窗口的选项 radio = cmds.radioCollection("randomMode", query=True, select=True) mode = cmds.radioButton(radio, query=True, label=True) # for循环处理 xyz 三个轴向 for axis in 'xyz': # 获取插件窗口的数值 val = cmds.floatField("%sAxisField" % axis, query=True, value=True) # 传入变量 执行随机化的函数 randomize(minValue=val*-1, maxValue=val, mode=mode, axes=axis)def createObjects(mode, numObjects=5): # 数组 objList = [] # 根据传入的参数 设置生成的物体 for n in range(numObjects): if mode == 'Cube': obj = cmds.polyCube() elif mode == 'Sphere': obj = cmds.polySphere() elif mode == "Cylinder": obj = cmds.polyCylinder() elif mode == 'Cone': obj = cmds.polyCone() else: cmds.error("I don't know what to create") # 将生成的物体赋予到数组中 objList.append(obj[0]) # 选择这个数组中的对象 cmds.select(objList) return objListdef randomize(objList=None, minValue=0, maxValue=10, axes='xyz', mode='Absolute'): # objList如果是空 也就是直接按Randomize按钮 if objList is None: # 获取选中的物体 objList = cmds.ls(selection=True) # 循环选中的物体 for obj in objList: # 循环三个轴向（参数'xyz') for axis in axes: # current归零 current = 0 # 如果是相对的情况就获取当前物体的位置 if mode == 'Relative': current = cmds.getAttr(obj+'.t%s' % axis) # uniform可以生成相应区间的随机值 val = current + random.uniform(minValue, maxValue) # 将随机的变量设置到相应的轴向中 .t 为.translate 简写 cmds.setAttr(obj+'.t%s' % axis, val) Aligner Python 代码分析 &emsp;&emsp;代码的英文注释已经写得非常详细，我就算是翻译一下吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235# 导入cmd库from maya import cmds# 导入partial库，可以预先加载函数参数from functools import partialdef align(nodes=None, axis='x', mode='mid'): # 如果没有传入nodes参数 获取当前选中的物体 if not nodes: nodes = cmds.ls(sl=True) # 如果当前没有任何选择 弹出错误 if not nodes: cmds.error('Nothing selected or provided') # 这里需要将选择的部分转换为点，并且需要将范围flatten # 没有flatten的话 范围取值 polyCube1.vtx[1:5] # 这种形式不利于编程调用，需要转换为 polyCube1.vtx[1], polyCube1.vtx[2], polyCube1.vtx[3] # 创建一个临时的数组 _nodes = [] for node in nodes: # 面的选择形式： polyCube1.f[2] # 可以寻找'.f[' 来确定是否选中了面 if '.f[' in node: # 如果有面选择起来就转换为点 node = cmds.polyListComponentConversion(node, fromFace=True, toVertex=True) elif '.e[' in node: # 同理 边的处理也是一样的 node = cmds.polyListComponentConversion(node, fromEdge=True, toVertex=True) # flatten点范围 需要先将点选择起来 cmds.select(node) # 使用fl命令进行 flatten node = cmds.ls(sl=True, fl=True) # 然后将当前的数组添加到_nodes中 _nodes.extend(node) # 重新选择我们选中的物体 cmds.select(nodes) # 将临时数组赋值给nodes nodes = _nodes # 这里检测当前选中的模式 # 三个变量将会获取到布尔值 # 布尔值为True的就是当前选择的模式 minMode = mode == 'min' maxMode = mode == 'max' midMode = mode == 'mid' # 数组是从零开始的 # 后面轴向是数组延续的 # start变量就是xyz转成数组的形式 if axis == 'x': start = 0 elif axis == 'y': start = 1 elif axis == 'z': start = 2 else: # 如果全都不符合 就报错 cmds.error('Unknown Axis') # 用来保存 碰撞盒 和 数值 的变量 bboxes = &#123;&#125; values = [] # 获取数组中的元素 for node in nodes: # 如果对象是点的话 if '.vtx[' in node: # 点是没有碰撞盒的 所以直接获取点的世界坐标 ws = cmds.xform(node, q=True, t=True, ws=True) # 点是没有体积的 所以三个值都是相等的 minValue = midValue = maxValue = ws[start] else: # 如果是个完整的物体 就获取它的碰撞盒 # 碰撞盒会返回一下的数组 # [x-min, y-min, z-min, x-max, y-max, z-max] bbox = cmds.exactWorldBoundingBox(node) # 通过start获取相应轴向的 最大最小值 及 中间值 minValue = bbox[start] maxValue = bbox[start+3] midValue = (maxValue+minValue)/2 # 将这些值存进上面声明的 bboxes 字典变量中 bboxes[node] = (minValue, midValue, maxValue) # 根据选择的模式将相应的数值存入变量数组中 if minMode: values.append(minValue) elif maxMode: values.append(maxValue) else: values.append(midValue) # 更具选中的模式进行不同的计算 if minMode: # 返回数组最小的值 target=min(values) elif maxMode: # 返回数组最大的值 target = max(values) else: # 获取中间的平均值 target = sum(values)/len(values) # for循环计算每一个物体需要移动的距离 for node in nodes: # 获取相应的bboxes字典的数据 bbox = bboxes[node] # 分离出相应的变量 minValue, midValue, maxValue = bbox # 获取选中物体的世界坐标 ws = cmds.xform(node, query=True, translation=True, ws=True) # 计算出移动的距离 width = maxValue - minValue if minMode: distance = minValue - target ws[start] = (minValue-distance) + width/2 elif maxMode: distance = target-maxValue ws[start] = (maxValue + distance) - width/2 else: distance = target - midValue ws[start] = midValue + distance # 根据计算的值移动物体 cmds.xform(node, translation=ws, ws=True)class Aligner(object): def __init__(self): # 创建窗口 并且让它只有一个存在。 name = "Aligner" if cmds.window(name, query=True, exists=True): cmds.deleteUI(name) window = cmds.window(name) self.buildUI() cmds.showWindow() cmds.window(window, e=True, resizeToFitChildren=True) def buildUI(self): column = cmds.columnLayout() # 添加 radioButton 进行选择 cmds.frameLayout(label="Choose an axis") cmds.gridLayout(numberOfColumns=3, cellWidth=50) cmds.radioCollection() self.xAxis = cmds.radioButton(label='x', select=True) self.yAxis = cmds.radioButton(label='y') self.zAxis = cmds.radioButton(label='z') # 创建图片按钮 # partial实现点击图片也可以改变当前选项 createIconButton('XAxis.png', command=partial(self.onOptionClick, self.xAxis)) createIconButton('YAxis.png', command=partial(self.onOptionClick, self.yAxis)) createIconButton('ZAxis.png', command=partial(self.onOptionClick, self.zAxis)) # 给模式选择添加按钮 cmds.setParent(column) cmds.frameLayout(label="Choose where to align") cmds.gridLayout(numberOfColumns=3, cellWidth=50) cmds.radioCollection() self.minMode = cmds.radioButton(label='min') self.midMode = cmds.radioButton(label='mid', select=True) self.maxMode = cmds.radioButton(label='max') createIconButton('MinAxis.png', command=partial(self.onOptionClick, self.minMode)) createIconButton('MidAxis.png', command=partial(self.onOptionClick, self.midMode)) createIconButton('MaxAxis.png', command=partial(self.onOptionClick, self.maxMode)) # 添加执行按钮 cmds.setParent(column) # bgc是backgroundcolor的缩写 # 它对应的值是 rgb cmds.button(label='Align', command=self.onApplyClick, bgc=(0.2, 0.5, 0.9)) def onOptionClick(self, opt): # 获取传入的参数 # 改变当前按钮的选择 cmds.radioButton(opt, edit=True, select=True) def onApplyClick(self, *args): # 获取当前轴向 if cmds.radioButton(self.xAxis, q=True, select=True): axis = 'x' elif cmds.radioButton(self.yAxis, q=True, select=True): axis = 'y' else: axis = 'z' # 获取当前模式 if cmds.radioButton(self.minMode, q=True, select=True): mode = 'min' elif cmds.radioButton(self.midMode, q=True, select=True): mode = 'mid' else: mode = 'max' # 执行对齐功能函数 align(axis=axis, mode=mode)def getIcon(icon): import os # 当前脚本路径应该在 script 文件夹中 # __file__ 是当前脚本的路径 # os.path.dirname 返回完整的路径名 scripts = os.path.dirname(__file__) # 获取 icons 文件夹路径 icons = os.path.join(scripts, 'icons') # 最后找到相应的 icon 并返回相应的路径 icon = os.path.join(icons, icon) return icon# 创建图标函数def createIconButton(icon, command=None): if command: cmds.iconTextButton(image1=getIcon(icon), width=50, height=50, command=command) else: cmds.iconTextButton(image1=getIcon(icon), width=50, height=50) 总结 &emsp;&emsp;Python For Maya - Artist Friendly Programming这套教程我也差不多看完了，这一部讲得比较浅显，非常适合入门，而最近看的这一部涉及的内容更多，还包含了pyqt和pymel，进阶的话可以看我最近看的这部教程（近期内会在B站更新）。&emsp;&emsp;掌握了JavaScript之后，感觉Python其实也没什么难度（可能只是我还没有接触到深奥的地方），编程很多地方都是相通的。&emsp;&emsp;如今要加快对 Maya 库的学习，除此之外，插件开发很重要的一点是要对Maya足够熟悉。 var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ $(this).parent().next().slideToggle(1000); }); } }); #processImg{ text-align: center; }]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 教程笔记</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
        <tag>ࠒ视频教程/pluralsight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】 2018年9月回顾 | 10月学习计划]]></title>
    <url>%2Fposts%2Ffe733535.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;自己写博客，总喜欢在每篇文章开头写原因，并且说说最近的事情，可能也算是自己的风格吧。&emsp;&emsp;今天刚好是2018-10-1，国庆假期来临，不过我明天才回家，今天依然在工作室里学习。&emsp;&emsp;我打算在这里新开一个新的专栏计划，我不知道自己下一个月能否记得并且坚持做这件事，但是我还是将自己的心愿写下来，共勉。 &emsp;&emsp;写博客是一件非常累的事情，自己要花很多时间去搜集图片、写下心路历程，如果这些时间都投入到学习中，一定能学到更多。&emsp;&emsp;但是我自己目前还是对写博客乐此不疲，偶尔总结一下学到的东西还是挺好的，以后也可以回顾一下自己一路走来的心路历程。&emsp;&emsp;或许自己还年轻吧，充满了干劲，有理想，无论是教程还是博客都可以不断学习。 &emsp;&emsp;自己的博客历程还是非常曲折的，记得最初接触Hexo博客的时候是在今年3月份左右，那个时候仲予师兄说写博客对招聘有用。&emsp;&emsp;于是自己就开始研究怎么才能写好博客，以及怎么搭建一个博客。&emsp;&emsp;其实搭建博客本来是最简单的事情，网上有大量的产品，诸如简书、博客园、CSDN等等&emsp;&emsp;最后自己还是剑走偏锋，选择了Hexo，不过到现在看来觉得自己的决定还是不错的。&emsp;&emsp;Hexo的优点在于fully customize，你可以更改页面的任何元素，也可以嵌入任何元素，只要前端的技术过硬，Hexo和普通网页别无二致。&emsp;&emsp;Hexo的缺点在于SEO优化麻烦，写博客、发布都比较繁琐。这些问题就导致它通常只是一些前端工程师炫技的工具。&emsp;&emsp;很有幸自己学习了一年的前端，虽然没有学习三大框架，但是对前端的运作也算是非常清楚了。&emsp;&emsp;我自己觉得Hexo很适合自己，在我看来瑕不掩瑜，Hexo虽然SEO困难，也保障了一定的隐私性需求。&emsp;&emsp;对于自己来说，目前并没有希望自己的文章能够大红大紫，不过也不希望自己的文章连搜索的权利也没有(:з」∠)&emsp;&emsp;自己目前想做、想写的是积累自己的技术经历，写下自己面对困难的应对经验。&emsp;&emsp;还记的四月份的时候成功搭建了一个博客，当日记一样写了段时间，但是后面实在写不下去，毕竟自己不是日记狂魔，另外每天写也太花时间了。&emsp;&emsp;随意后面因为各种原因就停用了（而且后面遇上了省赛，也确实够忙碌和操心的），到了五、六月份的时候，我决心要重建一个新的博客，破旧立新。&emsp;&emsp;这个新博客就是目前在用的博客了。&emsp;&emsp;目前博客也只是写了半年，这半年我觉得自己算是符合了心中的预期，我也不清楚写博客的习惯的维持多长时间。&emsp;&emsp;我记得很清楚，当时和我哥交流的时候，我就说道Hexo其实没什么的，博客的难度并不在搭建上，而是贵在坚持。&emsp;&emsp;毕竟看到太多的例子了，网上有大量的hexo博客都是停更状态。自己想了下，是以后工作之后，还有时间来整理自己的问题去写博客吗？&emsp;&emsp;这个答案是那么地让我无奈。&emsp;&emsp;无论如何，无论是为了就业、还是为了自己的心愿，总结自己的学习历程。我觉得自己如果能坚持，还是能写下不少东西的。 &emsp;&emsp;今天我打算开启一个新的专栏文章，每个月1日进行更新。&emsp;&emsp;主要是希望让自己给每个月的经历做一下总结，并且交代一下下一个月的学习计划。&emsp;&emsp;不过我也清楚，计划通常都是计划，做了才知道效果和问题所在。 九月份回顾花城汇 网页项目 &emsp;&emsp;一转眼大三的第一个月就这么结束了，这个月干了很多事情，但是自己是否满意呢？还不好说。&emsp;&emsp;九月份花城汇项目因为模型团队搬上去并且开课的作业问题，进度几乎停滞。&emsp;&emsp;不过也幸亏自己开发出了HoudiniVDB的方案，至此简化了80%的工作量，所以虽然没有突飞猛进的进度，但是也不必担心干不完。&emsp;&emsp;只是后面还是聪哥催促道现在才开始真正赶制起来(:з」∠) 数字媒体技术专业网站 &emsp;&emsp;这个网站从8月份感到9月末，情况也花城汇的进度一样，如果说8月是花城汇项目的时间，那么9月初就是技术网站的开发时间。&emsp;&emsp;全身心投入到这个网站的建设，接入各种各样的插件，那段时间确实是忙、也确实学到了不少前端的东西，包括php后台的一些知识。&emsp;&emsp;不过11号之后，因为老师已经将网站传播了，所以我们的进度都慢了下来。&emsp;&emsp;最后感觉网站的反响平平，自己感觉有点可惜。大概这就是大学吧。。。&emsp;&emsp;Anyway，制作过程对我而言更为重要。 Houdini教程 &emsp;&emsp;网站在11号公布之后，差不多告一段落之后，后面花城汇项目也让赶了一小段时间，不过都不是什么大问题。&emsp;&emsp;网站的制作经验让我的开发有了质的飞跃，最主要是弄懂了bootstrap以及使用了bootstrap可视化工具，开发花城汇的UI完全不是问题。&emsp;&emsp;后面因为没啥事做，自己觉得又不能闲着，所以开始看Houdini的教程。&emsp;&emsp;那个时候想来也是真的迷茫，自己觉得花城汇项目没干完，根本就不应该看Houdini，看了又忘记，甚至是没时间总结就会很麻烦。&emsp;&emsp;最后还是因为太闲了，自己还是看了两部教程。&emsp;&emsp;可以看看我9月份写的教程总结。&emsp;&emsp;Pluralsight - Houdini SOP Solver这套教程还是非常不错的，其中讲解到的VEX上，也和我看的下一部教程有所重叠。&emsp;&emsp;后面就借用教程的方法，制作了一个芯片电路板的效果（本来想做辉光的，不知道houdini怎么制作233）&emsp;&emsp;另外VEX教程也非常不错，不过我只是看了三分之一，还没看完。 台风 | 内推 &emsp;&emsp;9月“山竹”来袭，广州这边只是擦边，不过也依然是够惨烈的，很多树都别吹倒了，我趁着工作室关停的空档，将自己两年来的作品剪了一下。&emsp;&emsp;做完之后感觉心情复杂，感觉自己还有很多事情没干，有点惋惜，有点伤感。&emsp;&emsp;后面给师兄看了之后被说了一顿，不过自己也是清楚的，纯粹堆叠视频是真的不好。&emsp;&emsp;于是自己就重新剪了和CG相关的部分出来，反响还行。&emsp;&emsp;于是就投上建立让师兄内推了，师兄说很有希望，不过得1个多月之后才有结果。&emsp;&emsp;让我这段时间把python Maya的相关技术学好。（也因为这个原因我就停掉了VEX的教程）&emsp;&emsp;师兄说Houdini对我而言已经不是那么重要了，毕竟我的应聘岗位是pipeline TD&emsp;&emsp;所以我里面就开始准备全新的TD的教程（之前暑假的时候他也和我说过，所以我之前就已经搜集好了TD系列的编程教程）&emsp;&emsp;一开始自己还没有搞清楚这个内推的情况，还以为只是寒暑假实习。&emsp;&emsp;后面师兄告诉我这个是全职的工作之后，感觉心情复杂….&emsp;&emsp;一部分是很激动，没想到自己这么快就可以到dreamjob的岗位上了。&emsp;&emsp;另一部分是很担心，担心全职工作影响学业，影响工作室。&emsp;&emsp;因此为了把后事交代好，我就列了个提纲，找工作室的成员进行私聊。结果这个提纲一聊就是1个小时….&emsp;&emsp;每个人都要聊那么长的时间，真的是花了不少时间。&emsp;&emsp;后面工作室又要搬到4楼，比之前几乎小了一半,确实有点难受。 10月学习计划 &emsp;&emsp;上面就是借助百度脑图做出来的计划安排&emsp;&emsp;安排的教程也是非常的多，我只要完成前面两个部分，我觉得就够整个10月了&emsp;&emsp;我尽力吧，后面的学习心得将汇总到博客中。]]></content>
      <categories>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022 至 2023 的一封信]]></title>
    <url>%2Fposts%2F3cefe25e.html</url>
    <content type="text"><![CDATA[您好, 这里需要密码. 5e3da73d3a1798b6b06d36c3a91d5b5bf52f227a5da92f6c3cc6ba0a84d3db2e14eab3de4a3414cec8a9842ab139c30e67462eb681cb7513844397e10dbcf5f1e3189ef0013b1d90c7c67f191dd8f7ae0f77a94cd1adb67164fc8130fbd0869b4a489c0ba543458ca30f8cfe3c73124d202c09dea10c514786a32c1af01f53ba308f120b151715af8eed21e76d98ccd167f1ec17b831b40e3e27f743943e8b14ddf773773ac14ce4a794802c7b10a8cea838fcdc3ffba2de621c709d98cf35ebbe3153d0156f3f9d0d1f84cc330eb3c57ff51af6cf2fd7762a536636e66693e741d5722bcb06368709d8fad8e961017f2bf655e86edba1adfb48b973620c74db91bd9d9b798c68c3dd7399aaa1740f2f07a53d9bc99cbe4a19c4c0eb07322b9593b06958825d4037d970816437a29c690a691f6d9f81ff4cbaf66cc7d86b41e95628bcd2efa0f057f6eb2d9452ef5623b2e966d226ba2ba0eead2994e5ca94016775f9ed2b83ed0ccccccfebaa42aa4f631170b5d9bfb96fe84e444ff8101c44a2a881a1bebea3f9bcd6a6a16408342ebfda67b8b2e576d2d90a3ba17188bfad86f0031cd5aa13bad1818731266a4cc6bd1fb2c02b96b4bf21baa10732fecbc094f267f8bf677bdffc58efc3232b605a9678d4385cf3ec01c0443c5f779cc848ce7442ba34a2dbc57f6b2eb92d97319b0a04b38e50b3faeed7332bb8d28a03d98a8708639b1c0903469048813ee5b39f51ba041360997f3263167e3da17e229ce85bee4d09b24527e96c1232594b84bcf393cfb0f70b67283f76b671d63d02efb3f9d8c02b474686d27b4ada62c133baaf5a4c6d7ef98cd97df54e19776bdd94cb18afbd88b80c904de070b5397285d6bcacc4d79fd7400b3219a28825091b805a3631755bd214e8bcceb60ea8d890d0192b9387e43c4135d0dab6c3a429b48b794c645bcbd5987772f9bf8e10cb30e02c7544b0049791145eb8aa52b4cab2b0c18ef6699fcabd01794f533aabbcf5ccda98a1dcaa6f31eb33d890f018abba59aa011bdde7297eb0e629205add65e966bcbf02baeb768b9bb12c63a87db28c441b1519285c1757f7dc2a7a80cd3360db23cfe0b4de3919d0261a8336bae3e3d527b1b88dd0ec6b706f0cefa385efa9a06964dddc0691e4b9312afa2714e95e24eaaaf882b67c0528e38036afc2c86ca621b4029168d9f48d53b85adff8ca0a7ddd7e7169298497adda8e7274f2feb88c79a450021199266f23bdbd9fa0960be6d79780666bb248d6d74ba10eabbdb1b015dbbf1318329b07bfc1dc950232ca337f836ee59ee8315c70a17e5bebf7cc268c29a64837a560e3a66d679bfe438dbe4295a01d43203e88b9c45cb24c96a31dda468a10782cc073c7dddff8b4f9a5f5fbffbb85289fc50bea9e7494aa3397bad692866bdcbeee99b52f23b2f53b672c04775becd6d212e27412a8c5ae82ed8481bccade1197598f31896b5fe89ade4a2cefa3f894d59f43af3029b2f0a32b5279cec78bb8aadd3d1ea3db1b21ee64eeee27fefb65803fac9be36a6a30e439a514830b12727bdc3b33e89dee69d6d2bb351e88196a988e5525cb80f357e8661190dd0e56cf056d7786a4d2ab050d5fd924ad243524afdfa468776a6b34d1909efc78dbcc7e26162aef1d144cb8c6eff31a106bfd4ce6f61426042bb6392da74bf3e04c059daf5d9857369a35418a8ec8a355fc42743ad626268fb78a40aac23a49a9659f60c244be0b13b39bcd4107e7f896bf2dc146685549b1879486f68f809e050922e505ac52f5343eaca1eda2a094bc2b4f58bd1265ce6436ec463397b0bdd9cc8e9979dc970ecfbeb79337ae0e7fdd9edaa634cdfbe9a0d442ec519cb4a9e5ad13acfa46067807b06ba3d5a1ab1926d03df8382c4dfcfd4985709c29fe44328d8083ac0c80a97a02bd11b3bde9b4bdee65c90682a21688190ffd1b691c12709c9f134c2408fd6d715366dc27747cb09312353095651c0d9950f68c49c016003656b959478942f709b4125c28226ce11ecec6ba48d3ba6b2e1f975bcb433248740cf71bfdff72509de729f4ae74bb5cfd4debf592e90d91d1fc74fe0852fccd9318a0fc5ffc3227d21ad3b20aad9e4fb5bdcaed112f0f4a21f32bbf8a346f67cbe342780cc7df609ef5e4a82cb50446f5a0984c1620364e7206c2cfa9f1f0285043a92e27da1e1b9a7b182a3f8175a36024f2090f30c3f9cf6ce4cdb15b09eee8b6c2308362b929f875de9db658ffeae96a37883aa4d66379d2338ff40f665f779d36f0760a87eee68327a8b7470a77f505a111fd291c4b7a3272fce50a9ae663daeaabe6e46ae8e74857396b6f62a5fcaa4861cc3635201d22fd0ec9a793d718b296c96bb21d2eafbd6bec850629984cac4449ce302762c5a6757a37def9dcc2c9be78a49fceb05289dc5a6c1db897d353ae7a91e5bc2da998ace451b2b4afb8aa60b63872ede851ba915d75e73ef712049fa8469313e23fde57ecc89bc62554bad27df3b9f770a5568859c3d0632f8d73463928ce509a95f5a0c567d1e03422255a87e6e575a5d295d7efb75ea9d057e659439bd82d433fe5f89db3ae9c50b7276fea5c4855840be31b1457cabe10762beced516c85df1c99b2dd6eba3bf404f09ec6337db75bbb48f4690bd097b9241999ecaca63dabfa66b49fd7e243f8bb98c78c971add0cedcb3b4ca86dfd87d3c2bb9eb79dbdd378b9026f6cdb5d09a13cc691585111ad74a35b328728ba268cff1895b97115855c794485bad50133aebe1b205ce496cc70a14488ee254bfa82bbb30be947f7cef9052cfa79db6bf8a76fc5551f61f0b0344d5798dc4dd93b94736ef385cd54041ad3ba8f72698b61733736526039394fe34e7ad1db1515c7141736f7fba80ed4a08fe47c1fe8b962cb570469f65483f2992008de51aadc712b6c657875f2a9aced324c46dbd7ff3e8ae6eaf60328e554207d43c955a7e369f0f0c5f628fbb8e7a4f8af7fc8e2a99aa1625f38c1f9857a0bb6a4a08f0172b28d733c484aad10d893de19249d1866a8215a4921723686d76b0690a4482ba50173fcc3e882b55369b416250eec38a1ce8ba89955efe744da102a9f01e8b9ad0dc237651a40ea6a93448740b6626e23a657f888702137578c2a0045a49f3be53017baf70341805096058047a70f47c5e0bb7764bfbda31fc5ad7a1730a7018bd399b2f892b5f88cc17241053d48a2831ddfedefe9398c7c1e6e08381c9dc9d42f884bd696afac35261da6aaa7c033d88671eed3d1ac299b221457bd9e4a70f1d6a9a23bcfd12aafaf6520002296b140ccda2315f40bb9e9f19ba1a9edde694e875bab0728207af2b563bd8bb61e7671347add4eb44d26c2659ecbb1308ff9af3cfc3d7f8c07c9d7c919f750c5ca56ba1d16b40b8569197f1c4c19f1e2243d1da67d1015558807b254892a3b2c21ec73e82fdace90617794de658e2e9b6bd9f897f9ad67cd3577b2ea0308bd73b0f6f16b75573e9779db12a450b6a4a58c0dffb7b27af35972b55d2bcb219c6a63b23d41b997233c31cc9375a74c3353758a023a086d38504f11a1ddee46b893b6e38e81af4b84f32ed1c86d886558e8efd0b0efbd4237e050e145b5e30fbe4634e059abebfc3f9e906d559265591198e921eb0ff21163e2955600995af1ebb4e61b20da65d10bacfa5eeade435e3c1e0a2a10e348d76320e8281ef646b51d2046a1bb9c32f85bd0ec49e7a6305b2b185b2df6165e502023f077e6135fc707c49bf0de2cafacab6847d9c83aac791355cc3462d5f0e34e6fdedb7b534213f6fd2beb92e904e82faa56ecad920311bce301f7eab31e293c4138c885f73dc05aa4532005e43ed4b247494055bc9d127b402d0f54820296399f990734d4156447c339a8dcc2d12235dca20917e6b55acc208944791688027f89180b6f6d9dfd78204ac1898a474371e1efc5933f045a02fe77c17d6d6235ae058c4935339f3ef8cb4024cc0300bd5af2115efccb83b9192ebd994a4a0a609a68e55444bff0d0d02041a207607466a3208c42e158771689f002cc2a5d620220a3161cdde30851086d8ced6c1ecb7dd459f725d18c6eb839f3fe83f2654adfd2c9a757e3e2bf42d85c7c1bf20eafa45de89b4eeeb41e23de204995ed31cc8925be0206b789b91622d0dfd596a4d29da0ae5ddc2e17e9eab5df4683ec1bc17400702db956063247a6754342e0e25ccf1f6dc4296429983a1856242573a75d904303b79fc962dbf22f06f8932fa9e35ace0e70869ec4867684b7aeab913df38c6625dea381e71aadd8c50d0378897f0dd00ff4629e48b528f9a21908aa61eddce5d683854af235604e6f64f0d57a4700f92e0b55208d7f3eaa9cdddfa285fa0befab61be9fc1426e80ef5760c5084cdf39e32f7424db35b51a9f9efc59aaf40a3aac7e64aadc9efd477f4b72591bf6d98c446e779003506790936d2c79e8dc852dcea3fd2fa6b581f5d71688c6a5b85ebd7cde9b0e3f3f2d3752e628ddf9d857e37a6ea0d1261e542170a51aa6ac61c8b3cdced161db7256e8b0bdf06db186c39f46f0c08fb0bfd9ceef0910bec98013d67e2bb234650512a8f84f6b3b732124eb3e056b7507dea997739a11edd8f6e725f6879e964409e354d7b80f8c9884b8273fc5d80e38f86845876cc2f5525a80aabe810de9b00aac4a759ed3f08d303c41f7666f250cc648403535684a985e91f6de7b59a6a38ff98430aa37d52d9b136ad98d63ce62ade2c62452e10826edc5e74374cbeb2876efdca265b606f80eac1a788389dd4a83a50f33a15030eb7d2c9862e4268925c882faf909014f64467dfcc962a141b4ac9e464d79fccb194444f1258fc710fafa6f183cfbb9b2e7310c69f251938e515e480ac544149e4556d8a0c9020afa4c273fa4dccb41a726598b3098703744280a4a7924f2c9aa8019bae6df774d9b560e8f5bb632770a7fc6ff675bd0483039ce23c8f4a061ffcb4e07853ff60d004f88f5777eb80a6d50bed67299012fb0ae3d463a643b051f4321a8114d46bd62e67995444da1b712c84f4d3b1b22a18d78f919ba8de01e4bf1d214c8d3656eb86520ca8adfb99b0772700eb6b505bc8c90b6f92e8c1f8779db1bf0688eb167ffae4bbc9b68f7b64500ef43d47aaffa7301531bcfa64823088a68c577090bba4b18db820f43ec90fbf7b7b0c971db0d1e62aa393f931929f2f1bc61f5b1ac2859658f5f5469c26e837ea44385e18e728f6464c59d1a549366ed1b97f34b8073f0eca1f267d4cf02353903b10cb53cf8ca87e98a3d7350bfda067a4413a5c653e6c1a749a16a607d10b8d48afd510ade6fa08c91a8cef73e464683123521c7fc43cbcc9aa69d599db1ce96358d6a0e60f4434d92724534801c7e701b4087812089bb4f023e624aa88fa72350a89c9631efb87094347c3de4fc157721131a7dfb15fda1fbd12405f077854a8302362cc5c65f54cfefff8106753112112c9de469f5bc5662e07137ef29e5bb0ec221e113579ee7252f4229fc168b2981db6ca4b9c28abaf7936c4dd7a3521477682d21b08e40518845661cf000d2799d881deeb1e1e8e7bda8168a3224dee3f4912a49e714797b4109c7b25ebf071a5923398c8ae2071ffc01ca166d1e5f14e0ac4a58a5ef88742262f156340557051236ea864187e4787908290f01034b91890153dd322eafdf1efd72b8d4b36d034f0dad59ed737ee494c89419c7e26b8ac48e87b3b42cf8afb600a64404a28961747afee6cc3b24e9a57060be84]]></content>
      <categories>
        <category>年度总结</category>
        <category>致未来</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
        <tag>🧐回顾</tag>
        <tag>🎓教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（八） - Gitment换成Gittalk | SEO优化]]></title>
    <url>%2Fposts%2F59506.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;今天发现Gitment无法评论，当我视图初始化的时候就会弹出 progress Event 报错。&emsp;&emsp;之前在开发专业网站的时候使用过Gittalk，感觉比预想中要简单得多，因此，我就将Gitment换掉了。&emsp;&emsp;为什么当时研究Gittalk而不是在专业网站上使用Gitment呢？&emsp;&emsp;主要还是因为bootcdn居然没有收录Gitment而是收录了Gittalk，而且Gitment的作者又不进行更新，迟早被Gittalk取代的。&emsp;&emsp;另外自己又不想要世面上的评论系统，各种广告横飞是不可避免的。 Gitment换成Gittalk &emsp;&emsp;首先要先找到Gitment生成的ejs&emsp;&emsp;因此可以现在浏览器查看相关html代码，进而进行搜索&emsp;&emsp;我现在用的主题为dark-blue个人魔改版，Gitment的相关代码在gitment.ejs中&emsp;&emsp;找到相关代码，将Gittalk的代码添加进去。 1234567891011121314151617181920212223&lt;section id="comments"&gt; &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.css" rel="stylesheet"&gt; &lt;div class="gitalk" style="width:90%;margin:auto;"&gt; &lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; require(["https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.2.2/gitalk.min.js","https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js"], function (Gitalk,md5) &#123; const gitalk = new Gitalk(&#123; clientID: '&lt;%= client_id%&gt;', clientSecret: '&lt;%= client_secret%&gt;', repo: '&lt;%= repo%&gt;', owner: '&lt;%= githubID%&gt;', admin: ['&lt;%= githubID%&gt;'], id: md5(location.pathname), // Ensure uniqueness and length less than 50 distractionFreeMode: false // Facebook-like distraction free mode &#125;) gitalk.render('gitalk-container') &#125;); &lt;/script&gt; &lt;/div&gt;&lt;/section&gt; &emsp;&emsp;由于我的主题使用了require.js，使用其他的脚本需要异步加载，稍微有点麻烦。&emsp;&emsp;另外Gittalk对评论id有长度限制，因此需要额外的md5插件来缩短地址的长度。&emsp;&emsp;如此就实现了Gittalk的效果，是不是非常简单。 百度SEO优化 &emsp;&emsp;其实我也只是参照网上的做法，进行百度搜索优化而已。链接&emsp;&emsp;目前通过coding静态挂载，已经成功通过了爬虫测试，不过目前还能在百度上搜索到自己的coding页面。&emsp;&emsp;需要注意的坑是，Hexo的年月日文件夹结构是不利于SEO的。&emsp;&emsp;网上推荐使用hexo -abbrlink 插件&emsp;&emsp;可以将链接名称缩短，让网页更容易被抓取。&emsp;&emsp;另外百度提供了自动上传的相应代码，可以添加到页面中提高抓取几率。 总结 &emsp;&emsp;目前博客的优化已经达到了我的预期，后面是继续深入学习Maya-python以及Houdini了。&emsp;&emsp;另外最近注意到了一款非常棒的线上思维导图——百度脑图。&emsp;&emsp;我打算用在博客的文章中来进行总结^_^ 2018-10-5 更新 &emsp;&emsp;我还是在ejs中加入了百度提供的自动提交相关的js代码&emsp;&emsp;目前已经可以在百度中搜索到相关的文章了，只是收录比较慢而已。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字媒体技术专业网站 - 搭建感想]]></title>
    <url>%2Fposts%2F17676.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;暑假的时候，自己原本的想法其实很简单，就是想写一篇博客文章告诉新生应该怎么去度过大学4年。&emsp;&emsp;最初也确实在hexo博客写了一篇文章（其实那篇文章还没有整理好 - 2018-9-29）&emsp;&emsp;写了之后觉得太简单了，还想添加更多的内容，比如将大家的作品添加上去什么的，&emsp;&emsp;后面就在hexo博客中加了一个ppt滚动效果。 &emsp;&emsp;既然已经实现了这些效果，为什么不做得更好一点。&emsp;&emsp;抱着这样的心态，我的漫漫征程才刚刚开始。 数字媒体技术网站雏形 &emsp;&emsp;为了做得更好，我逐渐开始萌生搭建一个专业网站的想法。&emsp;&emsp;虽然自己并没有做过，不过倒是了解过，搭建一个网站当然不可能从零开始，否则那真是累死人。&emsp;&emsp;首先找一个中意的网页模板，在这个基础上进行修改。&emsp;&emsp;于是我又在网上找模板，下载了很多个模板、&emsp;&emsp;这其中也花费大量时间去筛选，最后筛选出了一个我比较满意的模板。&emsp;&emsp;后面就是综合所有的网页和效果，制作出一个网页。&emsp;&emsp;主要参考的是一个网页的模板。&emsp;&emsp;网页后面有很多联系我们之类的模块，我当时就想做出一个评论系统，这样新生就可以在网站上留言了。&emsp;&emsp;于是二话不说，就开干，研究了一下Gittalk的使用方法，感觉还是非常简单。&emsp;&emsp;于是就将Gittalk搭载在了初版页面上。（初版页面似乎被我删除了(:з」∠)） 后续接力 &emsp;&emsp;将这个简略版网页发布之后，收到了很多的回馈，特别是对评论以及内容丰富性的吐槽。&emsp;&emsp;于是为了让网页的效果更加丰富，我想做的东西就变得越大。&emsp;&emsp;于是乎去5iweb.com那里找了大量网页特效来加入到网页中。&emsp;&emsp;可以感受一下，我当时搭建了多少个特效效果，因此也让现在的网页加载速度降低了很多。 &emsp;&emsp;这个按钮包含了太多的功能了。 点击按钮弹出submenu的特效 -&gt; qooey.js 点击分享按钮弹出分享界面 -&gt; 分享面板 -&gt; socialshare.js 分享背景 -&gt; threejs line 弹幕插件 -&gt; danmu.js 动态弹出插件 -&gt; quttons.js 滚动条插件 -&gt; slider 弹幕输入的颜色插件 -&gt; spectrum.js &emsp;&emsp;接入上述的插件就耗费了我不少的精力（尽管也只是站在巨人的肩膀上实现的）&emsp;&emsp;另外也还有一些其他的插件： 滚动插件 -&gt; scrollify.js 翻牌插件 -&gt; Baraja.js 评论翻书插件 -&gt; bookblock.js 大小变化检测 -&gt; resize.js 课程意见滚动插件 -&gt; ticker.js 视频弹出插件 -&gt; classie-video &emsp;&emsp;当然还有必不可少的bootstrap和jquery，以及模板提供的插件。&emsp;&emsp;如此庞大的插件使用极大丰富了网站的内容，但是同时也大大降低了加载速度。&emsp;&emsp;后来我还不得不将threejs相关的脚本去掉来提升网页的速度。&emsp;&emsp;另外，网页的内容也非常多，我仅仅是接入这些插件就已经焦头烂额了。 团队协助 &emsp;&emsp;后面我把任务分配给工作室的同学，大家合力把所有的内容完善。 冯磊帮我研究了php的后台对接，实现了弹幕、评论的动态加载及反馈。另外在课程页面上也将大家的意见接入到了网页中。 彭梓浩帮我制作了CG、游戏页面的内容 李薇帮我制做了后台、前端页面的内容 谭晓雯帮我制作了软件开发页面的内容 &emsp;&emsp;在这个过程，我开始尝试魔改Hexo静态博客，将生成的博客页面嵌入到专业网站中。&emsp;&emsp;另外也广泛向大家获取投稿，最后全部搭载了博客中。&emsp;&emsp;一路走来非常曲折，感谢大家的支持与付出，感谢所有人给我的投稿。 后续问题 &emsp;&emsp;最后我们勉强赶在新生第一堂课之前将网页搭建好了。&emsp;&emsp;但是完全没有考虑到新生当前并没有电脑的事实，而网页并没有做好自适应。&emsp;&emsp;因此后续就是调整网页的自适应问题。&emsp;&emsp;另外网页挂载在了冯磊购买的服务器中（也有师兄提供的备用服务器），但是下行速度只有1M宽带，大概就是200多K的速度，因此多人访问的时候，速度就会变得很慢。&emsp;&emsp;为了让网站的体验提升，我最初想到问题可能是因为视频太大了，加载比较慢，于是想用bilibili来播放视频。&emsp;&emsp;然而哔哩哔哩的视频外链支持360P，体验非常糟糕，于是我尝试调查哔哩哔哩的外链API。&emsp;&emsp;可是在哔哩哔哩官网寻找了许久也没有找到相关的文档。&emsp;&emsp;最后在network中，寻找外链页面发送的请求时，找到了链接过去的另一个页面。&emsp;&emsp;在那里可以看到提供的API代码。&emsp;&emsp;即便是找到了API，也不知道这些参数分别代表什么的，最后测试了好几天，也没有弄清楚开启高清的方法(:з」∠)，只好放弃这个方案。&emsp;&emsp;最后还是决定采用腾讯云静态挂载的方案。 &emsp;&emsp;自适应还不是大问题，毕竟网站很多地方都采用了bootstrap的方案，自适应的问题只存在一些特定的效果中。&emsp;&emsp;后面这些问题彭梓浩帮我解决了。&emsp;&emsp;最大的问题在于解决首页的视屏ppt效果，因为在手机端，视频播放会被某些浏览器抓取，导致整个页面崩塌，这个问题可以在微信内置的qq浏览器中看到。&emsp;&emsp;最后没有很好的解决方案，我只好妥协识别移动设备，如果是移动设备就禁用视频，采用图片ppt的方式。&emsp;&emsp;终于，在拖了差不多10天的时间之后，终于把所有的问题解决了。&emsp;&emsp;通过给php页面添加允许头文件，也实现了在静态页面中跨域访问动态php，实现评论、弹幕显示以及添加。 总结 &emsp;&emsp;这次网站搭建只是我自己最初的一个小小想法，没想到后面会做得如此庞大。&emsp;&emsp;不过在这个过程中，我也学到了很多东西。&emsp;&emsp;这一次是真的弄懂了bootstrap的运作原理了，而且在网页的排版上也发现了bootstrap可视化排版的神器。&emsp;&emsp;在操纵各种复杂的js插件的过程中，又一次加深了对js的理解。&emsp;&emsp;虽然自己没有系统地学习php，不过在和冯磊的合作中也学习到了不少php相关的知识。&emsp;&emsp;最后真的非常感谢各位协助我搭建网站的所有人，帮我实现了这个心愿。]]></content>
      <categories>
        <category>大学</category>
        <category>我的作品</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode - 实现Maya-python代码快速提示]]></title>
    <url>%2Fposts%2F53349.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近这些天很多事情，流花展馆要陆续开始动工了。&emsp;&emsp;工作室搬到4楼的小地方去了，为了准备”后事”，还列了个框架，和每个成员私聊，真的是浪费了大量无谓的时间。&emsp;&emsp;这周三还有党支部的宪法擂台赛，花了不少时间去准备（其实我只是当天复习了下，真的很水了）&emsp;&emsp;今天比赛群里，老师在祝贺获得国家奖学金的同学，那里面没有提到我，莫名觉得沮丧…….&emsp;&emsp;或许印证了上次写的优越感，又被打碎一地了，所以有点失落… &emsp;&emsp;最近在看的教程分别有 Pluralsight - Python for Maya Fundamentals Python For Maya - Artist Friendly Programming &emsp;&emsp;第一部已经看完了，第二部看了前两部分。&emsp;&emsp;真·没想到两个教程的作者居然是一个人，此人居然进了pluralsight！！！&emsp;&emsp;第二部教程很明显时间久远一点的，那里推荐使用python专业IDE pycharm，遭到我个人一丝丝的不屑(:з」∠)（手动滑稽）&emsp;&emsp;后来转去看pluralsight的教程，居然发现这个大神也转了VScode，这让我很兴奋(づ｡◕‿‿◕｡)づ&emsp;&emsp;不过后面看了大神操作的VScode方法，感觉不符合我的个人情况(╥╯^╰╥) VScode python 支持 &emsp;&emsp;其实要让VScode支持Python代码提示不复杂&emsp;&emsp;安装python环境，然后安装VScode提供的Python插件&emsp;&emsp;这就可以轻松在VScode写Python代码了。&emsp;&emsp;下面就是利用 VScode的intellicense 实现自动补全代码功能。 Maya Python intellicense &emsp;&emsp;pluralsight的教程后面是下载了anaconda，通过anaconda提供的python2.7平台来实现的。&emsp;&emsp;但是当我下载这个包之后，我发现它居然有500M，当我安装完了之后，我发现它居然占用4个G的磁盘空间，原谅我的128GSSD，空间不足，卸了卸了。&emsp;&emsp;但是没有python环境如何实现python代码的运行呢？&emsp;&emsp;用脑子想一下Maya是怎么实现python代码的呢？&emsp;&emsp;通过外网的一通搜索，我发现maya其实内置了python2.7环境，只需要将其引导到VScode来执行，就不需要额外安装庞大的Python环境。&emsp;&emsp;更何况CG界的python版本一直没有升级，所以用maya内置或许会更好。&emsp;&emsp;maya的python环境shell名称为mayapy.exe&emsp;&emsp;要让VScode支持Maya 的 python 编程需要下载相关的开发资料包。（关于pycharm要如何设置可以参照这个文章）&emsp;&emsp;解压了之后，可以将devkit文件夹的内容覆盖到Maya安装目录的devkit中&emsp;&emsp;在VScode的首选项的json可以添加下面的代码 - 资料参考1234&quot;python.autoComplete.extraPaths&quot;: [ &quot;C:&#x2F;Program Files&#x2F;Autodesk&#x2F;Maya2018&#x2F;devkit&#x2F;other&#x2F;pymel&#x2F;extras&#x2F;completion&#x2F;py&quot;,],&quot;python.pythonPath&quot;: &quot;C:&#x2F;Program Files&#x2F;Autodesk&#x2F;Maya2018&#x2F;bin&#x2F;mayapy.exe&quot;,&emsp;&emsp;这样就可以实现和教程一样的效果 VScode 快速代码提示 &emsp;&emsp;好像代码提示的问题已经解决了，其实不然，在当前版本的VScode中加载巨慢无比，起码要等7、8秒以上，代码提示才会出来。&emsp;&emsp;为了解决这个问题，我真的查阅无数的资料，踏遍了github的各个关于 intellisence和autocomplet 缓慢的问题&emsp;&emsp;但是能够在根本上解决我当前问题的回答，少之又少。&emsp;&emsp;我甚至看到一个2016年的问题，到了2018年有人回复出现问题，并表示两年都还没有解决而令人非常失望。&emsp;&emsp;这当中确实绕了无数的弯路，甚至一度认为是pylint的检查问题，而试图让Mayapy安装pylint。&emsp;&emsp;但是经过研究，pylint并不是根本原因，毕竟使用不同版本的python环境还是会出现这个巨慢无比的问题。&emsp;&emsp;后来我甚至开始研究VScode的CPU调度，并且发现了一部分问题的根源。 &emsp;&emsp;gif已经经过了加速处理，但是通过上面的gif，相信也能感受我内心的无奈与崩溃，如果是这种速度，那代码提示就形同虚设。&emsp;&emsp;另外pluralsight的教程也有提到Maya也是自带代码提示的，但是可能是因为我的笔记本比较渣吧，我一旦开启提示，提示速度也和VScode不相上下……&emsp;&emsp;因此这样无解的问题，我认为pycharm也是无力回天的，所以我并没有尝试下载pycharm解决问题。 解决方案 &emsp;&emsp;后来我看到VScode的python autoComplete设置里面不仅仅只有extraPaths可以设置，还有preloadModules来加快加载速度的功能。&emsp;&emsp;因此我以这个为突破口找到了解决问题核心的github问题&emsp;&emsp;这个问题也是最近这几天才有了新的突破。&emsp;&emsp;也就是这是language server的锅，禁用Jedi方案，采用另一个语言配置，就可以解决问题。&emsp;&emsp;我尝试了一下，禁用了Jedi之后 VScode 会自动下载 Microsoft 的一个语言系统，安装完毕之后，再次尝试。&emsp;&emsp;谢天谢地，这次快了非常多。&emsp;&emsp;从gif图可以感受到，虽然这一次也需要loading一下，但是速度真的是质的飞跃！！！~ 总结 &emsp;&emsp;我目前真的是对VScode情有独钟，不过不管怎么说，VScode也确实有它的魅力。&emsp;&emsp;如此一来，我就可以通过VScode，既可以写MEL、VEX有可以完成Python的TD工作(∩_∩)]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
        <tag>ࠀMaya</tag>
        <tag>ࠕPython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Pluralsight - Houdini VEX Fundamentals]]></title>
    <url>%2Fposts%2F50174.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近因为要开始做三维动画的实训课，所以开始疯狂看教程了，（其实网页项目还没做完，不过研究出Houdini VDB 流程解决方案，还是简化了不少工作量）&emsp;&emsp;本来我们和动画合作要搞太空科幻题材的动画，这就需要破碎、爆炸、星尘之类的特效的。&emsp;&emsp;不过看到自己移动硬盘中以前囤积的教程，还是忍不住先看一下吧。 VEX入门 对着相关的函数按F1可以跳转到Houdini的相关函数的网页界面，而且经过我的测试，这是Houdini 16.5为你搭建的本地服务器所访问的内容，无需担心网络的问题 按d键进入界面设置可以在vissualize标签中将相关变量显示出来（visualize节点也可以） 属性和变量的区别，从编程的角度说就是全局和局部变量的区别，从Houdini来讲就是能否传递数值 printf(format, …)命令可以在Houdini console中打印数据。 vector变量的通道可以通过abc 、rgb 、 xyz 三种不同的方式获取 Matrix属于多维数组可以通过aa ab 获取其中的单通道 wrangle节点可以通过 alt + E 打开Houdini的代码编辑器，比起wrangle的小界面好用太多了，不过我还是觉得VScode好用 Houdini的Function定义类似于C语言 先声明返回值的变量类型 后接函数名和参数 需要注意的是Houdini的参数声明使用 ; 间隔而不是逗号（调用函数时参数间隔还是用逗号的） Array添加数组使用 append(array, value) 函数,效果和JavaScript的push是一样的。 len(array) 函数可以获取数组的的长度，与JavaScript array.length 效果一样。 函数传参修改回改变参数自身的，建议使用函数局部变量进行数据交换。 向量声明可以使用set 或者 用{} 声明 教程中VEX详解第十集 - 点线面命令相关的函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546&#x2F;&#x2F;获取属性point(geometry, attribute_name, pointnumber);prim(geometry, attribute_name, prim);vertex(geometry, attribute_name, prim, vertex);detail(geometry, attribute_name, ignored);&#x2F;&#x2F;修改属性setpointattrib(geohandle, name, pt, value, mode&#x3D;&quot;set&quot;)setprimattrib(geohandle, name, prim, value, mode&#x3D;&quot;set&quot;);setvertexattrib(geohandle, name, elemnum, vtxofprim, value, mode&#x3D;&quot;set&quot;);setdetailattrib(geohandle, name, value, mode&#x3D;&quot;set&quot;);&#x2F;&#x2F;创建addpoint(geohandle, pos);addprim(primnum, geohandle, type, points, vertices);addvertex(geohandle, prim, point);&#x2F;&#x2F;有多少个npoints(filename);nprimitives(filename);nvertices(filename);&#x2F;&#x2F;放进数组中setpointgroup(geohandle, name, pt, value, mode&#x3D;&quot;set&quot;);setprimgroup(geohandle, name, prim, value, mode&#x3D;&quot;set&quot;);setvertexgroup(geohandle, name, elemnum, vtxofprim, value, mode&#x3D;&quot;set&quot;);&#x2F;*获取属性 代码解析*&#x2F;vector myPos &#x3D; point(0, &quot;P&quot;, @ptnum);&#x2F;* * 第一个参数: &#96; geometry &#96; - wrangle节点的输入通道（0表示wrangle节点的第一个通道） * 第二个参数: &#96; attribute_name &#96; - 获取属性名称 如 N(法线Normal) Cd(颜色ColorDiffuse) P(位置Position) * 第三个参数: &#96; pointnumber &#96; - 根据点序号进行获取操作 * 上述操作就可以将特定模型点的位置存入到vector变量 myPos 中 *&#x2F;&#x2F;*修改属性 代码解析*&#x2F;setpointattrib(0, &quot;P&quot;, @ptnum, @P+1, &quot;set&quot;);&#x2F;* * 第一个参数: &#96; geohandle &#96; - wrangle节点的输入通道 * 第二个参数: &#96; name &#96; - 获取属性名称 * 第三个参数: &#96; pt &#96; - 进行操作的点序号 * 第四个参数: &#96; value &#96; - 进行操作的数值 * 第五个参数: &#96; mode &#96; - 官方文档有更多模式 * 上述操作就可以将特定模型点的位置偏移 *&#x2F; 第十一集 - Array数组操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879vector pos;vector pos_all[];for(int i &#x3D; 0; i&lt;npoints(0);i++)&#123; pos &#x3D; point(0, &quot;P&quot;, i); &#x2F;&#x2F;将获取到点位置信息存放到数组中 append(pos_all,pos);&#125;&#x2F;&#x2F;遍历数组 获取数组中的信息for(int y &#x3D; 0; y&lt;len(pos_all);y++)&#123; printf(&quot;%d\n&quot;,pos_all[y]);&#125;&#x2F;&#x2F; foreach (int index; element_type value; array)foreach (int index; vector posi; pos_all)&#123; &#x2F;&#x2F;posi是当前index遍历中pos_all数组的一个元素 if(posi.y &gt; 0 ) &#123; posi.y &#x3D; 0; setpointattrib(0, &quot;P&quot;, index, posi, &quot;set&quot;);&#x2F;&#x2F;进行位移操作 &#125;&#125;&#x2F;***************************************&#x2F;&#x2F;************第二种实现方案**************&#x2F;&#x2F;***************************************&#x2F;vector pos;&#x2F;&#x2F;根据面返回点 这里就是快速获取所有的点int pts[] &#x3D; primpoints(0, @primnum);foreach(int pt; pts)&#123; &#x2F;&#x2F; 计算所有点的位置 pos &#x3D; point(0, &quot;P&quot;, pt); if(pos.y &gt; 0) &#123; pos.y &#x3D; 0; setpointattrib(0, &quot;P&quot;, pt, pos, &quot;set&quot;); &#125;&#125;&#x2F;***************************************&#x2F;&#x2F;************第三种实现方案**************&#x2F;&#x2F;***************************************&#x2F;if(@P.y&gt;0)@P.y&#x3D;0;&#x2F;***************************************&#x2F;&#x2F;*************foreach解析***************&#x2F;&#x2F;**************************************&#x2F;&#x2F;&#x2F; 三个参数情况&#x2F;&#x2F; 官方解释&#x2F;&#x2F; For each iteration, this form assigns the current position in the array to index,&#x2F;&#x2F; copies the current member to value, and executes statement. For example:string days[] &#x3D; &#123; &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot; &#125;&#x2F;&#x2F; i为当前遍历的序号&#x2F;&#x2F; name为days中的元素(根据当前遍历序号获取)foreach (int i; string name; days) &#123; printf(&quot;Day number %d is %s&quot;, i, name);&#125;&#x2F;&#x2F; 两个参数情况&#x2F;&#x2F; 官方解释&#x2F;&#x2F; This loops over the members of array. For each iteration, &#x2F;&#x2F; it copies the current member to value and then executes statement. For example:int an_array[] &#x3D; &#123;1, 2&#125;foreach (int num; an_array) &#123; &#x2F;&#x2F;num既是index也是数组的元素 printf(&quot;%d&quot;, num);&#125; 第十三集 - 创建几何体123456789101112131415161718&#x2F;&#x2F; 创建一个面片vector pos1 &#x3D; set(1,0,1);vector pos2 &#x3D; set(-1,0,-1);vector pos3 &#x3D; set(-1,0,1);vector pos4 &#x3D; set(1,0,-1);int p1 &#x3D; addpoint(0, pos1);int p2 &#x3D; addpoint(0, pos2);int p3 &#x3D; addpoint(0, pos3);int p4 &#x3D; addpoint(0, pos4);int prim1 &#x3D; addprim(0, &quot;poly&quot;);&#x2F;&#x2F; 注意添加顺序addvertex(0, prim1, p1);addvertex(0, prim1, p3);addvertex(0, prim1, p2);addvertex(0, prim1, p4); 12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F; 创建一个金字塔vector pos1 &#x3D; set(1,0,1);vector pos2 &#x3D; set(-1,0,-1);vector pos3 &#x3D; set(-1,0,1);vector pos4 &#x3D; set(1,0,-1);int p1 &#x3D; addpoint(0, pos1);int p2 &#x3D; addpoint(0, pos2);int p3 &#x3D; addpoint(0, pos3);int p4 &#x3D; addpoint(0, pos4);int prim1 &#x3D; addprim(0, &quot;poly&quot;);addvertex(0, prim1, p1);addvertex(0, prim1, p3);addvertex(0, prim1, p2);addvertex(0, prim1, p4);vector pos &#x3D; &#123;0,2,0&#125;;int p &#x3D; addpoint(0, pos);int prim2 &#x3D; addprim(0, &quot;poly&quot;);addvertex(0, prim2, p);addvertex(0, prim2, p1);addvertex(0, prim2, p3);int prim3 &#x3D; addprim(0, &quot;poly&quot;);addvertex(0, prim3, p);addvertex(0, prim3, p4);addvertex(0, prim3, p1);int prim4 &#x3D; addprim(0, &quot;poly&quot;);addvertex(0, prim4, p);addvertex(0, prim4, p2);addvertex(0, prim4, p4);int prim5 &#x3D; addprim(0, &quot;poly&quot;);addvertex(0, prim5, p);addvertex(0, prim5, p3);addvertex(0, prim5, p2); 第十六集 - polyline123456789101112131415161718192021222324252627282930&#x2F;&#x2F;找到附近的点int closePTS[] &#x3D; nearpoints(0, @P, 5);foreach(int pt; closePTS)&#123; int connect &#x3D; addprim(0, &quot;polyline&quot;); addvertex(0, connect, @ptnum); addvertex(0, connect, pt);&#125;&#96;&#96;&#96; ![连线效果](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;FXTD-odyssey&#x2F;FXTD-odyssey.github.io@master&#x2F;post_img&#x2F;50174&#x2F;3.png)### 第十七集 - nearpoints&#96;&#96;&#96;vex&#x2F;&#x2F; 获取第二输入几何体序号为零的点位置vector pos &#x3D; point(1,&quot;P&quot;,0);float distance &#x3D; ch(&quot;dist&quot;);&#x2F;&#x2F;寻找小于distance的点int targets[] &#x3D; nearpoints(0, pos, distance);foreach(int pt;targets)&#123; setpointattrib(0, &quot;Cd&quot;, pt, 1, &quot;set&quot;);&#125; 第十八集 - neighbour12345678int origin &#x3D; chi(&quot;source&quot;);int neigh &#x3D; chi(&quot;neigh&quot;);&#x2F;&#x2F;neigh 可以获取单独的neighbour元素int targets &#x3D; neighbour(0, origin, neigh);setpointattrib(0, &quot;Cd&quot;, targets, 1, &quot;set&quot;); 123456789int origin &#x3D; chi(&quot;source&quot;);&#x2F;&#x2F; 获取所有neighbour相关元素int targets[] &#x3D; neighbours(0, origin);foreach(int pt; targets)&#123; setpointattrib(0, &quot;Cd&quot;, targets, 1, &quot;set&quot;);&#125; 第十九集 - 点云基本操作123456789101112131415float distance&#x3D;ch(&quot;dist&quot;);int amount&#x3D;chi(&quot;amount&quot;);int target;vector pos &#x3D;point(1,&quot;P&quot;, 0);int pcloud&#x3D;pcopen(0,&quot;P&quot;, pos, distance, amount);if(pcnumfound(pcloud)&gt;0)&#123; while(pciterate(pcloud))&#123; pcimport(pcloud,&quot;point.number&quot;, target); setpointattrib(0, &quot;Cd&quot;, target, 1, &quot;set&quot;); &#125;&#125; &#x2F;&#x2F; 获取最远的点f@far &#x3D; pcfarthest(pcloud); 第二十集 - 点云操作123456789101112131415161718192021&#x2F;&#x2F;获取点云信息int pcCloud &#x3D; pcopen(1, &quot;P&quot;, @P, 2, 1);&#x2F;&#x2F;获取球的的位置信息vector pos &#x3D; point(1, &quot;P&quot;, 0);&#x2F;&#x2F;计算球到面的距离算出方向vector dir &#x3D; normalize(@P - pos);&#x2F;&#x2F;获取点云识别到的点if(pcnumfound(pcCloud)&gt;0)&#123; &#x2F;&#x2F;计算两者之间的距离 因为上面的搜索半径为2 所以dist 是从0到2变化的 float dist &#x3D; distance(@P, pos); &#x2F;&#x2F;将距离信息重新映射作为区域的衰变范围 float falloff &#x3D; fit(dist, 0, 2, 1, 0); &#x2F;&#x2F;falloff 的作用是当距离越靠近的时候减弱点的位移，距离越远受到的位移就越大 @P +&#x3D; dir * falloff;&#125;]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠁHoudini</tag>
        <tag>ࠒ视频教程/pluralsight</tag>
        <tag>ࠁHoudini/VEX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VisualStudioCode 编辑器安利]]></title>
    <url>%2Fposts%2F3087.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;没想到有一天我会写安利这个编辑器的文章，不过也是，VisualStudioCode在国内确实小众了点。&emsp;&emsp;不过其实他大有来头。&emsp;&emsp;这个编辑器是微软为了推它们自个开发的TypeScript语言诞生的，主要针对Web前端。&emsp;&emsp;与它同类型的 Text Editor 文本编辑器还有 sublime 和 atom。&emsp;&emsp;下面我简称其为VScode。 VScode &emsp;&emsp;感觉貌似VScode和Houdini八竿子打不着呀，针对的领域也完全不同。&emsp;&emsp;不过VScode强大地方在于开源，有无数用户为其提供强大的插件。&emsp;&emsp;这么说来，其实atom 和 sublime 都是一样的，它们都拥有大量插件来提高开发效率。&emsp;&emsp;不过VScode是我用过最方便的，完全可定制的界面，可视化插件安装界面。安装插件已经简单到点击按钮的程度。&emsp;&emsp;VScode有支持Mel和Vex的语言插件，可以实现完美的编程体验。&emsp;&emsp;VScode还嵌套了cmd命令窗口（貌似这功能对Houdini开发没啥帮助(:з」∠)），完虐我之前用过的sublime，atom用得少不做评价。&emsp;&emsp;简单易用、轻量快捷是我对它的评价。&emsp;&emsp;即便是现在写的这篇博文也是在VScode的强力支持下，通过Hexo框架写出来的。&emsp;&emsp;VScode的代码补全机制比起原生的要好很多，可以提前告诉你各个参数分别是啥。&emsp;&emsp;另外VScode更是有好多插件来提高开发效率。比如鼠标中键的框选操作，部分选择替换操作，多光标操作等等，等一下，我所说的这些其实都不需要插件，VScode自带的。插件的作用就更加骚气了，可以批量给变量后缀添加后缀数字。只可惜VEX太小众了，其他语言还有formatter自动排版，还有自动找错的功能。&emsp;&emsp;VScode还可以定义snippet，一些比较通用的代码可以通过snippet一键生成。&emsp;&emsp;我觉得这些理由已经足够了，更何况它是开源免费的，而且背后还有微软爸爸帮忙维护。 总结 &emsp;&emsp;我最初接触VScode的时候，还是再弄网页前端的时候，毕竟这款编辑器就是为这个领域而生的。&emsp;&emsp;但是自从有了它，我就好久没有用其他的编辑器和IDE了。]]></content>
      <categories>
        <category>VScode</category>
      </categories>
      <tags>
        <tag>࠶vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Houdini VDB 将CAD图纸转成实体模型]]></title>
    <url>%2Fposts%2F21898.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;今年暑假，我们接了一个大的Three.js项目，主要负责搭建海心沙、花城汇、流花展馆的模型，放到网页上，为物业查看租客信息提供便利。&emsp;&emsp;网页上的模型就只能要求低模，面数不能太高，否则就会造成运行卡顿，下载缓慢的问题。&emsp;&emsp;硕大的花城汇，工作量真的是巨大无比，不过客户为我们提供了CAD图纸，我们还是能省下一丢丢功夫的。&emsp;&emsp;理论上，通过图纸，我们可以将图纸的曲线挤压出模型，大大减轻我们从零建模的工作量。&emsp;&emsp;但是实际的情况比想象中还要麻烦。 CAD图纸的问题 &emsp;&emsp;鉴于Maya的CAD图纸对接不是特别好，导入经常会陷入假死的状态，我们的模型团队最后采用了3dsMax来完成这个重任。&emsp;&emsp;不过我们毕竟是学动画的，还是Maya玩得熟悉。&emsp;&emsp;所以最后模型还是汇总到Maya上进行最终的处理。&emsp;&emsp;而Maya上的模型是这个样子的。 &emsp;&emsp;看前来好像也没啥毛病呀！&emsp;&emsp;但是放大看就知道问题不是一点半点的麻烦。 &emsp;&emsp;模型正如CAD图纸一样，中间的墙体都是镂空的，而且根据曲线挤压的面不是很正常，经常多个点、面重合在一起。&emsp;&emsp;我们花了大半个暑假，每天都在修复模型的墙体镂空问题。&emsp;&emsp;这个活真是累死人，毫无技术含量，但是却又非常费时。&emsp;&emsp;为此，我也一直想帮模型团队减轻工作压力，也在之前使用过Houdini研究过解决这个问题的方法。&emsp;&emsp;（在这个过程中我还开发了面片自动匹配的插件以及自动成盒的插件，一切为了让建模团队的不再爆肝） Houdini解决方案VDB方案初探 &emsp;&emsp;面对这个问题，学习过Houdini破碎的我，最先想到了VDB的方案。&emsp;&emsp;VDB可以根据物体的密度体积重新生成新的模型。&emsp;&emsp;而这需要用到 VDB from polygon 来解决。 &emsp;&emsp;然而可以看到这个方案的结果是有些比较细小的面片就会消失，而且参数很难调整到一个比较适合的区域。&emsp;&emsp;所以这个方案并不能两全。&emsp;&emsp;最后我就放弃了VDB流程。 布尔方案 &emsp;&emsp;后面我也想到了布尔的方案，只要有模型中心的面片，就可以挤出新的墙体了。&emsp;&emsp;然而因为模型有很多墙体不是闭合的，布尔之后的模型也无法提取出内部的面片。 &emsp;&emsp;当时和模型团队一商量，还不如手动修补来得快。&emsp;&emsp;所以后面我就没有继续研究这个问题，花城汇的全部模型多交给了模型团队去修补。&emsp;&emsp;但是这个情况延续到开学之后就不同了，模型团队要上课要做作业，根本就没有这么多时间来处理这些问题。&emsp;&emsp;为了妥善解决这个问题，我又开始深入研究如何用Houdini解决这个问题。&emsp;&emsp;我还问了师兄，不过并没有好的方案，只能说用代码来解决问题。&emsp;&emsp;我就只好自己去探索Houdini的功能了。 模型投射方案 &emsp;&emsp;后面我想能否获取到模型投射的面片，通过投射的面片面积进行挤出，那么也能生成实体的墙体。&emsp;&emsp;这个方案我首先想到了ray节点，即将模型投射到平面上的方法。 &emsp;&emsp;调整了参数之后，可以看到模型已经成功压成了平面了。但是… &emsp;&emsp;模型的镂空还是存在，甚至连面片都没有。&emsp;&emsp;于是我继续寻找Houdin和投射相关的操作节点，我发现很多和Maya一样，是属于NURBS处理，需要曲线进行操作的。 &emsp;&emsp;在误打误撞中，我发现了triangulate2d 节点。&emsp;&emsp;这个节点也可以实现平面投射。&emsp;&emsp;调整了参数之后就可以投射出相应的面片 &emsp;&emsp;通过计算模型的面积，将大面积的部分去除。 &emsp;&emsp;这样虽然已经非常接近终点了，但是还是留下了一些遗憾，面积的选择范围是在太难控制了，弄不好就会删多或者删少了。 &emsp;&emsp;虽然失败了，但是我还是没有死心，我觉得 triangulate2d 还可以再战500年。&emsp;&emsp;于是我发现它还可以实现ray节点的效果，然并卵而已。 &emsp;&emsp;最后我还是放弃了投射的方案。 VDB再探 &emsp;&emsp;我再次探索VDB是因为我发现VDB的线框正是我所需要模型结构。 &emsp;&emsp;虽然VDB的线框膨胀了，但是确实是我想要的效果，这种精简的线框效果是网页模型很必要的。&emsp;&emsp;于是我又开始研究VDB的转换了。&emsp;&emsp;在不断的测试中，我发现了VDB topology to sdf &emsp;&emsp;我当时还不知好歹地想，我靠怎么转VDB了，这面数让人难受啊。&emsp;&emsp;其实后面才发现，这个节点不是正好解决了VDB体积消失的问题吗(:з」∠)&emsp;&emsp;这个发现是很让人兴奋的，虽然布线密集了点。（这个问题正是解决我们问题的关键！！！） &emsp;&emsp;不过这个转化也是有缺点的，那就是体积会发生膨胀。 &emsp;&emsp;如何解决这个问题，其实只需要提高上面VDB的生成精度即可，但是内存就会爆发式地上涨。 &emsp;&emsp;通过这个方法虽然吃光了我手提电脑的8G内存，但是可以证明这个问题是可以解决的。&emsp;&emsp;后面只要将这个VDB模型转成多边形就可以了。 &emsp;&emsp;最初我是想到了convert这个节点，但是没想到这个模型转换异常巨大，我借用模型团队的台式电脑。16G的内存都不够用。&emsp;&emsp;后来我研究了一下，发现convert VDB 节点调整了参数之后可以生成较为可以可用的模型。 &emsp;&emsp;如此一来后面的操作都呼之欲出了，生成一个面片与VDB生成的polygon进行布尔。&emsp;&emsp;后面再通过布尔产生面片挤出模型，在后面就是降低面数就解决所有的问题了。 &emsp;&emsp;通过布尔生成组将多余的面删除掉。 &emsp;&emsp;通过transform 挤出多边形 &emsp;&emsp;这个流程下来，基本上就把所有的事情都弄好了。&emsp;&emsp;后面只需要到Maya里面做些修修补补的工作。&emsp;&emsp;工作效率真的提升了数十倍。 总结 &emsp;&emsp;自己去探索Houdini的过程是非常有趣的，不过自己也是幸运的，通过VDB流程找到了突破口。&emsp;&emsp;以后这种CAD图纸再不同担心构建困难了。&emsp;&emsp;不过说来说去还是因为我们对CAD不熟悉，理论上CAD是可以完成这个操作的。]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>实战</category>
      </categories>
      <tags>
        <tag>ࡄThreejs</tag>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观看笔记 - Pluralsight - Houdini SOP Solver]]></title>
    <url>%2Fposts%2F15486.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;好久没有看Houdini的教程了，最近闲下来就有种不知所措的感觉。&emsp;&emsp;想来还是开始看之前就留下来的Houdini教程吧，于是乎就选择了一个相对比较简短的教程。&emsp;&emsp;这个教程看效果我还以为是挺高级的SOP教程，不过想到自己基本看完了zplus系列教程，对SOP的理解应该到了足以应付的程度。&emsp;&emsp;没想到看完之后，这套教程比我想象的还要小白。 Houdini基础讲解 &emsp;&emsp;这套教程前面差不多10集都是在讲解Houdini的一些基本元素构成。&emsp;&emsp;讲解point prim vertex 的区别。&emsp;&emsp;通过attribute wrangle来生成几何体，讲得也是非常通俗易懂。 &emsp;&emsp;让我印象最深刻的是 vertex 和 point的区别 以及 vop sop 和 vex 的区别。 &emsp;&emsp;vertex是指每个面所占有的顶点，而point就是Maya当中的vertex。&emsp;&emsp;因此Houdini中的vertex是根据每个面单独去算的，两个四边面拼接在一起，就有6个points 有 8个vertices &emsp;&emsp;至于 vop sop 和 vex 比较也非常直观&emsp;&emsp;vopsop虽然不需要写代码，但是连线很容易交错，看起来非常复杂。&emsp;&emsp;而vex则在这方面非常清晰简单。&emsp;&emsp;所以师兄推荐使用vex解决问题，不是没有道理。 曲线生长案例 &emsp;&emsp;这个案例做出感觉非常酷炫的，通过这个教程终于知道那些卖芯片的线条特效是怎么做出来的。 制作思路 生成一个面片，随机删除面片上的点 根据剩下的点选出中心部分的点 用 Group range 间隔选出中心以外的点 用 find shortest path 早出距离中心最近的线 （这里可以根据相邻点的位置生成法线方向，从而实现沿着曲线运动的效果） 用 Carve 节点实现生成效果 成果 &emsp;&emsp;制作起来难度不大，思路倒是非常不错的。后面的一些操作并没有跟着教程来，而是加入自己的思考做出的效果。（其实也只是很简单的修改而已）]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
      </categories>
      <tags>
        <tag>ࠁHoudini/SOP</tag>
        <tag>ࠁHoudini</tag>
        <tag>ࠒ视频教程/pluralsight</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - EditorContrl 添加区域限制]]></title>
    <url>%2Fposts%2F57520.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;这个问题其实提早之前就解决了，一直懒得更新博客。&emsp;&emsp;趁着最近“山竹”台风天放假，我就来更新一波。 &emsp;&emsp;其实区域限制在OrbitContrl 中是有的，但是OrbitControl的上下交互不及EditorControl 来得舒服。&emsp;&emsp;所以，客户要求使用EditorControl的效果，但是EditorControl又没有OrbitControl的区域限制效果。&emsp;&emsp;倘若不限制区域的话，用户将很有可能不知所踪，这样交互就很糟糕。 &emsp;&emsp;于是为了解决这个问题，我就借鉴了OrbitControl的区域限制写法。 OrbitControl区域限制剖析OrbitControl.js 123456789101112131415161718// How far you can dolly in and out ( PerspectiveCamera only )this.minDistance = 0;this.maxDistance = Infinity;// How far you can zoom in and out ( OrthographicCamera only )this.minZoom = 0;this.maxZoom = Infinity;// How far you can orbit vertically, upper and lower limits.// Range is 0 to Math.PI radians.this.minPolarAngle = 0; // radiansthis.maxPolarAngle = Math.PI; // radians// How far you can orbit horizontally, upper and lower limits.// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].this.minAzimuthAngle = - Infinity; // radiansthis.maxAzimuthAngle = Infinity; // radians &emsp;&emsp;上面的部分就是OrbitControl中关于限制区域的API&emsp;&emsp;那么这些API是怎么运作的呢？&emsp;&emsp;我们可以追踪minDistance的去向。&emsp;&emsp;在169行代码可以找到这一行。 12// restrict radius to be between desired limitsspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) ); &emsp;&emsp;也就说让 spherical.radius 的最大最小范围只能是 maxDistance 和 minDistance&emsp;&emsp;那么什么是 spherical.radius 呢？&emsp;&emsp;继续追查spherical 1var spherical = new THREE.Spherical(); &emsp;&emsp;在260行可以看到这里声明了spherical&emsp;&emsp;什么是 THREE.Spherical ？&emsp;&emsp;又去官方文档查找资料 &emsp;&emsp;从这里可以知道 spherical 和数学运算有关，通过spherical可以限制摄像机做圆周运动。&emsp;&emsp;radius是圆心半径，而 phi 和 theta 就分别是经纬度，刚好和官方说的 spherical coordinates 吻合。 &emsp;&emsp;由此可以知道远近距离就是通过限制这个球坐标系的半径实现的。 &emsp;&emsp;那么同理 minPolarAngle 和 minAzimuthAngle 就是分别限制 经度 和 纬度 了。 EditorContrl 区域限制修改 &emsp;&emsp;EditorContrl 和 OrbitControl 不是用相同的方法开发的，直接复制代码就别想了。&emsp;&emsp;通过观察EditorControl的API可以发现， this.pan this.zoom this.rotate 这三个函数是控制移动的关键部分。 &emsp;&emsp;而这其中 this.rotate 使用了spherical的方法。&emsp;&emsp;因此迁移代码也就不难了。 1234567891011121314151617181920212223242526this.rotate = function ( delta ) &#123; vector.copy( object.position ).sub( center ); spherical.setFromVector3( vector ); spherical.theta += delta.x; spherical.phi += delta.y; /*加入的代码*/ // restrict theta to be between desired limits spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) ); // restrict phi to be between desired limits spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) ); spherical.makeSafe(); vector.setFromSpherical( spherical ); object.position.copy( center ).add( vector ); object.lookAt( center ); scope.dispatchEvent( changeEvent );&#125;; &emsp;&emsp;如此一来就实现了经纬度旋转限制的效果&emsp;&emsp;但是修改this.zoom的时候就遇到了麻烦&emsp;&emsp;这里的this.zoom并没有使用 spherical&emsp;&emsp;而是直接计算 摄像机 到 聚焦中心 的距离 &emsp;&emsp;如此就无法直接使用 sphercial 的代码套用&emsp;&emsp;在这个过程中也遇到了很多坑，搞不好就是旋转好好地，一平移镜头就会跳。&emsp;&emsp;本来想着不用 spherical 来解决的，最后还是妥协了，把spherical加进去计算就OK了。 123456789101112131415161718192021222324252627this.zoom = function ( delta ) &#123; var distance = object.position.distanceTo( center ); delta.multiplyScalar( distance * scope.zoomSpeed ); if ( delta.length() &gt; distance ) return; /*加入的代码*/ // delta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) ); vector.copy( object.position ).sub( center ); spherical.setFromVector3( vector ); spherical.radius += delta.z; // restrict radius to be between desired limits spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) ); vector.setFromSpherical( spherical ); object.position.copy( center ).add( vector ); // object.position.add( delta ); scope.dispatchEvent( changeEvent );&#125;; &emsp;&emsp;最后的最后就是需要限制生相机的聚焦中心了。&emsp;&emsp;这个功能OrbitControl也没有，但是想到spherical的区域限制实现。&emsp;&emsp;自然也就有限制中心的想法。 &emsp;&emsp;查了 Three.js 提供的数学运算，其中就有BOX3的方法&emsp;&emsp;这样就可以用类似的方法将聚焦中心限制在盒子中了。 12345678910111213141516171819202122232425262728293031323334353637//设置初始值this.panLimitMax = new THREE.Vector3(10,3,10);this.panLimitMin = new THREE.Vector3(-10,-3,-10);var box = new THREE.Box3();box.min = this.panLimitMin;box.max = this.panLimitMax;/*其他代码*/this.pan = function ( delta ) &#123; var distance = object.position.distanceTo( center ); delta.multiplyScalar( distance * scope.panSpeed ); delta.applyMatrix3( normalMatrix.getNormalMatrix( object.matrix ) ); object.position.add( delta ); center.add( delta ); /*加入的代码*/ vector.copy( object.position ).sub( center ); spherical.setFromVector3( vector ); box.min = this.panLimitMin; box.max = this.panLimitMax; box.clampPoint(center,center); vector.setFromSpherical( spherical ); object.position.copy( center ).add( vector ); /*结束*/ scope.dispatchEvent( changeEvent );&#125;; &emsp;&emsp;如此就实现了将摄像机聚焦中心限制在盒子中的效果，其实根据同样的方法可以迁移到球中。 总结 &emsp;&emsp;突然发现其实很多复杂的东西Three.js都已经做好给你了，我并不清楚 sphercial 和 BOX3 背后的数学运算，但是既然提供了相关的API，只管用就是了。&emsp;&emsp;所以自己还是未能深入到WebGL的深层学习中，只是学习Three.js流于表面的东西。 &emsp;&emsp;十月将近了，后面就是和研究了快一年的Three.js道别的时候了。&emsp;&emsp;时间真的过得很快，想来去年11月份的时候，聪哥让我研究WebGL。&emsp;&emsp;我就看了Lynda.com 和 pluralsight.com 的教程入坑了，在那里我学习到了Three.js&emsp;&emsp;后面的学习教程越来越少，只能靠看官方提供的文档和案例了，但是还是能做出一些东西，感觉还是挺欣慰的。因为这些的学习，自己的视力严重下降也真的让我感到悲哀… &emsp;&emsp;最近也将 THREE_View.js 的API文档写好了，后面继续Three.js的开发就相对简单了，通过自己封装的脚本可以写少很多很多的代码。]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈优越感]]></title>
    <url>%2Fposts%2F33613.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;不知不觉又好久没有再写博客了，最近这些天一直在忙碌专业网站的事情，忙碌之余还要继续弄花城汇的项目。&emsp;&emsp;今天心态有点崩，虽然每当这个时候我都会用“不以物喜，不以己悲”来告诫自己，但是今天细细想想或许并没有这么简单。 &emsp;&emsp;今天特别不开心，特别是在参加交流会的过程中。说实话，没有人针对过我，我只是静静地在听大家交流而已，那为什么自己会不开心呢？&emsp;&emsp;其实自己最初也不知道自己为什么不开心，因为不明白，所以才会觉得自己的情绪变化无常，才会用上面的名句来告诫自己。 &emsp;&emsp;后面我实在是听不下去了，我除掉耳机，静静地坐在电脑前思考。&emsp;&emsp;我总结起来，大概包括了一下两个点： 建模是个坑，我个人走过这条路，对此抱有极大的偏见，我的内心强烈觉得我们非艺术生走建模会后悔，然而我却不能去制止，不能将自己的主观认识强加于他人。 自己的优越感受到了打击，我或许嫉妒了吧。 &emsp;&emsp;其实前面的原因，顶多让我窝火，倒不至于让我看不下去。我觉得建模还是得从画画和美感去提升，目前阶段的作品让我感到前途堪忧吧，不过师兄毕竟也是从坑里爬出来的人，他应该比我更加清楚才是，所以对于这个问题，我并没有发表任何的内心想法。&emsp;&emsp;至于另外一个原因，真的是让我听不下去的罪魁祸首。 优越感 &emsp;&emsp;不知道从什么时候开始，我非常享受这种比别人棒的感觉。可能高中的时候无法在成绩上做到名列前茅，所以我就选择了剑走偏锋的兴趣爱好上吊打别人吧。&emsp;&emsp;确实我做到了，这份优越感也是在我不断探索学习的动力，不断督促我前进，从而形成了一种良性的循环。 优越感 → 学习 → 作品 → 优越感 &emsp;&emsp;我沉浸在优越感之中，自己仿佛就是这片领域的天之骄子。&emsp;&emsp;没错，在CG这片领域中我没有竞争对手，学习虽然是孤独的，但也一直是身边的人中最顶尖的。&emsp;&emsp;想来自己也是一直在逃避竞争，高中的时候就从来不和别人比成绩，因为我知道自己比不过别人，我也不和成绩好的人混在一起（除了打乒乓球之外）&emsp;&emsp;我拒绝竞争，要不就是以高手的姿态示人，比不过就保持低调在其他地方默默碾压别人。 &emsp;&emsp;这么多年，当然也认识过很多大神的作品，包括师兄很厉害的作品，但是我都没有太大的压力，因为我打从内心地认为假以时日，我一定超越你。&emsp;&emsp;也或许是因为这份倔强吧，让我可以在不同的领域都能学有所成（手动不要脸）。 &emsp;&emsp;或许是自己自恋吧，也或许是自己习惯了孤独吧，突然之间在特效的CG领域被人超越了，自己听不懂交流的内容了，那种心境的变化似乎是某种东西破碎了。&emsp;&emsp;没错我的优越感被粉碎了，这让我很难受，自己所享受所沉浸与的东西，被人超越了。我嫉妒，也包括对自己的表现的不满，所以我不开心，不高兴。&emsp;&emsp;虽然我有无数的理由来平衡内心的痛苦，比如我最近没有在弄CG呀，对于自己的学习能力还是非常有自信了啦。&emsp;&emsp;不过这也无法平复我内心消逝的优越感，或许我扮演过太多追赶超越的角色了，从来就没有体会过被被人超越的滋味。&emsp;&emsp;现在我才发猛然发现，为什么我如此渴望优越感，因为我渴求被人重视的感觉，而这种需求渴望还是源于自己的孤独，我自认为优秀的人，被人重视的人，多少能摆脱一些孤独。&emsp;&emsp;然而我却依旧可悲地活在孤独之中。 &emsp;&emsp;其实现在想来，活在孤独并不可悲，当今社会又有多少人有真正的知音，我只是没有能够真正敞开心扉的朋友而已，孤独如风，常伴吾身，习惯就好。 &emsp;&emsp;我本来应该讲优越感的，不过说着说着还是回到了自己的内心痛苦的根源——孤独去了。&emsp;&emsp;没有能够交心的朋友，说明我和身边打交道的人都是表面朋友而已。&emsp;&emsp;我愿意让自己成为一个老好人，虽然不会获得坚固的友谊，但是也不会付出任何代价。&emsp;&emsp;我希望自己可以像冰果的奉太郎那样消能量地活着，某种自足常乐的感觉，这也或许是对于现实的妥协吧，说习惯了也好，说麻木了也罢。&emsp;&emsp;当然，我还是清晰地认识到动漫总归是动漫，而且奉太郎身边还有database，而我就真的只能接受现实了。 总结 &emsp;&emsp;其实师弟学得比我快，是非常好的事情，于我于他都是好事，我的压力更大了，也就能学习得更卖力了…&emsp;&emsp;或许还是因为我不想参与到竞争中吧，宁愿像奉太郎一样消能量活着，也不想在竞争中付出失败的代价。&emsp;&emsp;把自己的观点写下来，心情确实好了很多，希望以后可以看看，以此为鉴。]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>✒博客/人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MEL - 选点成盒插件]]></title>
    <url>%2Fposts%2F988.html</url>
    <content type="text"><![CDATA[原理 &emsp;&emsp;通过选择的顶点生成面片，根据面片挤压出盒子。&emsp;&emsp;原理并不复杂，之前做的面片自动匹配插件也有很多相同的地方 &emsp;&emsp;但是鉴于连续顶点选择的时候，会有序号相连的情况，为此我特意开发了一个函数来处理这个问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162global proc FXTD_seperatePtNum(string $sel[])&#123; string $str = ""; string $PtStr[] = &#123;&#125;;//清空数组 for($j = 0; $j &lt; size($sel); $j++ )&#123; //查看数组是否包含 : 信息 $str = `match ":" $sel[$j]`; if($str == "")&#123;//没有就是正常的点 $PtStr[size($PtStr)] = $sel[$j]; &#125;else&#123; string $buffer2[]; string $buffer3[]; string $buffer4[]; //分离出 [***:***] 当中的数字 例如[123:321] tokenize `match "[0-9]+]" $sel[$j]` "]" $buffer2; tokenize `match "vtx[[0-9]+:" $sel[$j]` "[" $buffer3; //获取面的名字 tokenize $sel[$j] ".vtx" $buffer4; //数据类型转换 int $temp_1 = $buffer3[1]; int $temp_2 = $buffer2[0]; //添加到数组最后的位置 for($i = 0; $i + $temp_1 &lt;= $temp_2; $i++ )&#123; $PtStr[size($PtStr)] = ($buffer4[0] + ".vtx[" + ($i + $temp_1) + "]"); &#125; &#125; $str = ""; &#125; $sel = $PtStr;&#125;//获取选择的顶点$sel = `ls -sl`;//清楚相连的序号重新存储到数组中FXTD_seperatePtNum($sel);float $vtx_position[] = &#123;&#125;;//清空数组//将收集的点的位置信息批量放进数组中for($j = 0; $j &lt; size($sel); $j++ )&#123; FXTD_floatPush($vtx_position,`xform -q -ws -t $sel[$j]`);&#125;//根据选择的点生成多边形string $temp_tri[] = `polyCreateFacet -ch off -tx 1 -s 1 -p $vtx_position[0] $vtx_position[1] $vtx_position[2] -p $vtx_position[3] $vtx_position[4] $vtx_position[5] -p $vtx_position[6] $vtx_position[7] $vtx_position[8]`; 2019-10-26 补充其实ls -fl可以通过 flattern 参数将这种数组展平(:з」∠) 序号错乱问题 &emsp;&emsp;目前这种方案可以解决选点问题，直接生成模型。&emsp;&emsp;然而序号是从小到大排序而非选择的顺序。&emsp;&emsp;这会导致面片错乱的情况。 &emsp;&emsp;为了解决这个问题，就需要记录选点的顺序操作。&emsp;&emsp;然而网上找不到相关的资料（MEL真的是太小众了）&emsp;&emsp;于是只好自己去想办法&emsp;&emsp;而我所想到唯一靠谱的方案就是使用scriptjob动态记录选择。&emsp;&emsp;因为理论上每一个选择都需要存储到数组中，从而实现顺序记录。&emsp;&emsp;然而这种方案写起来很痛苦的 &emsp;&emsp;终于，最后费了我九牛二虎之力才在CGsociety中找到了2005年的解决方案。&emsp;&emsp;当然原先的解决方案可能年代久远吧，有点问题，我进行了一些修改。&emsp;&emsp;原答案是针对选择边提出的解决方案，其实迁移到其他地方并不困难。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970global string $selectOrder_edges[];global string $selectOrder_updateSet;global int $selectOrder_jobNum;global proc string[] selectOrder ()&#123; // Get globals global string $selectOrder_edges[]; global string $selectOrder_updateSet; global int $selectOrder_jobNum; if ( !`scriptJob -exists $selectOrder_jobNum` || $selectOrder_jobNum == 0 ) &#123;//判断scriptJob 是否已经开启了 //题头信息提示用户 headsUpMessage "开始监听-选择内容"; //清空数组 $selectOrder_edges = &#123;&#125;; //创建选择集 记录当前的选择 string $selEdges[] = `ls -sl`; $selectOrder_updateSet = `sets -n selectOrderSet $selEdges`; //添加scriptJob 记录信息 $selectOrder_jobNum = `scriptJob -event SelectionChanged "selectOrder.update"`; &#125; else &#123;//如果scriptJob 已经开启了 headsUpMessage "停止监听-选择内容"; //删除选择集 delete $selectOrder_updateSet; //注销scriptJob scriptJob -kill $selectOrder_jobNum -force; &#125; //返回记录选择的数组 return $selectOrder_edges;&#125;//scriptJob 动态记录函数global proc selectOrder.update ()&#123; // Get Globals global string $selectOrder_edges[]; global string $selectOrder_updateSet; // Get change string $selEdges[] = `ls -sl`; //创建选择集 将当前的选择放进去 string $tempSet = `sets -n selectOrderSetTemp $selEdges`; //减去之前已经选择的部分 string $diff[] = `sets -sub $tempSet $selectOrder_updateSet`; //添加-fl flatten 标签可以 清理序号相连的问题 $diff = `ls -fl $diff`; //将选择集放入到string数组中 $selectOrder_edges = stringArrayCatenate($selectOrder_edges,$diff); //删除选择集 delete $tempSet; delete $selectOrder_updateSet; //重新创建选择集 $selectOrder_updateSet = `sets -n selectOrderSet $selEdges`;&#125; &emsp;&emsp;这里使用了-fl标签，通过内置flag，完美解决了我上面头疼的序号问题。(:з」∠)&emsp;&emsp;这个方法我测试了一下，确实可以记录操作顺序，但是也有其他的问题。&emsp;&emsp;开启了scriptJob之后撤销就会很麻烦。&emsp;&emsp;每一次都要按一下来开启scriptjob &emsp;&emsp;想到ls 还有-fl 这样的操作，我就想官方会不会已经提供了什么解决方案。&emsp;&emsp;于是我又在官方文档中寻找。&emsp;&emsp;还真的找到了更为简洁的解决方案。 123456//开启 记录选择顺序selectPref -trackSelectionOrder 1;//-fl flattern清理序号相连问题 //-os orderSelected 按顺序获取选择$sel = `ls -fl -os`; &emsp;&emsp;如此开发中所有的坑都已经解决了，剩下的只是界面和挤压面片的操作而已。 总结 &emsp;&emsp;MEL真的不好弄，不像JavaScript，资料一大堆。&emsp;&emsp;CG行业现在普遍都用python进行开发了，MEL小众语言被挤得没有生存空间。&emsp;&emsp;但是开发Maya插件始终是离不开MEL的，即便使用pymel，代码的源头还是来自于MEL。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠀMaya/MEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MEL - 面片自动匹配插件（二）]]></title>
    <url>%2Fposts%2F52737.html</url>
    <content type="text"><![CDATA[位移吸附 &emsp;&emsp;上文讲到可以通过计算法线角度实现旋转角的计算。&emsp;&emsp;那么为什么要计算出旋转角呢？&emsp;&emsp;直接吸附相关的点到对应的模型上不就OK了吗？ &emsp;&emsp;问题当然没有那么简单，如果模型没有旋转正确的角度就去吸附的话，会产生问题的。 &emsp;&emsp;可以看到非正确的角度吸附会变形的。&emsp;&emsp;不过这个问题已经在上文中解决了。&emsp;&emsp;现在要解决的是头疼的吸附问题。 &emsp;&emsp;最初想的效果是通过缩放比例来匹配目标点的大小，但是仔细一想就知道有多扯淡。&emsp;&emsp;怎样的缩放比例才是适合的，压根就没有谱。&emsp;&emsp;因此只有吸附位移点的操作才是重中之重。 操作逻辑 &emsp;&emsp;其实仅仅是吸附到位的核心代码并不复杂。 ![吸附点]https://cdn.jsdelivr.net/gh/FXTD-odyssey/FXTD-odyssey.github.io@master/post_img/52737/2.png) ![吸附点]https://cdn.jsdelivr.net/gh/FXTD-odyssey/FXTD-odyssey.github.io@master/post_img/52737/3.png) &emsp;&emsp;如此就可以将点吸附到想要的位置。&emsp;&emsp;然后记录下当前吸附的位置。&emsp;&emsp;然后吸附另一边的点，然后将刚才记录的位置返回给左边部分的点。&emsp;&emsp;通过点的模型拉伸就完美实现了。 &emsp;&emsp;难点 如何自动识别出需要吸附的顶点 如何记录相应的点的位置 自动识别需要吸附的顶点 &emsp;&emsp;要让两者互相配对，就需要识别对应关系。&emsp;&emsp;首先是模型自身的顶点——左下角和右下角顶点。&emsp;&emsp;这个还真的没有好的办法，因此我认为这个需要用户定义这两个角的序号。&emsp;&emsp;毕竟不同的模型，左下角和右下角的定义是不一样的。 &emsp;&emsp;问题是如何让点与点之间产生配对关系，这个让我想了很久。&emsp;&emsp;最后我的解决方案也不是很完美，不过至少也是把问题解决了。 &emsp;&emsp;我的想法是获取模型上的极端点，或者说是碰撞盒上的点。&emsp;&emsp;毕竟导入模型的左下角和右下角也算是极端的碰撞盒点了（至少面片属于的）&emsp;&emsp;那么我们的目标位置又如何有极端的碰撞盒点呢？&emsp;&emsp;这就需要借助之前提到的三角形了。&emsp;&emsp;三角形也是面片，只要分离出两者极端点的关系，就可以产生对应关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235global proc int[] computeBoudingPt(string $target)&#123; int $versNum[] = `polyEvaluate -v $target`; //截取“.” 判断传入参数是否是面 string $buffer[]; tokenize $target "." $buffer; select -r $target; //将面转为顶点 ConvertSelectionToVertices; string $selectedPt[] = `ls -sl `; //如果传入的顶点信息是相连的情况需要进行处理 //例如这样：store5:store.vtx[0:9] if(size($selectedPt) == 1)&#123; string $buffer2[]; string $buffer3[]; //分离出 [***:***] 当中的数字 例如[123:321] 分离目标数据 tokenize `match "[0-9]]" $selectedPt[0]` "]" $buffer2; tokenize `match "vtx[[0-9]+:" $selectedPt[0]` "[" $buffer3; //数据类型转换 int $temp_1 = $buffer3[1]; int $temp_2 = $buffer2[0]; //将目标数据存放到一个数组变量中 int $pointNum_Seperate[] = &#123;&#125;; for($i = 0; $i + $temp_1 &lt;= $temp_2; $i++ )&#123; $pointNum_Seperate[$i] = $i + $temp_1; &#125; &#125; float $tempPtPos[]; float $MinPtX; float $MinPtY; float $MinPtZ; float $MaxPtX; float $MaxPtY; float $MaxPtZ; //遍历所有的点 计算点的世界坐标 算出所有轴向的最大值和最小值 for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; //获取点的世界坐标 if($buffer[1] == "")&#123;//传入参数不是面 $tempPtPos = `xform -q -ws -t ($target + ".vtx[" + $j +"]")`; &#125;else&#123;//传入参数是面 $tempPtPos = `xform -q -ws -t ($buffer[0] + ".vtx[" + $pointNum_Seperate[$j] +"]")`; &#125; //初始化数值 if($j == 0)&#123; $MinPtX = $tempPtPos[0]; $MinPtY = $tempPtPos[1]; $MinPtZ = $tempPtPos[2]; $MaxPtX = $tempPtPos[0]; $MaxPtY = $tempPtPos[1]; $MaxPtZ = $tempPtPos[2]; &#125; //计算极端值 $MinPtX = `min $MinPtX $tempPtPos[0]`; $MinPtY = `min $MinPtY $tempPtPos[1]`; $MinPtZ = `min $MinPtZ $tempPtPos[2]`; $MaxPtX = `max $MaxPtX $tempPtPos[0]`; $MaxPtY = `max $MaxPtY $tempPtPos[1]`; $MaxPtZ = `max $MaxPtZ $tempPtPos[2]`; &#125; int $CornerPT[] ; //初始化数值 //复制-1是避免和0序号冲突 $CornerPT[0] = -1; $CornerPT[1] = -1; $CornerPT[2] = -1; $CornerPT[3] = -1; $CornerPT[4] = -1; $CornerPT[5] = -1; $CornerPT[6] = -1; $CornerPT[7] = -1; //由于mel自身的浮点数可能有偏差，没有办法让两次获取的数据相等 //经过网上查找，这里用python的代码强行保留小数点三位小数。 $MinPtX = `python ("round ("+ $MinPtX +", 3)")`; $MinPtY = `python ("round ("+ $MinPtY +", 3)")`; $MinPtZ = `python ("round ("+ $MinPtZ +", 3)")`; $MaxPtX = `python ("round ("+ $MaxPtX +", 3)")`; $MaxPtY = `python ("round ("+ $MaxPtY +", 3)")`; $MaxPtZ = `python ("round ("+ $MaxPtZ +", 3)")`; //根据点坐标最大值和最小值 获取边角的点序号 for($j = 0; $j &lt; $versNum[0]; $j++)&#123; //获取点的世界坐标 if($buffer[1] == "")&#123;//传入参数不是面 $tempPtPos = `xform -q -ws -t ($target + ".vtx[" + $j +"]")`; $tempPtPos[0] = `python ("round ("+ $tempPtPos[0] +", 3)")`; $tempPtPos[1] = `python ("round ("+ $tempPtPos[1] +", 3)")`; $tempPtPos[2] = `python ("round ("+ $tempPtPos[2] +", 3)")`; if($tempPtPos[1] == $MinPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[0] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[1] = $j; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[2] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[3] = $j; &#125; &#125; &#125;else if($tempPtPos[1] == $MaxPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[4] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[5] = $j; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[6] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[7] = $j; &#125; &#125; &#125; &#125;else&#123;//传入参数是面 $tempPtPos = `xform -q -ws -t ($buffer[0] + ".vtx[" + $pointNum_Seperate[$j] +"]")`; $tempPtPos[0] = `python ("round ("+ $tempPtPos[0] +", 3)")`; $tempPtPos[1] = `python ("round ("+ $tempPtPos[1] +", 3)")`; $tempPtPos[2] = `python ("round ("+ $tempPtPos[2] +", 3)")`; if($tempPtPos[1] == $MinPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[0] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[1] = $pointNum_Seperate[$j]; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[2] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[3] = $pointNum_Seperate[$j]; &#125; &#125; &#125;else if($tempPtPos[1] == $MaxPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[4] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[5] = $pointNum_Seperate[$j]; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[6] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[7] = $pointNum_Seperate[$j]; &#125; &#125; &#125; &#125; &#125; //返回的$CornerPT包含8个数值，处于极端点的就会存储点序号，否则就输出-1值。 return $CornerPT;&#125; &emsp;&emsp;通过上面的方法就可以计算出boundingbox的点，但是缺点也很明显。&emsp;&emsp;如果是面片的话倒也还好，如果是个正方体之类的复杂模型，只要稍微一旋转。&emsp;&emsp;所有的点都不在碰撞盒里面，就无法获取想要的对应关系了。&emsp;&emsp;当然也不是没有解决方法，只是需要将模型旋转到正对轴向的方向才行，当然复杂的模型是不可能的了。&emsp;&emsp;我目前还没有想到更好的方案（估计更进一步就要学习复杂的算法了） &emsp;&emsp;如此一来就可以通过极端点的对应关系，知道左边的点对应的三角形面片的点。&emsp;&emsp;从而实现自动吸附功能。 记录点的位置 &emsp;&emsp;记录点的位置需要一开始分别识别左边的点和右边的点。&emsp;&emsp;我想到的方法就是以X轴为界限，分别记录左边的点和右边的点。 12345678910111213141516171819202122232425//记录左边和右边的点//$target 就是导入的模型//获取模型的点数 用于遍历int $versNum[] = `polyEvaluate -v $target`;string $leftPtSel[] ;string $rightPtSel[] ;for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; //获取每个点的世界坐标 $tempPtPos = `xform -q -ws -t ($target + ".vtx[" + $j +"]")`; //无关变量赋予无关值 $leftPtSel[$j] = -1; $rightPtSel[$j] = -1; //区分左边和右边的点 if($tempPtPos[2] &gt; 0)&#123;//判断Z轴 $leftPtSel[$j] = $j; &#125;else&#123; $rightPtSel[$j] = $j; &#125;&#125; &emsp;&emsp;下面要考虑的是如何通过这里的点信息来记录吸附点的坐标位置。&emsp;&emsp;并且在吸附结束之后，将记录的信息还原到对应的点上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//////////////////////////////////////////////////////////////////////////// 匹配需要吸附的点 /////////////////////////////////////////////////////////////////////////////select -r $leftCorner;//选择左下角的顶点//目标模型的左下角点的面片ConvertSelectionToFaces;string $selFace[] = `ls -sl `;//获取左下角的面int $CornerPtnum[] = FXTD_computeBoudingPt($selFace[0]);int $TriPtnum[] = FXTD_computeBoudingPt($temp_tri[0]);int $num_1 = -1;int $num_2 = -1;//找到互相匹配的点 进行吸附for($j = 0; $j &lt; 4; $j++)&#123; if($CornerPtnum[$j] != -1 &amp;&amp; $TriPtnum[$j] != -1)&#123; if($num_1 == -1)&#123; $num_1 = $j; &#125;else if($num_2 == -1)&#123; $num_2 = $j; &#125; &#125;&#125;//第一次吸附点select -r ($target + ".vtx["+ $CornerPtnum[$num_1] + "]");select -tgl ($temp_tri[0] + ".vtx["+ $TriPtnum[$num_1] + "]");SnapPointToPoint;float $left_vtx_position[] = &#123;&#125;;//清空数组float $right_vtx_position[] = &#123;&#125;;//清空数组//记录当前的位置信息if($CornerPtnum[$num_1] == $leftNum)&#123;//如果是吸附左边的点 for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($leftPtSel[$j] != -1 )&#123; FXTD_floatPush($left_vtx_position,`xform -q -ws -t ($target + ".vtx[" + $j +"]")`); &#125; &#125; &#125;else&#123; for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($rightPtSel[$j] != -1 )&#123; FXTD_floatPush($right_vtx_position,`xform -q -ws -t ($target + ".vtx[" + $j +"]")`); &#125; &#125;&#125;select -r ($target + ".vtx["+ $CornerPtnum[$num_2] + "]");select -tgl ($temp_tri[0] + ".vtx["+ $TriPtnum[$num_2] + "]");SnapPointToPoint;//复原上面记录的位置int $temp = 0;if($CornerPtnum[$num_1] == $leftNum)&#123;//如果是吸附左边的点 for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($leftPtSel[$j] != -1 )&#123; select -r ($target + ".vtx[" + $j +"]"); move -a $left_vtx_position[$temp*3] $left_vtx_position[$temp*3+1] $left_vtx_position[$temp*3+2]; $temp++; &#125; &#125; &#125;else&#123; for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($rightPtSel[$j] != -1 )&#123; select -r ($target + ".vtx[" + $j +"]"); move -a $right_vtx_position[$temp*3] $right_vtx_position[$temp*3+1] $right_vtx_position[$temp*3+2]; $temp++; &#125; &#125; &#125; 插件制作 &emsp;&emsp;基本上整个插件的难点已经剖析出来了。&emsp;&emsp;剩下的就是将一些琐碎的功能连接到一起而已。注：导入的模型面片一定要朝向X轴正方向，这里偷了懒，没有做法线方向的计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515//面片匹配插件 ver 1.0//制作时间2018-8-25 - 2018-8-27//制作人：智伤帝，可在B站关注我哟~//模拟 push数组 的效果将数据放到数组最后global proc FXTD_floatPush(float $array[],float $added[])&#123; int $addedSize = size($added); int $arraySize = size($array); for($i = $arraySize; $i &lt; $arraySize+$addedSize; $i++ ) &#123; $array[$i] = $added[$i-$arraySize]; &#125; &#125;//计算模型的边角点（仅在正90度的正方形、面片起作用）global proc int[] FXTD_computeBoudingPt(string $target)&#123; int $versNum[] = `polyEvaluate -v $target`; //截取“.” 判断传入参数是否是面 string $buffer[]; int $pointNum_Seperate[] = &#123;&#125;; tokenize $target "." $buffer; select -r $target; ConvertSelectionToVertices; string $selectedPt[] = `ls -sl `; if(size($selectedPt) == 1)&#123; string $buffer2[]; string $buffer3[]; //分离出 [***:***] 当中的数字 例如[123:321] tokenize `match "[0-9]]" $selectedPt[0]` "]" $buffer2; tokenize `match "vtx[[0-9]+:" $selectedPt[0]` "[" $buffer3; //数据类型转换 int $temp_1 = $buffer3[1]; int $temp_2 = $buffer2[0]; for($i = 0; $i + $temp_1 &lt;= $temp_2; $i++ )&#123; $pointNum_Seperate[$i] = $i + $temp_1; &#125; &#125; float $tempPtPos[]; float $MinPtX; float $MinPtY; float $MinPtZ; float $MaxPtX; float $MaxPtY; float $MaxPtZ; //遍历所有的点 计算点的世界坐标 算出所有轴向的最大值和最小值 for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; //获取点的世界坐标 if($buffer[1] == "")&#123;//传入参数不是面 $tempPtPos = `xform -q -ws -t ($target + ".vtx[" + $j +"]")`; &#125;else&#123;//传入参数是面 $tempPtPos = `xform -q -ws -t ($buffer[0] + ".vtx[" + $pointNum_Seperate[$j] +"]")`; &#125; //初始化数值 if($j == 0)&#123; $MinPtX = $tempPtPos[0]; $MinPtY = $tempPtPos[1]; $MinPtZ = $tempPtPos[2]; $MaxPtX = $tempPtPos[0]; $MaxPtY = $tempPtPos[1]; $MaxPtZ = $tempPtPos[2]; &#125; $MinPtX = `min $MinPtX $tempPtPos[0]`; $MinPtY = `min $MinPtY $tempPtPos[1]`; $MinPtZ = `min $MinPtZ $tempPtPos[2]`; $MaxPtX = `max $MaxPtX $tempPtPos[0]`; $MaxPtY = `max $MaxPtY $tempPtPos[1]`; $MaxPtZ = `max $MaxPtZ $tempPtPos[2]`; &#125; int $CornerPT[] ; //初始化数值 $CornerPT[0] = -1; $CornerPT[1] = -1; $CornerPT[2] = -1; $CornerPT[3] = -1; $CornerPT[4] = -1; $CornerPT[5] = -1; $CornerPT[6] = -1; $CornerPT[7] = -1; $MinPtX = `python ("round ("+ $MinPtX +", 3)")`; $MinPtY = `python ("round ("+ $MinPtY +", 3)")`; $MinPtZ = `python ("round ("+ $MinPtZ +", 3)")`; $MaxPtX = `python ("round ("+ $MaxPtX +", 3)")`; $MaxPtY = `python ("round ("+ $MaxPtY +", 3)")`; $MaxPtZ = `python ("round ("+ $MaxPtZ +", 3)")`; //根据点坐标最大值和最小值 获取边角的点序号 for($j = 0; $j &lt; $versNum[0]; $j++)&#123; //获取点的世界坐标 if($buffer[1] == "")&#123;//传入参数不是面 $tempPtPos = `xform -q -ws -t ($target + ".vtx[" + $j +"]")`; $tempPtPos[0] = `python ("round ("+ $tempPtPos[0] +", 3)")`; $tempPtPos[1] = `python ("round ("+ $tempPtPos[1] +", 3)")`; $tempPtPos[2] = `python ("round ("+ $tempPtPos[2] +", 3)")`; if($tempPtPos[1] == $MinPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[0] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[1] = $j; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[2] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[3] = $j; &#125; &#125; &#125;else if($tempPtPos[1] == $MaxPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[4] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[5] = $j; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[6] = $j; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[7] = $j; &#125; &#125; &#125; &#125;else&#123;//传入参数是面 $tempPtPos = `xform -q -ws -t ($buffer[0] + ".vtx[" + $pointNum_Seperate[$j] +"]")`; $tempPtPos[0] = `python ("round ("+ $tempPtPos[0] +", 3)")`; $tempPtPos[1] = `python ("round ("+ $tempPtPos[1] +", 3)")`; $tempPtPos[2] = `python ("round ("+ $tempPtPos[2] +", 3)")`; if($tempPtPos[1] == $MinPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[0] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[1] = $pointNum_Seperate[$j]; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[2] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[3] = $pointNum_Seperate[$j]; &#125; &#125; &#125;else if($tempPtPos[1] == $MaxPtY )&#123; if($tempPtPos[0] == $MinPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[4] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[5] = $pointNum_Seperate[$j]; &#125; &#125;else if($tempPtPos[0] == $MaxPtX )&#123; if($tempPtPos[2] == $MinPtZ)&#123; $CornerPT[6] = $pointNum_Seperate[$j]; &#125;else if($tempPtPos[2] == $MaxPtZ)&#123; $CornerPT[7] = $pointNum_Seperate[$j]; &#125; &#125; &#125; &#125; &#125; return $CornerPT;&#125;//面片匹配的主函数global proc FXTD_MatchPlane()&#123; global string $target; //////////////////////////////////////////////////////////// //////////// 根据选择的点生成面 ////////////// /////////////////////////////////////////////////////////// string $sel[] = `ls -sl `; float $vtx_position[] = &#123;&#125;;//清空数组 //将收集的点的位置信息批量放进数组中 for($j = 0; $j &lt; size($sel); $j++ ) &#123; FXTD_floatPush($vtx_position,`xform -q -ws -t $sel[$j]`); &#125; print $vtx_position; string $temp_tri[]; //通过数据生成三角面 string $temp_tri[] = `polyCreateFacet -ch off -tx 1 -s 1 -p $vtx_position[0] $vtx_position[1] $vtx_position[2] -p $vtx_position[3] $vtx_position[4] $vtx_position[5] -p $vtx_position[6] $vtx_position[7] $vtx_position[8]`; //////////////////////////////////////////////////////////// //////////// 根据生成的面匹配旋转角度 ////////////// /////////////////////////////////////////////////////////// //获取法线角度信息 string $NormalFaceStr[] = `polyInfo -fn $temp_tri[0]`; string $buffer[]; //分离出需要的法线数据 tokenize $NormalFaceStr[0] " " $buffer; float $Normal[]; $Normal[0] = $buffer[2]; $Normal[1] = $buffer[3]; $Normal[2] = $buffer[4]; //获取旋转角度 float $rotation[] = `angleBetween -euler -v1 1.0 0.0 0.0 -v2 $Normal[0] $Normal[1] $Normal[2]`; //////////////////////////////////////////////////////////// //////////// 将旋转角度赋予到目标模型上 ///////////// /////////////////////////////////////////////////////////// // file -i -ns "store" `textField -q -tx model_path`; //用变量记录导入的物体 select -r ( `textField -q -tx model_name`) ; string $storeSel[] = `ls -sl `; select -r $storeSel[size($storeSel)-1]; duplicate -rr; string $storeSel[] = `ls -sl `; $target = $storeSel[0]; //记录左边和右边的点 int $leftNum = `intField -q -v leftCorner`; int $rightNum = `intField -q -v rightCorner`; string $leftCorner = $target + ".vtx["+ $leftNum + "]"; string $rightCorner = $target + ".vtx["+ $rightNum + "]"; int $versNum[] = `polyEvaluate -v $target`; string $leftPtSel[] ; string $rightPtSel[] ; for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; $tempPtPos = `xform -q -ws -t ($target + ".vtx[" + $j +"]")`; //无关变量赋予无关值 $leftPtSel[$j] = -1; $rightPtSel[$j] = -1; //区分左边和右边的点 if($tempPtPos[2] &gt; 0)&#123;//判断Z轴 $leftPtSel[$j] = $j; &#125;else&#123; $rightPtSel[$j] = $j; &#125; &#125; //矫正物体的旋转角度 select -r $target; rotate -a -ws -fo 0 $rotation[1] 0 ; //////////////////////////////////////////////////////////// //////////////// 匹配需要吸附的点 ////////////////// /////////////////////////////////////////////////////////// select -r $leftCorner; //目标模型的左下角点的面片 ConvertSelectionToFaces; string $selFace[] = `ls -sl `; int $CornerPtnum[] = FXTD_computeBoudingPt($selFace[0]); int $TriPtnum[] = FXTD_computeBoudingPt($temp_tri[0]); int $num_1 = -1; int $num_2 = -1; //找到互相匹配的点 进行吸附 for($j = 0; $j &lt; 4; $j++)&#123; if($CornerPtnum[$j] != -1 &amp;&amp; $TriPtnum[$j] != -1)&#123; if($num_1 == -1)&#123; $num_1 = $j; &#125;else if($num_2 == -1)&#123; $num_2 = $j; &#125; &#125; &#125; //第一次吸附点 select -r ($target + ".vtx["+ $CornerPtnum[$num_1] + "]"); select -tgl ($temp_tri[0] + ".vtx["+ $TriPtnum[$num_1] + "]"); SnapPointToPoint; float $left_vtx_position[] = &#123;&#125;;//清空数组 float $right_vtx_position[] = &#123;&#125;;//清空数组 //记录当前的位置信息 if($CornerPtnum[$num_1] == $leftNum)&#123;//如果是吸附左边的点 for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($leftPtSel[$j] != -1 )&#123; FXTD_floatPush($left_vtx_position,`xform -q -ws -t ($target + ".vtx[" + $j +"]")`); &#125; &#125; &#125;else&#123; for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($rightPtSel[$j] != -1 )&#123; FXTD_floatPush($right_vtx_position,`xform -q -ws -t ($target + ".vtx[" + $j +"]")`); &#125; &#125; &#125; select -r ($target + ".vtx["+ $CornerPtnum[$num_2] + "]"); select -tgl ($temp_tri[0] + ".vtx["+ $TriPtnum[$num_2] + "]"); SnapPointToPoint; //复原上面记录的位置 int $temp = 0; if($CornerPtnum[$num_1] == $leftNum)&#123;//如果是吸附左边的点 for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($leftPtSel[$j] != -1 )&#123; select -r ($target + ".vtx[" + $j +"]"); move -a $left_vtx_position[$temp*3] $left_vtx_position[$temp*3+1] $left_vtx_position[$temp*3+2]; $temp++; &#125; &#125; &#125;else&#123; for($j = 0; $j &lt; $versNum[0]; $j++ )&#123; if($rightPtSel[$j] != -1 )&#123; select -r ($target + ".vtx[" + $j +"]"); move -a $right_vtx_position[$temp*3] $right_vtx_position[$temp*3+1] $right_vtx_position[$temp*3+2]; $temp++; &#125; &#125; &#125; //////////////////////////////////////////////////////////// //////////////// 添加偏移避免重面 ////////////////// /////////////////////////////////////////////////////////// float $offset = `floatField -q -v offset`; select -r $target; move -r ($Normal[0]*$offset) ($Normal[1]*$offset) ($Normal[2]*$offset); //获取三角面的中心位置 global float $rightPtPos[]; global float $leftPtPos[]; $leftPtPos = `xform -q -ws -t ($temp_tri[0] + ".vtx["+ $TriPtnum[$num_1] + "]")`; $rightPtPos = `xform -q -ws -t ($temp_tri[0] + ".vtx["+ $TriPtnum[$num_2] + "]")`; //删除临时三角面 delete $temp_tri[0]; &#125;// global proc FXTD_importModel()&#123;// file -i -ns "store" `textField -q -tx model_path`;// &#125;global proc FXTD_planeFix()&#123; global string $target; global float $rightPtPos[]; global float $leftPtPos[]; select $target; move -a (($leftPtPos[0]+$rightPtPos[0])/2) (($leftPtPos[1]+$rightPtPos[1])/2) (($leftPtPos[2]+$rightPtPos[2])/2) ($target+ ".scalePivot") ($target+ ".rotatePivot"); rotate -r -ws -fo 0 180 0 ;&#125;if (`window -ex FXTD_MatchPlaneWin` != true)&#123; window -w 310 -h 100 -t ("面片自动匹配 - 插件") -in "将面片自动匹配模型上（能自动拉伸模型）" -s true -tb true FXTD_MatchPlaneWin; columnLayout FXTD_mainCol; separator -style "in" -w 300 -h 8; rowColumnLayout -nc 2 -cw 1 70 -cw 2 230; text -l "偏移值: " -al "right"; floatField -v 0 -w 60 -min 0 offset; setParent ".."; rowColumnLayout -nc 2 -cw 1 70 -cw 2 230; text -l "模型名称: " -al "right"; textField -tx "store2:store" model_name ; setParent ".."; rowColumnLayout -nc 2 -cw 1 70 -cw 2 230; text -l "左下角顶点: " -al "right"; intField -v 3 -w 60 -min 0 leftCorner; setParent ".."; rowColumnLayout -nc 2 -cw 1 70 -cw 2 230; text -l "右下角顶点: " -al "right"; intField -v 2 -w 60 -min 0 rightCorner; setParent ".."; separator -style "none" -w 300 -h 4; button -l "导入模型" -al "center" -w 300 -c ("Import;") -ann "" FXTD_Import; button -l "一键匹配" -al "center" -w 300 -c ("FXTD_MatchPlane();") -ann "" FXTD_Match; button -l "一键修正" -al "center" -w 300 -c ("FXTD_planeFix();") -ann "" FXTD_Fix; showWindow FXTD_MatchPlaneWin;&#125;else // else just pop it up from being minimized again&#123; showWindow FXTD_MatchPlaneWin;&#125;]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠀMaya/MEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MEL - 面片自动匹配插件（一）]]></title>
    <url>%2Fposts%2F19450.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近的暑期项目为了制作广袤而庞大的花城汇广场，我们需要将店铺搭建出来，而这个过程既繁琐有无趣。&emsp;&emsp;为了加快进度，Mel插件俨然刻不容缓了。 &emsp;&emsp;在搭建插件之前，我和建模团队商量了需要的店铺效果。&emsp;&emsp;其实并没有那么复杂，做好一个店铺的贴图面片，只要将其贴到相应的墙面上就大功告成了。&emsp;&emsp;并且很重要的一点是，面片需要根据墙面自动拉伸。 最初的思路 &emsp;&emsp;MEL插件的思路说白了就是通过代码将一大堆的人工操作转换为机器执行。&emsp;&emsp;因此，我们先要将思路理清楚，才能将事半功倍。 &emsp;&emsp;最初的思路 导入面片模型 缩放模型 移动到相应位置进行匹配 &emsp;&emsp;当我在Maya进行操作的时候，发现了不少问题。&emsp;&emsp;匹配位置需要匹配旋转轴，如何获取旋转角度却是非常棘手。&emsp;&emsp;如果使用缩放模型的话，难以判断缩放的比例。 snap together tool 获取转角度 &emsp;&emsp;如何获取当前墙面的角度呢？&emsp;&emsp;确实这个不容易弄，毕竟墙面模型本身没有旋转角度，而有的墙就是斜的。&emsp;&emsp;更不用说如果旋转之后又冻结变换的情况了。 &emsp;&emsp;那么需要考虑的是，如何吸附到墙面并且获取旋转角度问题了。&emsp;&emsp;而确实Maya也有相关的吸附命令。 &emsp;&emsp;然而事与愿违，首先选择面去吸附对于自动化代码是极大地不便。&emsp;&emsp;而且，snap together的代码回显也非常扯淡。 &emsp;&emsp;我清理了代码历史，并且开启了echo all command命令来显示所有的回显命令。&emsp;&emsp;然而执行之后的回显真让人头大。 12345678&#123; float $rp[] = `xform -q -rotatePivot "|pCube1"`; xform -worldSpace -preserve true -rotatePivot 0 1.89666 6.70638 "|pCube1"; rotate -relative 0 207 0 "|pCube1"; xform -rotatePivot $rp[0] $rp[1] $rp[2] "|pCube1";&#125;;move -relative 0.448401 -1.89666 -5.82634 "|pCube1"; &emsp;&emsp;上面的代码是众多Mel回显中，至关重要的部分，然而看看就知道有多扯淡。&emsp;&emsp;单看命令就知道它是如何实现旋转和位移的，但是角度和位移值确实莫名其妙出现的。&emsp;&emsp;而且这个命令不知道如何通过代码来选择面（mel没有回显相关的代码）&emsp;&emsp;这一系列的情况彻底给这种方法宣布了死刑。 利用吸附获取旋转角度 &emsp;&emsp;Mel编程的难度逐渐在这里体现了，它既不是考验算法也不是考验编写，而是考验对Maya的熟悉程度。&emsp;&emsp;获取角度的另一种方法就是获取轴心点的旋转角。 &emsp;&emsp;在移动轴心点的状态点击模型的component（点线面的总称），就可以将模型的轴心方向与选择component发现相匹配。&emsp;&emsp;然而这里遇到了和上面一样的问题。&emsp;&emsp;代码回显的时候角度已经莫名其妙地出现了。 Set to Face 获取旋转角度 &emsp;&emsp;至此，我就陷入了僵局了……&emsp;&emsp;直到我想起了ADV5插件开发的时候，似曾相识地遇到同样的问题，后面似乎解决了。&emsp;&emsp;于是我翻找自己的旧插件，找到了关键的代码。 123//举个例子（不是旧插件的代码）&#123; string $Selection1[]; $Selection1[0] = "pCube1.f[2]"; manipMoveAlignHandleToComponent($Selection1[0], &#123;"pCube1"&#125;, &#123;""&#125;, "none", 0);; &#125;; &emsp;&emsp;然而这段代码是哪里来的呢？&emsp;&emsp;花了一阵子的功夫终于想了起来，Maya的隐藏吸附功能有核心代码!!! &emsp;&emsp;执行之后就可以获取到上面代码块的内容了。&emsp;&emsp;如此就能自动生成选择角度，只需要后期获取数值即可。 创建三角形 &emsp;&emsp;话有说回来，角度值虽然是获取了，但是如果是冻结变换过的模型，又如何获取回到原点的旋转值呢？&emsp;&emsp;况且这里的模型更为复杂，如何才能获取到旋转角度呢？&emsp;&emsp;我想到的解决方案是通过三个点画出三角形，通过计算三角形到原点的旋转角度差返回需要的旋转角。 &emsp;&emsp;那么如何才能画出三角形呢？&emsp;&emsp;可以用Create polygon tool来实现 &emsp;&emsp;这样只需要选择三个点就可以根据三个点的坐标制作三角形了。 12polyCreateFacet -ch on -tx 1 -s 1 -p -0.5 3.317463 0.5 -p -0.5 2.317463 0.5 -p 0.5 2.317463 0.5 ;// Result: polySurface1 polyCreateFace1 // 获取精确的旋转值 &emsp;&emsp;然而创建的三角形算是冻结变换的模型了，&emsp;&emsp;如何将一个冻结过的模型如何旋转回归到原点呢？&emsp;&emsp;这就需要bake pivot命令了。 &emsp;&emsp;bake pivot命令可以将模型回归到原点的状态数值，即便是冻结变换也没有问题。&emsp;&emsp;需要注意的是，角度烘焙需要在自定义轴上才能烘焙。&emsp;&emsp;恰好通过上面的吸附到面命令获取到的旋转轴已经是自定义的，完全不用担心这个问题。 &emsp;&emsp;如此一来就可以通过烘焙枢轴实现从原点到当前的旋转状态，解决了任意角度的旋转问题。 &emsp;&emsp;不过后面我并没有采用这种方式。&emsp;&emsp;因为导入模型的朝向是不可控的，而这种方法必须要特定朝向才能正确执行。&emsp;&emsp;弄得不好，很容易出错。 &emsp;&emsp;经过网上的资料查阅。&emsp;&emsp;后面我决定采用通过面法线计算角度的方法。 12polyInfo -fn pCube1.f[0];// Result: FACE_NORMAL 0: 0.000000 0.000000 1.000000 &emsp;&emsp;可以看到polyInfo 可以返回面法线的信息，但是却是以字符串的形式返回&emsp;&emsp;这就需要截取字符串相关的数据，并且将数据转换为浮点数。 1234567891011121314151617181920//获取法线角度信息string $NormalFaceStr[] = `polyInfo -fn pCube1.f[0]`;string $buffer[];//分离出需要的法线数据tokenize $NormalFaceStr[0] " " $buffer;//根据空格 将法线信息分割出来print $buffer;// FACE_NORMAL// 0:// 0.000000// 0.000000// 1.000000//转换数据类型 用浮点数类型存储buffer中的数据字符串float $Normal[];$Normal[0] = $buffer[2];$Normal[1] = $buffer[3];$Normal[2] = $buffer[4]; &emsp;&emsp;这样就获得了面法线信息了，但是如何计算角度呢？ 1angleBetween -euler -v1 1.0 0.0 0.0 -v2 $Normal[0] $Normal[1] $Normal[2] &emsp;&emsp;angleBetween可以计算两个向量角度。 初步总结 &emsp;&emsp;以上将上面的代码汇总起来，那么第一步就差不多完成了。&emsp;&emsp;然而也还是遇到了一些坑，MEL没有像JavaScript数组push的功能。&emsp;&emsp;可能用python就没有那么操蛋的问题了。&emsp;&emsp;不够没有足够的时间去研究python了，因此得用mel解决。&emsp;&emsp;幸好网上找到了解决问题的代码。&emsp;&emsp;如此一来就方便我进行数据汇总操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//////////////////////////////////////////////////////////////////////// 根据选择的点生成面 /////////////////////////////////////////////////////////////////////////string $sel[] = `ls -sl `;//模拟 push数组 的效果将数据放到数组最后global proc floatPush(float $array[],float $added[])&#123; int $addedSize = size($added); int $arraySize = size($array); for($i = $arraySize; $i &lt; $arraySize+$addedSize; $i++ ) &#123; $array[$i] = $added[$i-$arraySize]; &#125; &#125;float $vtx_position[] = &#123;&#125;;//清空数组//将收集的点的位置信息批量放进数组中for($j = 0; $j &lt; size($sel); $j++ ) &#123; floatPush($vtx_position,`xform -q -ws -t $sel[$j]`); &#125;print $vtx_position;string $temp_tri[];//通过数据生成三角面string $temp_tri[] = `polyCreateFacet -ch off -tx 1 -s 1 -p $vtx_position[0] $vtx_position[1] $vtx_position[2] -p $vtx_position[3] $vtx_position[4] $vtx_position[5] -p $vtx_position[6] $vtx_position[7] $vtx_position[8]`;//////////////////////////////////////////////////////////////////////// 根据生成的面匹配旋转角度 ///////////////////////////////////////////////////////////////////////////获取法线角度信息string $NormalFaceStr[] = `polyInfo -fn $temp_tri[0]`;string $buffer[];//分离出需要的法线数据tokenize $NormalFaceStr[0] " " $buffer;float $Normal[];$Normal[0] = $buffer[2];$Normal[1] = $buffer[3];$Normal[2] = $buffer[4];//获取旋转角度float $rotation[] = `angleBetween -euler -v1 1.0 0.0 0.0 -v2 $Normal[0] $Normal[1] $Normal[2]`;]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠀMaya/MEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js -通过JQuery处理脚本异步加载]]></title>
    <url>%2Fposts%2F35846.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间决定弃用require引用脚本的方式，而是尝试用jQuery的$.getScript()的方式动态获取脚本，结果在过程中又遇到了许多的坑。 &emsp;&emsp;当我开始封装outlinePass函数的时候，我遇到了需要加载数个脚本的问题。但是jQuery提供的解决方案只能加载一个脚本。&emsp;&emsp;于是我上网查了一下，找到了解决方案 123456789101112131415161718192021$.getMultiScripts = function(arr, path) &#123; var _arr = $.map(arr, function(scr) &#123; return $.getScript( (path||"") + scr ); &#125;); _arr.push($.Deferred(function( deferred )&#123; $( deferred.resolve ); &#125;)); return $.when.apply($, _arr);&#125;var script_arr = [ 'myscript1.js', 'myscript2.js', 'myscript3.js'];$.getMultiScripts(script_arr, '/mypath/').done(function() &#123; // all scripts loaded&#125;); &emsp;&emsp;其实你会发现代码都提供了，只管用就是了。&emsp;&emsp;虽然不清楚是怎么实现的，但是可以知道它是通过jQuery的对象对jQuery的$.getScript()重新封装了。&emsp;&emsp;但是当我封装renderPass相关的四个脚本（EffectComposer.js | RenderPass.js | ShaderPass.js | CopyShader.js）的时候，我遇到了报错问题（至今我也没完全弄明白）&emsp;&emsp;当我错开脚本加载之后，问题就得以解决，这个过程中就接触到了done()操作。&emsp;&emsp;也就是第一个脚本完成之后再加载后面三个脚本 &emsp;&emsp;$.getMultiScripts()用起来也问题不大，但是当我将所有的代码封装好之后，我遇到了金字塔回调的地狱。 123456789101112131415161718//外轮廓显示var pass = app.renderPass(function()&#123;//动态加载renderPass相关脚本 pass.outlinePass(function(outline)&#123;//动态加载outlinePass相关脚本 var RayCaster = app.Raycaster(function(selectedObject)&#123; let selectedObjects = []; selectedObjects.push(selectedObject) outline.selectedObjects = selectedObjects; &#125;,function()&#123; outline.selectedObjects = []; &#125;) RayCaster.Click(); &#125;);&#125;); &emsp;&emsp;看起来好像问题还不是很大，毕竟现在只是两层嵌套而已。&emsp;&emsp;但是如果回调函数如果不停增多的话，那么代码就会变得非常复杂，代码的可读性就会大大下降。 &emsp;&emsp;鉴于这个问题，我网上找了一下。发现这个详解&emsp;&emsp;另外，博文里面附带的链接有国外大神文章的翻译。&emsp;&emsp;里面有个例子就非常形象. 123456789101112131415161718192021222324252627// Normal callback usage =&gt; PYRAMID OF DOOOOOOOOMasyncOperation(function(data)&#123; // Do some processing with `data` anotherAsync(function(data2)&#123; // Some more processing with `data2` yetAnotherAsync(function()&#123; // Yay we're finished! &#125;); &#125;);&#125;);//这只是三层而已，如果嵌入了10层，那么末尾的 &#125;); 将会多到眼花缭乱的。//ajax多重嵌套就更清晰了$.ajax(&#123; url: url1, success: function(data)&#123; $.ajax(&#123; url: url2, data: data, success: function(data)&#123; $.ajax(&#123; //... &#125;); &#125; &#125;); &#125;&#125;); &emsp;&emsp;看来这个问题也是早已有之，国外的大神早就开始寻求解决方案了。&emsp;&emsp;在搜索的过程中还额外发现了另一篇挺有用的博文，没想到最有用的四种设计模式都是在pluralsight上面学习的。如果还不懂什么是回调函数之类的可以看看。 &emsp;&emsp;现在是问题很清楚了，但是如何解决呢。&emsp;&emsp;CommonJS给出的解决方案是使用Promise/A规范，具体的方案可以参照国外大神文章的讲法。&emsp;&emsp;不过单单是使用起来还不是很方便。&emsp;&emsp;鉴于此，还是使用jQuery的方法比较好，而且我也想弄懂multiScript封装是怎么实现的。 jQuery Deferred &emsp;&emsp;通过jQuery的deferred对象可以通过promise对象实现脚本延时加载，避免回调地狱的噩梦。&emsp;&emsp;那jQuery的deferred要怎么用呢？&emsp;&emsp;有在网上寻找解决方案，但是很多网页都是一大堆文字，讲得我懵逼得很。&emsp;&emsp;后面我发现阮一峰的讲解还是挺不错的。 1234567891011121314151617181920212223//最后总结起来是这样的var wait = function (dtd) &#123; var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function () &#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks, 5000); return dtd.promise(); // 返回promise对象&#125;;//通过when调用，实现done操作$.when(wait()).done(function () &#123; alert("哈哈，成功了！"); &#125;).fail(function () &#123; alert("出错啦！"); &#125;); &emsp;&emsp;这样写有什么好处呢？看完之后好像也不比回调函数好多少呀。&emsp;&emsp;还不是得function来function去的吗？ &emsp;&emsp;我一开始也是那么懵逼的，虽然在上面的promise原生讲解中多少体会到了一些promise对象的魅力，但是jQuery似乎并没有什么值得称道的地方。&emsp;&emsp;直到我看了这篇博文 1234567891011121314151617var promiseA = $.get(urlA);// 这里添加promiseA的回调var promiseB = promiseA.then(function()&#123; return $.get(urlB);&#125;);// 这里添加promiseB的回调var promiseC = promiseB.then(function()&#123; return $.get(urlC);&#125;);// 这里添加promiseC的回调var promiseD = promiseC.then(function()&#123; return $.get(urlD);&#125;);// 这里添加promiseD的回调 &emsp;&emsp;这下子就清晰了很多了，回调函数不需要嵌套在callback函数里面。&emsp;&emsp;而是通过then去直接调用，可读性大大增加了。 jQuery done() 和 then() &emsp;&emsp;deferred对象可以通过$.when()来触发，实现then操作。&emsp;&emsp;而除了用then之外，也可以用done来执行成功回调，用fail来执行失败回调。&emsp;&emsp;而then操作则是包含了 success、fail和always三个参数。 &emsp;&emsp;我一开始没有搞懂它们之间的区别，结果吃了大亏。 &emsp;&emsp;经过网上搜索，我又找到了一篇博文 12345678910111213141516171819202122232425var defer = jQuery.Deferred(); defer.done(function(a,b)&#123; console.log("a = " + a+"b = " + b);//a = 2b = 3 return a * b; &#125;).done(function( result ) &#123; console.log("result = " + result);//result = 2 &#125;).then(function( a, b ) &#123; console.log("a = " + a+"b = " + b);//a = 2b = 3 return a * b; &#125;).done(function( result ) &#123; console.log("result = " + result);//result = 6 &#125;).then(function( a, b ) &#123; console.log("a = " + a+"b = " + b);//a = 6b = undefined return a * b; &#125;).done(function( result ) &#123; console.log("result = " + result);//result = NaN &#125;); defer.resolve( 2, 3 ); &emsp;&emsp;通过这篇文章可以找到done()的返回值是没有意义的。&emsp;&emsp;但是then()的返回值是可以返回的。&emsp;&emsp;这个巨大的差别让我卡了很久。&emsp;&emsp;我一直以为done实现会更加简洁，其实就是坑了爹。 总结 &emsp;&emsp;经过了一天的调试，最后我利用jquery实现了promise对象回调。 1234567891011121314151617181920212223242526272829303132333435363738//最初的实现效果//外轮廓显示var pass = app.renderPass(function()&#123;//动态加载renderPass相关脚本 pass.outlinePass(function(outline)&#123;//动态加载outlinePass相关脚本 var RayCaster = app.Raycaster(function(selectedObject)&#123; let selectedObjects = []; selectedObjects.push(selectedObject) outline.selectedObjects = selectedObjects; &#125;,function()&#123; outline.selectedObjects = []; &#125;) RayCaster.Click(); &#125;);&#125;);//jQuery实现的Deferred回调var pass = app.renderPass();//加载renderPass相关的脚本pass.then(function (renderPass) &#123; return renderPass.outlinePass();//加载outlinePass相关的脚本&#125;).done(function (outlinePass) &#123;//回调获取outlinePass var RayCaster = app.Raycaster(function (selectedObject) &#123; let selectedObjects = []; selectedObjects.push(selectedObject) outlinePass.selectedObjects = selectedObjects; &#125;, function () &#123; outlinePass.selectedObjects = []; &#125;)&#125;) &emsp;&emsp;真是没有对比就没有伤害。&emsp;&emsp;显然后者更加清晰，更加易于理解程序的操作。&emsp;&emsp;当然背后的工程量也就越大。&emsp;&emsp;个人觉得Deferred也不必滥用，如果回调函数比较少的时候，还是回调起来比较方便。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js -动态加载相关的js]]></title>
    <url>%2Fposts%2F24831.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;昨天打算开始重新写我的封装脚本了，将一些函数命名修改，加入更多的功能。&emsp;&emsp;为了更好地使用Three.js，这次我决定使用require.js进行脚本引入。&emsp;&emsp;我希望通过require.js实现js动态记载，在加载控制器的时候可以根据加载的控制器动态加载脚本，这就不需要将无关的脚本加载进来。&emsp;&emsp;在决定使用require之前，我也研究了webpack的方案，但是想到上面的问题，webpack绝对会打包到一起的，这就与我的出发点冲突了，所以决定弃用webpack。 坑爹的开始 &emsp;&emsp;决定好要用require.js之后，就找了相关的资料查阅。&emsp;&emsp;官网地址&emsp;&emsp;菜鸟教程（一）&emsp;&emsp;菜鸟教程（二） &emsp;&emsp;看完这三个教程之后，我对require有了全面的认识。&emsp;&emsp;require的好处就是可以异步加载js文件，避免浏览器假死（因为加载js而不加载页面） &emsp;&emsp;既然如此，那我就根据教程的方法设置requirejs.config就好了。&emsp;&emsp;然而坑爹的地方开始了 123456789101112131415161718192021222324252627282930313233343536373839404142434445requirejs.config(&#123; paths: &#123; "three": ["https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min"], "OrbitControls": ["OrbitControls"] &#125;, shim: &#123; // three: &#123;exports: 'THREE'&#125;, OrbitControls: &#123; deps: ["three"] &#125; &#125;&#125;)require(["three", 'OrbitControls'], function (THREE) &#123; // require(["three"],function(THREE)&#123; //案例代码来自于官方入门Demo var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000); var renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); var geometry = new THREE.BoxGeometry(1, 1, 1); var material = new THREE.MeshBasicMaterial(&#123; color: 0x00ff00 &#125;); var cube = new THREE.Mesh(geometry, material); scene.add(cube); camera.position.z = 5; //require(['OrbitControls'], function () &#123; var controls = new THREE.OrbitControls(camera); //&#125;) var animate = function () &#123; requestAnimationFrame(animate); cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render(scene, camera); &#125;; animate();&#125;); &emsp;&emsp;这种方法无论怎么弄，都会说orbitControl的THREE没有定义。&emsp;&emsp;我一直以为是我没有正确使用require shim所以才导致问题的。&emsp;&emsp;我在网上搜索了大量关于require的教程，找到了jq插件的加载方法。&emsp;&emsp;然而坑爹的地方是，jq的插件可以用这样的方法加载，而Three.js的orbit插件却会报错。 &emsp;&emsp;到这里我已经花了大半天的时间研究了，然而一直没有起色。&emsp;&emsp;后来我去官网认真地看了一遍require的用法，发现模块化需要define才能用&emsp;&emsp;然后我在orbit脚本中加入define的语句包含起来之后就可以了。 12345define(['three'], function(THREE) &#123;//orbit 相关的脚本&#125;) &emsp;&emsp;这样的操作，不会吧！&emsp;&emsp;每个脚本都要处理一下，工作量挺大的，因此我决定一定要知道解决方案。&emsp;&emsp;然而我还是思维局限了，其实问题不在require而是在Three.js。 坑爹的尾声 &emsp;&emsp;后面我搜索了和three.js相关的require问题之后，找到了github 的issue&emsp;&emsp;github地址&emsp;&emsp;我终于得到石锤，不是require的问题而是Three.js自身的问题。&emsp;&emsp;解决方案也在里面。 1234define('three', ['https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js'], function ( THREE ) &#123; window.THREE = THREE; return THREE;&#125;); &emsp;&emsp;在requirejs.config之后加入上面的代码就可以了，无需对各个脚本进行单独的操作。 坑爹地结束 &emsp;&emsp;解决了问题总归是兴奋的，但是当我真正用起来才发现，这里实现了异步加载js，而不是动态加载js。&emsp;&emsp;搞了半天结果发现跑题了……. &emsp;&emsp;我上网搜了一下异步加载的处理方案，发现jquery就有$.getScript的方案，用起来方便得多。&emsp;&emsp;到头来我连require.js也摈弃了，毕竟纯Three.js的三维页面并没有太多网页页面内容，require.js isn’t require.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - postprocessing 后期处理]]></title>
    <url>%2Fposts%2F59091.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近想要制作动态模糊的效果，又想起之前研究过的postprocesisng来制作模糊，网上搜索了一下如何通过Three.js制作动态模糊，没想到居然是这个案例里面有动态模糊。 &emsp;&emsp;postprocessing难学的地方在于没有官方文档的说明，连引用的脚本也没有使用说明，所以只能先从简单的入手，慢慢去看懂postprocessing的运行原理。 postprocesing的作用 &emsp;&emsp;正如名字所说的，这个是后期处理，可以给画面添加后期合成软件的滤镜效果。&emsp;&emsp;当然上面的说法易于理解但也不完全准确，three.js的后期处理更多的是计算机图形学意义上的后期处理，因此辉光、AO生成都属于这里范畴，不只是单纯的滤镜。&emsp;&emsp;如此说来，postprocessing应该有很多的效果，官方确实给了不少效果，而且有些使用了postprocessing的效果还不在postprocessing的分类当中。&emsp;&emsp;找出他们去学习就得费不少的周折。 postprocessing的运用 &emsp;&emsp;先从最简单的postprocessing效果入手，去理解它是怎么运作的。官方案例 &emsp;&emsp;前面的流程就是Three.js的三件套，生成物体等等的，我就不加赘述了。 // postprocessing /******************************/ /*********合成基本要素*********/ /****************************/ //创建合成容器EffectComposer //用Three.js去理解就是在合成中起到renderer（渲染）和scene（容器）的作用 //将渲染器添加进去获取渲染信息 composer = new THREE.EffectComposer( renderer ); //添加通道 RenderPass 获取渲染的场景和摄像机 //用Three.js去理解就是生成的模型需要添加到容易当中才能起作用 composer.addPass( new THREE.RenderPass( scene, camera ) ); /******************************/ /***********添加通道***********/ /****************************/ //DotScreenShader使屏幕产生点状噪点 var effect = new THREE.ShaderPass( THREE.DotScreenShader );//添加材质通道层 effect.uniforms[ 'scale' ].value = 4;//设置噪点的到小 composer.addPass( effect ); //RGBShiftShader偏移颜色是屏幕产生色差效果 var effect = new THREE.ShaderPass( THREE.RGBShiftShader ); effect.uniforms[ 'amount' ].value = 0.0015; effect.renderToScreen = true;//最后一个效果一定添加这个才可以在屏幕看到处理效果 composer.addPass( effect ); /******************************/ /*******改变窗口大小适配*******/ /****************************/ window.addEventListener( 'resize', onWindowResize, false ); function onWindowResize() { //resize的基本操作 camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight ); //加入合成器的resize composer.setSize( window.innerWidth, window.innerHeight ); } /******************************/ /***********刷新函数***********/ /****************************/ function animate() { //刷新函数的基本操作 requestAnimationFrame( animate ); //动态效果 object.rotation.x += 0.005; object.rotation.y += 0.01; //这里可以不加入renderer.render进行渲染，直接渲染composer即可 composer.render(); //如果需要加入renderer.rende // renderer.render( scene, camera ); //务必将这一行语句放在composer的上面 //否则就会覆盖掉composer渲染出来的画面 }]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[至2018级数字媒体技术新生]]></title>
    <url>%2Fposts%2F4257.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;一晃眼就块要开学了，这篇文章才千呼万唤始出来，我自己也只能感叹时间的流逝，感觉昨天还是大一萌新，一转眼就已经快成为大三的老油条了。&emsp;&emsp;作为师兄，有很多东西想和大一分享，算是对自己大学两年生活的总结，希望18级新生能从中吸取经验少走弯路。 我的过去我是谁 &emsp;&emsp;我是2016级数字媒体技术2班的梁伟添，来自广东江门。&emsp;&emsp;我是一名真·技术宅，喜欢逛B站、看动漫、宅在电脑面前研究一些东西。 为什么会来到数字媒体技术专业 &emsp;&emsp;自己小时候看的动漫比较多，希望可以通过学习制作动漫来为国漫做些什么。&emsp;&emsp;曾经也经历过迷茫，不知道自己该朝哪个方向努力，自己并不擅长画画，又如何为动漫做努力呢？&emsp;&emsp;高中的时候，我偶然发现了三维动画技术，不再需要研究绘画中高深莫测的光影变化和造型把握，你只需要把模型搁在那里，所有的光影生成、明暗变化计算机会为你生成。&emsp;&emsp;那个时候初学CG，那种新鲜感真的让我很兴奋，感觉终于找到了自己的目标。&emsp;&emsp;后来也确实做出了一些动画作品（往事不堪回首(:з」∠)）&emsp;&emsp;一触即发I &emsp;&emsp;一触即发II &emsp;&emsp;高一和高二都花了不少时间学习Maya来制作想要的动画效果，当然当中也少不了拿来主义，短片最后都有提及，很多东西都是直接拿教程的模型来做的。&emsp;&emsp;高三的时候因为学业问题所以基本停摆了。&emsp;&emsp;高考之后，填报志愿之前，我还以为自己可以去动画专业继续进修自己的技术，然而我错了，动画专业只有艺术生才能去，现实狠狠地向我泼了一盆冷水。&emsp;&emsp;然而山穷水尽疑无路，柳暗花明又一村。我发现了数字媒体技术专业，整个广东省最类似动画的理科专业，就这样我来到了数字媒体技术。 大学生活 &emsp;&emsp;东风路校区和我想象中的大学相差很大，不过麻雀虽小，五脏俱全。&emsp;&emsp;我进大学之初有幸去参观机电厂的工作室，凭借自己高中的实力，我荣幸大一就可以进驻动画的工作室，但是条件也会苛刻的，那就是必须退出社团。&emsp;&emsp;最后经过我的考虑，我还是退出了学生会，学习更多的技术才是我所追求的。&emsp;&emsp;到了工作室想必就一定会有师兄带我装逼带我发了吧，起初确实是这样的。然而到后来我错了，可能也是我们工作室内部的原因吧，中间发生了很多事情，后面很多东西就只能靠自己去学习去专研。有些东西师兄也不会，而工作室又需要会这方面的技术，这个时候我就只能自己去探索了。&emsp;&emsp;工作室的师兄并没有教会我太多的东西，但是我在工作室的收获却很多。&emsp;&emsp;工作室提供了极佳的学习环境，至少我们工作室的学习环境还是非常不错的。安静而自由的学习氛围，没有人玩游戏，大家都在学习或者搞事情。可能有人不喜欢这种枯燥的生活，不过我正是在这种氛围的熏陶下才能让大一的自己保持不断学习的状态。&emsp;&emsp;后来又发生了许多事情，当中当然也包括了许多的不愉快，但是沉沉浮浮跌跌撞撞地就待了两年。&emsp;&emsp;我的大学生活基本上就是上课、工作室学习、回宿舍娱乐睡觉，三条线来回走。（另外我大学基本就没有怎么出过学校(:з」∠)）寒暑假除了过年也基本都在工作室度过的，大二之后情况有些特殊，工作室曾经被撤出去一段时间……现在又回到机电厂了。 总结 &emsp;&emsp;大学给我的感觉就是自由，没有父母的管束,自己终于成为成年人，自己做出选择来左右自己的生活。&emsp;&emsp;而很多同学给我的感觉是迷茫，摆脱了高考的束缚同时也意味着失去了奋进的方向，如果新的目标不确立，那么大学很容易会陷入放纵和沉沦。&emsp;&emsp;迷茫很容易让人感到孤独，特别是没有办法靠自己树立新的方向和目标的时候，你就会向外界寻求归属感，你会逐渐开始人云亦云，尝试去融入一些集体中来摆脱孤独感，比如你会选择通过和同学和舍友联机打游戏，跟着别人一起出去浪之类的。&emsp;&emsp;或许你的内深处明白重复这些事情是没有意义，甚至会觉得有负罪感，但是迷茫会让你沉沦，逐渐让你变得如同行尸走肉。&emsp;&emsp;当然不要误会我上面的意思，打打游戏和朋友出去玩可以促进大家的交流是好事来的，但是要把握好分寸。如果你是每天都如此循环来摆脱孤独，那就该好好考虑一下自己的未来，决定自己的方向了。 （以上是我个人的鸡汤，不喜勿喷） 专业剖析 &emsp;&emsp;先上张图压压惊，下方随时高能。 &emsp;&emsp;事先说明一下所有的分析都是我个人的总结，并不是学校官方的观点。&emsp;&emsp;我不能保证所有的分析都是对的，只能说是目前我这个阶段所接触到的了解到的情况，仅供参考。 &emsp;&emsp;我个人认为我们专业主要可以分为两个大方向 编程开发（程序猿） CG制作（技术人员） &emsp;&emsp;为什么要这样划分呢？&emsp;&emsp;下面我来给大家剖析一下这两个方向。 编程开发 &emsp;&emsp;编程开发主要分为网站编程、游戏编程、软件应用编程。 &emsp;&emsp;网站编程 前端 JavaScript Html CSS 后台 PHP Java 数据库 mysql &emsp;&emsp;游戏编程 Unity引擎 C# Unreal引擎 C++ &emsp;&emsp;软件应用编程 桌面应用开发 Java .NET 手机App开发 Java 前端前端是啥？ &emsp;&emsp;前端主要负责编写网页的前台，即用户界面，实现网页界面上的交互。百度百科&emsp;&emsp;前端不仅可以用于开发网站，也可以开发小程序和WebApp。（不断抢走移动端的饭碗了） 前端用到的技术 HTML CSS JavaScript &emsp;&emsp;看似好难，前端居然要学习三门语言，其实反而是编程开发中最容易上手的。&emsp;&emsp;HTML的好处是所见即所得，而且标记语言前后对应非常简单易懂。&emsp;&emsp;CSS只是样式表而已，基本机构其实很简单的，新手只需要了解架构之下提供的属性即可。&emsp;&emsp;JavaScript则是前端最难的地方，因为它最像传统的编程语言(没错，在旧版本中，前两者基本没有逻辑处理，甚至说不上是编程语言。) 前端的就业前景 &emsp;&emsp;前端是我们专业比较热门的方向，从专业学习的范围来讲，我们专业也确实有我们自己的优势。&emsp;&emsp;那么前端 大学经验东风路介绍及衣食住行各方面 &emsp;&emsp;其实我是个整天都不怎么出门的人，其实我没什么发言权。大家可以参考贴吧的(文章)[http://tieba.baidu.com/p/3888993383]，内容基本属实的。 吃 &emsp;&emsp;在吃的方面我也没有任何发言权，因为我要求比较低，饭堂就能够满足我的胃口了。&emsp;&emsp;如果吃腻了饭堂可以选择点外卖，市中心的优势就在这里。 &emsp;&emsp;另外我简单分析一下学校的饭堂。学校的饭堂可以分为两个区域，教学区的南苑饭堂和生活区的一二三饭。&emsp;&emsp;教学区的饭堂相对比较干净卫生，但是人很多，特别是周一到周五的中午时段，一群又一群的上班族会霸占饭堂，请做好排队的心理准备。&emsp;&emsp;生活区的饭堂，人会少很多，口味也不一样，看大家的喜好吧。 住 &emsp;&emsp;主要讲男生宿舍的情况，图片可以参考贴吧里的。&emsp;&emsp;大部分男生宿舍都是有独立卫浴和阳台的，环境还是不错的。&emsp;&emsp;宿舍是6人一间，初来乍到的时候感觉还算宽敞，不过生活几个月，等大家的电脑来了之后，你就会感受到宿舍的拥挤。&emsp;&emsp;宿舍没有电梯，如果住在高楼层（比如我们在8楼），就只能爬楼梯，肥胖人士的噩梦。&emsp;&emsp;宿舍配备有空调，不必担心夏日的酷暑。&emsp;&emsp;最近宿舍的阳台新安装了水龙头和插头，方便放置洗衣机，不过洗衣机还是需要宿舍合伙买的。 学 &emsp;&emsp;基本上80%的课程都7号楼上课，不在7号楼的一般都是选修课和公共课（思修、近代史），这些课程会有多个班级上课，需要大教室，一般在5号楼上课。&emsp;&emsp;另外大一的美术课是在5号楼（艺术与设计学院）的画室教室里面上课。]]></content>
      <categories>
        <category>大学</category>
      </categories>
      <tags>
        <tag>🧐回顾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（七）- 代码块进阶优化&分类优化]]></title>
    <url>%2Fposts%2F56108.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;博客优化之路 计划 博客资源搬家瘦身 图片添加水印 fancybox 图片跳转修正 代码块显示优化 本地搜索优化 归档和分类优化 代码块加入复制和切换样式按钮 分类页面优化 代码块进一步优化 &emsp;&emsp;在我自己的浏览过程中，我发现代码块的代码复制非常不方便，想着既然已经加入了clipboard.js了，不妨做多一个按钮方便复制代码。&emsp;&emsp;在制作的过程中又干脆再加多一个切换样式的按钮吧。 &emsp;&emsp;好像只是加入两个按钮而已，一点难度都没有。&emsp;&emsp;然而我就是这么想，所以吃了大亏，弄了我大半天才弄好(:з」∠) &emsp;&emsp;首先用bootstrap生成按钮。绑定点击事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103if($(".highlight").length &gt; 0) &#123;//判断代码块是否存在 $(".highlight").each(function(index)&#123;//遍历代码块 let btnDiv = $('&lt;div&gt;&lt;/div&gt;'); $(this).prepend(btnDiv); let scope = this; btnDiv.css('position','absolute'); $(window).load(function() &#123;//确保其他东西加载完成才执行 btnDiv.css('top',$(scope).position().top + 12); btnDiv.css('right','2em'); &#125;); $(window).resize(function () &#123;//当浏览器大小变化时 setTimeout(function()&#123; btnDiv.css('top',$(scope).position().top + 12); btnDiv.css('right','2em'); &#125;,100); &#125;); //用于复制代码按钮 $(scope).find('.code').addClass("code"+index); //复制按钮 let copyBtn=$("&lt;button type='button' class='btn btn-primary' id='copyBtn" + index + "'data-clipboard-action='copy' data-clipboard-target='.code"+index+"'&gt;复制&lt;/button&gt;"); $(btnDiv).prepend(copyBtn); //识别Vex if($(this).attr('data-lang') == 'vex')&#123; let VEXBtn=$("&lt;button type='button' class='btn btn-primary' id='VEXBtn" + index + "'&gt;VEX原生样式&lt;/button&gt;"); $(btnDiv).prepend(VEXBtn); let VEXBtnCheck = false; let scope = this; $(scope).find('.built_in').removeClass('built_in').addClass("VEX_built_in"); $(scope).find('.string').removeClass('string').addClass("VEX_string"); $(scope).find('.operator').removeClass('operator').addClass("VEX_operator"); $(scope).find('.number').removeClass('number').addClass("VEX_number"); $(scope).find('.command').removeClass('command').addClass("VEX_command"); $('#VEXBtn'+ index).click(function()&#123; if(VEXBtnCheck)&#123; $(this).text('VEX原生样式'); VEXBtnCheck = false; $(scope).find('.built_in').removeClass('built_in').addClass("VEX_built_in"); $(scope).find('.string').removeClass('string').addClass("VEX_string"); $(scope).find('.operator').removeClass('operator').addClass("VEX_operator"); $(scope).find('.number').removeClass('number').addClass("VEX_number"); $(scope).find('.command').removeClass('command').addClass("VEX_command"); &#125;else&#123; $(this).text('自定义样式'); VEXBtnCheck = true; $(scope).find('.VEX_built_in').removeClass('VEX_built_in').addClass("built_in"); $(scope).find('.VEX_string').removeClass('VEX_string').addClass("string"); $(scope).find('.VEX_operator').removeClass('VEX_operator').addClass("operator"); $(scope).find('.VEX_number').removeClass('VEX_number').addClass("number"); $(scope).find('.VEX_command').removeClass('VEX_command').addClass("command"); &#125; &#125;); &#125; //识别MEL if($(this).attr('data-lang') == 'mel')&#123; let melBtn=$("&lt;button type='button' class='btn btn-primary' id='melBtn" + index + "'&gt;MEL原生样式&lt;/button&gt;"); $(btnDiv).prepend(melBtn); let melBtnCheck = false; let scope = this; $(scope).find('.keyword').removeClass('keyword').addClass("mel_keyword"); $(scope).find('.string').removeClass('string').addClass("mel_string"); $(scope).find('.number').removeClass('number').addClass("mel_number"); $(scope).find('.command').removeClass('command').addClass("mel_command"); $(scope).find('.operator').removeClass('operator').addClass("mel_operator"); $('#melBtn'+ index).click(function()&#123; if(melBtnCheck)&#123; $(this).text('MEL原生样式'); melBtnCheck = false; $(scope).find('.keyword').removeClass('keyword').addClass("mel_keyword"); $(scope).find('.string').removeClass('string').addClass("mel_string"); $(scope).find('.number').removeClass('number').addClass("mel_number"); $(scope).find('.command').removeClass('command').addClass("mel_command"); $(scope).find('.operator').removeClass('operator').addClass("mel_operator"); &#125;else&#123; $(this).text('自定义样式'); melBtnCheck = true; $(scope).find('.mel_keyword').removeClass('mel_keyword').addClass("keyword"); $(scope).find('.mel_string').removeClass('mel_string').addClass("string"); $(scope).find('.mel_number').removeClass('mel_number').addClass("number"); $(scope).find('.mel_command').removeClass('mel_command').addClass("command"); $(scope).find('.mel_operator').removeClass('mel_operator').addClass("operator"); &#125; &#125;); &#125; &#125;) &#125; &emsp;&emsp;为了这个我还将之前的highlight.js当中的vex.js和mel.js进行了修改。&emsp;&emsp;主要是改了class名，方便后面的DOM操作改变颜色。&emsp;&emsp;在这个过程中最让我蛋疼的是地方是按钮的位置。&emsp;&emsp;我想要将按钮放在伪元素上面，但是伪元素不能进行DOM操作。&emsp;&emsp;因此我的想法是获取代码的高度，然后将按钮匹配到我想要的位置。&emsp;&emsp;然而无论我怎么尝试，高度就是不太统一。&emsp;&emsp;遇到图片等记载的时候，情况尤为严重。&emsp;&emsp;不同的文章获取到的高度也不太一致。 &emsp;&emsp;经过了很长的测试才发现，原来是获取的高度太早了，后面的内容都还没完成加载。&emsp;&emsp;当我加入setTimeout之后，问题就得到了解决。&emsp;&emsp;不过setTimeout毕竟不知道要延时多少吧，网上查了一下，还是用jquery的onload比较安全。 &emsp;&emsp;除了高度匹配之外，按钮的右侧位置匹配也是让我煞费苦心，一开始是采用left的方案。&emsp;&emsp;这个方案不仅坑多，需要计算出代码块的宽度，并且后面出现两个按钮的情况，就会因为空间不够而挤压到了一起。&emsp;&emsp;后面不得已采用了right方案，这个方案就舒服多了，用em单位之后简直就完美。&emsp;&emsp;不需要js计算宽度，直接适配到我想要的位置，也没有了挤压问题。 &emsp;&emsp;后面的问题就是要修改css样式让切换的颜色匹配。 123456789101112/* VEX 原生亮显 */pre .VEX_built_in&#123;color:#66cccc&#125;pre .VEX_operator&#123;color:#ed77ed&#125;pre .VEX_command&#123;color:#ed77ed&#125;pre .VEX_string&#123;color:#63c563&#125;/* MEL 原生亮显 */pre .mel_keyword&#123;color:#00ffff&#125;pre .mel_operator&#123;color:#00ff00&#125;pre .mel_command&#123;color:#00ff00&#125;pre .mel_string&#123;color:#ffff00&#125; &emsp;&emsp;另外制作复制按钮的时候也遇到了小问题。&emsp;&emsp;代码块没有区分，只能复制第一个，因此我在js里面加入新的class，来使代码块unique&emsp;&emsp;效果在意料之中，这样复制代码就方便多了 分类界面的优化 &emsp;&emsp;这个界面其实原本看起来虽然颜色单一，但是还是基本合格的。&emsp;&emsp;但是我还是想要美化的效果。&emsp;&emsp;结果在这个过程中遇到无与伦比的坑。 &emsp;&emsp;上面的几个分类标签原本不是彩色的，为了让它们变为彩色没少费功夫。 &emsp;&emsp;通过js可以批量给它们添加class，从而实现不同的颜色。&emsp;&emsp;这个倒不是什么问题。 12345 $('.category-list-item').each(function(index)&#123; $(this).addClass("categoryColor"+(index%5+1)); &#125;) &emsp;&emsp;问题是我想要实现鼠标移动到按钮的时候改为更加明亮的颜色，然而却事与愿违地变黑了。 &emsp;&emsp;我知道这是CSS的问题但是却不知道是那个样式导致了问题。&emsp;&emsp;我翻遍了page.ejs相关的样式，却还是没能找到我想要的CSS内容。&emsp;&emsp;最后我在控制台里发现了有用的功能。 &emsp;&emsp;我知道了是这个样式的问题之后，第一反应就写一个同名的样式将其覆盖。&emsp;&emsp;然而事情却弄得很复杂。&emsp;&emsp;覆盖虽然可以，但是却没有办法获取我想要的颜色。&emsp;&emsp;我可以设置为透明或者其他颜色，但是我就是不可以变为其他颜色。&emsp;&emsp;在这里做了很多测试，甚至去寻找background-color有没有none属性（结果是没有的）&emsp;&emsp;最后也没能在这里找到突破口。&emsp;&emsp;后来我看到控制台的颜色那里发现，我想要亮显的CSS样式被复写了。 &emsp;&emsp;这时候我才恍然大悟，原来是CSS优先级的问题。&emsp;&emsp;但是:hover属于伪元素，我没有办法加入style属性来实现优先级的变化。&emsp;&emsp;那该怎么打破这个优先级呢？&emsp;&emsp;我又研究了好久，终于在网上找打了!important的写法。&emsp;&emsp;加入这个标记，就可以打破优先级，执行当前的CSS样式。 &emsp;&emsp;这样我总算是做好了这个效果，后面的标签效果就没什么难度了。&emsp;&emsp;另外自己又心血来潮地做了个闪烁动态，也没啥的。 123456789101112131415161718192021222324252627282930let vary = 0; let shinningCheck = true; let shinning = setInterval(function()&#123; vary++; $('.tags').children().each(function(index)&#123; $(this).removeClass(); $(this).addClass("tagColor"+((vary+index)%5+1)); &#125;) &#125;,80) $('#stopShinning').click(function()&#123; if(shinningCheck)&#123; shinningCheck = false; $('#stopShinning').text('开始闪烁'); shinning = window.clearInterval(shinning); &#125;else&#123; shinningCheck = true; $('#stopShinning').text('停止闪烁'); shinning = setInterval(function()&#123; vary++; $('.tags').children().each(function(index)&#123; $(this).removeClass(); $(this).addClass("tagColor"+((vary+index)%5+1)); &#125;) &#125;,80) &#125; &#125;) 总结 &emsp;&emsp;Hexo博客优化做到现在大概做了差不多1个星期了，基本我想要的效果全部优化完成了。满满的满足感，付出还是有收获的，虽然绕了很多弯路。&emsp;&emsp;另外这个系列也算是完结了，以后有新的想法，再过来补充。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MEL 随机大小插件]]></title>
    <url>%2Fposts%2F1905.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;之前有篇博文实现了超低精度树的效果，那个时候就提到过可以用这种方法可以制作细节好像，面数超低的森林。&emsp;&emsp;但是项目需要根据地形安排树木，那么就只能用人工去排面片的方法。&emsp;&emsp;目前面片是弄好了，需要在Maya中弄出每个面片都有些许大小变化的效果。&emsp;&emsp;这种操作人工操作会累死的，所以本插件就诞生了。 实现 &emsp;&emsp;原理其实非常简单，获取当前的物体放到字符串数组中，对字符串循环操作，将随机数加入到scale中。 &emsp;&emsp;废话不多，直接上代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495if (`window -ex ZSD_randScaleWin` != true)&#123;//判断当前窗口是否打开了 //创建插件窗口 window -w 310 -h 100 -t ("批量随机缩放 - 插件") -in "randomScale" -s true -tb true ZSD_randScaleWin; // 宽度 高度 title标题 icon-name 图标名称 sizeble改变大小 titlebar 标题栏 窗口的调用名 //创建一个柱状布局 columnLayout cr_mainCol; //创建分割线 separator -style "in" -w 300 -h 8; // 样式 "in"为内凹效果 宽度 高度 //创建栏状布局 rowColumnLayout -nc 2 -cw 1 70 -cw 2 230; // numberOfColumns 两个子对象 column宽度 第一个70 第二个230 //创建面板上的Text文字栏 text -l "缩放值: " -al "right"; // lable 标签文字 align 对齐方向 //创建浮点数输入区 floatField -v 0 -w 60 -min 0 scaleVal; // 默认值为0 宽度 最小值 调用数值的query名 //设置上一个层级为父对象 setParent ".."; rowColumnLayout -nc 2 -cw 1 70 -cw 2 230; text -l "偏移振幅: " -al "right"; floatField -v 1 -w 60 offsetAmp; setParent ".."; separator -style "none" -w 300 -h 4; //创建随机 button -l "随机大小" -al "center" -w 300 -c ("randScale();") -ann "" butSearchReplace; // label 按钮名称 align 对齐方式 宽度 command 执行的命令 annotation 提示 query名 //展示窗口 showWindow ZSD_randScaleWin;&#125;else//已经打开了就重新将最小化的窗口打开。&#123; showWindow ZSD_randScaleWin;&#125;//按钮执行的函数global proc randScale()&#123; //获取输入的scale数值 float $scaleVal = `floatField -q -v scaleVal`; //获取输入的缩放振幅 float $offsetAmp = `floatField -q -v offsetAmp`; //执行判断的布尔变量 int $checkScale = 0; if($scaleVal == 0)&#123;//判断缩放值是否为零 $checkScale = 1;//布尔设置为true &#125; //获取当前的选择的物体 存入字符串数组当中 string $sel[] = `ls -sl `; //获取数组的长度 int $len = size($sel); int $num; float $rand; if($checkScale == 0)&#123;//如果缩放值传入的值不为0 for($num = 0; $num &lt; $len; $num++)&#123;//循环遍历选中的对象 $rand =(`rand 0 1`*2 - 1)*$offsetAmp;//获取-1到1的随机数，并且用缩放振幅来控制缩放的大小 //设置缩放值并进行偏移 setAttr ($sel[$num]+".scaleX") ($scaleVal+$rand); setAttr ($sel[$num]+".scaleY") ($scaleVal+$rand); setAttr ($sel[$num]+".scaleZ") ($scaleVal+$rand); &#125; &#125;else&#123;//如果缩放值为0 for($num = 0; $num &lt; $len; $num++)&#123; $rand = ((`rand 0 1`)*2 - 1 )*$offsetAmp; //获取物体本身的缩放值 float $scaleX = `getAttr ($sel[$num]+".scaleX")`; float $scaleY = `getAttr ($sel[$num]+".scaleY")`; float $scaleZ = `getAttr ($sel[$num]+".scaleZ")`; setAttr ($sel[$num]+".scaleX") ($scaleX+$rand); setAttr ($sel[$num]+".scaleY") ($scaleY+$rand); setAttr ($sel[$num]+".scaleZ") ($scaleZ+$rand); &#125; &#125;&#125; 总结 &emsp;&emsp;在写随机数的时候本来用rand来实现随机效果的，但是不知道为什么物体太多的话随机效果就不明显了，又专研了很久才得出这个结果。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
        <tag>ࠀMaya/MEL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路(六) - 本地搜索优化]]></title>
    <url>%2Fposts%2F50883.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;博客优化之路 计划 博客资源搬家瘦身 图片添加水印 fancybox 图片跳转修正 代码块显示优化 本地搜索优化 归档和分类优化 参考NEXT主题的本地搜索 &emsp;&emsp;NEXT主题的自动搜索功能不仅可以搜索出文章的标题，也可以将文章的相关信息搜索出来,比起当前的主题真是好太多了。 &emsp;&emsp;另外当前使用的主题也有很大的问题，手机界面没有搜索功能，也是我不能忍，当初选择这个主题一是因为好看。&emsp;&emsp;其次是手机端有目录，而hexo是没有的，但是目前才发现，根本就没有能让我称心如意的主题，所以我只好自己来弄了。 NEXT主题本地搜索的探索 &emsp;&emsp;既然NEXT已经有如此优秀的本地搜索，那我就不需要去找插件，更不需要自己去思考怎么弄了，自己复制NEXT的代码就好了。&emsp;&emsp;在NEXT主题下的搜索按钮可以看到相关的class信息，通过class信息可以找到先关的js代码。&emsp;&emsp;在这里我就发现了关键的localsearch.swig文件，里面完全都是关于NEXT主题的localsearch相关的js代码。&emsp;&emsp;我将所有的代码都复制到black-blue主题的left-con.ejs当中。 &emsp;&emsp;上面的截图可以看到，我遇到第一个问题就是路径问题，NEXT原本的路径处理是好的，但是当前主题并不适用，&emsp;&emsp;config.search.path这些相关的环境变量全部都无法正确调用，无奈，我只好将路径写死。 &emsp;&emsp;而在_partials文件夹中你也可以找到另一个localsearch.swig文件，里面保存的正是搜索栏相关的div信息。&emsp;&emsp;同样将它复制到left-con.ejs当中。 &emsp;&emsp;完成上述步骤之后，hexo s来打开网站查看效果，你会发现搜索框在左下角呈现出奇怪的效果。 &emsp;&emsp;很明显这个问题是因为缺少相应的CSS样式。&emsp;&emsp;寻找一番之后，你会在localsearch.styl文件中找到相关的CSS样式。&emsp;&emsp;当然这个样式还需要调整成CSS，也不算太复杂。 &emsp;&emsp;当一切样式都调整好之后，打开网站就没有了奇怪的搜索面板了。&emsp;&emsp;现在的问题是怎么触发搜索面板了，那么我就需要一个按钮。&emsp;&emsp;于是我决定将按钮做到图标下拉菜单中。 &emsp;&emsp;在li列表中加入多个按钮就可以完成我想要的效果。 &emsp;&emsp;但是直接加入会导致下面的面板错误移动，那样友情链接的区域就没有办法去到正确的地方。&emsp;&emsp;因此我需要去找到处理这方面的js。&emsp;&emsp;最后在pc.js里面找到相应的代码。 &emsp;&emsp;这样每一个按钮多有相应的事件，也添加上我之前就想要的归档和分类页面。&emsp;&emsp;然而点击搜索按钮也没有任何反应，js也有相关的报错，但是看不懂。 &emsp;&emsp;这里找了好久都没有找到问题的根源，一度让我迷茫。&emsp;&emsp;最后只能沿着程序的逻辑找出出错的地方。&emsp;&emsp;在这个过程中，还真就发现了问题。 &emsp;&emsp;原来这里绑定的位置是NEXT相关的class，改成适合我这边的class container就好了。&emsp;&emsp;这次是终于可以了，谢天谢地。 &emsp;&emsp;这个配色好像和当前的主题不匹配。&emsp;&emsp;没事，手动修改相应的CSS就好了。 &emsp;&emsp;现在好像没有问题了，但是点击搜索，却发现根本搜索不出东西。&emsp;&emsp;我想到可能是search.json文件出问题了，所以我按照NEXT的主题xml生成，重新配置了设置文档，并且修改了相应的链接信息。这样就可以了。 &emsp;&emsp;另外还需要在主题设置中添加NEXT主题localsearch相关的设置，但是获取变量的时候却不太成功，我只能将一些代码写死。&emsp;&emsp;比如说输入之后自动搜索功能，主题相关的配置永远回馈false信息。 &emsp;&emsp;到了这里，电脑端的本地搜索已经移植成功。后面就是移植手机端了。 NEXT主题本地搜索手机端移植 &emsp;&emsp;本以为电脑端都成功了，手机端应该是毫无压力的，然而我却大错特错了。 &emsp;&emsp;首先需要将下来菜单的内容移植到手机当中。&emsp;&emsp;经过搜索，我发现手机侧边栏的生成是在mobile.js当中完成的。 &emsp;&emsp;添加了归档和分类的标签之后，剩下的就是实现搜索功能。&emsp;&emsp;理论上并没有难度，只要做好class给代码识别就可以了。&emsp;&emsp;然而这里却不行，即便给了对应的class，却怎么也触发不了事件。&emsp;&emsp;我在点击事件中加入console.log也没有在控制台中回馈我想要的信息。 &emsp;&emsp;这里我折腾了好久才弄明白，原来mobile.js的DOM事件需要额外绑定的 &emsp;&emsp;这样就弄好了手机端的搜索界面了。 额外的优化 - 侧边栏 &emsp;&emsp;手机端的搜索虽然做好了，但是制作过程中发现了一些小BUG。我简直是不能忍。 &emsp;&emsp;首先是侧边栏不能拖拽，如果标签太多的话就看不到了。&emsp;&emsp;为此在样式上面加入overflow就好了。&emsp;&emsp;但是滚动条又变得太长了(:з」∠) &emsp;&emsp;修复这个问题也花了好长时间去研究，首先考虑的是高度问题。&emsp;&emsp;但是到底是哪个高度出了问题还需要时间去研究。&emsp;&emsp;最后我写了一堆样式进行测试之后，发现高度值竟然是固定的。&emsp;&emsp;重新翻了一遍代码之后发现js强行加入当前body的高度。 &emsp;&emsp;注释掉这一行之后，重新调整CSS样式，就可以做到完美滚动了。&emsp;&emsp;然而就遇到了另一个问题，侧边栏关不掉了。&emsp;&emsp;经过研究才发现，侧边栏有两个div，一个是viewer-box-l 侧边栏本身，一个viewer-box-r 用于点击关闭侧边栏的。&emsp;&emsp;上面的操作取消掉了右边的高度，导致无法触发关闭页面。&emsp;&emsp;那么加入height:100vh样式保持屏幕的高度就可以解决问题。（为此在网上找了很多CSS相关的资料） 额外的优化 - TAG开关 &emsp;&emsp;另外在归档页面中的TAG开关也出现了BUG。 &emsp;&emsp;TAG开关一直跟随着屏幕移动。而且这个位置非常不合理。&emsp;&emsp;经过一番查找，在hide-labels.ejs找到相关的代码。&emsp;&emsp;我想让TAG开关和侧边栏的按钮一样保持一致。 &emsp;&emsp;另外这里涉及到比较复杂的代码操作，我不想要js进行复写，而是直接在CSS完成操作。&emsp;&emsp;经过我一晚上的测试，才最终写出了完美的效果。 额外的优化 - Clipboard.js &emsp;&emsp;其实这个问题是前些天解决的。 &emsp;&emsp;这个按钮就是通过clipboard.js实现链接复制功能。&emsp;&emsp;这个是SPFK主题里面带的效果，然而连官方的复制都是翻车的，因为不用最新版的clipboard.js就需要按很多次才能出发复制。（这都是后话了）&emsp;&emsp;首先找到相关的代码，可以在nav.ejs可以找到相关内容。 &emsp;&emsp;这里需要注意的是，不能直接引用clipboard.js，这会和main.js的require产生冲突（clipboard并没有require） &emsp;&emsp;这里需要在mian.js中加入相关的require信息。 总结 &emsp;&emsp;这些天一直在弄博客的样式等等，自己的付出还是有很多收获的，这次对Hexo这个运作原理有了全新的认识。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（五）- 代码块优化]]></title>
    <url>%2Fposts%2F51575.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;我的博客主题采用的是black-blue，从SPFK和yalia主题摇身一变过来的，整体风格偏黑，我比较喜欢，最重要的是，手机版有目录页面！！！&emsp;&emsp;然而最近在使用的过程中，发现代码块的效果有很多问题 代码块的标题栏长度，随着滚动会不及代码的长度 代码块标题栏没有当前语言的显示 代码块不支持VEX等大部分的CG语言 代码块滚动问题 &emsp;&emsp;滚动条的问题原本不难解决，只要让它窗口监听resize事件，当窗口发生变化的时候，让代码的长度匹配标题的长度。&emsp;&emsp;然而这里并没有这么简单，最主要的问题是，标题栏居然是个CSS伪元素，正如上面截图看到的，它的element是::before，那么要对其进行DOM操作就变得非常曲折。&emsp;&emsp;后面我上网查了之后，得出结论就是要动态加入style标签修改::before的样式。&emsp;&emsp;虽然思路是对的，但是代码块的::before都是源于同一个CSS，直接修改就会修改全部的代码块，最后只能让一个代码块适配。&emsp;&emsp;因此我要为一个代码块另外创建一个有区分的CSS样式表。&emsp;&emsp;这个过程我一度怀疑这样的可行性，如此麻烦还不如用div进行操作。&emsp;&emsp;后来还是让我找到了解决方案，将下面的代码放到article.ejs里面（这个文件在主题文件夹的layout里面）&emsp;&emsp;这样在生成文章html的时候，代码就会嵌套到文章当中。 123456789101112131415161718192021222324//添加到article.ejs中function codeAutoResize()&#123; if($(".highlight").length &gt; &amp;emsp;&amp;emsp;0) &#123;//判断代码块是否存在 $(".highlight").each(function(index)&#123;//遍历代码块 let parentWidth = $(this).css('width');//获取代码块的宽度 let childWidth = $(this).children('table').css('width');//获取代码的宽度 if(parseInt(parentWidth) &lt; parseInt(childWidth) )&#123;//转成整数比较宽度大小 $(this).children('style').remove();//清理style标签（不会让style标签无限增加） $(this).addClass("resize"+ index);//添加class名 用于区分不同的代码块 $(this).append("&lt;style&gt;.highlight.resize"+ index +"::before&#123;width:" + childWidth + "&#125;&lt;/style&gt;");//根据class名来修改宽度 &#125;else&#123; $(this).children('style').remove(); $(this).addClass("resize"+ index); $(this).append("&lt;style&gt;.highlight.resize"+ index +"::before&#123;width:" + parentWidth + "&#125;&lt;/style&gt;"); &#125; &#125;); &#125; &#125;codeAutoResize();//初始化$(window).resize(function()&#123; codeAutoResize();//改变尺寸的时候执行&#125;); 代码块标题栏没有当前语言的显示 &emsp;&emsp;在上面的截图可以看到伪元素的content上是有attr(data-lang)属性。&emsp;&emsp;网上查了才知道原来这个可以获取html的自定义属性嵌入到内容中，显然这里的html就没有这个属性。&emsp;&emsp;但是代码块是在哪里生成的，又应该在哪里嵌入这个html属性呢？&emsp;&emsp;经过我一番摸索，在article.ejs里面发现了猫腻， &emsp;&emsp;上面的div标签是通过浏览器的控制台发现的，但是文章内容这么多，为何ejs的模板却这么短。&emsp;&emsp;原来所有的内容都在post.content里面了。&emsp;&emsp;也就是说hexo内部完成了markdown的解析，作为hexo的使用者只需要关心网站的架构即可。&emsp;&emsp;但是这样就导致我没有办法给相应的代码块添加对应语言的标签了。(或许可以通过jquery添加对应的data-lang属性，但是获取到对的应语言似乎挺麻烦的) &emsp;&emsp;鉴于此，我就在hexo里面寻找答案，况且后面解决代码高亮的问题也许好在hexo的内核里面寻求答案。&emsp;&emsp;经过很长时间的摸索，我终于找到了关键代码。在node_module中的hexo\lib\plugins\filter\before_post_render文件其中有backtick_code_block.js的js文件。&emsp;&emsp;这个文件就是hexo解析markdown代码块的核心代码，通过在这里加入console.log之后可以在hexo生成文章链接的时候看到信息反馈在git中， &emsp;&emsp;这里通过正则表达式将代码块识别出来，并且分别截获代码块后面的内容，进行不同的操作。而关键的代码语言存储到options.lang中,最后options传入到highlight函数中。&emsp;&emsp;在node_module的hexo-util\lib中可以找到highlight.js，这里就可以找到html代码块的生成代码了。 &emsp;&emsp;在这里加入data-lang就可以在生成代码块的时候将语言的信息嵌套到html供::before去调用了。 加入自定义语言高亮支持 &emsp;&emsp;通过上面的一通操作可以知道，hexo解析markdown代码块是通过highlight.js来实现的。上面hexo的highlight.js是hexo内部用来调用外部的highlight.js用的，在node_module文件夹中就有highlight.js，专门用来高亮代码的脚本。&emsp;&emsp;奈何特效相关的编程语言比较小众，它居然还支持MEL，我都惊了。然而VEX还是个遗憾,另外之前我写了正则表达式相关的博文，正则表达式也没有高亮支持。 &emsp;&emsp;既然没有那就做一个呗，反正它内部有那么多门语言作为参考我就不信自己搞不定，所以我先从简单的正则表达式入手。&emsp;&emsp;不过加入之前要先在hexo弄好相关的代码，否则就会跳过脚本的。&emsp;&emsp;首先是node_modules\highlight.js\lib 的 index.js，需要在里面添加新的注册语言。&emsp;&emsp;另外node_modules\hexo-util 的 highlight_alias.json可以添加语言的模糊识别。&emsp;&emsp;后面就是如何对相应的内容进行高亮显示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344module.exports = function(hljs) &#123; var COMMA = &#123; className: 'keyword',//识别成功之后加入的class名 begin: '[,]'//正则表达式识别 &#125;; var Key = &#123; className: 'keyword', begin: '[?!$*+.\^|]'//识别正则表达式的典型符号 &#125;; var BUILD_IN = &#123; className: 'class', begin: /\\/ , end: '[dfnrsStvbBw]'//识别正则表达式\n \w 等标志 &#125;; var PARENTHESIS = &#123; className: 'value', begin: /[()]/, &#125;; return &#123; case_insensitive: true, contains: [ &#123; className: 'strings', begin: /\&#123;/, end: /\&#125;/, relevance: 0, contains: [ hljs.C_NUMBER_MODE, COMMA, ] &#125;, hljs.C_LINE_COMMENT_MODE,//C语言单行注释 hljs.C_BLOCK_COMMENT_MODE,//C语言多行注释 hljs.C_NUMBER_MODE,//识别数字 Key, BUILD_IN, PARENTHESIS ] &#125;;&#125;; &emsp;&emsp;从上面的代码可以知道，highlight.js是通过正则表达式找到相应的代码加入class名，而着色是需要自己写css给相应的代码进行着色。 123(&lt;script&gt;(.*\n)+&lt;&#x2F;.*?&gt;)|(&lt;.*?&gt;)(?&#x3D;(.*\n)+&#96;&#96;&#96;[a-zA-Z])|(&lt;.*?&gt;)(?!(.*\n)+&#96;&#96;&#96;) &emsp;&emsp;貌似正则表达式还是比较简单的，要处理Vex这种复杂的语言要如何进行正则表达式判断呢？&emsp;&emsp;其实没有那么复杂，因为VScode和sublime都支持VEX高亮，截取里面的关键代码就好了。&emsp;&emsp;VEX高亮脚本-链接 &emsp;&emsp;当然别忘了加入CSS样式处理高亮效果 12345678910pre .vex_built_in&#123;color:#66cccc&#125;pre .vex_type&#123;color:#ed77ed&#125;pre .vex_operator&#123;color:#ed77ed&#125;pre .vex_string&#123;color:#63c563&#125;/* 这个部分Houdini没有高亮 有需要的话可以自己设置 *//* pre .vex_context&#123;color:#ed77ed&#125; *//* pre .vex_variable&#123;color:#eecd10&#125; *//* pre .vex_function&#123;color:#66d9ef&#125; *//* pre .vex_title&#123;color:#66d9ef&#125; *//* pre .vex_number&#123;color:#7163d7&#125; */ &emsp;&emsp;Vex代码的呈现效果： 123456for (int i &#x3D; 0; i &lt; @numprim; i++)&#123; float test &#x3D; 1; string group_name &#x3D; &quot;curve&quot; + itoa(i+1); setprimgroup(0, group_name, i, true);&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 用最小面数生成立体的物体]]></title>
    <url>%2Fposts%2F50589.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;最近制作three.js的项目，场景可能需要大量的花草树木进行装饰，但是如果采用模型去修饰的话，工作量很大，而且加载负荷也很重，如何才能在性能和效果上面做好平衡，这就是核心问题。 Maya给我的灵感 &emsp;&emsp;显然用实体的模型是不现实的，一棵还算客观的树至少也要有上千个面，然而当这个面数乘以几百之后，无谓的负荷将会让场景卡到无法动弹。 &emsp;&emsp;因此要用面片贴图去实现树的效果，而Maya自带的Paint Effect效果就提供了很好的参考。 &emsp;&emsp;用paint effect的笔刷在视图中画一笔，就可以生成一堆面片。 &emsp;&emsp;需要注意的是paint effect并不是多边形，它不能直接导出，只能用maya 软件渲染器去渲染，因此需要将它转成多边形。&emsp;&emsp;转成多边形后按6键可以在视图中看到树木面片。 &emsp;&emsp;奇迹般的效果出来了，当你转动视图的时候，面片会自动朝向摄像机。&emsp;&emsp;遗憾的是，当你删除了转化历史之后，所有的效果就消失了，所以当然这种效果也是不可能通过模型导出来的。 &emsp;&emsp;重点是这里提供了操作思路。只要面片是朝向摄像机的，就可以实现不错的伪3D效果。另外也可以在这里获取Maya的树木贴图，省得网上找了。 Three.js的sprite实现 &emsp;&emsp;如何在Three.js实现图片永远朝向摄像机呢，我首先想到了sprite，以前做Maya的粒子效果的时候有接触过这种形式的贴图效果，印象深刻。 &emsp;&emsp;首先的了解sprite在Three.js怎么用 - 链接 &emsp;&emsp;看过之后其实很简单，链接图片，添加材质，即可生成。和生成方块的流程差不多。 1234567891011121314//核心代码var treeMap = textureLoader.load("oakTree.png");//加载树的贴图 var geometry = new THREE.PlaneBufferGeometry( 50, 50, 32 );var material = new THREE.MeshLambertMaterial( &#123;color: 0x333333, side: THREE.DoubleSide&#125; );var plane = new THREE.Mesh( geometry, material );plane.rotation.x = Math.PI/2;//旋转地面scene.add( plane );//添加地面spriteMaterial = new THREE.SpriteMaterial( &#123; side:THREE.DoubleSide,map:treeMap,transparent:true,alphaTest:0.20 &#125; ); var sprite = new THREE.Sprite( spriteMaterial );sprite.scale.set(10,10,1);sprite.position.set(0,5,0);scene.add(sprite);//添加树sprite 这个效果还是有不少遗憾 不够立体。 和Maya的不一样，Maya的效果只在水平方向指向摄像机，sprite是无时无刻都指向摄像机，看起来就很奇怪。 定位麻烦 进阶解决方案 &emsp;&emsp;既然如此，那就考虑如何实现Maya的效果吧。所以后面我摈弃了sprite的使用，还是改为使用多边形面片。 &emsp;&emsp;多边形面片的好处是可以实现模型定位。 &emsp;&emsp;后面我尝试将Maya的模型面片导出，看看实现的效果。 &emsp;&emsp;我在代码上实现了效果，但是透明上出了大问题。 透明遮挡问题的解决方案 &emsp;&emsp;在Three.js的编辑器可以更加透彻方便地看到这里的问题。 &emsp;&emsp;这里并不是完全看不到透明背后的部分，只是渲染顺序不同导致透明的部分渲染后看不到背后的物体，这种情况下有些透明的面片先渲染，背后的物体还没有出来，透明部分后面的模型就看不到了。(如下图) &emsp;&emsp;这种问题怎么解决呢?!Three.js的新版编辑器提供了render order选项，通过调节渲染顺序可以实现正确的渲染效果 &emsp;&emsp;这样子的话岂不是每个物体都要去手动调整，即便是用代码智能实现也要去研究物体到摄像机的距离，进而分配render order，这个工作量得干死人的。&emsp;&emsp;当时真的慌得一匹。 &emsp;&emsp;我记得之前在弄房产信息Demo的时候也有遇到过类似的问题，当时网上找到的信息是去调整depthwrite的材质属性。&emsp;&emsp;于是我赶紧在编辑器里面测试，但是开了之后效果惊为天人，透明完全错乱了。 &emsp;&emsp;我算是想尽办法了，不知道该怎么解决，回到编辑器看一下吧，在材质属性上看到alphaTest属性，想着也和透明有关系，就试着调了一下。 &emsp;&emsp;没想到问题就解决了，加上alphaTest的数值之后，就不用考虑渲染顺序的问题了。 123456789101112131415161718192021//核心代码 //加载模型 var path = 'model/obj/treeSprite.obj'; var mtl = 'model/obj/treeSprite.mtl'; var model_source_1= new app.getModel(path,mtl); scene.add(model_source_1); var treeMap = textureLoader.load("oakTree.png");//加载树的贴图 //在manager中模型加载完成之后执行，如果直接执行的话,模型还没加载，会找不到模型的子对象 for(let num in model_source_1.children[0].children)&#123; //将模型的材质替换 开启双面、贴图贴上树、开启透明 model_source_1.children[0].children[num].material = new THREE.MeshBasicMaterial(&#123;side:THREE.DoubleSide,map:treeMap,transparent:true&#125;); //关闭depthWrite 会让透明物体互相穿透 效果很魔性 // model_source_1.children[0].children[num].material.depthWrite = false; //开启alphaTest解决透明遮挡问题 model_source_1.children[0].children[num].material.alphaTest = 0.2; &#125; 立体效果制作 &emsp;&emsp;上面的实现效果，模型始终还是个面片呀，怎么才能实现立体的效果呢？&emsp;&emsp;先复制几个面片看看效果吧。&emsp;&emsp;这次就尝试用Three.js的面片来实现，不用考虑模型导入那么麻烦。 &emsp;&emsp;这个效果并不理想，一看就知道是几个面片组成的树(:з」∠)&emsp;&emsp;这时我想到了depthWrite的魔性效果，可能穿插的透明感觉正好可以混淆这里的立体效果 &emsp;&emsp;的确开了之后，效果确实不错，只是能感觉到有一个面片在旋转， &emsp;&emsp;现在要考虑怎么实现在镜头移动的时候，树可以保持望向镜头，这样看起来就不会那么奇怪。&emsp;&emsp;怎么实现类似于Maya的面片效果呢？&emsp;&emsp;网上搜了一下还真找到了方案 Three.js plane facing away from camera aligned with viewport TextGeometry to always face user? &emsp;&emsp;两个链接的核心处理就是 mesh.lookAt( camera.position );&emsp;&emsp;但是我弄上去之后的效果就和sprite实现的效果是一样的了。 &emsp;&emsp;为了解决这个问题，我又去查了lookAt函数的用法。 &emsp;&emsp;给lookat的Y轴方向传入0参数就好了. 12345678910111213141516171819202122232425262728293031323334353637//核心代码 var geometry = new THREE.PlaneBufferGeometry( 50, 50, 1 ); var material = new THREE.MeshLambertMaterial( &#123;color: 0x333333, side: THREE.DoubleSide&#125; ); var plane = new THREE.Mesh( geometry, material ); plane.rotation.x = Math.PI/2; scene.add( plane );//生成地板 var geometry = new THREE.PlaneBufferGeometry( 10, 10, 1 ); var material = new THREE.MeshLambertMaterial(&#123;side:THREE.DoubleSide,map:treeMap,transparent:true,alphaTest:0.2&#125;); material.depthWrite = false; let treeOrigin = new THREE.Mesh( geometry, material ); //生成原始的面片模型 //批量复制面片 let amount =6; for(let i = 0;i&lt;amount;i++)&#123; let tree = treeOrigin.clone(); tree.rotation.y = Math.PI/amount*i;//根据复制的数量自动旋转 //弧度转角度 Math.PI 为 180 度 //绕面片中心旋转，只需要转半圈 180 度 treeGrp.add(tree); &#125; treeGrp.position.y = 5; scene.add( treeGrp ); function update()&#123;//这里只是演示，update函数当然也包括其他的代码 treeGrp.lookAt( camera.position.x,0,camera.position.z ); &#125; 顶部贴图 &emsp;&emsp;现在效果已经算是比较完美了，但是移动到顶部的时候，还是会暴露物体是由面片构成的。&emsp;&emsp;如此就需要有一张树顶部的贴图了，同时又要求颜色基本保持一致，那就只能在原先的树贴图上用图章进行处理了。&emsp;&emsp;弄好之后将水平贴到树的中心。&emsp;&emsp;并且给它加入朝向摄像机的效果。 最终效果 &emsp;&emsp;将顶部贴图的透明度调节为0.5，这样不会显得违和，效果非常棒。 总结&emsp;&emsp;这是我搭建出来的面数压到最低的生成效果，一棵树用了7个面片，总计14个三角形，另外还用了两张贴图。&emsp;&emsp;用种方法搭建树林都毫无压力，缺点就是不能支持阴影，如果需要点击处理的话也会很麻烦而已。]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（四）- fancybox 图片跳转问题]]></title>
    <url>%2Fposts%2F39119.html</url>
    <content type="text"><![CDATA[前言 &emsp;&emsp;前段时间总结了博客使用图床解决了存储图片的问题，实现了博客的全面瘦身。&emsp;&emsp;然而在使用的过程中发现，fancybox的图片浏览功能与图传链接产生了冲突，出现了意想不到的BUG。&emsp;&emsp;主要原因是fancybox是使用a标签的href属性进行跳转的，之前链接图片都是本地链接，href并没有跳转新的网页，然而用了图床的链接之后，a标签就直接跳转到了图片地址去了。 解决尝试 &emsp;&emsp;fancybox的使用方法并没有研究过，我首先想到是的将href属性名称改变,比如改为hrefs。不过首先得找到a标签的生成位置。&emsp;&emsp;我通过VScode搜索black-blue 主题的fancy相关的脚本，经过筛选，找到main.js的压缩中有a标签的生成代码。 &emsp;&emsp;将href属性修改为无关的hrefs属性之后，虽然可以实现弹窗，但是每次弹窗之后图片就被吞了。 解决方案 &emsp;&emsp;后面上网找到了解决方案&emsp;&emsp;第一个解答有提到可以将href修改为data-fancybox-href进行调用，我完全按照回答的方法进行修改。 &emsp;&emsp;经过测试之后，我发现根源是 type: ‘iframe’ 这段代码上，但是去掉之后又点击图片就没有反应了。&emsp;&emsp;后面我上官网查了type可以填写的参数，填上’image’之后，完美解决了问题。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构大作业回顾]]></title>
    <url>%2Fposts%2F59323.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;时隔两个月，也没想到自己居然会回来挖坟，不过这次导航系统确实有种魔力，让我着了魔地去思索和编程。 &emsp;&emsp;前后总共花了2周时间，写了4000行的代码才实现了整个系统。回想起来感觉自己好像在做毕设一样^_^ &emsp;&emsp;作品：下载地址 数据结构&emsp;&emsp;对我来说，学习数据结构是很痛苦的，我数学并不是很好，学习这个也十分耗费心神，不过正因为难所以数据结构和算法才是编程的重中之重。 数据结构这门课到底是学了点东西的 时间复杂度 （用求和公式和用for循环累加的执行效率是几何级的） 数据结构存储方式 （不同的方式对应了不同的遍历递归方案，在不同的操作环境下各有优劣） 排序与哈希值 （排序对于存储的作用以及排序的方法) 数据结构大作业的要求&emsp;&emsp;老师罗列了很多要求。 总结起来有如下几点 信息查询功能 导航功能 后台数据管理功能 模块上需要包含以下几点 用户界面 输入模块（读相关的数据文件） 输出模块（更新后的数据保存到文件） 查询功能模块：如查询目标的相关信息 线路规划模块 后台管理功能：如添加、修改或者删除道路、区间信息等 测试用例要求 通道路不少于12条，高速道路不少于6条。 普通道路每个区间除了端点目标和交叉口目标 需求文档:下载 SFML框架&emsp;&emsp;为了更好地实现图形化界面，我借助了C++的SFML库来实现效果。 &emsp;&emsp;SFML全称是Simple and Fast Multimedia Library，是基于OpenGL实现多媒体跨平台、多语言支持的C++库。 &emsp;&emsp;SFML 官网：https://www.sfml-dev.org/ &emsp;&emsp;SFML在国外是一个比较流行的图形化界面游戏开发库，通过对OpenGL的封装实现更加简便的图形、音频操作，大大简化了代码的复杂程度。 &emsp;&emsp;接触SFML完全是因为Lynda.com上面有一套C++游戏开发的教程，我想着图形化界面最契合的就是用游戏框架去开发了，所以果断选择了SFML框架。 数据结构设计逻辑结构定义&emsp;&emsp;导航系统使用了数据结构图的功能，通过迪杰斯特拉算法，实现寻路的功能。通过结构体定义图的基本结构 &emsp;&emsp;我自己用C++写了Path类和Circle类从而方便我更好地使用SFML库通过读取数据库将信息存放到了图的结构体变量当中 ArcCell代表道路 VertexTyoe 代表景点 MGraph 代表图的基本单元 &emsp;&emsp;Circle类则包含了 景点的序号、类型、名称、评价、花费 等public变量 &emsp;&emsp;另外还有很多关于SFML反馈的函数 &emsp;&emsp;Path 类则包含了 道路的类型、名称、起点序号、终点序号、序号、距离、限制速度 等public变量。 &emsp;&emsp;当然这里也有很多关于SFML反馈的函数 &emsp;&emsp;通过迪杰斯特拉算法实现最短路径的寻找 &emsp;&emsp;设置相应的动态数组 初始化变量的数值 &emsp;&emsp;通过三个for循环实现迪杰斯特拉算法 存储结构定义 &emsp;&emsp;通过C++的流操作读取txt数据将数据存入二维数组当中 功能模块实现IO模块用户界面&emsp;&emsp;通过不同的用户名和密码实现 普通用户 和 系统管理员 的级别区分 输入模块&emsp;&emsp;输入用户名和密码来登录系统&emsp;&emsp;用户名输入支持中文输入法&emsp;&emsp;密码仅支持英文数字和特殊符号 &emsp;&emsp;系统会读取用户数据的数据库进行匹配验证用户输入的信息是否正确&emsp;&emsp;输入正确和错误均有相应的系统提示 查询功能&emsp;&emsp;通过图形化界面，用户可以直接通过点击相应的图形反馈查询到相关的信息 系统设置&emsp;&emsp;在系统设置当中实现音量控制、画面全屏、寻路动画、寻路方式等功能的实现 后台管理功能模块后台管理功能&emsp;&emsp;通过图形化界面对相应的景点和道路进行信息修改 &emsp;&emsp;按编辑可以实现信息的修改 &emsp;&emsp;点击编辑之后会出现相应的输入框&emsp;&emsp;这样就可以对输入框进行修改 &emsp;&emsp;点击确定会显示修改成功&emsp;&emsp;并且将修改的信息储存到数据库当中&emsp;&emsp;同时也再次读取数据库的信息实现画面的信息更新 用户数据后台管理功能&emsp;&emsp;将用户的数据信息保存到数据库中实现对数据库的增删改查 线路规划模块&emsp;&emsp;通过直接绘制实现图形化的数据添加和删除 &emsp;&emsp;这些绘制都会直接保存到数据库中&emsp;&emsp;每次保存都会更新算法信息&emsp;&emsp;保证寻路的准确性 系统测试与结果展示&emsp;&emsp;登录界面 &emsp;&emsp;获取系统管理员界面 &emsp;&emsp;忘记密码 &emsp;&emsp;注册账号 &emsp;&emsp;普通用户界面 &emsp;&emsp;系统管理员界面 &emsp;&emsp;路线分析界面 总结&emsp;&emsp;SFML主要用于基于OpenGL的C++小游戏的开发，在国外的C++圈子里比较流行，但是国内的并未普及。所以国内的资料非常稀缺，我所有的学习基本都是看网上的英文API文档以及借助国外的论坛、网站来解决问题的。 &emsp;&emsp;这前前后后也踩了很多很多的坑，我做完这个系统深刻的感受到SFML其实并不适合进行软件开发，图形化的软件界面有更好的C++库可以实现，而且实现效率要比复杂的游戏开发库高得多，诸如imgui之类的，很多国外软件都是使用它来开发gui的，另外qt也非常流行，国内也有不少的资料。鉴于自己已经把坑开了，所以也要硬着头皮把坑填完。 &emsp;&emsp;当中当然也查询了很多C++的操作，比如变量类型的转换，流操作实现txt文本的存储和读取，这也多亏了国内的CSDN论坛的相助。成功解决了我大量的问题。 &emsp;&emsp;在整个制作过程中最让我印象深刻的就是通过SFML制作输入文本框，SFML并不像qt或者MFC那样有组件控件的开发方式，也没有提供相关的文本框输入封装的类，所以要实现用户名输入等等的文本框操作，我只能自己去写文本框的输入逻辑，然而网上完全没有这方面的资料，搜索到的也是用其他的gui库来简化实现复杂度，最后我只能通过自己的摸索以及解读SFML 的API文档实现了。虽然最后文本框输入不能使用鼠标切换输入位置，不过基础的功能都实现了，我还是挺欣慰的。 &emsp;&emsp;当然开发文本框的时候最蛋疼的莫过于中文输入的问题了，这当中也让我纠结了好了久，中文输入显示乱码，全都是因为中文编码是两个字节的不同于英文的单字节，这需要SFML提供额外的支持，同时又要让C++自带的string库可以与SFML的string库当中实现转换，这个过程也是一点点摸索才弄明白，SFML用的是wstring的宽字节输入方式，这样就支持unicode从而实现更多语言显示的支持，所以又在网上弄了很多资料，国内外的资料都搜罗了一遍才有了眉目。 &emsp;&emsp;最后，当然也是最让我颇有成就感的就是将迪杰斯特拉的算法放到了我的系统当中，实现了寻路的功能，整个寻路的方法基本都是看老师写的ppt的算法实现，因为老师使用了结构体，我也不想作死改成C++的类了。这当中的摸索我个人感觉并没有上面的SFML库那么艰辛，不过实现算法动态演示倒是个技术活，这需要对迪杰斯特拉算法有很深刻的了解，理解它的运行原理才可以做到，之前写了好多遍都遇到了各种各样的bug，比如找到的路径不是最短的，显示的路径有奇奇怪怪的错漏，经过一段时间的思考，才终于将最好完美地效果呈现出来。 &emsp;&emsp;现在蓦然回首，发现自己写了近4千行代码了，其中还不包括一些测试用的代码，感觉自己还是挺用心的把坑填完了，写了两个多星期。其实最初也没想过做到如此复杂，比如说绘制功能，用户数据管理功能，这些都是在制作过程突然产生了制作的想法，然后就孜孜不倦的尝试实现。为了实现这些功能我也不得不去推倒了很多已经写好的代码，不过也算是把一些落后的实现方式摒弃吧。]]></content>
      <categories>
        <category>大学</category>
        <category>我的作品</category>
      </categories>
      <tags>
        <tag>ࠇCpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（三）- 正则表达式 清除markdown中的HTML标签]]></title>
    <url>%2Fposts%2F37850.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;最近整理博客，想要将自己的博文发到其他的博客网站上，如此就遇到了一个问题，如何将md里面嵌套的HTML标签删除。 &emsp;&emsp;因为我的博文都是用Hexo写的，我可以自定义一些按钮来隐藏一些图片，让文章看起来更加简洁。 &emsp;&emsp;但是其他博客网站统统都不支持这种操作，所以我需要想办法用快速的方法将Hexo博文中的HTML标签清除。 &emsp;&emsp;我想到的解决方案就是用正则表达式进行内容替换，这样不需要代码也可以实现批量清理HTML标签。 正则表达式 正则表达式教程 &emsp;&emsp;关于什么是正则表达式，我就不在这里赘述了，需要注意的是正则表达式也分很多种，js比较标新立异，和其他语言不大相同。大多数语言都是相似的。 &emsp;&emsp;我想要实现的是通过Visaul Studio Code里面的搜索替换用正则表达式批量替换文件。 &emsp;&emsp;Visaul Studio Code的替换方式和Visual stuido是相通的。 微软官方的正则表达式的说明 正则表达式效果实现初步实现效果&emsp;&emsp;要匹配HTML标签其实非常简单 1234567&lt;.*?&gt;&#x2F;&#x2F;左匹配尖括号后面内容&#x2F;&#x2F;.*批量匹配&#x2F;&#x2F;?只匹配一次&#x2F;&#x2F;右尖括号结束。&#x2F;&#x2F;&#x2F;&#x2F;这样所有的&lt;&gt;内容都会被选中 &emsp;&emsp;这里遇到的问题是只能单行适配，而且不能多行识别，比如scirpt标签中的多行内容就无法识别选中 参考链接 https://bbs.csdn.net/topics/390231333 https://bbs.csdn.net/topics/390592490 &emsp;&emsp;第一个链接的方法纯属扯淡，而重点在于第二链接中的正则表达式 1234567891011(&lt;td)( )?(\w*&#x3D;&quot;\w*&quot;( )?)&#123;0,9&#125;(&gt;)\r\n.*&lt;cc1:UEditor &#x2F;&#x2F;分析了&#123;0,9&#125;的用法之后&#x2F;&#x2F;我自己测了好几遍终于写出了可用的正则表达式&lt;script&gt;(.*\n)&#123;1,&#125;&lt;&#x2F;.*?&gt;&#x2F;&#x2F;寻找&lt;script&gt;标签，从这个标签之后开始&#x2F;&#x2F;(.*\n)匹配一整行到下一行&#x2F;&#x2F;&#123;1,&#125;重复匹配直到结束为止&#x2F;&#x2F;&lt;&#x2F;.*?&gt;寻找&lt;&#x2F;的位置，并且使第一次识别完成即结束 &emsp;&emsp;好像已经完美识别了所有HTML标签以及要去除的内容了，然而却遇到了很郁闷的问题，如果我的MD要展示HTML的代码，那么这个部分就不能被替换。 &emsp;&emsp;怎么才能跳过MD中嵌套的部分呢？ 进一步的效果实现（错误的思路） 参考链接 https://blog.csdn.net/zhangyu_kenshin/article/details/23377517 &emsp;&emsp;其实这篇文章并没有有用的正则表达式提供给我，不过也算是开拓了我写正则表达式的思路吧。 &emsp;&emsp;后面我是重点看?!和?=的过滤用法，花了很长的时间去想。 123456789101112131415161718192021222324252627282930313233(&lt;.*?&gt;)(?&#x3D;(.*\n)&#123;1,&#125;&#96;&#96;&#96;html)|(&lt;.*?&gt;)(?!(.*\n)&#123;1,&#125;&#96;&#96;&#96;)&#x2F;&#x2F;最开始我重点研究?!的方法，只实现了后半段(&lt;.*?&gt;)(?!(.*\n)&#123;1,&#125;&#96;&#96;&#96;)&#x2F;&#x2F;这样可以实现&#96;&#96;&#96; &#96;&#96;&#96;标记以上的部分全部过滤，只保留以下的部分&#x2F;&#x2F;然而我却想不到怎么实现保留上面部分&#x2F;&#x2F;直到我研究了?&#x3D;&#x2F;&#x2F;这样可以只识别以上的范围，从而过滤&#96;&#96;&#96; &#96;&#96;&#96;标记(&lt;.*?&gt;)(?&#x3D;(.*\n)&#123;1,&#125;&#96;&#96;&#96;html)&#x2F;&#x2F;?&#x3D;可以让前面括号的内容只识别?&#x3D;后面的内容&#x2F;&#x2F;(.*\n)&#123;1,&#125;&#96;&#96;&#96;html 这个就限定了在 &#96;&#96;&#96;html 上面的内容(&lt;.*?&gt;)(?!(.*\n)&#123;1,&#125;&#96;&#96;&#96;)&#x2F;&#x2F;(?!(.*\n)&#123;1,&#125;&#96;&#96;&#96;)?!就是不识别&#96;&#96;&#96;以上的内容给(&lt;.*?&gt;)(?&#x3D;(.*\n)&#123;1,&#125;&#96;&#96;&#96;html)|(&lt;.*?&gt;)(?!(.*\n)&#123;1,&#125;&#96;&#96;&#96;)&#x2F;&#x2F;加入合并识别内容 &emsp;&emsp;最后代码是这样子的 12345(&lt;script&gt;(.*\n)+&lt;&#x2F;.*?&gt;)|(&lt;.*?&gt;)(?&#x3D;(.*\n)+&#96;&#96;&#96;[a-zA-Z])|(&lt;.*?&gt;)(?!(.*\n)+&#96;&#96;&#96;)&#x2F;&#x2F;菜鸟教程里面有提到&#123;1,&#125; 等同于 +（我后面都这样写 比较简洁好看）&#x2F;&#x2F;有BUG &emsp;&emsp;然而经过测试还是有很严重的BUG，只能识别最后一个代码块…… &emsp;&emsp;目前我已经搞到怀疑人生了，猜测可能是VScode不支持这种操作，毕竟它连多行模式都没有。 完美实现&emsp;&emsp;又经过了一天的思考之后，效果终于实现了，真是非常欣慰，不留遗憾了Y(^o^)Y~~~ &emsp;&emsp;最主要是思路没有想好，就一直在死胡同里面转牛角尖。 &emsp;&emsp;今天研究的时候也有一些失败的例子 12345&lt;.*?&gt;|(?&#x3D;(^&#96;&#96;&#96;[a-zA-Z](.*\n)+?^&#96;&#96;&#96;))&#x2F;&#x2F;这样可以只识别第一个代码块前面的HTML标签&#x2F;&#x2F;原理我也不清楚 冏rz &emsp;&emsp;后面我转换了思路，突然就忽然开朗，既然代码块不能修改，那就选中它，替换的时候保留它就得了。 &emsp;&emsp;感觉自己被?!过滤给坑爹了(:з」∠) 12345678910111213141516171819202122(^&#96;&#96;&#96;(.*\n)+?^&#96;&#96;&#96;)|(&lt;script&gt;(.*\n)+?&lt;&#x2F;.*?&gt;)|&lt;.*?&gt;&#x2F;&#x2F;完美实现&#x2F;&#x2F;VScode 替换的时候输入 $1(^&#96;&#96;&#96;(.*\n)+?^&#96;&#96;&#96;)&#x2F;&#x2F;识别代码块部分的内容&#x2F;&#x2F;^&#96;&#96;&#96;表示在首行的&#96;&#96;&#96;（避免错误识别了文章中的&#96;&#96;&#96;）&#x2F;&#x2F;(.*\n)+? 逐行获取内容&#x2F;&#x2F;最外面的大括号用于生成$1（$1、$2的序号是由括号的顺序生成）(&lt;script&gt;(.*\n)+?&lt;&#x2F;.*?&gt;)&#x2F;&#x2F;参照上文 用于识别&lt;script&gt;代码块&lt;.*?&gt;&#x2F;&#x2F;参照上文 用于识别HTML标签 总结&emsp;&emsp;为了实现这个效果，最近都弄得茶饭不思，今天终于终于是实现了，不留遗憾的感觉真好~ &emsp;&emsp;通过这次也对正则表达式的使用方法有了深刻的理解，虽然各个语言的正则表达式使用稍有不同，但是还是很好的经验。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（二）- 前端添加图片水印方案]]></title>
    <url>%2Fposts%2F35734.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;前段时间在写houdini学习之路的博文，这个过程中引用了大量的图片，我担心图片被人盗取，所以想要给所有的博客图片添加水印，这篇博文就应运而生了。 &emsp;&emsp;这次研究还延伸除了博客瘦身的方法，详情可以了解另一篇博文——博客瘦身方法。 &emsp;&emsp;最开始我是直接搜索js给图片添加水印的方法，有通过给图片添加div生成水印的，但是这种方案只是在网页上实现水印，用户下载图片水印就消失了，这样的方案指标不治本，所以我需要将水印合成到图片当中，获取合成后的图片地址。这之中有利用canvas和直接生成的链接方案。当然网上也有封装好的插件。 &emsp;&emsp;最开始我并不打算使用插件来完成的，但是canvas的方案实在让我头疼，不得已我只好去寻求插件来解决。 &emsp;&emsp;canvas的最大问题在于我无法将img标签替换为canvas，我在这地方卡壳了，所以就放弃了canvas方案。 利用插件生成图片水印pa7/watermark.js&emsp;&emsp;最开始在网上找到了watermark.js，看名字就知道这个东西铁定和水印有关的，但是这个脚本是很久没有更新了。官方给出的使用方法看得我不明不白，而且有些代码错误，而且实现不了效果。 相关链接 国内找到的链接 官方地址 github地址 brianium/watermarkjs&emsp;&emsp;后面我就去github上面找watermark，找个星星多的，就找到了另一个watermark.js脚本，然而这个也不好弄，官方的doc介绍不明不白的（bootstrap的脚本路径还是错误的），用得我很是不爽，还是实现不了效果。 相关链接 github地址 Img2Blob.js&emsp;&emsp;这个工具也是在网上找的，感觉实现还算友好，单独的图片好像是可以的，但是博客上还是不行。 相关链接 国内找到的链接 github地址 lelinhtinh/watermark&emsp;&emsp;终于在使用这个工具的时候，我发现博客之所以不行是因为要等待图片加载，需要加入setTimeout进行操作。后面这个插件就实现了效果。 相关链接 github地址 1&lt;script src="/js/jquery.watermark.min.js"&gt;&lt;/script&gt; 1234567891011121314151617setTimeout(function()&#123; $('.fancy-ctn').each(function()&#123;//最开始我是只遍历img的，但是这会导致头像之类的img也被误操作，所以最后是遍历img的父对象 $(this).children('img').watermark(&#123; text: 'FXTD-odyssey', textSize:50, textWidth: 300, // gravity: 'w', opacity: 0, margin: 10, done:function(imgURL)&#123; this.src=imgURL;//修改图片的链接地址 $(this).parent().attr('href',imgURL);//fancybox打开的时候链接的就是自带水印的图了 &#125; &#125;); &#125;)&#125;,500) 总结&emsp;&emsp;这是通过生成合成了水印的图片链接，将图片的src地址替换掉，从而实现效果，这样就不用去用canvas去替换img标签那么麻烦了。 &emsp;&emsp;效果虽然实现了，但是有个致命的问题。 &emsp;&emsp;如果博文的图片少还不是很明显，我Houdini系列中，有些博文一篇就有30多张图，打开之后要卡顿很久很久才能将水印生成出来，为此回想起canvas的快速实现效果，于是乎我重新去研究canvas的实现方案。 canvas生成图片水印&emsp;&emsp;因为最开始我一直在寻找img替换为canvas的方法，但是并没有好的实现方案，网上的那些转换，在博客当中都不起作用。 &emsp;&emsp;所以经过水印插件的研究，我认为替换图片路径会是更好的方案，问题是图片地址要怎么生成出来。 &emsp;&emsp;经过不懈的努力，我找到了这篇博文 &emsp;&emsp;但是他实现的效果和我的大相径庭，我将它的代码复制了下来进行了魔改。 1234567891011121314151617181920212223242526272829303132333435363738setTimeout(function()&#123; $('.fancy-ctn').each(function()&#123; var scope = this; Img_waterMark($(this).children().attr('src'),function(url)&#123; $(scope).children('img').attr('src',url);//这里也被坑了好久才发现为什么this不起作用 $(scope).attr('href',url); &#125;); &#125;)&#125;,500) function Img_waterMark(imgPath,setImg)&#123; var src = imgPath; var canvas = document.createElement('canvas'); var logoText ='FXTD-odyssey'; // 水印 var context = canvas.getContext('2d'); var imgUpload = new Image(); imgUpload.src =src; imgUpload.onload = function () &#123; var width = imgUpload.width; var height= imgUpload.height; canvas.width = width; // 给canvas赋值宽度 canvas.height = height; // 给canvas 赋值高度 context.font="50px 微软雅黑"; context.fillStyle = "#fff"; context.drawImage(imgUpload, 0, 0,imgUpload.width,imgUpload.height,0,0,width,height); context.fillText(logoText,10,50); let url=canvas.toDataURL("image/jpg"); // canvas转换成base64位 setImg(url); &#125;&#125; 图片加载完成才添加水印&emsp;&emsp;使用setTimeout其实并不好，延迟的时间很难定夺，图片太多的话500毫秒可能也是不够的。 &emsp;&emsp;为了解决这个问题，我找了这篇博文 &emsp;&emsp;这样就实现了图片都加载完才去添加水印。 &emsp;&emsp;最后的代码汇总 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*canvas 方案*/var t_img; // 定时器var isLoad = true; // 控制变量// 判断图片加载状况，加载完成后回调isImgLoad(function()&#123; // 加载完成 $('.fancy-ctn').each(function()&#123; var scope = this; console.log("test"); Img_waterMark($(this).children().attr('src'),function(url)&#123; $(scope).children('img').attr('src',url); $(scope).attr('href',url); &#125;); &#125;)&#125;);/*https://www.cnblogs.com/ymy124/p/4538695.html*/// 判断图片加载的函数function isImgLoad(callback)&#123; // 注意我的图片类名都是cover，因为我只需要处理cover。其它图片可以不管。 // 查找所有封面图，迭代处理 $('img').each(function()&#123; // 找到为0就将isLoad设为false，并退出each if(this.height === 0)&#123; isLoad = false; return false; &#125; &#125;); // 为true，没有发现为0的。加载完毕 if(isLoad)&#123; clearTimeout(t_img); // 清除定时器 // 回调函数 callback(); // 为false，因为找到了没有加载完成的图，将调用定时器递归 &#125;else&#123; isLoad = true; t_img = setTimeout(function()&#123; isImgLoad(callback); // 递归扫描 &#125;,500); // 我这里设置的是500毫秒就扫描一次，可以自己调整 &#125;&#125;/*https://www.cnblogs.com/zuoan-oopp/p/8006524.html*/function Img_waterMark(imgPath,setImg)&#123; var src = imgPath; var canvas = document.createElement('canvas'); var logoText ='FXTD-odyssey'; // 水印 var context = canvas.getContext('2d'); var imgUpload = new Image(); imgUpload.src =src; imgUpload.onload = function () &#123; var width = imgUpload.width; var height= imgUpload.height; canvas.width = width; // 给canvas赋值宽度 canvas.height = height; // 给canvas 赋值高度 context.font="50px 微软雅黑"; context.fillStyle = "#fff"; context.drawImage(imgUpload, 0, 0,imgUpload.width,imgUpload.height,0,0,width,height); context.fillText(logoText,10,50); let url=canvas.toDataURL("image/jpg"); // canvas转换成base64位 setImg(url); &#125;&#125; 总结&emsp;&emsp;其实canvas的方案和插件的实现效率相差无几，而且在加载的过程中原图会暴露，不仅起不到保护作用，也让网页加载巨慢无比，因此，我最后不得不放弃这些js的实现方案，采用图床来添加水印。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客优化之路（一）- 博客瘦身方法]]></title>
    <url>%2Fposts%2F20763.html</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;前些天将一些前端three.js实现的作品搬运到博客上来，遇到了不少问题。 &emsp;&emsp;首先是文件很大，每次上传都要等很久，其次是github的链接速度非常慢，作品的加载体验极差。 &emsp;&emsp;另外github虽然支持1G的静态空间但是coding只支持100M，我那几个案例就是图片素材加起来就有好几百M了，这样就导致coding page没法使用了。 &emsp;&emsp;最开始我并不在意，毕竟GitHub上面是没有问题，这点差体验也不算什么，能看就行。 &emsp;&emsp;后面在我上传博客的图片的时候，意识到图片是直接暴露的，很可能被人盗图，所以就想着给图片加个水印，自己又不想用PS去手动加水印，因此最好的方法就是通过代码批量生成水印。 &emsp;&emsp;后面我在网上找了不少方案，最完美的方案是在后端生成水印的，但是github pages没有这种功能，而且我也不会后台。所以我只好选择用前端的方法在图片上添加水印，这个研究结果可以去看我的另一篇博文。 &emsp;&emsp;最后的最后，我还是放弃了使用前端生成的水印的方案,具体原因上面的博文有说明。 &emsp;&emsp;为了解决图片水印的问题，我有搜索和hexo相关的方案，最后才发现了图床的方法，也就是本文主要要讲的事情。 七牛云&emsp;&emsp;在网上搜索大量关于hexo的资料都是采用七牛云的方案作为图床，而且也可以实现水印效果，简直完美。 &emsp;&emsp;使用七牛云首先需要注册一个账号，具体的操作方法可以参考 https://blog.csdn.net/Android_MSK/article/details/75394818 https://www.jianshu.com/p/ec2c8acf63cd 我的七牛云空间截图 七牛云支持图片添加水印，而且可以加入不同的样式通过不同的后缀来获取添加样式的图片 添加了样式之后只需要添加在原图的链接上加上样式分割符和样式名即可获取有水印的图片注：你可以开启原图保护，从而实现只能获取水印图片的方法。 &emsp;&emsp;七牛云除了可以做图床之外，对象存储也可以用来存储js脚本，以及一些素材资源，比如我three.js中的模型贴图资源等等。 &emsp;&emsp;瞬间我博客的瘦身就豁然开朗了。 &emsp;&emsp;后面就是将所有的资源上传到七牛云就OK了。 &emsp;&emsp;我大概花了一天的时间，才将所有的项目链接换成了七牛云的链接，其中当然也少不了各种本地的测试，一切顺利，没有问题。 &emsp;&emsp;可是上传到了github就傻眼了，七牛云所有的链接都是http链接，https升级还需要额外的证书支持，这就导致了GitHub上面的作品全部出现Mix Content报错，而且七牛上申请ssl证书还挺麻烦的，真的是郁闷死我了。 腾讯云&emsp;&emsp;后面我在搜索中，发现有人推荐用腾讯云，免费额度更好，所以目前就入坑了。 &emsp;&emsp;后面我注册了腾讯云之后发现腾讯云是自带https的，而且支持静态网页搭建，COS的存储空间更是每月免费50G，同时还有万象优图加持，可以实现和七牛云一样的水印，支持防盗链和原图保护功能，支持文件夹上传，如此丰富的功能真是爽死我了，大厂就是不一样…（真香）。所以我果断弃坑七牛云。 腾讯云空间截图 在使用的过程中遇到了跨域的问题可以如此设置来解决问题 开启静态网页可以之间线上浏览html等等操作注：静态网页的链接和下载的链接是不一致的 在控制台上面可以添加万象优图，将存储图片的bucket放入其中 在bucket的设置里面可以开启原图保护 图面的水印样式处理和七牛云一致 同时还支持更为强大的图片压缩方案——Guetzli图片压缩 总结&emsp;&emsp;七牛云虽然不错，但是还是不敌腾讯云，而且腾讯云有客户端程序，上传方便了很多。&emsp;&emsp;另外想到大厂我也考虑过阿里云，奈何阿里云是收费的，学生党……溜了溜了。]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zplus 教程系列（四）]]></title>
    <url>%2Fposts%2F60230.html</url>
    <content type="text"><![CDATA[神经元案例ZPLUS_Houdini_SOP_1、2、3、4笔记 观看笔记 通过for循环生成神经元连接线 重点在for循环的运用上 加入vop point给神经元增加混乱度 通过点云来寻找神经元的根从而不会产生位置偏移 解决曲线重叠的问题 通过partion可以生成对各组 通过点云获取曲线位置 通过Primitive attribute节点实现UV方向上的位置偏移 get attribute 可以获取相应的属性值进行比较 通过VDB生成模型 attribute transfer 有blend融合过渡功能 神经元多重线段制作 操作逻辑 生成方块 并通过volume在方块上面撒点 操作截图 通过for each循环点来生成线 操作截图 通过delete当前循环的点获取当前循环中的其他点 加入point vop 获取循环点与其他周围点的距离 通过fit range 将获取范围区分得更加黑白分明 操作截图 根据颜色删除其他的点从而获取到当前循环点以及其周围的点 操作截图 将获取的点与循环点连线&emsp;&emsp;为此需要循环遍历获取的点，从而只获取两个点来连线 操作截图 最后循环遍历生成最终的线段效果 操作截图 &emsp;&emsp;这样生成会线段会产生重叠的问题，通过打开primnum可以看到每条线段都有两条 操作截图 &emsp;&emsp;解决方案有两种，一种是教程提到的根据点序号跳过的方案，还有一种是我自己研究的使用connect adjacent pieces节点 线段不重叠方案点序号方案 在最上面加入attribute wrangle 添加一个新的变量来记录ptnum&emsp;&emsp;ptnum在后面的循环中会发生变化，需要提前获取 操作截图 再循环中加入switch节点来跳过部分线段的生成，判断条件是当循环点的pointnum大于周围点时跳过&emsp;&emsp;因为pointnum是固定的，小于的时候执行从而实现只执行一次 操作截图 connect adjacent pieces节点方案 添加connect adjacent pieces节点 将connection type 改为adjacent points 调节搜索范围和最大点 操作截图 &emsp;&emsp;这个方案不需要循环遍历、也不需要处理线段重叠，一个节点解决问题 神经元噪波添加&emsp;&emsp;注：教程最后并没有采用不重叠的方案，而是充分利用多出来的线段 添加connectivity节点添加class属性（通过class属性可以区分不同的线段） 使用partition节点根据class属性批量添加组&emsp;&emsp;教程的方案在最新版的houdini中不起作用，这里采用VEX来解决 操作截图 12345for (int i = 0; i &lt; @numprim; i++)//根据面数循环&#123; string group_name = "curve" + itoa(i+1);//生成组的名字 setprimgroup(0, group_name, i, true);//批量生成组&#125; 给曲线添加噪波，增加混乱度&emsp;&emsp;大小噪波都是相同的point vop调整参数实现 操作截图 神经元动态辉光制作 根据上面生成组的来复制点 操作截图 添加point vop让生成的点在神经元上偏移 操作截图 添加point vop根据动点在线上添加颜色 操作截图 完成神经元制作 添加resample节点为后面VDB采样提高精度 在根部点生成球 通过将球作为bounding Object进行打组并删除掉其他点 操作截图 生成由内而外变小的pscale 操作截图 根据余下的点通过VDB生成模型，借助pscale实现神经元的根部内大外小 操作截图 添加file缓存节点加快加载速度 给神经元添加随机的辉光颜色 操作截图 通过attribute transfer节点将点的颜色详细传到模型上，借助blend width实现颜色渐变效果 操作截图 &emsp;&emsp;添加辉光小球 删除根部的点 根据剩余的点复制小球 操作截图 &emsp;&emsp;合并所有的模型和线段 操作截图 var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().next().hide(); $(this).css('width','100%'); $(this).click(function(){ $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
        <category>zplus 教程系列</category>
      </categories>
      <tags>
        <tag>ࠒ视频教程/zplus</tag>
        <tag>ࠁHoudini/SOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 学习之路（五）]]></title>
    <url>%2Fposts%2F12961.html</url>
    <content type="text"><![CDATA[极客学院 设计模式课程 设计模式存在的根本原因是为了代码复用，增加可维护性，有如下原则： 【开闭原则】对扩展开放，对修改关闭。 【里氏转换原则】子类继承父类，单独掉完全可以运行。 【依赖倒转原则】引用一个对象，如果这个对象有底层的类型，直接引用底层。 【接口隔离原则】每一个接口应该是一种角色。 【合成/聚合复用原则】新的对象应使用一些已有的对象，使之成为新对象一部分。 【迪米特原则】一个对象应对其他对象有尽可能少的了解。 单例模式1234567891011121314151617181920212223242526272829303132333435363738394041 /*模式作用 *1.模块间通信。 *2.系统中某个类的对象只能存在一个。 *3.保护自己的属性和方法。 */ /*注意事项 *1.注意this的使用。 *2.闭包容易造成内存泄漏，不需要的赶快干掉。 *3.注意new的成本。（继承） */var xiaowang = (function (argument) &#123; var xiaowangjia = function(message)&#123; this.menling = message; &#125; var men; var info = &#123; sendMessage:function (message) &#123; if(!men)&#123; men = new xiaowangjia(message); &#125;; return men; &#125; &#125;; return info;&#125;)();var xiaoli = &#123; callXiaowang:function(msg)&#123; var _xxw = xiaowang.sendMessage(msg); alert(_xxw.menling); _xxw = null; &#125;&#125;;/*用户使用区域*/xiaoli.callXiaowang('didi');xiaoli.callXiaowang('hello');//我自己添加的测试 单例模式 按钮实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//该案例只是概念，无法正常运行 // 页面上有6个按钮 //a b c =&gt; top //d e f =&gt; banner var top = &#123; init:function()&#123; this.render(); this.bind(); &#125;, a:4, render:function()&#123; var me = this; me.btna = $('#a'); &#125;, bind:function()&#123; var me = this; me.btna.click(function()&#123; me.test(); &#125;); &#125;, test:function()&#123; a = 5; &#125; &#125; var banner = &#123; init:function()&#123; this.render(); this.bind(); &#125;, a:4, render:function()&#123; var me = this; me.btna = $('#d'); &#125;, bind:function()&#123; var me = this; me.btna.click(function()&#123; me.test(); &#125;); &#125;, test:function()&#123; top.a = 6; &#125; &#125; top.init(); banner.init(); 构造函数模式1234567891011121314151617181920212223242526272829/*模式作用 *1.用于创建特定类型的对象。 *2.第一次声明的时候给对象赋值。 *3.自己声明构造函数，赋予属性和方法。 *//*注意事项 *1.声明函数的时候处理业务逻辑。 *2.区分和单例的区别，配合单例实现初始化。 *3.构造函数大写字母开头。（建议） */function zaomen(huawen)&#123; var _huawen="普通"; if(huawen)&#123; _huawen = huawen; &#125; this.suo = '普通'; this.huawen = _huawen; this.create = function()&#123; return '【锁头】' + this.suo + '【花纹】' + this.huawen &#125; &#125; var xiaozhang = new zaomen(); alert("xiaozhang" + xiaozhang.create()); var xiaoli = new zaomen('绚丽'); alert('xiaoli' + xiaoli.create()); 建造者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 /*模式作用 *1.分步创建一个复杂的对象。 *2.解耦封装过程和具体创建的组件。 *3.无需关心组件如何组装。 */ /*注意事项 *1.一定要一个稳定的算法进行支持。 *2.加工工艺是暴露的。 */ function Fangzi()&#123; this.woshi = ""; this.keting = ""; this.chufang = ""; &#125; function Baogongtou()&#123; this.gaifangzi = function(gongren)&#123; gongren.jian_woshi(); gongren.jian_keting(); gongren.jian_chufang(); &#125; &#125; function Gongren()&#123; this.jian_woshi = function()&#123; alert("卧室盖好了"); &#125; this.jian_keting = function()&#123; alert("客厅盖好了"); &#125; this.jian_chufang = function()&#123; alert("厨房盖好了"); &#125; this.jiaogong = function()&#123; var _fangzi = new Fangzi(); _fangzi.woshi = "OK"; _fangzi.keting = "OK"; _fangzi.chufang = "OK"; return _fangzi; &#125; &#125;;var gongren = new Gongren;var baogongtou = new Baogongtou();baogongtou.gaifangzi(gongren);var myfangzi = gongren.jiaogong();console.log(myfangzi); 工厂模式12345678910111213141516171819202122232425262728/*模式作用 *1.对象的构建十分复杂。 *2.需要依赖具体的环境创建不同的实例。 *3.处理大量具有相同属性的小对象。 *//*注意事项 *1.不能滥用工厂，有时候仅仅是给代码增加复杂度。 */var gongchang = &#123;&#125;;gongchang.chanyifu = function(argument)&#123; this.gongren = 50; alert('我们有' + this.gongren + '个工人。')&#125;gongchang.chanxie = function()&#123; alert('生产鞋子');&#125;gongchang.yunshu = function()&#123; alert('运输');&#125;gongchang.changzhang = function(para)&#123; return new gongchang[para]();&#125;var me = gongchang.changzhang('chanxie'); 代理模式1234567891011121314151617181920212223242526272829303132/*模式作用 *1.远程代理（一个对象将不同空间的对象进行局部代理）。 *2.虚拟代理（根据需要创建开销代价很大的对象如渲染网页暂时用占位符代替真图）。 *3.安全代理（控制真是对象的访问权限）。 *4.智能指引（调用对象代理处理另外一些事情如垃圾回收机制）。 *//*注意事项 *1.不能滥用代理，有时候仅仅是给代码增加复杂度。 */function maijia(argument)&#123; this.name = '小明' ;&#125;function zhongjie()&#123;&#125;zhongjie.prototype.maifang = function()&#123; new fangdong(new maijia()).maifang("20万");&#125;;function fangdong(maijia)&#123; this.maijia_name = maijia.name; this.maifang = function(money)&#123; alert('收到钱'); &#125;&#125;var zhongjianshang = new zhongjie;zhongjianshang.maifang(); 司令模式123456789101112131415161718192021222324252627282930/*模式作用 *1.将函数的封装、请求、调用结合为一体。 *2.调用具体的函数解耦命令对象与接收对象。 *3.提高程序模块化的灵活性。 */ /*注意事项 *1.不需要接口一致，直接调用函数即可，以免造成浪费。 */ var lian = &#123;&#125;; lian.paobing = function(pao_num)&#123; alert(pao_num + '炮' + '开始战斗'); &#125; lian.bubing = function(bubing_num)&#123; alert(bubing_num + '人' + '开始战斗'); &#125; lian.lianzhang = function(mingling)&#123; lian[mingling.type](mingling.num); &#125; lian.lianzhang(&#123; type:'paobing', num:100 &#125;); lian.lianzhang(&#123; type:'bubing', num:500 &#125;) 极客学院-总结 &emsp;&emsp;极客学院的js设计模式教程的案例都是为了便于理解和解构出来的，但是我认为这样就是耍流氓，原理都懂但是没有实战就是纸上谈兵而已，所以我看完之后其实收获不大（能力有限(:з」∠)） Plurasight.com - JavaScript Design PatternsChaining pattern 链式模式1234567891011121314151617181920212223242526//这种方法就是JQuery常见的构造方法var Calc = function(start)&#123; this.add = function(x)&#123; start = start + x; return this; &#125;; this.multiply = function(x)&#123; start = start * x; return this; &#125;; this.equals = function(callback)&#123; callback(start); return this; &#125;;&#125;new Calc(0) .add(1) .add(2) .multiply(3) .equals(function(result)&#123; console.log(result); &#125;); Creating Observerable Properties 观察者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859var Book = function(name,price)&#123; var priceChanging = []; var priceChanged = []; this.name = function(val)&#123; return name; &#125;; this.price = function(val)&#123; if(val !== undefined &amp;&amp; val !== price)&#123; for(var i = 0; i &lt; priceChanging.length;i++)&#123; if(!priceChanging[i](val))&#123; return price; &#125; &#125; price = val; for(var i = 0; i &lt; priceChanged.length; i++)&#123; priceChanged[i](this); &#125; &#125; return price; &#125;; this.onPriceChanging = function(callback)&#123; priceChanging.push(callback); &#125;; this.onPriceChanged = function(callback)&#123; priceChanged.push(callback); &#125;;&#125;/*****************//*用户使用时的代码*//****************//* *Book CLass *传入书名和价格 *改变价格是预判条件的 onPriceChanging =&gt; function */var book = new Book('JavaScript: The Good Parts',23.99);book.onPriceChanging(function(price)&#123; if(price &gt; 100)&#123; console.log('系统错误，价格超过了预估值！'); return false; &#125; return true;&#125;);book.onPriceChanged(function(b)&#123; console.log('书本的价格已经改变为：￥' + b.price());&#125;);book.price(19.99);book.price(20); JavaScript Design Patterns - 总结 &emsp;&emsp;观察者模式非常实用，可以在外部补充内部代码的不足，从外部完成对内部运行的一些代码补充，非常方便。&emsp;&emsp;JQuery的链式模式我并没有怎么用，但是理论明白还是觉得非常方便的，threejs的add函数也是用相似的方法写的。 总结 &emsp;&emsp;设计模式其实所有面向对象语言都存在的，四人帮（gang of four）就有著名的著作&emsp;&emsp;Jjs在设计模式的实现和其他语言大相径庭，因为js的理念是万物皆对象，无论是变量还是函数都可以升级为类，当然现在ES6标准已经加入了语法糖可以用类似Java的方法来构造类了。]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 学习之路（四）]]></title>
    <url>%2Fposts%2F61471.html</url>
    <content type="text"><![CDATA[案例效果 OpenGL(WebGL) 大作业 面向过程封装 核心思路 通过一个js提前将场景、灯光、控制按钮生成出来只需要关心模型导入的部分以及刷新部分的编写 脚本前言 这个脚本是今年（2018年）寒假的时候在聪哥家里学习three.js写的我更新到了第三版之后，后面改成了面向对象的写法 网页代码 脚本依赖于以下的库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;body&gt; &lt;!--设置webgl的id让threejs链接--&gt; &lt;div id="webgl"&gt; &lt;div id="logo"&gt; &lt;div id="container"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!--链接threejs的库--&gt; &lt;script src="js/three.js-master/build/three.min.js"&gt;&lt;/script&gt;&lt;!--threejs 的主要脚本--&gt; &lt;script src="js/three.js-master/examples/js/controls/OrbitControls.js"&gt;&lt;/script&gt;&lt;!--实现摄像机点击旋转平移的脚本--&gt; &lt;script src="js/three.js-master/examples/js/controls/PointerLockControls.js"&gt;&lt;/script&gt; &lt;script src="js/three.js-master/examples/js/controls/TransformControls.js"&gt;&lt;/script&gt; &lt;script src="js/three.js-master/examples/js/shaders/BokehShader2.js"&gt;&lt;/script&gt; &lt;script src="js/three.js-master/examples/libs/stats.min.js"&gt;&lt;/script&gt;&lt;!--显示帧率的脚本--&gt; &lt;script src="js/three.js-master/examples/libs/dat.gui.min.js"&gt;&lt;/script&gt;&lt;!--实现简单的gui界面方便调试的脚本--&gt; &lt;script src="js/three.js-master/loaders/OBJLoader.js"&gt;&lt;/script&gt;&lt;!--加载OBJ的脚本--&gt; &lt;script src="js/three.js-master/loaders/DDSLoader.js"&gt;&lt;/script&gt;&lt;!--加载DDS的脚本--&gt; &lt;script src="js/three.js-master/examples/js/Detector.js"&gt;&lt;/script&gt;&lt;!--检测webgl启动的脚本 目前已无使用--&gt; &lt;!--链接html5tooltips的库 实现小标签动画--&gt; &lt;script src="js/microjs/html5tooltips/html5tooltips.1.7.2.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" type="text/css" href="js/microjs/html5tooltips/html5tooltips.animation.css"&gt;&lt;/link&gt; &lt;link rel="stylesheet" type="text/css" href="js/microjs/html5tooltips/html5tooltips.css"&gt;&lt;/link&gt; &lt;!--链接animatelo的库 目前还没有使用--&gt; &lt;script src="js/microjs/animatelo-master/dist/animatelo.min.js"&gt;&lt;/script&gt; &lt;!--链接picoModal的库 实现按钮弹窗--&gt; &lt;script src="js/microjs/picoModal.js"&gt;&lt;/script&gt; &lt;!--链接isMobile的库 检测移动设备--&gt; &lt;script src="js/microjs/isMobile/isMobile.js"&gt;&lt;/script&gt; &lt;!--链接progressbar的库 快速生成加载条--&gt; &lt;script src="js/microjs/progressbar.min.js"&gt;&lt;/script&gt; &lt;!--链接webglreport的库 检测webgl是否开启--&gt; &lt;script src="js/underscore-min.js"&gt;&lt;/script&gt; &lt;!--导入封装用的js--&gt; &lt;script src="plugin/scene_init-ver3.0.js"&gt;&lt;/script&gt; &lt;script src="plugin/import.js"&gt;&lt;/script&gt; &lt;/body&gt; scene_init-ver3.01234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924/************************//*******添加全屏按钮********//*****并且添加全屏功能*******/ /************************///使用JQuery实现按钮添加var bar_path_Su,bar_path_S,bar_path_Y,bar_path_an,bar_path_Yu,bar_path_logobar_path_i_upper,bar_path_i_lower,tooltip_stop,tooltip_background;$(function()&#123; //webgl加载失败时显示提示 代码复制自webglreport.js var webglVersion = window.location.search.indexOf('v=2') &gt; 0 ? 2 : 1; var report = &#123; platform: navigator.platform, userAgent: navigator.userAgent, webglVersion: webglVersion &#125;; if (webglVersion === 2) &#123; $('body').addClass('webgl2'); &#125; if ((webglVersion === 2 &amp;&amp; !window.WebGL2RenderingContext) || (webglVersion === 1 &amp;&amp; !window.WebGLRenderingContext)) &#123; // The browser does not support WebGL //显示浏览器不支持webgl的信息 webgl_fail(); return; &#125; var canvas = $('&lt;canvas /&gt;', &#123; width: '1', height: '1' &#125;).appendTo('body'); var gl; var possibleNames = (webglVersion === 2) ? ['webgl2', 'experimental-webgl2'] : ['webgl', 'experimental-webgl']; var contextName = _.find(possibleNames, function (name) &#123; gl = canvas[0].getContext(name, &#123; stencil: true &#125;); return !!gl; &#125;); canvas.remove(); if (!gl) &#123; // The browser supports WebGL, but initialization failed //显示浏览器需要开启webgl的信息 webgl_update(); return; &#125; //添加按钮的CSS样式 var main_css = $("&lt;style&gt;&lt;/style&gt;").text("#container&#123;position:absolute;width:100%;height:5%;margin-top:40% ;right:25%;&#125;#logo&#123;position:absolute;width:40%;left:40%;top:30%;&#125; #main&#123;position: fixed;bottom: 20px;right: 20px;padding: 1px 15px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;transition: transform 0.2s linear;&#125; #main:hover &#123;cursor: pointer;opacity: 1;transform: rotate(180deg);&#125;#help_btn &#123;position: fixed;bottom: 100px;right: 30px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125;#full_btn &#123;position: fixed;bottom: 150px;right: 30px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125;#share_btn &#123;position: fixed;bottom: 200px;right: 30px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125;#stop_btn &#123;position: fixed;bottom: 250px;right: 30px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125;#origin_btn &#123;position: fixed;bottom: 300px;right: 30px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125; #color_dark_btn &#123;position: fixed;bottom: 200px;right: 80px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125; #color_white_btn &#123;position: fixed;bottom: 200px;right: 80px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125; #color_white_btn_small &#123;position: fixed;bottom: 20px;right: 20px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125; #color_dark_btn_small &#123;position: fixed;bottom: 20px;right: 45px;padding: 5px 5px;color: #fff;background-color: #89a;opacity: 0.7;border-radius: 50%;font-size: 50px;cursor:pointer;&#125; #panel &#123;padding: 0; margin: 0; width: 200px;height: 500px;background: #a0a0f0;position: absolute;right:3px;top:20%;border:2px solid #bbb&#125; #blocker &#123;position: absolute; top:0px;width: 100%;height: 100%;background-color: rgba(0,0,0,0.5);&#125; #instructions &#123;width: 100%;height: 100%;display: -webkit-box;display: -moz-box;display: box;-webkit-box-orient: horizontal;-moz-box-orient: horizontal;box-orient: horizontal;-webkit-box-pack: center;-moz-box-pack: center;box-pack: center;-webkit-box-align: center;-moz-box-align: center;box-align: center;color: #ffffff;text-align: center;cursor: pointer;&#125;"); $("body").append(main_css); //添加按钮 $("#webgl").after("&lt;button id='main' onclick='icon_display()' onDblClick='express()'&gt;+&lt;/button&gt;"); tooltip_anim("main","主菜单"); $("#webgl").after("&lt;img id='help_btn' src='http://webgl.suiyuankj.com/images/ico/information.ico' width='32px' height='32px' onclick='help_display()'&gt;") tooltip_anim("help_btn","帮助");//添加按钮tooltip $("#help_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='full_btn' src='http://webgl.suiyuankj.com/images/ico/statusNotDone.ico' width='32px' height='32px' onclick='full_screen_fun()'&gt;") tooltip_anim("full_btn","全屏");//添加按钮tooltip $("#full_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='share_btn' src='http://webgl.suiyuankj.com/images/ico/flag.ico' width='32px' height='32px' onclick='share_display()'&gt;") tooltip_background = tooltip_anim("share_btn","背景颜色");//这里用这个无法删除改变按钮 $("#share_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='stop_btn' src='http://webgl.suiyuankj.com/images/ico/jumplist_pausealltask.ico' width='32px' height='32px' onclick='rotate_stop()'&gt;") tooltip_stop = tooltip_anim("stop_btn","暂停旋转");//添加按钮tooltip $("#stop_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='origin_btn' src='http://webgl.suiyuankj.com/images/ico/sync.ico' width='32px' height='32px'onclick='origin_position()'&gt;") tooltip_anim("origin_btn","初始位置");//添加按钮tooltip $("#origin_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='color_white_btn' src='http://webgl.suiyuankj.com/images/ico/white.jpg' width='32px' height='32px'onclick='white_BG()'&gt;") tooltip_anim("color_white_btn","白背景",'top');//添加按钮tooltip $("#color_white_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='color_dark_btn' src='http://webgl.suiyuankj.com/images/ico/dark.jpg' width='32px' height='32px'onclick='dark_BG()'&gt;") tooltip_anim("color_dark_btn","黑背景",'top');//添加按钮tooltip $("#color_dark_btn").hide();//隐藏按钮 $("#webgl").after("&lt;img id='color_white_btn_small' src='http://webgl.suiyuankj.com/images/ico/white.jpg' width='10px' height='10px'onclick='white_BG()' &gt;") tooltip_anim("color_white_btn_small","白背景",'top');//添加按钮tooltip $("#color_white_btn_small").hide();//隐藏按钮 $("#webgl").after("&lt;img id='color_dark_btn_small' src='http://webgl.suiyuankj.com/images/ico/dark.jpg' width='10px' height='10px'onclick='dark_BG()' &gt;") tooltip_anim("color_dark_btn_small","黑背景",'top');//添加按钮tooltip $("#color_dark_btn_small").hide();//隐藏按钮 $("#webgl").append("&lt;div id='panel'&gt;&lt;/div&gt;");//控制面板 $("#panel").hide();//隐藏面板 $("#panel").append("&lt;div id='transform' style='position:absolute;top:5px;left:20px;'&gt;&lt;center&gt;&lt;p&gt;&lt;b&gt;属性面板&lt;/b&gt;&lt;/p&gt;&lt;/center&gt;&lt;div id='panel_translate'style='position:relative;margin:5px;'&gt;平移 &lt;input value='0.0' class='translateX' style='border:2px solid transparent;background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;input value='0.0' class='translateY' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;input value='0.0' class='translateZ' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;/div&gt;&lt;div id='panel_rotate'style='position:relative;margin:5px;'&gt;旋转 &lt;input class='Number' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;input class='Number' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;input class='Number' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;/div&gt;&lt;div id='panel_scale'style='position:relative;margin:5px;'&gt;缩放 &lt;input class='Number' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;input class='Number' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;input class='Number' style='background-color: transparent; cursor: col-resize; width: 25px;margin:0px 5px;'&gt;&lt;/div&gt;&lt;/div&gt;");//控制面板 ico_size();//默认使用小图标（大图标在手机端竖屏时使用） //如果当前窗口过小，隐藏主菜单按钮 if(window.innerHeight&lt;300 || window.innerWidth &lt; 300)&#123; rotate_stop(); $("#main").hide(); $("#color_white_btn_small").show(); $("#color_dark_btn_small").show(); &#125; html5tooltips.refresh();//通过这个刷新tooltip 方可正常显示 //加载SVG路径生成公司logo为动画做准备 $("#logo").append(" &lt;svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 400' &gt;&lt;defs&gt;&lt;style&gt;.a&#123;fill:none;&#125;.b&#123;fill:#1d815e;&#125;.c&#123;fill:#3ea251;&#125;&lt;/style&gt;&lt;/defs&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M533.5,390.2V339.7c0-2.9,1.2-4,4.1-4.1h23.5c1.8,0,2.8,1,2.8,2.6s0,1.9,0,2.8q0,12.5,0,25h0q0,12.8,0,25.7a1.7,1.7,0,0,0,.3.9,2.1,2.1,0,0,0,1.2-.4c2.3-2.2,4.4-4.5,6.8-6.7a4.8,4.8,0,0,0,1.6-3.9q-.1-16.6-.1-33.2c0-5.6,0-11.1-.1-16.7a5.9,5.9,0,0,0-1.1-3.3,6.8,6.8,0,0,0-5.8-2.5H531c-2.7,0-5.7,1.6-6.2,4.6-.1.7-.6.9-1.2.7l-1.1-.5-4.7-3.2c-2-1.3-4.3-1.6-6-.2s-2.4,5.2-.8,6.5,6.3,4.8,9.4,7.2,3,1.9,1.6,5.1-1.9,2.9-4,2.8h-24a7.3,7.3,0,0,0-7.3,7.3q0,15.2.2,30.5a5.1,5.1,0,0,0,3.6,5,11.3,11.3,0,0,0,3.2.4h26.9c.7,0,.9-.4.7-1a3.3,3.3,0,0,0-.6-.9l-6.3-7.3a1.9,1.9,0,0,0-1.6-.7H499.8a9.5,9.5,0,0,1-2.3-.3c-1.3-.4-1.7-1-1.7-2.4q-.1-8.9-.1-17.9c0-1.8.6-2.5,2.3-3h23.3c1.4,0,1.9.5,2,1.9s0,.8,0,1.3q0,13.8-.1,27.6a2.4,2.4,0,0,0,2.5,2.7H531A2.3,2.3,0,0,0,533.5,390.2Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M363.2,326.6a2.7,2.7,0,0,1,2.5,2.8c0,1.6,0,3.3,0,4.9a2.3,2.3,0,0,1-2,2.3h-2.2l-79.9-.3c-2-.1-3.1.9-3.2,3-.1,4.7-.1,9.4,0,14.1a2.7,2.7,0,0,0,3,2.7h23.6a9,9,0,0,1,5.2,1.6,5.3,5.3,0,0,1,2.2,4.3c.2,2.5.2,5,.2,7.5,0,5.9,0,11.8,0,17.7A5.8,5.8,0,0,1,307,393H270.6l-1.2-.3a4.8,4.8,0,0,1,.6-1l4.2-4.3c1.4-1.5,2.9-2.9,4.4-4.3a2.8,2.8,0,0,1,1.7-.5h19.3c2.3,0,3.1-.7,3.1-3s-.1-7.3-.2-10.9c0-1.5-1-2.3-2.8-2.4H275.8a7.2,7.2,0,0,1-7.1-5.5,3.8,3.8,0,0,1-.1-1c0-8.4-.1-16.8,0-25.2.1-4.4,2.1-7.8,7.4-8.1C279,326.4,361.8,326.5,363.2,326.6Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M387.2,326.2h11.5c1.8,3.4,4.3,8,6.2,11.3a40.2,40.2,0,0,0,2.6,3.8c.5.7.9.3,1.2-.2l5.2-9.1,3.3-5.9h75.7c.5,0,.5.9.1,1.3l-8.9,8.2a2.1,2.1,0,0,1-1.3.3H425.7a1.3,1.3,0,0,0-1.3.8c-2.5,4.6-4.9,9.3-7.6,13.7-.9,1.4-2.3,4.2-2.3,4.2s-.4,26.7-.5,35.3c0,1.4-.7,2.6-1.9,2.6H405c-1.8,0-2.7-.7-2.7-2.5,0-7.9-.1-16.2-.1-24,0-3.4.1-7.7,0-11l-.9-1.9c-4.5-8.9-8.9-16.8-13.5-25.6C387.6,327.4,387.4,326.7,387.2,326.2Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M318.6,364.6q0-10.7,0-21.4a2.4,2.4,0,0,1,2.4-2.5h5.2a2.4,2.4,0,0,1,2.6,2.6q.1,17.9.2,35.9c0,2.3.8,3.2,3.2,3.2h21.8c.9,0,1.3-.3,1.3-1.3q0-12.1,0-24.1c0-4.6.1-9.2.2-13.7,0-1.3.5-2.5,2.3-2.5h5.4a2.7,2.7,0,0,1,2.6,3c0,1.2-.2,19.3-.2,27.1,0,5.3.1,10.6,0,15.9a6.9,6.9,0,0,1-1.6,4.9,3.6,3.6,0,0,1-2.8,1.2H333.7c-3.1,0-6.2.2-9.3,0s-5.8-1.8-5.8-5.6c0-7.6,0-15.2,0-22.7Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M432.9,364.8q0-10.7,0-21.5c0-2.3.8-3.1,3.1-3.1h4.1a2.6,2.6,0,0,1,2.7,3c0,1,.1,2,.1,3q0,16.1,0,32.2c0,.4,0,.8,0,1.2a2.3,2.3,0,0,0,2.6,2.4h20.7c2,0,2.9-.8,3.2-2.8a22.7,22.7,0,0,0,.1-2.4c0-11,0-23.7,0-34.7a1.8,1.8,0,0,1,1.8-1.3H478a1.9,1.9,0,0,1,1.9,2c0,1.3,0,2.6,0,3.9q0,15.2.1,30.4,0,4.5.1,8.9c0,2.5-.7,4.7-3.1,5.9a6.8,6.8,0,0,1-2.4.6c-4.4.3-11.7.1-17.6.1H438.9c-3.8,0-5.6-1.8-5.8-5.3-.1-1.9-.1-3.9-.1-5.8,0-5.5,0-11.1,0-16.6Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M372.6,366.2q0-11.4,0-22.9c0-1.7.7-2.4,2.3-2.5h5.5c.9,0,2.2.3,2.3,1.5s.1,2.7.1,4q.1,22.3,0,44.5c0,1.5-.3,1.8-1.8,1.9h-7.2a1.4,1.4,0,0,1-1.3-1.4C372.4,383.6,372.5,366.2,372.6,366.2Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='1' stroke='#bbb' d='M377.4,326.3h-2.8a3.7,3.7,0,0,0-3.9,3.7c0,.9,0,2.2,0,3.2a3.1,3.1,0,0,0,2.8,2.9c2.5.2,4.7.1,7.2.1a2.7,2.7,0,0,0,2.7-2.8c0-1,0-2.8,0-3.9a3.5,3.5,0,0,0-3.1-3.1Z' transform='translate(-268.6 -160.1)'/&gt; &lt;!--animation path--&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='an' d='M533.5,390.2V339.7c0-2.9,1.2-4,4.1-4.1h23.5c1.8,0,2.8,1,2.8,2.6s0,1.9,0,2.8q0,12.5,0,25h0q0,12.8,0,25.7a1.7,1.7,0,0,0,.3.9,2.1,2.1,0,0,0,1.2-.4c2.3-2.2,4.4-4.5,6.8-6.7a4.8,4.8,0,0,0,1.6-3.9q-.1-16.6-.1-33.2c0-5.6,0-11.1-.1-16.7a5.9,5.9,0,0,0-1.1-3.3,6.8,6.8,0,0,0-5.8-2.5H531c-2.7,0-5.7,1.6-6.2,4.6-.1.7-.6.9-1.2.7l-1.1-.5-4.7-3.2c-2-1.3-4.3-1.6-6-.2s-2.4,5.2-.8,6.5,6.3,4.8,9.4,7.2,3,1.9,1.6,5.1-1.9,2.9-4,2.8h-24a7.3,7.3,0,0,0-7.3,7.3q0,15.2.2,30.5a5.1,5.1,0,0,0,3.6,5,11.3,11.3,0,0,0,3.2.4h26.9c.7,0,.9-.4.7-1a3.3,3.3,0,0,0-.6-.9l-6.3-7.3a1.9,1.9,0,0,0-1.6-.7H499.8a9.5,9.5,0,0,1-2.3-.3c-1.3-.4-1.7-1-1.7-2.4q-.1-8.9-.1-17.9c0-1.8.6-2.5,2.3-3h23.3c1.4,0,1.9.5,2,1.9s0,.8,0,1.3q0,13.8-.1,27.6a2.4,2.4,0,0,0,2.5,2.7H531A2.3,2.3,0,0,0,533.5,390.2Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='s' d='M363.2,326.6a2.7,2.7,0,0,1,2.5,2.8c0,1.6,0,3.3,0,4.9a2.3,2.3,0,0,1-2,2.3h-2.2l-79.9-.3c-2-.1-3.1.9-3.2,3-.1,4.7-.1,9.4,0,14.1a2.7,2.7,0,0,0,3,2.7h23.6a9,9,0,0,1,5.2,1.6,5.3,5.3,0,0,1,2.2,4.3c.2,2.5.2,5,.2,7.5,0,5.9,0,11.8,0,17.7A5.8,5.8,0,0,1,307,393H270.6l-1.2-.3a4.8,4.8,0,0,1,.6-1l4.2-4.3c1.4-1.5,2.9-2.9,4.4-4.3a2.8,2.8,0,0,1,1.7-.5h19.3c2.3,0,3.1-.7,3.1-3s-.1-7.3-.2-10.9c0-1.5-1-2.3-2.8-2.4H275.8a7.2,7.2,0,0,1-7.1-5.5,3.8,3.8,0,0,1-.1-1c0-8.4-.1-16.8,0-25.2.1-4.4,2.1-7.8,7.4-8.1C279,326.4,361.8,326.5,363.2,326.6Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='y' d='M387.2,326.2h11.5c1.8,3.4,4.3,8,6.2,11.3a40.2,40.2,0,0,0,2.6,3.8c.5.7.9.3,1.2-.2l5.2-9.1,3.3-5.9h75.7c.5,0,.5.9.1,1.3l-8.9,8.2a2.1,2.1,0,0,1-1.3.3H425.7a1.3,1.3,0,0,0-1.3.8c-2.5,4.6-4.9,9.3-7.6,13.7-.9,1.4-2.3,4.2-2.3,4.2s-.4,26.7-.5,35.3c0,1.4-.7,2.6-1.9,2.6H405c-1.8,0-2.7-.7-2.7-2.5,0-7.9-.1-16.2-.1-24,0-3.4.1-7.7,0-11l-.9-1.9c-4.5-8.9-8.9-16.8-13.5-25.6C387.6,327.4,387.4,326.7,387.2,326.2Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='Su' d='M318.6,364.6q0-10.7,0-21.4a2.4,2.4,0,0,1,2.4-2.5h5.2a2.4,2.4,0,0,1,2.6,2.6q.1,17.9.2,35.9c0,2.3.8,3.2,3.2,3.2h21.8c.9,0,1.3-.3,1.3-1.3q0-12.1,0-24.1c0-4.6.1-9.2.2-13.7,0-1.3.5-2.5,2.3-2.5h5.4a2.7,2.7,0,0,1,2.6,3c0,1.2-.2,19.3-.2,27.1,0,5.3.1,10.6,0,15.9a6.9,6.9,0,0,1-1.6,4.9,3.6,3.6,0,0,1-2.8,1.2H333.7c-3.1,0-6.2.2-9.3,0s-5.8-1.8-5.8-5.6c0-7.6,0-15.2,0-22.7Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='Yu' d='M432.9,364.8q0-10.7,0-21.5c0-2.3.8-3.1,3.1-3.1h4.1a2.6,2.6,0,0,1,2.7,3c0,1,.1,2,.1,3q0,16.1,0,32.2c0,.4,0,.8,0,1.2a2.3,2.3,0,0,0,2.6,2.4h20.7c2,0,2.9-.8,3.2-2.8a22.7,22.7,0,0,0,.1-2.4c0-11,0-23.7,0-34.7a1.8,1.8,0,0,1,1.8-1.3H478a1.9,1.9,0,0,1,1.9,2c0,1.3,0,2.6,0,3.9q0,15.2.1,30.4,0,4.5.1,8.9c0,2.5-.7,4.7-3.1,5.9a6.8,6.8,0,0,1-2.4.6c-4.4.3-11.7.1-17.6.1H438.9c-3.8,0-5.6-1.8-5.8-5.3-.1-1.9-.1-3.9-.1-5.8,0-5.5,0-11.1,0-16.6Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='i-lower' d='M372.6,366.2q0-11.4,0-22.9c0-1.7.7-2.4,2.3-2.5h5.5c.9,0,2.2.3,2.3,1.5s.1,2.7.1,4q.1,22.3,0,44.5c0,1.5-.3,1.8-1.8,1.9h-7.2a1.4,1.4,0,0,1-1.3-1.4C372.4,383.6,372.5,366.2,372.6,366.2Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='i-upper' d='M377.4,326.3h-2.8a3.7,3.7,0,0,0-3.9,3.7c0,.9,0,2.2,0,3.2a3.1,3.1,0,0,0,2.8,2.9c2.5.2,4.7.1,7.2.1a2.7,2.7,0,0,0,2.7-2.8c0-1,0-2.8,0-3.9a3.5,3.5,0,0,0-3.1-3.1Z' transform='translate(-268.6 -160.1)'/&gt; &lt;path fill-opacity='0' stroke-width='3' stroke='#1d815e' id='logo_path' d='M354.1,298.4m85.8-14.3a54.6,54.6,0,0,1-16.6,4.3,57.8,57.8,0,0,1-9.7.1,55.7,55.7,0,0,1-9.6-1.5,58.6,58.6,0,0,1-12.1-4.5,56.9,56.9,0,0,1-15.7-12,63.5,63.5,0,0,1-5.4-6.9c-2.1-3.1-3.2-5.6-3.6-6.2a8.2,8.2,0,0,0-3.6-3.5,8.1,8.1,0,0,0-10.8,3.7,8,8,0,0,0,.1,7.2,69.8,69.8,0,0,0,4,7.1c2.2,3.3,4.9,6.7,5.5,7.4a72.6,72.6,0,0,0,11.6,11,71.5,71.5,0,0,0,14.4,8.5,75.6,75.6,0,0,0,13.9,4.5c1.9.4,4.6.9,6.3,1.1s6.8.6,8.3.6a77.5,77.5,0,0,0,17.6-1.9,72.5,72.5,0,0,0,17.4-6.6c1.7-.9,4.6-2.7,6.3-3.8a95.2,95.2,0,0,0,8.5-6.7,106,106,0,0,0,8.3-8.9,62.9,62.9,0,0,0,4.9-7.2c.9-1.4,2.4-4.4,3.6-6.8a74.6,74.6,0,0,0,4-10.8,76.1,76.1,0,0,0,2.3-12c.1-1.7.4-5.7.4-8.3s-.3-5.7-.3-5.8a74.8,74.8,0,0,0-3.1-15.2,81.1,81.1,0,0,0-4.1-10.2,8.2,8.2,0,0,0-12.5-2.6,8.3,8.3,0,0,0-2.4,3.5,8.3,8.3,0,0,0,.1,5.8,52.5,52.5,0,0,1,3.5,8.4c.6,2,1.2,4.3,1.4,5.2a23,23,0,0,1,.3,3.3,5.5,5.5,0,0,1-3.3,4.2c-2,.8-3.9.6-6.8-1-7.5-4.3-16.7-4.8-21.3-4.8-7.6-.1-16.8,3.4-21.9,5.6-13.5,5.9-15.7,8.3-23.9,8.3a25.5,25.5,0,0,1-18.1-7.8,25.2,25.2,0,0,1-7-15.8,24.1,24.1,0,0,1,1.5-10.7,25.7,25.7,0,0,1,3.8-6.8c1.6-2.1,3.9-4.2,8.1-7.5a61.1,61.1,0,0,1,12.6-7.1,54,54,0,0,1,12.7-3.5,65.6,65.6,0,0,1,15-.1,58.2,58.2,0,0,1,15.4,4.1,52.8,52.8,0,0,1,8.8,4.7c2.1,1.4,3.6,2.6,5.9,4.4a8.4,8.4,0,0,0,8.6.1,7.8,7.8,0,0,0,3.6-4.8,8.2,8.2,0,0,0-2.9-8.7l-3.8-2.9a77.9,77.9,0,0,0-7.1-4.5,72.4,72.4,0,0,0-9.1-4.3,70.7,70.7,0,0,0-19.3-4.5,73.8,73.8,0,0,0-15.9.3,69,69,0,0,0-14.7,3.5,57.7,57.7,0,0,0-8.9,3.9,51.2,51.2,0,0,0-8.1,4.8,63.7,63.7,0,0,0-14.1,13.1,40.9,40.9,0,0,0-6.5,13,38.7,38.7,0,0,0-1.7,10.7,43,43,0,0,0,2.6,15.6,42.2,42.2,0,0,0,9,14.1,43.7,43.7,0,0,0,13.4,9.3c8.3,3.5,13.6,3.3,18.3,3.4,12.1-.9,15-4.6,28-9.7s21.1-3.5,26.5-1.8,9.6,3.2,12.2,9.4a13.9,13.9,0,0,1,.8,5.2,33.2,33.2,0,0,1-1,6,24.6,24.6,0,0,1-3.3,7,22.7,22.7,0,0,1-2.1,2.8l-1.9,2c-.8.8-5.5,4.5-6.2,5.1C447.7,280.4,442.5,283,439.9,284.1Z' transform='translate(-268.6 -160.1)'/&gt; "); //设置SVG内部id 的动画效果 var bar_Su = new ProgressBar.Path('#Su', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_Su.set(0); bar_path_Su = bar_Su;//赋值到全局变量上，供后面使用 var bar_S = new ProgressBar.Path('#s', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_S.set(0); bar_path_S = bar_S; var bar_i_upper = new ProgressBar.Path('#i-upper', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_i_upper.set(0); bar_path_i_upper = bar_i_upper; var bar_i_lower = new ProgressBar.Path('#i-lower', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_i_lower.set(0); bar_path_i_lower = bar_i_lower; var bar_Y = new ProgressBar.Path('#y', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_Y.set(0); bar_path_Y = bar_Y; var bar_Yu = new ProgressBar.Path('#Yu', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_Yu.set(0); bar_path_Yu = bar_Yu; var bar_an = new ProgressBar.Path('#an', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_an.set(0); bar_path_an = bar_an; var bar_logo = new ProgressBar.Path('#logo_path', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_logo.set(0); bar_path_logo = bar_logo;&#125;);/*************************//***添加tooltip的函数封装***//************************/function tooltip_anim(id,text,direction,animateType,color)&#123; var tooltip = new HTML5TooltipUIComponent; var target = document.getElementById(id); //预设没有传参的数据 animateType = animateType ===undefined ? "scalein" : animateType; color = color === undefined ? 'bamboo' :color; direction = direction === undefined ?'left':direction; tooltip.set(&#123; animateFunction: animateType, color: color, contentText: text, stickTo: direction, target: target &#125;); target.addEventListener('mouseenter',function()&#123; tooltip.show();//鼠标在上面时显示tooltip &#125;); target.addEventListener('mouseleave',function()&#123; tooltip.hide();//鼠标离开时取消显示 &#125;); tooltip.mount(); return tooltip;&#125;/************************//*****识别手机横竖屏状态****//*****调整按钮图标的大小****//************************/var screen_horizontal_check = true;//判断手机横竖屏状态： 参考网上的代码function hengshuping()&#123; if(window.orientation==180||window.orientation==0) &#123; //alert("竖屏状态！") large_ico(); screen_horizontal_check = true; &#125; if(window.orientation==90||window.orientation==-90) &#123; //alert("横屏状态！") tiny_ico(); screen_horizontal_check = false; &#125; &#125; hengshuping();//打开网页就进行识别window.addEventListener("onorientationchange" in window ? "orientationchange" : "resize", hengshuping, false); //移动设备适应图标大小function ico_size()&#123; if(isMobile.any == true &amp;&amp; full_screen_check == false)&#123; //默认打开网页额时候放大按钮 if(screen_horizontal_check)&#123; large_ico(); &#125; &#125;else&#123; //当全屏的时候 恢复按钮大小 tiny_ico(); &#125;&#125;//大图标 设置的函数function large_ico()&#123; $("#main").css('padding','20px 48px '); $("#main").css('font-size','100px '); $("#help_btn").attr('width','64px'); $("#full_btn").attr('width','64px'); $("#share_btn").attr('width','64px'); $("#stop_btn").attr('width','64px'); $("#origin_btn").attr('width','64px'); $("#color_dark_btn").attr('width','64px'); $("#color_white_btn").attr('width','64px'); $("#help_btn").attr('height','64px'); $("#full_btn").attr('height','64px'); $("#share_btn").attr('height','64px'); $("#stop_btn").attr('height','64px'); $("#origin_btn").attr('height','64px'); $("#color_dark_btn").attr('height','64px'); $("#color_white_btn").attr('height','64px'); $("#help_btn").css('padding','20px 20px'); $("#full_btn").css('padding','20px 20px'); $("#share_btn").css('padding','20px 20px'); $("#stop_btn").css('padding','20px 20px'); $("#origin_btn").css('padding','20px 20px'); $("#color_dark_btn").css('padding','20px 20px'); $("#color_white_btn").css('padding','20px 20px'); $("#help_btn").css('bottom','200px'); $("#full_btn").css('bottom','325px'); $("#share_btn").css('bottom','450px'); $("#stop_btn").css('bottom','575px'); $("#origin_btn").css('bottom','700px'); $("#color_dark_btn").css('bottom','450px'); $("#color_white_btn").css('bottom','450px'); $("#help_btn").css('right','50px'); $("#full_btn").css('right','50px'); $("#share_btn").css('right','50px'); $("#stop_btn").css('right','50px'); $("#origin_btn").css('right','50px'); $("#color_dark_btn").css('right','160px'); $("#color_white_btn").css('right','270px');&#125;//小图标 其实就是默认图标大小function tiny_ico()&#123; $("#main").css('padding','1px 15px '); $("#main").css('font-size','50px '); $("#help_btn").attr('width','32px'); $("#full_btn").attr('width','32px'); $("#share_btn").attr('width','32px'); $("#stop_btn").attr('width','32px'); $("#origin_btn").attr('width','32px'); $("#color_dark_btn").attr('width','32px'); $("#color_white_btn").attr('width','32px'); $("#help_btn").attr('height','32px'); $("#full_btn").attr('height','32px'); $("#share_btn").attr('height','32px'); $("#stop_btn").attr('height','32px'); $("#origin_btn").attr('height','32px'); $("#color_dark_btn").attr('height','32px'); $("#color_white_btn").attr('height','32px'); $("#help_btn").css('padding','5px 5px'); $("#full_btn").css('padding','5px 5px'); $("#share_btn").css('padding','5px 5px'); $("#stop_btn").css('padding','5px 5px'); $("#origin_btn").css('padding','5px 5px'); $("#color_dark_btn").css('padding','5px 5px'); $("#color_white_btn").css('padding','5px 5px'); $("#help_btn").css('bottom','100px'); $("#full_btn").css('bottom','150px'); $("#share_btn").css('bottom','200px'); $("#stop_btn").css('bottom','250px'); $("#origin_btn").css('bottom','300px'); $("#color_dark_btn").css('bottom','200px'); $("#color_white_btn").css('bottom','200px'); $("#help_btn").css('right','30px'); $("#full_btn").css('right','30px'); $("#share_btn").css('right','30px'); $("#stop_btn").css('right','30px'); $("#origin_btn").css('right','30px'); $("#color_dark_btn").css('right','80px'); $("#color_white_btn").css('right','130px');&#125;/*************************//*******实现按钮功能********//************************//*主菜单 显示按钮功能*/function icon_display()&#123; $("#help_btn").fadeToggle(100); $("#full_btn").fadeToggle(200); $("#share_btn").fadeToggle(300); $("#stop_btn").fadeToggle(400); $("#origin_btn").fadeToggle(500); $("#color_dark_btn").hide(); $("#color_white_btn").hide(); &#125;/*按帮助按钮弹出窗口*/function help_display()&#123; //检测是否是移动设备 弹出不同的帮助文档 分别指示触摸和鼠标 if(isMobile.any)&#123; //这里使用picoModal的弹框 代码引用自官方文档 picoModal(&#123; content: "&lt;div style= 'float:left; margin:10px 10px ;'&gt;&lt;center&gt;&lt;img src = 'http://webgl.suiyuankj.com/images/ico/sync.ico' width='100px' height='100px'&gt;&lt;/br&gt;单手滑动进行旋转&lt;/center&gt;&lt;/div&gt;" + "&lt;div style= 'float:left; margin:10px 10px ;'&gt;&lt;center&gt;&lt;img src = 'http://webgl.suiyuankj.com/images/ico/sync.ico' width='100px' height='100px'&gt;&lt;/br&gt;双手滑动进行缩放&lt;/center&gt;&lt;/div&gt;" + "&lt;div style= 'float:left; margin:10px 10px ;'&gt;&lt;center&gt;&lt;img src = 'http://webgl.suiyuankj.com/images/ico/sync.ico' width='100px' height='100px'&gt;&lt;/br&gt;三指滑动进行平移&lt;/center&gt;&lt;/div&gt;" , overlayStyles: function ( styles ) &#123; styles.opacity = 0; &#125;, modalStyles: function ( styles ) &#123; styles.opacity = 0; &#125; &#125;) .afterShow(function(modal)&#123; $(modal.overlayElem()).animate(&#123;opacity: .5&#125;); $(modal.modalElem()).animate(&#123;opacity: 1&#125;); &#125;) .beforeClose(function(modal, event) &#123; event.preventDefault(); $(modal.overlayElem()).add(modal.modalElem()) .animate( &#123; opacity: 0 &#125;, &#123; complete: modal.forceClose &#125; ); &#125;) .show(); &#125;else&#123; //这里使用picoModal的弹框 代码引用自官方文档 picoModal(&#123; content: "&lt;div style= 'float:left; margin:10px 10px ;'&gt;&lt;center&gt;&lt;img src = 'http://webgl.suiyuankj.com/images/ico/sync.ico' width='100px' height='100px'&gt;&lt;/br&gt;鼠标左键进行旋转&lt;/center&gt;&lt;/div&gt;" + "&lt;div style= 'float:left; margin:10px 10px ;'&gt;&lt;center&gt;&lt;img src = 'http://webgl.suiyuankj.com/images/ico/sync.ico' width='100px' height='100px'&gt;&lt;/br&gt;鼠标滚轮进行缩放&lt;/center&gt;&lt;/div&gt;" + "&lt;div style= 'float:left; margin:10px 10px ;'&gt;&lt;center&gt;&lt;img src = 'http://webgl.suiyuankj.com/images/ico/sync.ico' width='100px' height='100px'&gt;&lt;/br&gt;鼠标右键进行平移&lt;/center&gt;&lt;/div&gt;" , overlayStyles: function ( styles ) &#123; styles.opacity = 0; &#125;, modalStyles: function ( styles ) &#123; styles.opacity = 0; &#125; &#125;) .afterShow(function(modal)&#123; $(modal.overlayElem()).animate(&#123;opacity: .5&#125;); $(modal.modalElem()).animate(&#123;opacity: 1&#125;); &#125;) .beforeClose(function(modal, event) &#123; event.preventDefault(); $(modal.overlayElem()).add(modal.modalElem()) .animate( &#123; opacity: 0 &#125;, &#123; complete: modal.forceClose &#125; ); &#125;) .show(); &#125; &#125;/*分享按钮*/ //现在是背景颜色修改功能了 233var share_click = true;function share_display()&#123; if(share_click)&#123; tooltip_background.set(&#123;stickTo:"right"&#125;); share_click = false; $("#color_dark_btn").toggle(500); $("#color_white_btn").toggle(500); &#125;else&#123; tooltip_background.set(&#123;stickTo:"left"&#125;); share_click = true; $("#color_dark_btn").toggle(500); $("#color_white_btn").toggle(500); &#125; &#125;//更改背景颜色的函数function dark_BG()&#123; scene.background = new THREE.Color( 0x333333 );//灰色背景 &#125;function white_BG()&#123; scene.background = new THREE.Color( 0xF0FFFF );//白蓝色背景 &#125;/*旋转停止按钮*/var rotate_check = true;function rotate_stop()&#123; if(rotate_check)&#123; rotate_check=false; $("#stop_btn").attr("src","http://webgl.suiyuankj.com/images/ico/jumplist_startalltask.ico"); //修改图标 tooltip_stop.set(&#123;contentText:"开始旋转"&#125;);//修改tooltip提示 html5tooltips.refresh(); &#125;else&#123; rotate_check=true; $("#stop_btn").attr("src","http://webgl.suiyuankj.com/images/ico/jumplist_pausealltask.ico");//修改图标 tooltip_stop.set(&#123;contentText:'暂停旋转'&#125;);//修改tooltip提示 html5tooltips.refresh(); &#125; &#125;/*设置全屏函数，供全屏按钮调用*/var full_screen_check = false;function full_screen_fun()&#123; if(full_screen_check)&#123; exitFull();//退出全屏 ico_size();//自动检测 自适应图标大小 &#125;else&#123; requestFullScreen(document.documentElement);// 全屏整个网页 ico_size();//自动检测 自适应图标大小 &#125; &#125;;//全屏功能function requestFullScreen(element) &#123; // 判断各种浏览器，找到正确的方法 full_screen_check = true; var requestMethod = element.requestFullScreen || //W3C element.webkitRequestFullScreen || //Chrome等 element.mozRequestFullScreen || //FireFox element.msRequestFullScreen; //IE11 if (requestMethod) &#123; requestMethod.call(element); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125;&#125;//退出全屏 判断浏览器种类function exitFull() &#123; full_screen_check = false; // 判断各种浏览器，找到正确的方法 var exitMethod = document.exitFullscreen || //W3C document.mozCancelFullScreen || //Chrome等 document.webkitExitFullscreen || //FireFox document.webkitExitFullscreen; //IE11 if (exitMethod) &#123; exitMethod.call(document); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125;&#125; //摄像机回到默认位置var camera_check;//默认摄像机就会自动归位function origin_position()&#123; camera_check = true; //点击归位按钮自动归位&#125;/*获取摄像机位置初值 采用vector向量约束*/var cameraPosX,cameraPosY,cameraPosZ;cameraPosX = 5;cameraPosY = 2;cameraPosZ = 3;var PosRange = 0.3;var PosChange = 0.3;//摄像机位置修正 functionfunction cameraFix()&#123; //约束摄像机目标点 if(camera_orbitControl_check)&#123; controls.target = new THREE.Vector3(0, 0, 0) &#125; //摄像机位置修正 通过持续递减和递增让摄像机复位 if( camera.position.x &gt;= cameraPosX+PosRange)&#123; camera.position.x -= PosChange; &#125; if( camera.position.x &lt;= cameraPosX-PosRange)&#123; camera.position.x += PosChange; &#125; if( camera.position.y &gt;= cameraPosY+PosRange)&#123; camera.position.y -= PosChange; &#125; if( camera.position.y &lt;= cameraPosY-PosRange)&#123; camera.position.y += PosChange; &#125; if( camera.position.z &gt;= cameraPosZ+PosRange)&#123; camera.position.z -= PosChange; &#125; if( camera.position.z &lt;= cameraPosZ-PosRange)&#123; camera.position.z += PosChange; &#125; //复位完成 关闭修正功能 if(camera.position.x &lt;= cameraPosX+PosChange &amp;&amp; camera.position.x &gt;= cameraPosX-PosChange &amp;&amp;camera.position.y &lt;= cameraPosY+PosChange &amp;&amp; camera.position.y &gt;= cameraPosY-PosChange &amp;&amp;camera.position.z &lt;= cameraPosZ+PosChange &amp;&amp; camera.position.z &gt;= cameraPosZ-PosChange )&#123; camera_check = false; &#125; &#125;/************************//******自动化按钮函数******//************************///自动修正摄像机位置var cameraTimer;var rotateTimer;//旋转时停止旋转document.getElementById("webgl").addEventListener('touchstart',rotate_AutoStop_0,false );document.getElementById("webgl").addEventListener('touchend', rotate_AutoStop_1, false );document.getElementById("webgl").addEventListener( 'mousedown',rotate_AutoStop_0,false );document.getElementById("webgl").addEventListener( 'mouseup', rotate_AutoStop_1, false );rotateTimer = setTimeout("rotate_stop();",10000);//定时10秒之后自动旋转function rotate_AutoStop_0()&#123; clearTimeout(rotateTimer); //clearTimeout(cameraTimer); rotate_check = true; rotate_stop();&#125;function rotate_AutoStop_1()&#123; rotateTimer=setTimeout("rotate_stop();",3000); //cameraTimer=setTimeout("camera_check = true;",10000);&#125;/************************//************************//************************///这段代码可以在右上角显示帧率//需要stats.min.js支持var stats = new Stats(); stats.setMode(0); stats.domElement.style.position = 'absolute'; stats.domElement.style.left = '0px'; stats.domElement.style.top = '0px'; document.body.appendChild(stats.domElement); /************************//*****webgl报错函数********//************************///浏览器不支持webgl时 弹出消息的函数 此处调用在最顶部function webgl_fail() &#123; //这里依然采用picoModal插件 代码复制自官方（修改弹出内容） picoModal(&#123; content: "&lt;center&gt;&lt;strong&gt;当前浏览器没有webgl功能&lt;/br&gt;无法浏览本页面的的内容&lt;/br&gt;您可以更新版本或者使用其他浏览器&lt;/br&gt;推荐使用最新版的chrome浏览器&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;" , overlayStyles: function ( styles ) &#123; styles.opacity = 0; &#125;, modalStyles: function ( styles ) &#123; styles.opacity = 0; &#125; &#125;) .afterShow(function(modal)&#123; $(modal.overlayElem()).animate(&#123;opacity: .5&#125;); $(modal.modalElem()).animate(&#123;opacity: 1&#125;); &#125;) .beforeClose(function(modal, event) &#123; event.preventDefault(); $(modal.overlayElem()).add(modal.modalElem()) .animate( &#123; opacity: 0 &#125;, &#123; complete: modal.forceClose &#125; ); &#125;) .show();&#125;//浏览器未开启webgl 弹出消息的函数function webgl_update() &#123; picoModal(&#123; content: "&lt;center&gt;&lt;strong&gt;当前浏览器没有开启webgl 无法加载本页面&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;&lt;/br&gt;" + "&lt;center&gt;&lt;strong&gt;需要在浏览器中开启 硬件加速功能 以加载webgl&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;&lt;/br&gt;" + "&lt;center&gt;&lt;strong&gt;如果开启 硬件加速功能 不能解决问题&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;" + "&lt;center&gt;&lt;strong&gt;说明你的显卡较弱被浏览器屏蔽&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;" + "&lt;center&gt;&lt;strong&gt;你需要在浏览器上的地址上输入\"chrome://flags\"&lt;/br&gt;启用Override software rendering list 选项&lt;/br&gt;（中文译名为：覆盖软件渲染列表）&lt;/br&gt;然后重启浏览器&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;" + "&lt;center&gt;&lt;strong&gt;上述解决方案来自 &lt;a href='https://www.zhihu.com/question/19647275'&gt;@知乎&lt;/a&gt;&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;" + "&lt;center&gt;&lt;strong&gt;更多解决方案 &lt;a href='http://blog.csdn.net/long405581649/article/details/22614153'&gt;@链接&lt;/a&gt;&lt;strong&gt;&lt;/center&gt;&lt;/br&gt;" , overlayStyles: function ( styles ) &#123; styles.opacity = 0; &#125;, modalStyles: function ( styles ) &#123; styles.opacity = 0; &#125; &#125;) .afterShow(function(modal)&#123; $(modal.overlayElem()).animate(&#123;opacity: .5&#125;); $(modal.modalElem()).animate(&#123;opacity: 1&#125;); &#125;) .beforeClose(function(modal, event) &#123; event.preventDefault(); $(modal.overlayElem()).add(modal.modalElem()) .animate( &#123; opacity: 0 &#125;, &#123; complete: modal.forceClose &#125; ); &#125;) .show();&#125;/*****************************//*********搭建三维场景**********//*设置好望向坐标原点的orbit摄像机*//****************************/var scene = new THREE.Scene();//创建三维场景var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );//创建摄像机var renderer = new THREE.WebGLRenderer(&#123; antialias: true, alpha:false, preserveDrawingBuffer: false&#125;);//使用Webgl渲染 renderer.setSize( window.innerWidth - 3, window.innerHeight-3 );//设置渲染的范围大小renderer.setPixelRatio( window.devicePixelRatio );renderer.shadowMapEnabled = true; //为渲染器开启 深度贴图阴影renderer.shadowMapType = THREE.PCFSoftShadowMap;//将渲染的内容添加到HTML中document.getElementById('webgl').appendChild( renderer.domElement );//开启pointerLock摄像机var controls;var controlsEnabled = false;var moveForward = false;var moveBackward = false;var moveLeft = false;var moveRight = false;var canJump = false;var prevTime = performance.now();var velocity = new THREE.Vector3();var direction = new THREE.Vector3();//var raycaster;var objects = [];function camera_pointerLockControl()&#123; controls = new THREE.PointerLockControls( camera ); scene.add( controls.getObject() ); var onKeyDown = function ( event ) &#123; switch ( event.keyCode ) &#123; case 38: // up case 87: // w moveForward = true; break; case 37: // left case 65: // a moveLeft = true; break; case 40: // down case 83: // s moveBackward = true; break; case 39: // right case 68: // d moveRight = true; break; case 32: // space if ( canJump === true ) velocity.y += 250; canJump = false; break; &#125; &#125;; var onKeyUp = function ( event ) &#123; switch( event.keyCode ) &#123; case 38: // up case 87: // w moveForward = false; break; case 37: // left case 65: // a moveLeft = false; break; case 40: // down case 83: // s moveBackward = false; break; case 39: // right case 68: // d moveRight = false; break; &#125; &#125;; document.addEventListener( 'keydown', onKeyDown, false ); document.addEventListener( 'keyup', onKeyUp, false ); raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 ); &#125;function camera_pointerLockControl_block()&#123; $('#webgl').append("&lt;div id=\"blocker\"&gt;&lt;div id=\"instructions\"&gt;&lt;span style=\"font-size:40px\"&gt;点击开始&lt;/span&gt;&lt;br /&gt;(键盘WASD键可以移动, 空格键可以跳跃, 鼠标可以控制镜头)&lt;/div&gt;&lt;/div&gt;"); var blocker = document.getElementById( 'blocker' ); var instructions = document.getElementById( 'instructions' ); var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document; if ( havePointerLock ) &#123; var element = document.body; var pointerlockchange = function ( event ) &#123; if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) &#123; controlsEnabled = true; controls.enabled = true; blocker.style.display = 'none'; &#125; else &#123; controls.enabled = false; blocker.style.display = 'block'; instructions.style.display = ''; &#125; &#125;; var pointerlockerror = function ( event ) &#123; instructions.style.display = ''; &#125;; // Hook pointer lock state change events document.addEventListener( 'pointerlockchange', pointerlockchange, false ); document.addEventListener( 'mozpointerlockchange', pointerlockchange, false ); document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false ); document.addEventListener( 'pointerlockerror', pointerlockerror, false ); document.addEventListener( 'mozpointerlockerror', pointerlockerror, false ); document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false ); instructions.addEventListener( 'click', function ( event ) &#123; instructions.style.display = 'none'; // Ask the browser to lock the pointer element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock; element.requestPointerLock(); &#125;, false ); &#125; else &#123; instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API'; &#125;&#125;function camera_pointerLockControl_collison_detect()&#123; var angle = controls.getObject().rotation.y; var raycaster_top = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, 1, 0), 0, 1 ); raycaster_top.ray.origin.copy( controls.getObject().position ); var intersections_top = raycaster_top.intersectObjects( objects ); if ( intersections_top.length &gt; 0) &#123; //console.log("detect_top"); velocity.y = Math.min( 0, velocity.y ); &#125; var raycaster_front = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -Math.sin(angle), 0, -Math.cos(angle)), 0, 2 ); raycaster_front.ray.origin.copy( controls.getObject().position ); var intersections_front = raycaster_front.intersectObjects( objects ); if ( intersections_front.length &gt; 0) &#123; //console.log("detect_front"); velocity.z = Math.max( 0, velocity.z ); &#125; var raycaster_back = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -Math.sin(angle + Math.PI), 0, -Math.cos(angle + Math.PI)), 0, 2 ); raycaster_back.ray.origin.copy( controls.getObject().position ); var intersections_back = raycaster_back.intersectObjects( objects ); if ( intersections_back.length &gt; 0) &#123; //console.log("detect_back"); velocity.z = Math.min( 0, velocity.z ); &#125; var raycaster_left = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -Math.sin(angle + Math.PI/2), 0, -Math.cos(angle + Math.PI/2)), 0, 2 ); raycaster_left.ray.origin.copy( controls.getObject().position ); var intersections_left = raycaster_left.intersectObjects( objects ); if ( intersections_left.length &gt; 0) &#123; //console.log("detect_left"); velocity.x = Math.max( 0, velocity.x ); &#125; var raycaster_right = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -Math.sin(angle - Math.PI/2), 0, -Math.cos(angle - Math.PI/2)), 0, 2 ); raycaster_right.ray.origin.copy( controls.getObject().position ); var intersections_right = raycaster_right.intersectObjects( objects ); if ( intersections_right.length &gt; 0) &#123; //console.log("detect_right"); velocity.x = Math.min( 0, velocity.x ); &#125; var raycaster_down = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 ); raycaster_down.ray.origin.copy( controls.getObject().position ); //raycaster_down.ray.origin.y += 10; var intersections_down = raycaster_down.intersectObjects( objects ); if ( intersections_down.length &gt; 0) &#123; velocity.y = Math.max( 0, velocity.y ); canJump = true; &#125; var raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( -Math.sin(angle), 0, -Math.cos(angle)), 0, 5 ); raycaster.ray.origin.copy( controls.getObject().position ); var intersections = raycaster.intersectObjects( objects ); if ( intersections.length &gt; 0) &#123; /*var glowMesh = new THREEx.GeometricGlowMesh(intersections[0]) intersections[0].add(glowMesh.object3d) var insideUniforms = glowMesh.insideMesh.material.uniforms insideUniforms.glowColor.value.set('white') var outsideUniforms = glowMesh.outsideMesh.material.uniforms outsideUniforms.glowColor.value.set('white')*/ &#125;&#125;//开启orbit摄像机camera_orbitControl_check = false;function camera_orbitControl(minDistance,maxDistance,enableDamping,dampingFactor,rotateSpeed,zoomSpeed)&#123; camera_orbitControl_check = true; //启用orbit摄像机 可以实现环绕360度摄像机 支持缩放功能 需要OrbitControls.js支持 controls = new THREE.OrbitControls( camera, renderer.domElement ); //设置摄像机的位置（摄像机在0，0，0位置，看不见东西） camera.position.z = 25; camera.position.y = 20; camera.position.x = 25; controls.target = new THREE.Vector3(0, 0, 0); //camera.lookAt(new THREE.Vector3(0, 30, 0));//使摄像机望向原点 //这里为参数设置初值 /* a==b?b++:0 这个就是如果a等于b成立，就返回b++，如果不成立，就返回0 */ minDistance = minDistance === undefined ? 3 : minDistance; maxDistance = maxDistance === undefined ? 25 : maxDistance; enableDamping = enableDamping === undefined ? true : enableDamping; dampingFactor = dampingFactor === undefined ? 0.1 : dampingFactor; rotateSpeed = rotateSpeed === undefined ? 0.15 : rotateSpeed; zoomSpeed = zoomSpeed === undefined ? 1 : zoomSpeed; controls.enableDamping = enableDamping; controls.dampingFactor = dampingFactor; controls.rotateSpeed = rotateSpeed; controls.zoomSpeed = zoomSpeed; controls.maxDistance = maxDistance; controls.minDistance = minDistance;&#125;window.addEventListener('resize',function()&#123; //调节窗口大小的时候可以自动刷新界面（否则渲染界面大小不改变） var width = window.innerWidth - 3; var height = window.innerHeight -3; renderer.setSize(width,height); camera.aspect = width/height; camera.updateProjectionMatrix(); //当窗口过小的时候 图标放不下 所以使用小图标模式 if(width&lt;300 || height &lt; 300)&#123; $("#main").hide(); $("#help_btn").hide(); $("#full_btn").hide(); $("#share_btn").hide(); $("#stop_btn").hide(); $("#origin_btn").hide(); $("#color_white_btn_small").show(); $("#color_dark_btn_small").show(); &#125;else&#123; //当窗口够大回复默认状态 $("#main").show(); $("#color_white_btn_small").hide(); $("#color_dark_btn_small").hide(); &#125;&#125;)/*******************//*****初始化灯光******//*******************///初始化环境灯光 营造更好地灯光效果var ambientLight = getLight('ambient',1,0xFFFFFF);//var ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);//ambientLight.position.set( 3, 1, 10 );scene.add(ambientLight);//创建平行光 var directionalLight = getLight('directional',.7,0xFFFFFF);directionalLight.position.set( 3, 1, 10 );//scene.add(directionalLight);var helper = new THREE.DirectionalLightHelper( directionalLight, 5 );scene.add(helper);var rimLight = getLight('directional',0.5,0xFFFFFF);rimLight.position.set( 0, 0, -20 );//scene.add(rimLight);var rimhelper = new THREE.DirectionalLightHelper( rimLight, 5 );scene.add(rimhelper);var fillLight = getLight('directional',0.3,0xFFFFFF);fillLight.position.set( 3, 1, 10 );//scene.add(fillLight);var fillhelper = new THREE.DirectionalLightHelper( fillLight, 5 );scene.add(fillhelper);rimLight.castShadow =false ;//关闭投射阴影的功能fillLight.castShadow = false ;var threeLightState = true;function toggleThreeLight()&#123; if(threeLightState)&#123; scene.add(directionalLight); scene.add(rimLight); scene.add(fillLight); &#125;else&#123; scene.remove(directionalLight); scene.remove(rimLight); scene.remove(fillLight); &#125; &#125;//加载默认的白蓝色的背景scene.background = new THREE.Color( 0xF0FFFF );/*********/ /*函数封装*//********///加载环境环境贴图cubemapfunction getEnvMap(path , format , fileNames)&#123;//加载样式//var path = '../../js/three.js-master/examples/textures/cube/skyboxsun25deg/';//var format = '.jpg';//var fileNames = ['px', 'nx', 'py', 'ny', 'pz', 'nz']; //如果参数没有定义设置初值 path= path === undefined ? 'http://webgl.suiyuankj.com/js/three.js-master/examples/textures/cube/skyboxsun25deg/' : path; format= format === undefined ? '.jpg' : format; fileNames= fileNames === undefined ? ['px', 'nx', 'py', 'ny', 'pz', 'nz'] : format; var reflectionCube = new THREE.CubeTextureLoader(manager).load(fileNames.map(function(fileName) &#123; return path + fileName + format; &#125;)); return reflectionCube; //这里参考lynda教程的写法&#125;//材质函数封装//这个是获取材质阴影的一种奇葩的方法，因为没法解决，所以用这种荒唐的做法修正材质无法投射阴影的问题function shadowMaterial(selectedMaterial,castShadow,receiveShadow)&#123; var cube_obj = new THREE.BoxGeometry( 0.001, 0.001,0.001 ); var cube2 = new THREE.Mesh( cube_obj, selectedMaterial ); cube2.castShadow = castShadow; cube2.receiveShadow = receiveShadow; scene.add( cube2 );&#125;function getMaterial(type,color,shadow,castShadow,receiveShadow) &#123; var selectedMaterial; shadow = shadow === undefined ? true : shadow; castShadow = castShadow === undefined ? true : castShadow; receiveShadow = receiveShadow === undefined ? true : receiveShadow; var materialOptions = &#123; color: color === undefined ? 'rgb(255, 255, 255)' : color, side: THREE.DoubleSide &#125;;//这里如果color没有定义直接定义为纯白，否则就color的值 //下面是threejs内置的常用材质，可以加载第三方js来扩展材质 switch (type) &#123; case 'basic': selectedMaterial = new THREE.MeshBasicMaterial(materialOptions); break;//这个材质等同于Maya中的surface表面材质，不受灯光影响 case 'lambert': selectedMaterial = new THREE.MeshLambertMaterial(materialOptions); if(shadow)&#123; shadowMaterial(selectedMaterial,castShadow,receiveShadow); &#125; break;//这个材质等同于Maya中的lambert材质 case 'phong': selectedMaterial = new THREE.MeshPhongMaterial(materialOptions); if(shadow)&#123; shadowMaterial(selectedMaterial,castShadow,receiveShadow); &#125; break;//这个材质等同于Maya中的phong材质 case 'standard': selectedMaterial = new THREE.MeshStandardMaterial(materialOptions); if(shadow)&#123; shadowMaterial(selectedMaterial,castShadow,receiveShadow); &#125; break;//这个材质等同于unity的standrad材质，这个材质支持的功能相对较多，性能消耗最厉害 default: selectedMaterial = new THREE.MeshBasicMaterial(materialOptions); break;//默认是basic材质 &#125; return selectedMaterial;&#125;//获取灯光函数的封装function getLight(type,intensity, color, distant) &#123; var light_check = true; color = color === undefined ? 'rgb(255, 255, 255)' : color;//设置颜色，与材质的相同 distant = distant === undefined ? 50 : distant;//设置点光源初始值为50 switch (type) &#123; case 'spot': var light = new THREE.SpotLight(color, intensity); break;//创建聚光灯 case 'point': var light = new THREE.PointLight(color, intensity ,distant); break;//创建点光源 case 'directional': var light = new THREE.DirectionalLight(color, intensity); break;//创建平行光 case 'ambient': var light = new THREE.AmbientLight(color, intensity); light_check = false; break;//创建环境光 default: var light = new THREE.PointLight(color, intensity); break; &#125; //设置深度贴图的大小以及偏差值 if(light_check)&#123; light.penumbra = 0.5;//使灯光边缘柔化 light.castShadow = true;//开启阴影 light.shadow.mapSize.width = 1024;//设置深度贴图的大小 light.shadow.mapSize.height = 1024; light.shadow.bias = 0.001; //设置阴影偏差值 &#125; return light;&#125;//导入manager//进度条预加载 需要ProgressBar.js的支持 代码复制自官方var bar = new ProgressBar.Line(container, &#123; strokeWidth: 4, easing: 'easeInOut', duration: 1000, color: '#FFEA82', trailColor: '#eee', trailWidth: 1, svgStyle: &#123;width: '100%', height: '50%'&#125;, text: &#123; style: &#123; color: '#eee', position: 'absolute', right: '45%', top: '75%', padding: '5px', margin: 0, transform: null &#125;, autoStyleContainer: false &#125;, from: &#123;color: '#FFEA82'&#125;, to: &#123;color: '#1d815e'&#125;, step: (state, bar) =&gt; &#123; bar.path.setAttribute('stroke', state.color); bar.setText(Math.round(bar.value() * 100) + ' %'); &#125; &#125;);var manager = new THREE.LoadingManager(); manager.onStart = function ( url, itemsLoaded, itemsTotal ) &#123; console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' ); &#125;;manager.onLoad = function ( ) &#123; //添加logo 眼睛setTimeout(" $('#logo').append(\"&lt;svg id='svg_fill' style='position: absolute;left:0px;' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 600 400' &gt;&lt;defs&gt;&lt;style&gt;.a&#123;fill:none;&#125;.b&#123;fill:#1d815e;&#125;.c&#123;fill:#3ea251;&#125;&lt;/style&gt;&lt;/defs&gt; &lt;ellipse class='c' cx='127.2' cy='50.5' rx='15.2' ry='15.5'/&gt; &lt;path class='b' d='M354.1,298.4m85.8-14.3a54.6,54.6,0,0,1-16.6,4.3,57.8,57.8,0,0,1-9.7.1,55.7,55.7,0,0,1-9.6-1.5,58.6,58.6,0,0,1-12.1-4.5,56.9,56.9,0,0,1-15.7-12,63.5,63.5,0,0,1-5.4-6.9c-2.1-3.1-3.2-5.6-3.6-6.2a8.2,8.2,0,0,0-3.6-3.5,8.1,8.1,0,0,0-10.8,3.7,8,8,0,0,0,.1,7.2,69.8,69.8,0,0,0,4,7.1c2.2,3.3,4.9,6.7,5.5,7.4a72.6,72.6,0,0,0,11.6,11,71.5,71.5,0,0,0,14.4,8.5,75.6,75.6,0,0,0,13.9,4.5c1.9.4,4.6.9,6.3,1.1s6.8.6,8.3.6a77.5,77.5,0,0,0,17.6-1.9,72.5,72.5,0,0,0,17.4-6.6c1.7-.9,4.6-2.7,6.3-3.8a95.2,95.2,0,0,0,8.5-6.7,106,106,0,0,0,8.3-8.9,62.9,62.9,0,0,0,4.9-7.2c.9-1.4,2.4-4.4,3.6-6.8a74.6,74.6,0,0,0,4-10.8,76.1,76.1,0,0,0,2.3-12c.1-1.7.4-5.7.4-8.3s-.3-5.7-.3-5.8a74.8,74.8,0,0,0-3.1-15.2,81.1,81.1,0,0,0-4.1-10.2,8.2,8.2,0,0,0-12.5-2.6,8.3,8.3,0,0,0-2.4,3.5,8.3,8.3,0,0,0,.1,5.8,52.5,52.5,0,0,1,3.5,8.4c.6,2,1.2,4.3,1.4,5.2a23,23,0,0,1,.3,3.3,5.5,5.5,0,0,1-3.3,4.2c-2,.8-3.9.6-6.8-1-7.5-4.3-16.7-4.8-21.3-4.8-7.6-.1-16.8,3.4-21.9,5.6-13.5,5.9-15.7,8.3-23.9,8.3a25.5,25.5,0,0,1-18.1-7.8,25.2,25.2,0,0,1-7-15.8,24.1,24.1,0,0,1,1.5-10.7,25.7,25.7,0,0,1,3.8-6.8c1.6-2.1,3.9-4.2,8.1-7.5a61.1,61.1,0,0,1,12.6-7.1,54,54,0,0,1,12.7-3.5,65.6,65.6,0,0,1,15-.1,58.2,58.2,0,0,1,15.4,4.1,52.8,52.8,0,0,1,8.8,4.7c2.1,1.4,3.6,2.6,5.9,4.4a8.4,8.4,0,0,0,8.6.1,7.8,7.8,0,0,0,3.6-4.8,8.2,8.2,0,0,0-2.9-8.7l-3.8-2.9a77.9,77.9,0,0,0-7.1-4.5,72.4,72.4,0,0,0-9.1-4.3,70.7,70.7,0,0,0-19.3-4.5,73.8,73.8,0,0,0-15.9.3,69,69,0,0,0-14.7,3.5,57.7,57.7,0,0,0-8.9,3.9,51.2,51.2,0,0,0-8.1,4.8,63.7,63.7,0,0,0-14.1,13.1,40.9,40.9,0,0,0-6.5,13,38.7,38.7,0,0,0-1.7,10.7,43,43,0,0,0,2.6,15.6,42.2,42.2,0,0,0,9,14.1,43.7,43.7,0,0,0,13.4,9.3c8.3,3.5,13.6,3.3,18.3,3.4,12.1-.9,15-4.6,28-9.7s21.1-3.5,26.5-1.8,9.6,3.2,12.2,9.4a13.9,13.9,0,0,1,.8,5.2,33.2,33.2,0,0,1-1,6,24.6,24.6,0,0,1-3.3,7,22.7,22.7,0,0,1-2.1,2.8l-1.9,2c-.8.8-5.5,4.5-6.2,5.1C447.7,280.4,442.5,283,439.9,284.1Z' transform='translate(-268.6 -160.1)'/&gt;\");",1000); //使加载图标消失 setTimeout("$('#logo').fadeToggle(2000);",1000) ; //删除加载进度条 setTimeout("bar.destroy();",4000); setTimeout("$('bar_Su').remove();",4000); setTimeout("$('bar_S').remove();",4000); setTimeout("$('bar_i_upper').remove();",4000); setTimeout("$('bar_i_lower').remove();",4000); setTimeout("$('bar_Yu').remove();",4000); setTimeout("$('bar_an').remove();",4000); setTimeout("camera_check = true;",2500) ; //关闭镜头模糊 setTimeout("postprocessing.enabled = false;",2500) ; if(camera_orbitControl_check==false)&#123; setTimeout("camera_pointerLockControl_block();",2500); &#125; setTimeout("if(isMobile.any)&#123;full_screen_fun();&#125;",2500) ; console.log( 'Loading complete!');&#125;;manager.onProgress = function ( url, itemsLoaded, itemsTotal ) &#123; /* var bar_dot = new ProgressBar.Path('#dot', &#123; easing: 'easeInOut', duration: 1000 &#125;); bar_dot.set(0); bar_dot.animate(itemsLoaded/itemsTotal); */ bar.animate(itemsLoaded/itemsTotal); setTimeout("bar_path_Su.animate(1);",100); setTimeout("bar_path_S.animate(1); ",100); setTimeout("bar_path_i_upper.animate(1);",100); setTimeout("bar_path_i_lower.animate(1); ",100); setTimeout("bar_path_Y.animate(1); ",100); setTimeout("bar_path_Yu.animate(1); ",100); setTimeout("bar_path_an.animate(1);",100); console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );&#125;;manager.onError = function ( url ) &#123; console.log( 'There was an error loading ' + url );&#125;;//导入模型的封装函数function getModel(modelPath,mtl)&#123; //获取加载文件的后缀名var arr=modelPath.split('.');//通过点将路径字符串切分 var format = arr[arr.length-1];// 那么后缀名就是数组最后一个元素 switch(format)&#123; //通过switch匹配后缀名 //这里采用正则表达式进行后缀名匹配，忽略后缀名的大小写 case (format.match(/obj$/i)||&#123;&#125;).input: /*****************************/ /*********识别Obj加载**********/ /****************************/ //这里本来使用下面这个函数缩减代码量的，但是这样参数传递会导致未知的错误。 //getObjModel(modelPath,mtl); //为了稳定，我将代码从function里面拆了出来 //这些函数并没有删除，提供更多的加载选择。 //注意OBJ加载函数是背景模型加载专用的，加载OBJ要使用这个函数 var loader = new THREE.OBJLoader(manager);//加载Obj加载器，需要OBJLoader.js的支持 var model = new THREE.Group();//设置模型的大组，后面会return到外面 var GeoY = new Array();//这个function内部的全局变量，用来储存模型各个部分的最低点 //传入的参数如果是字符串 说明是路径 则加载mtlLoader 导入mtl文件 if(typeof(mtl) == 'string')&#123; //mtl为mtl文件路径 例如：'obj/bed.mtl' var arr=mtl.split('/');//按照/切割路径 var mtl_file = arr[arr.length-1];//获取路径中最后一个元素 即‘bed.mtl’ var arr = mtl.split(mtl_file);//按照最后一个元素切割路径 获取mtl文件之前的文件夹 即‘obj/’ var mtl_folder = arr[0]; THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader(manager) );//用于dds贴图的加载 var mtlLoader = new THREE.MTLLoader(manager);//需要MTLLoader.js的支持 mtlLoader.setPath( mtl_folder );//将mtl的文件夹路径设置进去 //设置mtl文件传入的材质的部分属性 这里添加双面材质及重复贴图的处理 mtlLoader.setMaterialOptions( &#123;side:THREE.DoubleSide,wrap:THREE.MirroredRepeatWrapping &#125; ); //加载mtl //输入传入的路径 mtlLoader.load( mtl_file, function( materials ) &#123; materials.preload();//这行代码官方有，但是不知道有什么作用，去掉也无影响。 loader.setMaterials( materials );//设置Obj的材质为mtl带有的材质 //加载Obj文件 loader.load( modelPath, function ( object ) &#123; object.traverse(function(child) &#123; //设置所有的子对象都可以投射和接受阴影 child.castShadow = true; child.receiveShadow = true; objects.push( child ); &#125; ); //完成OBJ文件的加载 //将模型添加到model组里面 model.add( object ); backgroundY = backgroundY ===undefined ? 0 :backgroundY;//设置初值 //让模型导入就到背景模型上 model.position.y += backgroundY; &#125;); &#125;); &#125; //传入的参数如果是材质（object）则直接赋到模型上 if(typeof(mtl) == 'object')&#123; loader.load(modelPath, function (object) &#123; //这里使用的方法与上面调用基本相同 object.traverse(function(child) &#123; child.material = mtl; child.castShadow = true; child.recieveShadow = true; objects.push( child ); &#125; ); //添加模型 model.add( object ); backgroundY = backgroundY ===undefined ? 0 :backgroundY; model.position.y += backgroundY; &#125;); &#125; return model;//返回模型 break;//结束OBJ的导入 //检测模型如果符合JSON的后缀名 case (format.match(/json$/i)||&#123;&#125;).input: /******************************/ /*********识别Json加载**********/ /*****************************/ var loader = new THREE.JSONLoader(manager);//加载JSON文件 只需要three.js的支持 var model = new THREE.Group(); loader.load( modelPath, function ( geometry, materials ) &#123; var mesh = new THREE.Mesh( geometry, materials );//将模型和材质添加到mesh中 mesh.castShadow = true; mesh.recieveShadow = true; model.add(mesh);//添加到model组中 objects.push( mesh ); backgroundY = backgroundY ===undefined ? 0 :backgroundY;//设置初值 model.position.y += backgroundY;//移动模型到地板上 &#125; ); /********************************/ /*********识别Object加载**********/ /*******************************/ var ObjectLoader = new THREE.ObjectLoader(manager); ObjectLoader.load(modelPath,function ( obj ) &#123; obj.castShadow = true; obj.recieveShadow = true; model.add(obj); objects.push( obj ); backgroundY = backgroundY ===undefined ? 0 :backgroundY;//设置初值 model.position.y += backgroundY;//移动模型到地板上 &#125; ); return model; break; // default:// return model;// break; &#125;&#125;//导入Object的函数封装function getObjectModel(modelPath,mtl)&#123; var ObjectLoader = new THREE.ObjectLoader(manager); var model = new THREE.Group(); ObjectLoader.load(modelPath,function ( obj ) &#123; obj.castShadow = true; obj.recieveShadow = true; model.add(obj); backgroundY = backgroundY ===undefined ? 0 :backgroundY;//设置初值 model.position.y += backgroundY;//移动模型到地板上 &#125; ); return model;&#125;//导入Json的函数封装function getJsonModel(modelPath,mtl)&#123; var loader = new THREE.JSONLoader(manager);//加载JSON文件 只需要three.js的支持 var model = new THREE.Group(); loader.load( modelPath, function ( geometry, materials ) &#123; //geometry.computeBoundingBox(); //获取模型的边界 mtl = mtl === undefined ? materials :mtl; var mesh = new THREE.Mesh( geometry, mtl );//将模型和材质添加到mesh中 mesh.castShadow = true; mesh.recieveShadow = true; model.add(mesh);//添加到model组中 //changePivot(0,min,0,model);//修改模型轴心点到最低点上 backgroundY = backgroundY ===undefined ? 0 :backgroundY;//设置初值 model.position.y += backgroundY;//移动模型到地板上 &#125; ); return model;&#125;//导入Obj的函数封装function getObjModel(modelPath,mtl,colorMap,bumpMap)&#123;var loader = new THREE.OBJLoader(manager);//加载Obj加载器，需要OBJLoader.js的支持 var model = new THREE.Group();//设置模型的大组，后面会return到外面 var GeoY = new Array();//这个function内部的全局变量，用来储存模型各个部分的最低点 //传入的参数如果是字符串 说明是路径 则加载mtlLoader 导入mtl文件 if(typeof(mtl) == 'string')&#123; //mtl为mtl文件路径 例如：'obj/bed.mtl' var arr=mtl.split('/');//按照/切割路径 var mtl_file = arr[arr.length-1];//获取路径中最后一个元素 即‘bed.mtl’ var arr = mtl.split(mtl_file);//按照最后一个元素切割路径 获取mtl文件之前的文件夹 即‘obj/’ var mtl_folder = arr[0]; THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader(manager) );//用于dds贴图的加载 var mtlLoader = new THREE.MTLLoader(manager);//需要MTLLoader.js的支持 mtlLoader.setPath( mtl_folder );//将mtl的文件夹路径设置进去 //设置mtl文件传入的材质的部分属性 这里添加双面材质及重复贴图的处理 mtlLoader.setMaterialOptions( &#123;side:THREE.DoubleSide,wrap:THREE.MirroredRepeatWrapping &#125; ); //加载mtl //输入传入的路径 mtlLoader.load( mtl_file, function( materials ) &#123; materials.preload();//这行代码官方有，但是不知道有什么作用，去掉也无影响。 loader.setMaterials( materials );//设置Obj的材质为mtl带有的材质 //加载Obj文件 loader.load( modelPath, function ( object ) &#123; object.traverse(function(child) &#123; //设置所有的子对象都可以投射和接受阴影 child.castShadow = true; child.recieveShadow = true; if(colorMap !== undefined)&#123; mtl.map = colorMap;//颜色贴图 &#125; if(bumpMap !== undefined)&#123; mtl.bumpMap = bumpMap;//凹凸贴图 &#125; &#125; ); //完成OBJ文件的加载 //将模型添加到model组里面 model.add( object ); backgroundY = backgroundY ===undefined ? 0 :backgroundY;//设置初值 //让模型导入就到背景模型上 model.position.y = backgroundY; &#125;); &#125;); &#125; //传入的参数如果是材质（object）则直接赋到模型上 if(typeof(mtl) == 'object')&#123; loader.load(modelPath, function (object) &#123; //这里使用的方法与上面调用基本相同 object.traverse(function(child) &#123; child.material = mtl; child.castShadow = true; child.recieveShadow = true; if(colorMap !== undefined)&#123; mtl.map = colorMap;//颜色贴图 &#125; if(bumpMap !== undefined)&#123; mtl.bumpMap = bumpMap;//凹凸贴图 &#125; &#125;, onProgress, onError ); //添加模型 model.add( object ); backgroundY = backgroundY ===undefined ? 0 :backgroundY; model.position.y = backgroundY; &#125;); &#125; return model;//返回模型&#125;//背景obj函数封装var background_obj_exist = false;var backgroundY;var background_material;function background_obj(objPath,background_mtl,positionY,scale)&#123; positionY = positionY === undefined ? -3 :positionY; scale = scale === undefined ? 1.1 : scale; switch (objPath) &#123; case 'capsule': var background_path = 'http://webgl.suiyuankj.com/assets/background_obj/background_capsule.obj'; break; default: var background_path = objPath; break; &#125; background_mtl = background_mtl === undefined ? getMaterial('standard',0x777777,true) :background_mtl; background_mtl.roughness = 1; var background_obj = getObjModel(background_path,background_mtl); scene.add(background_obj); background_obj.scale.x = background_obj.scale.y =background_obj.scale.z = scale; background_obj.position.y = positionY; backgroundY = positionY; background_obj_exist =true; background_material = background_mtl; background_material.transparent = true; return background_obj;&#125;//完成封装函数var modelgrp = new THREE.Group();scene.add(modelgrp);modelgrp.recieveShadow = true;modelgrp.castShadow = true;function finish_init(model,floorCheck,floorPoxY)&#123; modelgrp.add( model ); floorCheck = floorCheck === undefined ? false : floorCheck; floorPoxY = floorPoxY === undefined ? -3 : floorPoxY; _floorCheck = floorCheck; _floorPoxY = floorPoxY; update() ;&#125;//update函数封装 function update() &#123; //确保每秒刷新60次场景 requestAnimationFrame( update ); //通过camera的摄像机将场景渲染出来 renderer.render( scene, camera ); stats.update(); if(camera_orbitControl_check)&#123; controls.update(); &#125;else&#123; rotate_check = false; &#125; //实现摄像机回到初始位置 if(camera_check == true &amp;&amp; camera_orbitControl_check == true)&#123; cameraFix(); &#125; //实现模型自动旋转 if(rotate_check)&#123; modelgrp.rotation.y += 0.01; &#125; //锁定摄像机的最低位置 if(_floorCheck)&#123; if(camera.position.y &lt;_floorPoxY)&#123; camera.position.y = _floorPoxY; &#125; &#125; // if(transformControls_rotate)&#123; transformControls.setMode( "rotate" ); &#125; if(transformControls_translate)&#123; transformControls.setMode( "translate" ); &#125; if(transformControls_scale)&#123; transformControls.setMode( "scale" ); &#125; if(background_obj_exist)&#123; if(camera.position.y &lt;backgroundY + 3 &amp;&amp; background_material.opacity&gt;0)&#123; background_material.opacity -= 0.1; &#125; if(background_material.opacity&lt;0)&#123; background_material.opacity = 0; &#125; if(camera.position.y &gt;backgroundY &amp;&amp; background_material.opacity&lt;.5)&#123; background_material.opacity += 0.05; &#125; &#125; if ( controlsEnabled === true ) &#123; var time = performance.now(); var delta = ( time - prevTime ) / 1000; velocity.x -= velocity.x * 10.0 * delta; velocity.z -= velocity.z * 10.0 * delta; velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass direction.z = Number( moveForward ) - Number( moveBackward ); direction.x = Number( moveLeft ) - Number( moveRight ); direction.normalize(); // this ensures consistent movements in all directions if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta; if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta; camera_pointerLockControl_collison_detect(); ///////////////////////////////// controls.getObject().translateX( velocity.x * delta ); controls.getObject().translateY( velocity.y * delta ); controls.getObject().translateZ( velocity.z * delta ); if ( controls.getObject().position.y &lt; 10 ) &#123; velocity.y = 0; controls.getObject().position.y = 10; canJump = true; &#125; prevTime = time; &#125; postprocessing_blur();&#125;/****************************//***Postprocessing 后期处理***//***************************///Postprocessing 使场景模糊var postprocessing = &#123; enabled : true &#125;;var shaderSettings = &#123;rings: 3,samples: 4&#125;;function initPostprocessing() &#123; postprocessing.scene = new THREE.Scene(); postprocessing.camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, -10000, 10000 ); postprocessing.camera.position.z = 100; postprocessing.scene.add( postprocessing.camera ); var pars = &#123; minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat &#125;; postprocessing.rtTextureDepth = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars ); postprocessing.rtTextureColor = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, pars ); var bokeh_shader = THREE.BokehShader; postprocessing.bokeh_uniforms = THREE.UniformsUtils.clone( bokeh_shader.uniforms ); postprocessing.bokeh_uniforms[ "tColor" ].value = postprocessing.rtTextureColor.texture; postprocessing.bokeh_uniforms[ "tDepth" ].value = postprocessing.rtTextureDepth.texture; postprocessing.bokeh_uniforms[ "textureWidth" ].value = window.innerWidth; postprocessing.bokeh_uniforms[ "textureHeight" ].value = window.innerHeight; postprocessing.materialBokeh = new THREE.ShaderMaterial( &#123; uniforms: postprocessing.bokeh_uniforms, vertexShader: bokeh_shader.vertexShader, fragmentShader: bokeh_shader.fragmentShader, defines: &#123; RINGS: shaderSettings.rings, SAMPLES: shaderSettings.samples &#125; &#125; ); postprocessing.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( window.innerWidth, window.innerHeight ), postprocessing.materialBokeh ); postprocessing.quad.position.z = - 500; postprocessing.scene.add( postprocessing.quad ); postprocessing.bokeh_uniforms[ "maxblur" ].value = 3.0; postprocessing.bokeh_uniforms[ "manualdof" ].value = false; postprocessing.bokeh_uniforms[ "vignetting" ].value = false; postprocessing.bokeh_uniforms[ "depthblur" ].value = false; postprocessing.bokeh_uniforms[ "threshold" ].value = 0; postprocessing.bokeh_uniforms[ "gain" ].value = 0; postprocessing.bokeh_uniforms[ "bias" ].value = 0; postprocessing.bokeh_uniforms[ "fringe" ].value = 0;&#125;initPostprocessing();var material_depth = new THREE.MeshDepthMaterial();function postprocessing_blur()&#123; if ( postprocessing.enabled ) &#123; renderer.clear(); scene.overrideMaterial = null; renderer.render( scene, camera, postprocessing.rtTextureColor, true ); scene.overrideMaterial = material_depth; renderer.render( scene, camera, postprocessing.rtTextureDepth, true ); renderer.render( postprocessing.scene, postprocessing.camera ); &#125; else &#123; scene.overrideMaterial = null; renderer.clear(); renderer.render( scene, camera ); &#125;&#125;THREEx.Screenshot.bindKey(renderer);//实现按P键屏幕截图/****************//***设置调节GUI***//***************///设置灯光的位置directionalLight.position.x = 12;directionalLight.position.y = 18.5;directionalLight.position.z = 17;directionalLight.rotation.x = -0.5;directionalLight.rotation.y = 0.2;directionalLight.rotation.z = 0.25;fillLight.position.x = -20;fillLight.position.y = 14;fillLight.position.z = 9;fillLight.rotation.x = -0.9;fillLight.rotation.y = -1.1;fillLight.rotation.z = 0.28;//添加灯光的GUIvar gui = new dat.GUI();helper.visible = false;fillhelper.visible = false;rimhelper.visible = false;var h = gui.addFolder( "light control" );h.add( directionalLight, "intensity", 0, 20.0, .1 ).name( "光照强度" );h.add( directionalLight.position, "x", -20 , 20.0, 0.5 ).name( "PosX" );h.add( directionalLight.position, "y", -20, 20.0, 0.5).name( "PosY" );h.add( directionalLight.position, "z", -20, 20.0, 0.5 ).name( "PosZ" );h.add( directionalLight.rotation, "x", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180 ).name( "RotX" );h.add( directionalLight.rotation, "y", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180).name( "RotY" );h.add( directionalLight.rotation, "z", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180 ).name( "RotZ" );h.add(helper,"visible").name("灯光助手");var h = gui.addFolder( "rim control" );h.add( rimLight, "intensity", 0, 20.0, .1 ).name( "光照强度" );h.add( rimLight.position, "x", -20 , 20.0, 0.5 ).name( "PosX" );h.add( rimLight.position, "y", -20, 20.0, 0.5).name( "PosY" );h.add( rimLight.position, "z", -20, 20.0, 0.5 ).name( "PosZ" );h.add( rimLight.rotation, "x", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180 ).name( "RotX" );h.add( rimLight.rotation, "y", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180).name( "RotY" );h.add( rimLight.rotation, "z", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180 ).name( "RotZ" );h.add(rimhelper,"visible").name("灯光助手");var h = gui.addFolder( "fill control" );h.add( fillLight, "intensity", 0, 20.0, .1 ).name( "光照强度" );h.add( fillLight.position, "x", -20 , 20.0, 0.5 ).name( "PosX" );h.add( fillLight.position, "y", -20, 20.0, 0.5).name( "PosY" );h.add( fillLight.position, "z", -20, 20.0, 0.5 ).name( "PosZ" );h.add( fillLight.rotation, "x", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180 ).name( "RotX" );h.add( fillLight.rotation, "y", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180).name( "RotY" );h.add( fillLight.rotation, "z", -180* Math.PI /180, 180.0* Math.PI /180, 0.25* Math.PI /180 ).name( "RotZ" );h.add(fillhelper,"visible").name("灯光助手");var h = gui.addFolder( "ambient control" );h.add( ambientLight, "intensity", 0, 20.0, .1 ).name( "光照强度" );//双击主菜单按钮 可以开启高级模式 打开gui 和 帧率显示express();var express_check = true;function express()&#123; dat.GUI.toggleHide();//显示灯光控制 if(express_check)&#123; document.body.appendChild(stats.domElement); //添加帧率显示 express_check = false; express_control(); rotate_check = true; rotate_stop(); &#125;else&#123; document.body.removeChild(stats.domElement); express_check = true; scene.remove( gridHelper ); scene.remove( transformControls ); $("#panel").hide(); rotate_check = false; rotate_stop(); &#125; &#125;var transformControls,gridHelper;var transformControls_check = false;var transformControls_rotate = false;var transformControls_translate = false;var transformControls_scale = false;function express_control()&#123; transformControls_check = false; transformControls_check = true; //添加网格显示 gridHelper = new THREE.GridHelper( 10, 10 ); scene.add( gridHelper ); transformControls = new THREE.TransformControls( camera, renderer.domElement ); //selectControl.addEventListener( 'change', selectControl.update ); transformControls.attach( RotateGrp ); scene.add( transformControls ); $("#panel").show(); window.addEventListener( 'keydown', function ( event ) &#123; switch ( event.keyCode ) &#123; case 81: // Q transformControls.setSpace( transformControls.space === "local" ? "world" : "local" ); break; case 17: // Ctrl transformControls.setTranslationSnap( 100 ); transformControls.setRotationSnap( THREE.Math.degToRad( 15 ) ); break; case 87: // W transformControls.setMode( "translate" ); transformControls_rotate = false; transformControls_translate = true; transformControls_scale = false; break; case 69: // E transformControls.setMode( "rotate" ); transformControls_rotate = true; transformControls_translate = false; transformControls_scale = false; break; case 82: // R transformControls.setMode( "scale" ); transformControls_rotate = false; transformControls_translate = false; transformControls_scale = true; break; case 187: case 107: // +, =, num+ transformControls.setSize( transformControls.size + 0.1 ); break; case 189: case 109: // -, _, num- transformControls.setSize( Math.max( transformControls.size - 0.1, 0.1 ) ); break; &#125; &#125;); window.addEventListener( 'keyup', function ( event ) &#123; switch ( event.keyCode ) &#123; case 17: // Ctrl control.setTranslationSnap( null ); control.setRotationSnap( null ); break; &#125; &#125;); //object &#125; import.js参考写法1234567891011121314151617181920212223242526272829303132333435//加载贴图var textureLoader = new THREE.TextureLoader();var envPath = '../../js/three.js-master/examples/textures/cube/skyboxsun25deg/';var reflectionCube = getEnvMap(envPath);//调用scene_init-ver3.0 封装的环境贴图函数renderer.shadowMapEnabled = false;toggleThreeLight();//调用scene_init-ver3.0 封装的三点照明函数ambientLight.intensity = 0.5;scene.background = reflectionCube;//添加背景天空盒var RotateGrp = new THREE.Group();var background_mat = getMaterial('standard','rgb(180,160,120)');background_mat.roughness = 1;var path = 'obj/room.obj';var earphone = getModel(path,background_mat);//调用scene_init-ver3.0 封装的获取函数函数RotateGrp.add(earphone);//orbit控制//camera_orbitControl(2,40);//添加碰撞物体//objects.push(Group_test.children[0]);//pointerLock第一人称视角camera_pointerLockControl();//函数初始化完成finish_init(RotateGrp,true,-20);/*var capsule_obj = background_obj('../../assets/background_obj/background_disc.obj',background_mat,-3);background_obj.scale.x = background_obj.scale.y =background_obj.scale.z = 1;background_material.opacity = 0.5;*///background_obj.position.y -= 3;//RotateGrp.position.y = 6; 总结 这种写法是我还没有学习js面向对象以及js的设计模式时最笨的写法面向对象的问题是使用不灵活，很多时候需要在scene_init-ver3.0里面写相应的函数来匹配相应的功能变量全部是暴露的，容易产生莫名其妙的冲突]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zplus 教程系列（三）]]></title>
    <url>%2Fposts%2F34183.html</url>
    <content type="text"><![CDATA[雷电案例19：闪电的制作 操作逻辑 通过多个turbulence和resample可以将直线弄成比较弯曲的线 20：闪电分支添加 操作逻辑 通过vop给曲线标记颜色，通过颜色来删除曲线 获取曲线的ptnum以及点的总数 让点的总数减一 将ptnum转成浮点型 将ptnum与点数减一相除 获取的值赋值到颜色上，即可实现颜色从零到一的黑白渐变 加入ramp节点进行调节 操作细节 21：vopsop参数及效果控制 观看笔记 Polyframe节点可以添加切线和法线 操作逻辑 通过vop给曲线标记颜色，通过颜色来删除曲线上的点 通过copy节点根据撒的点复制曲线 给复制的曲线添加polyframe节点将tangent的信息写到N法线上 操作细节 添加point节点将法线的信息反转 22：vopsop参数及效果控制 观看笔记 rotate节点可以实现切线（法线）旋转 point函数可以获取到具体点序号的属性 scatter随意撒点导致撒的点不在曲线的点上，这导致后面合点会出问题 sort节点可以修改序号排序，甚至可以修改为随机 操作逻辑 添加point节点加入pscale属性 pscale加入随机数实现，实现随机大小 操作细节 加入Vop point 实现切线方向向左的往左偏移，向右的往右偏移 加入rotate节点乘到法线属性上实现偏移 加入random节点实现随机旋转 加入fit函数调整random输出值的范围 加入外部参数方便外部调节 加入vector to float节点获取N的X轴向 加入two way switch 节点进行判断切换 加入compare节点判断是否大于零 加入multiply constant来乘-1 实现大于零往正转，小于零往负转 操作细节 主干线加入ratio属性 copy节点加入stamp复制ratio 支线加入sub_ratio属性 实现支线从主干线的ratio值到1 操作细节 加入fuse节点合并顶点 通过表达式根据ratio删除点实现雷电的从零到一的效果 添加polywire添加实现多边形 添加normal节点修正法线 操作细节 雷电案例总结 &emsp;&emsp;雷电这个案例的逻辑还是挺复杂的，整理出来之后就清晰了很多，难点都在vop point里面。 玻璃裂痕案例23：玻璃裂纹制作思路 观看笔记 玻璃裂纹需要无序的点进行曲线复制 用曲线去模拟玻璃裂纹的感觉 通过int取整可以实现0.1 0.2 0.3的间隔取值 transfer attribute 可以实现将其他地方的属性传送到需要的地方中 操作逻辑 加入add节点添加点 用copy节点复制点 加入vop让点在平面上随机排布 操作细节 添加point节点，通过pscale加入随机的大小 添加line节点，并加多一些点，为后面传递颜色做准备&emsp;&emsp;曲线要让中心与原点居中，复制的时候才合理 添加transform节点来旋转直线 通过copy stamp来传递旋转值 用同样的方法制作弧线 弧线的pscale可以取整，看起来更加合理 另外弧线的长度也可以根据pscale的值进行调整 操作细节 通过color节点分别给弧线和直线添加黑和白的颜色 添加attribute transfer节点将直线的信息传递到弧线上 Distantce Threshold 来控制传递的精度 操作细节 通过attribute promote节点将point的Cd属性转成primitive&emsp;&emsp;promote的averge合并可以让曲线的颜色混合，没有传递到值的曲线颜色位黑色 删除黑色的弧线 去除颜色属性 通过merge合并 24：玻璃裂纹的蔓延动画及渲染 观看笔记 gourp节点的Bounding volume 可以用几何体去框选需要的点线面 box节点可以通过根据上面的bounding box生成大小 操作逻辑 加入sphere节点添加分组的用几何体 加入mountain节点给球加入随机效果 加入transform节点设置关键帧实现模型组件变大的效果 加入group节点进行分组 操作细节 加入point vop节点实现噪波（实现原理与上面撒点的一致） 加入delete节点进行删除，删除非打组的部分，实现模型由中心向外延伸 加入polyextrude节点挤压面&emsp;&emsp;挤压后需要去掉用于生成的曲线 操作细节 玻璃裂痕案例总结 &emsp;&emsp;这个案例也不复杂，逻辑理顺之后非常简单。&emsp;&emsp;最后的噪波实现如果按照教程赋予给多边形会导致每一帧模型都在变化，所以最后我把噪波加载曲线上了。 脚印案例25：solver节点的特点 观看笔记 solver节点可以实现根据时间累加的效果 脚印就是将相应的面往下拉，只要模型的细分足够就可以看到比较精细的结果 操作逻辑 通过该alembic节点加载模型 缩放模型 加入grid节点生成地面 分别给模型赋予不同的颜色 通过solver节点来处理attribute transfer&emsp;&emsp;实现触碰的区域有颜色区分，并且效果是叠加的 操作细节 加入group节点根据颜色信息进行打组&emsp;&emsp;输入的表达式不能有空格，否则不起作用 操作细节 加入time shift节点实现保留240帧的结果 加入subdivide对组细分 加入第二个solver节点进行脚印变形&emsp;&emsp;这里的group节点需要勾选unshared Edges来实现 操作细节 通过magnet节点实现模型往下移动的效果，magnet只能接收metaball的体积 加入color节点让地面颜色统一 26：solver的使用 观看笔记 通过xyz distant 来获取地板周围的区域 操作逻辑 通过attribute create 创建dis值&emsp;&emsp;默认值不能为零需要和搜索的最大值一致，否则最小值为零就没有凸起效果了（教程可能有误） 操作细节 在第二个solver中加入point vop节点 加入xyz distant 节点获取人物模型和地面的接触区域&emsp;&emsp;根据搜索的最大值，获取的区域由0到最大值过渡 操作细节 设置min节点保证最小值过滤&emsp;&emsp;保护已找到的区域，从而不会导致脚离去，抬起的部分又缩回去 通过bind节点获取外部dis值&emsp;&emsp;如果dis的初值为零，就会导致最小过滤一直在零值上 操作细节 在颜色处理之前加入point vop节点抬起周围的区域 &emsp;&emsp;fit1的范围值让0到0.5的区域变为1到0，从而实现大于0.5的区域都为黑色，0-0.5的区域逐渐变大抬起 操作细节 &emsp;&emsp;fit2的范围让-0.1到0的区域变为0到1，从而实现Y轴小于-0.1的区域乘以0，保持脚踩坑的高度在地面以下 操作细节 加入parameter节点生成scale参数方便外部控制抬起的程度 27：脚印效果以及改善 观看笔记 加入turbulence 节点增加地面抬起的复杂度&emsp;&emsp;用perlin噪波的效果比较理想 脚印案例总结 &emsp;&emsp;脚印案例还是有点难度的，我主要是在打组的表达式以及min节点操作上面卡了不少时间，其他部分就不算太难。 var ImgArray = []; $('button').each(function(){ if($(this).attr("id") == "processImg_btn"){ ImgArray.push($(this).parent().next()); $(this).parent().parent().children("#processImg").hide(); $(this).css('width','100%'); $(this).click(function(){ $(this).parent().next().slideToggle(1000); }); } });]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
        <category>zplus 教程系列</category>
      </categories>
      <tags>
        <tag>ࠒ视频教程/zplus</tag>
        <tag>ࠁHoudini/SOP</tag>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 学习之路（三）]]></title>
    <url>%2Fposts%2F40670.html</url>
    <content type="text"><![CDATA[帧率显示代码12345678910111213141516171819//这段代码可以在右上角显示帧率（复制自官方代码 修改了引用js的路径）//官方地址：https://github.com/mrdoob/stats.js/(function()&#123; var script=document.createElement('script');//添加script标签 script.onload=function()&#123;//当脚本加载时运行 var stats=new Stats(); document.body.appendChild(stats.dom);//添加到body标签中 requestAnimationFrame(function loop()&#123;//添加刷新函数 stats.update();//调用实时刷新 requestAnimationFrame(loop)//递归调用实现刷新 &#125;); &#125;; script.src='https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.js';//script标签加入src document.head.appendChild(script);//script标签添加到头部&#125;)()//闭包编写，这样对其他代码的影响是最少的//闭包编写，相当于 C++ 类中的private变量和函数，无法在外部调用//console.log(script)//执行后会报错 Uncaught ReferenceError: script is not defined Three.js 三件套 用init()函数将下面的代码包含起来 12345678910111213141516171819202122232425262728293031323334353637//创建threejs的场景var scene = new THREE.Scene();// 创建透视摄像机 并且初始化位置var camera = new THREE.PerspectiveCamera( 45, //视场角 window.innerWidth / window.innerHeight, // 长宽比 1, // 近景裁剪 1000 // 远景裁剪);camera.position.z = 20;camera.position.x = 0;camera.position.y = 5;camera.lookAt(new THREE.Vector3(0, 10, 0));//确保摄像机望向坐标原点//创建 webGL的渲染器 这里的设置和上一节一致var renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight);//为渲染器开启 阴影贴图renderer.shadowMap.enabled = true;//开启这个 阴影效果会抗锯齿 但是也会卡许多//renderer.shadowMapType = THREE.PCFSoftShadowMap;//官方说明：Sets device pixel ratio. This is usually used for HiDPI device to prevent bluring output canvas.//大意就是针对HiDPI设备（比如使用苹果Retina的）进行的设置，防止输出画面被施加模糊renderer.setPixelRatio( window.devicePixelRatio );//启用orbit摄像机 需要OrbitControls.js文件支持 可以实现环绕摄像机 支持缩放、平移功能var controls = new THREE.OrbitControls( camera, renderer.domElement );//将渲染器绑定到html的特定div上 方便以后的DOM操作document.getElementById('webgl').appendChild(renderer.domElement);//调用update函数update(renderer, scene, camera, controls); 资料补充 PCF解释 阴影贴图与阴影贴图相对的技术是光线追踪阴影（Ray Tracing Shadow），效果更真实，也更加消耗资源。 Update函数编写 补充update函数的调用 123456789101112131415161718192021222324function update(renderer, scene, camera, controls) &#123; //OrbitControl 如果要开启damping效果才需要这一行 //controls.update(); //这里的写法与上一节一致 controls也可以去掉 renderer.render(scene, camera); requestAnimationFrame(function() &#123; update(renderer, scene, camera, controls); &#125;); //创建resize函数 在调节窗口大小时三维界面会响应缩放 window.addEventListener('resize',function()&#123;//窗口大小改变时响应 var width = window.innerWidth;//计算当前窗口的宽度 var height = window.innerHeight;//计算当前窗口的高度 renderer.setSize(width,height);//重新设置渲染的区域大小 camera.aspect = width/height;//重新设置摄像机的长宽比 //官方说明：Updates the camera projection matrix. Must be called after any change of parameters. //任何参数的变化都需要调用这个函数进行计算 camera.updateProjectionMatrix(); &#125;)&#125; 添加灯光以及控制灯光的GUI 这里我们又回到了init()函数内部 123456789101112131415161718192021222324252627282930//添加两个聚光灯 填写参数分别是 强度 和 颜色var lightLeft = getSpotLight(0.4, 'rgb(255, 220, 180)');var lightRight = getSpotLight(1.25, 'rgb(255, 220, 180)');//调整聚光灯的位置lightLeft.position.x = 6;lightLeft.position.y = 8;lightLeft.position.z = 12;lightRight.position.x = 50;lightRight.position.y = 14;lightRight.position.z = -6;// 将灯光添加到场景中scene.add(lightLeft);scene.add(lightRight);//导入gui界面var gui = new dat.GUI();// 添加图形操作界面 滑竿 参数分别代表 控制源 具体属性（控制源的子对象） 最小值 最大值gui.add(lightLeft, 'intensity', 0, 10);gui.add(lightLeft.position, 'x', -50, 50);gui.add(lightLeft.position, 'y', -50, 50);gui.add(lightLeft.position, 'z', -50, 50);gui.add(lightRight, 'intensity', 0, 10);gui.add(lightRight.position, 'x', -50, 50);gui.add(lightRight.position, 'y', -50, 50);gui.add(lightRight.position, 'z', -50, 50); 编写灯光调用函数 我们又跳出init()函数看看灯光调用的编写 123456789101112131415161718192021222324252627//聚光灯构造函数function getSpotLight(intensity, color) &#123; /* a = a == b ? b++ : 0 这个就是如果a等于b成立，就返回b++，如果不成立，就返回0 等价于 if(a==b) a = b++ else a = 0 */ //设置颜色，如果color没有定义直接定义为纯白，否则就是color传入的值 color = color === undefined ? 'rgb(255, 255, 255)' : color; var light = new THREE.SpotLight(color, intensity);//创建聚光灯 light.castShadow = true;//开启阴影 //使聚光灯边缘柔化 light.penumbra = 0.5;//penumbra半影 在三维中专门指聚光灯轮廓的模糊程度 //设置深度贴图的大小以及偏差值 light.shadow.mapSize.width = 1024; light.shadow.mapSize.height = 1024; light.shadow.bias = 0.001; return light;&#125; 加载OBJ模型和贴图 这里我们又双叒叕回到了init()函数内部 1234567891011121314151617181920212223242526272829303132333435363738394041//加载外部模型//需要OBJLoader.js的支持var loader = new THREE.OBJLoader();var textureLoader = new THREE.TextureLoader();//加载模型，以及模型预加载的函数loader.load('model/fellow.obj', function (object) &#123; //获取颜色贴图和凹凸贴图的路径 var colorMap = textureLoader.load('model/texture.jpg'); var bumpMap = textureLoader.load('model/texture.jpg'); //获取材质，材质函数在下面定义，传入参数 材质类型 颜色 var faceMaterial = getMaterial('lambert', 'rgb(255, 255, 255)'); //traverse 对模型的各个部分进行逐一操作，可以用for loop递归来实现 //traverse 是threejs自带的功能 object.traverse(function(child) &#123; //设置材质以及材质的属性 child.material = faceMaterial; faceMaterial.roughness = 0.375;//粗糙度 faceMaterial.map = colorMap;//颜色贴图 faceMaterial.bumpMap = bumpMap;//凹凸贴图 faceMaterial.roughnessMap = bumpMap;//粗糙度贴图 faceMaterial.metalness = 0;//金属度 faceMaterial.bumpScale = 0.175;//凹凸程度 child.material.side = THREE.DoubleSide;//双面材质 &#125; ); //放大和移动模型 object.scale.x = 0.01; object.scale.y = 0.01; object.scale.z = 0.01; object.position.z = 0; object.position.y = -2; //添加模型 scene.add(object);&#125;); //init()函数返回值 返回场景 return scene; 编写getMaterial函数123456789101112131415161718192021222324252627282930function getMaterial(type, color) &#123;var selectedMaterial;var materialOptions = &#123; color: color === undefined ? 'rgb(255, 255, 255)' : color&#125;;//这里如果color没有定义直接定义为纯白，否则就color的值//下面展示了threejs内置的材质(可以加载第三方js来扩展材质,或者通过GLSL语言自己写材质)switch (type) &#123; case 'basic': selectedMaterial = new THREE.MeshBasicMaterial(materialOptions); break;//这个材质等同于Maya中的surface表面材质，不受灯光影响 case 'lambert': selectedMaterial = new THREE.MeshLambertMaterial(materialOptions); break;//这个材质等同于Maya中的lambert材质 case 'phong': selectedMaterial = new THREE.MeshPhongMaterial(materialOptions); break;//这个材质等同于Maya中的phong材质 case 'standard': selectedMaterial = new THREE.MeshStandardMaterial(materialOptions); break;//这个材质等同于unity的standrad材质 case 'PBR': selectedMaterial = new THREE.MeshPhysicalMaterial(materialOptions); break;//PBR材质 default: selectedMaterial = new THREE.MeshBasicMaterial(materialOptions); break;&#125;return selectedMaterial;&#125; 添加全屏按钮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$(function()&#123; //添加按钮的CSS样式 var full_screen_css = $("&lt;style&gt;&lt;/style&gt;").text("#full_screen &#123;position: fixed;bottom: 20px;right: 20px;padding: 8px;color: #fff;background-color: #555;opacity: 0.7;&#125;#full_screen:hover &#123;cursor: pointer;opacity: 1;&#125;"); $("head").append(full_screen_css); //添加按钮 $("#webgl").after("&lt;button id=\"full_screen\" onclick=\"full_screen_fun()\"&gt;全屏&lt;/button&gt;");&#125;);var full_screen_check = false;//判断全屏状态function full_screen_fun()&#123; if(full_screen_check)&#123;//全屏状态 exitFull();//退出全屏 &#125;else&#123; requestFullScreen(document.documentElement);// 全屏整个网页 &#125;&#125;;function requestFullScreen(element) &#123; // 判断各种浏览器，找到正确的方法 full_screen_check = true; var requestMethod = element.requestFullScreen || //W3C element.webkitRequestFullScreen || //Chrome等 element.mozRequestFullScreen || //FireFox element.msRequestFullScreen; //IE11 if (requestMethod) &#123; requestMethod.call(element); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125;&#125;//退出全屏 判断浏览器种类function exitFull() &#123; full_screen_check = false; // 判断各种浏览器，找到正确的方法 var exitMethod = document.exitFullscreen || //W3C document.mozCancelFullScreen || //Chrome等 document.webkitExitFullscreen || //FireFox document.webkitExitFullscreen; //IE11 if (exitMethod) &#123; exitMethod.call(document); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125;&#125; HTML源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;实物演示&lt;/title&gt;&lt;/head&gt;&lt;style&gt; /*overflow:hidden取消滑动栏*/ body &#123; margin: 0;overflow: hidden &#125;&lt;/style&gt;&lt;body&gt; &lt;!--这个div用来加载js--&gt; &lt;div id="webgl"&gt;&lt;/div&gt; &lt;!--链接threejs的库--&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.2/dat.gui.min.js"&gt;&lt;/script&gt; &lt;script src="../js/controls/OrbitControls.js"&gt;&lt;/script&gt; &lt;script src="../js/loaders/OBJLoader.js"&gt;&lt;/script&gt; &lt;script type="application/javascript"&gt; //这段代码可以在右上角显示帧率（复制自官方代码 修改了引用js的路径） //官方地址：https://github.com/mrdoob/stats.js/ (function()&#123; var script=document.createElement('script');//添加script标签 script.onload=function()&#123;//当脚本加载时运行 var stats=new Stats(); document.body.appendChild(stats.dom);//添加到body标签中 requestAnimationFrame(function loop()&#123;//添加刷新函数 stats.update();//调用实时刷新 requestAnimationFrame(loop)//递归调用实现刷新 &#125;); &#125;; script.src='https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.js';//script标签加入src document.head.appendChild(script);//script标签添加到头部 &#125;)()//闭包编写，减少对其他代码的影响 //闭包编写，相当于 C++ 类中的private变量和函数，无法在外部调用 //console.log(script) //执行后会报错 Uncaught ReferenceError: script is not defined function init() &#123; //创建threejs的场景 var scene = new THREE.Scene(); // 创建透视摄像机 并且初始化位置 var camera = new THREE.PerspectiveCamera( 45, //视场角 window.innerWidth / window.innerHeight, // 长宽比 1, // 近景裁剪 1000 // 远景裁剪 ); camera.position.z = 20; camera.position.x = 0; camera.position.y = 5; camera.lookAt(new THREE.Vector3(0, 10, 0));//确保摄像机望向坐标原点 //创建 webGL的渲染器 这里的设置和第一节一致 var renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); //为渲染器开启 深度贴图阴影 renderer.shadowMap.enabled = true; renderer.setPixelRatio( window.devicePixelRatio ); //启用orbit摄像机 需要OrbitControls.js文件支持 可以实现环绕360度摄像机 支持缩放功能 var controls = new THREE.OrbitControls( camera, renderer.domElement ); //将渲染器绑定到html的div上 document.getElementById('webgl').appendChild(renderer.domElement); //调用update函数 update(renderer, scene, camera, controls); /************************/ /************************/ /************************/ //添加两个聚光灯 参数分别是 强度 和 颜色 var lightLeft = getSpotLight(1.6, 'rgb(255, 220, 180)'); var lightRight = getSpotLight(0.4, 'rgb(255, 220, 180)'); //调整聚光灯的位置 lightLeft.position.x = 6; lightLeft.position.y = 8; lightLeft.position.z = 12; lightRight.position.x = 50; lightRight.position.y = 14; lightRight.position.z = -6; // 加载灯光到场景中 scene.add(lightLeft); scene.add(lightRight); //导入gui界面 var gui = new dat.GUI(); // 添加图形界面 滑竿 参数分别代表 控制的原件 具体属性 最小值 最大值 gui.add(lightLeft, 'intensity', 0, 10); gui.add(lightLeft.position, 'x', -50, 50); gui.add(lightLeft.position, 'y', -50, 50); gui.add(lightLeft.position, 'z', -50, 50); gui.add(lightRight, 'intensity', 0, 10); gui.add(lightRight.position, 'x', -50, 50); gui.add(lightRight.position, 'y', -50, 50); gui.add(lightRight.position, 'z', -50, 50); //加载外部模型 //需要OBJLoader.js的支持 var loader = new THREE.OBJLoader(); var textureLoader = new THREE.TextureLoader(); //加载模型，以及模型预加载的函数 loader.load('model/fellow.obj', function (object) &#123; //获取颜色贴图和凹凸贴图的路径 var colorMap = textureLoader.load('model/texture.jpg'); var bumpMap = textureLoader.load('model/texture.jpg'); //获取材质，材质函数在下面定义，传入参数 材质类型 颜色 var faceMaterial = getMaterial('lambert', 'rgb(255, 255, 255)'); //traverse 对模型的各个部分进行逐一操作，可以用for loop递归来实现 //traverse 是threejs自带的功能 object.traverse(function(child) &#123; //设置材质以及材质的属性 child.material = faceMaterial; faceMaterial.roughness = 0.375;//粗糙度 faceMaterial.map = colorMap;//颜色贴图 faceMaterial.bumpMap = bumpMap;//凹凸贴图 faceMaterial.roughnessMap = bumpMap;//粗糙度贴图 faceMaterial.metalness = 0;//金属度 faceMaterial.bumpScale = 0.175;//凹凸程度 child.material.side = THREE.DoubleSide;//双面材质 &#125; ); //放大和移动模型 object.scale.x = 0.01; object.scale.y = 0.01; object.scale.z = 0.01; object.position.z = 0; object.position.y = -2; //添加模型 scene.add(object); &#125;); //返回场景 return scene; &#125; //聚光灯构造函数 function getSpotLight(intensity, color) &#123; /* a==b?b++:0 这个就是如果a等于b成立，就返回b++，如果不成立，就返回0 */ color = color === undefined ? 'rgb(255, 255, 255)' : color;//设置颜色，如果color没有定义直接定义为纯白，否则就color的值 var light = new THREE.SpotLight(color, intensity);//创建聚光灯 light.castShadow = true;//开启阴影 light.penumbra = 0.5;//使灯光边缘柔化 //设置深度贴图的大小以及偏差值 light.shadow.mapSize.width = 1024; light.shadow.mapSize.height = 1024; light.shadow.bias = 0.001; return light; &#125; //材质构造函数 function getMaterial(type, color) &#123; var selectedMaterial; var materialOptions = &#123; color: color === undefined ? 'rgb(255, 255, 255)' : color &#125;;//这里如果color没有定义直接定义为纯白，否则就color的值 //下面展示了threejs内置的材质(可以加载第三方js来扩展材质,或者通过GLSL语言自己写材质) switch (type) &#123; case 'basic': selectedMaterial = new THREE.MeshBasicMaterial(materialOptions); break;//这个材质等同于Maya中的surface表面材质，不受灯光影响 case 'lambert': selectedMaterial = new THREE.MeshLambertMaterial(materialOptions); break;//这个材质等同于Maya中的lambert材质 case 'phong': selectedMaterial = new THREE.MeshPhongMaterial(materialOptions); break;//这个材质等同于Maya中的phong材质 case 'standard': selectedMaterial = new THREE.MeshStandardMaterial(materialOptions); break;//这个材质等同于unity的standrad材质 case 'PBR': selectedMaterial = new THREE.MeshPhysicalMaterial(materialOptions); break;//PBR材质 default: selectedMaterial = new THREE.MeshBasicMaterial(materialOptions); break; &#125; return selectedMaterial; &#125; function update(renderer, scene, camera, controls) &#123; controls.update();//controls是orbit摄像机的传参用来实现摄像机的更新，不过没有它目前也没问题 //这里的写法与前文一致 controls也可以去掉 renderer.render(scene, camera); requestAnimationFrame(function() &#123; update(renderer, scene, camera, controls); &#125;); //创建resize函数 在调节窗口大小时三维界面会响应缩放 window.addEventListener('resize',function()&#123; var width = window.innerWidth; var height = window.innerHeight; renderer.setSize(width,height); camera.aspect = width/height; camera.updateProjectionMatrix(); &#125;) &#125; //调用初始化函数 var scene = init(); /************************/ /*******添加全屏按钮********/ /*****并且添加全屏功能*******/ /************************/ $(function()&#123; //添加按钮的CSS样式 var full_screen_css = $("&lt;style&gt;&lt;/style&gt;").text("#full_screen &#123;position: fixed;bottom: 20px;right: 20px;padding: 8px;color: #fff;background-color: #555;opacity: 0.7;&#125;#full_screen:hover &#123;cursor: pointer;opacity: 1;&#125;"); $("head").append(full_screen_css); //添加按钮 $("#webgl").after("&lt;button id=\"full_screen\" onclick=\"full_screen_fun()\"&gt;全屏&lt;/button&gt;"); &#125;); var full_screen_check = false;//判断全屏状态 function full_screen_fun()&#123; if(full_screen_check)&#123;//全屏状态 exitFull();//退出全屏 &#125;else&#123; requestFullScreen(document.documentElement);// 全屏整个网页 &#125; &#125;; function requestFullScreen(element) &#123; // 判断各种浏览器，找到正确的方法 full_screen_check = true; var requestMethod = element.requestFullScreen || //W3C element.webkitRequestFullScreen || //Chrome等 element.mozRequestFullScreen || //FireFox element.msRequestFullScreen; //IE11 if (requestMethod) &#123; requestMethod.call(element); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125; &#125; //退出全屏 判断浏览器种类 function exitFull() &#123; full_screen_check = false; // 判断各种浏览器，找到正确的方法 var exitMethod = document.exitFullscreen || //W3C document.mozCancelFullScreen || //Chrome等 document.webkitExitFullscreen || //FireFox document.webkitExitFullscreen; //IE11 if (exitMethod) &#123; exitMethod.call(document); &#125; else if (typeof window.ActiveXObject !== "undefined") &#123;//for Internet Explorer var wscript = new ActiveXObject("WScript.Shell"); if (wscript !== null) &#123; wscript.SendKeys("&#123;F11&#125;"); &#125; &#125; &#125; /************************/ /************************/ /************************/ &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果 效果链接 备注：全屏按钮在&lt;iframe&gt;中不起作用，可以点击链接感受]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 学习之路（二）]]></title>
    <url>%2Fposts%2F37543.html</url>
    <content type="text"><![CDATA[第一部分的代码 创建 场景、摄像机、渲染器 123456789101112131415161718192021//一个三维场景需要包含 场景、摄像机、渲染器 //这行代码用来创建三维场景var scene = new THREE.Scene();//这行代码用来创建透视摄像机 //参数分别代表 视场角（视野的范围 于焦距成关系） 摄像机的长宽比 近景裁剪 远景裁剪var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );//使用Webgl渲染（如果当前环境不支持webgl，threejs会自动跳转其他的渲染方式）var renderer = new THREE.WebGLRenderer();//设置渲染的范围大小//隐藏的第三个参数可以为false，写法如：//setSize(window.innerWidth/2, window.innerHeight/2, false)//false情况渲染分辨率减半renderer.setSize( window.innerWidth, window.innerHeight );//将渲染的内容添加到HTML中document.body.appendChild( renderer.domElement );//这里可以附加到特定id的标签中 第二部分的代码 添加物体并将物体添加到场景中 123456789101112//创建一个方块 参数分别是 长宽高var geometry = new THREE.BoxGeometry( 1, 1, 1 );//创建模型构成数据//创建一个材质 并且给予绿色var material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );//创建模型材质数据//创建方块（将上面的变量作为参数传递进去）var cube = new THREE.Mesh( geometry, material );//将上面的数据绑定到一起//给场景添加方块scene.add( cube ); 第三部分的代码 设置摄像机位置并添加刷新函数 123456789101112131415161718192021//设置摄像机的位置（摄像机在0，0，0位置，看不见方块）camera.position.z = 5;//调整到其他位置的方法// camera.position.y = 2;// camera.position.x = 3;// camera.lookAt(new THREE.Vector3(0, 0, 0));//让摄像机望向原点function animate() &#123; //确保每秒刷新60次场景 requestAnimationFrame( animate ); //实现方块自转 cube.rotation.x += 0.1; cube.rotation.y += 0.1; //通过camera的摄像机将场景渲染出来 renderer.render( scene, camera );&#125;animate(); 官方的源代码1234567891011121314151617181920var scene = new THREE.Scene();var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );var renderer = new THREE.WebGLRenderer();renderer.setSize( window.innerWidth, window.innerHeight );document.body.appendChild( renderer.domElement );var geometry = new THREE.BoxGeometry( 1, 1, 1 );var material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; );var cube = new THREE.Mesh( geometry, material );scene.add( cube );camera.position.z = 5;function animate() &#123;requestAnimationFrame( animate );renderer.render( scene, camera );&#125;animate(); HTML源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=utf-8&gt; &lt;!--本文件来自于官方文档--&gt; &lt;title&gt;My first three.js app&lt;/title&gt; &lt;style&gt; /*overflow:hidden取消滑动栏*/ body &#123; margin: 0;overflow: hidden &#125; canvas &#123; width: 100%; height: 100% &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--引用three.js--&gt; &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/92/three.min.js"&gt;&lt;/script&gt; &lt;script type="application/javascript"&gt; var scene = new THREE.Scene(); var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 ); var renderer = new THREE.WebGLRenderer(); renderer.setSize( window.innerWidth, window.innerHeight ); document.body.appendChild( renderer.domElement ); var geometry = new THREE.BoxGeometry( 1, 1, 1 ); var material = new THREE.MeshBasicMaterial( &#123; color: 0x00ff00 &#125; ); var cube = new THREE.Mesh( geometry, material ); scene.add( cube ); camera.position.z = 5;// camera.position.y = 2;// camera.position.x = 3;// camera.lookAt(new THREE.Vector3(0, 0, 0)); function animate() &#123; requestAnimationFrame( animate ); cube.rotation.x += 0.1; cube.rotation.y += 0.1; renderer.render( scene, camera ); &#125; animate(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 实现效果 效果链接 备注：这里没有添加resize函数，调整窗口需要刷新页面来更新效果]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 房产信息线上浏览Demo]]></title>
    <url>%2Fposts%2F33144.html</url>
    <content type="text"><![CDATA[（成果展示： 第三版房产信息线上浏览Demo） 前言&emsp;&emsp;前天聪哥带我去见了客户，为此前几天我做了一个房产信息线上浏览的Demo，那个时候开始接触了bootstrap，所以前几天写了bootstrap学习有感。 &emsp;&emsp;目前已经制作第三个版本，各种bug问题修复以及各种功能都实现得差不到了。（这两天一直在弄这个，又没什么时间去弄Houdini了(:з」∠)） 版本展示 第一版 第二版 第三版 第四版 第一版&emsp;&emsp;第一个版本是最粗糙的版本，控制面板是使用原生的CSS写的，有种原始的html风格，当时图省事，直接套用了以前尝试些web三维编辑器时留下的CSS样式，配色特别像法线贴图。 &emsp;&emsp;第一个版本的制作也是比较轻松的，之前写的js封装将outline功能封装起来了，我当时直接去调用outline里面的projector投射，实现点击反馈，算是完成了大概的框架。 第二版&emsp;&emsp;后来想着要给客户看的，这么丑陋的东西实在拿不出手，就开始找提高逼格的方法，最初是冲着UI去找的，所以最先发现的是Semantic UI，网上对比了一下，发现bootstrap也有类似的功能，想到这么多人都在用bootstrap，自己好歹也学一下吧，所以就有了之前的bootstrap - 学习感悟 &emsp;&emsp;这次花了大量的时间弄面板，最后通过bootstrap制作出可以折叠的面板，这个效果我还是比较满意的。（在使用bootstrap之前，我还用JQ把面板的高度匹配都做好了，最后发现bootstrap的折叠插件如此简单） &emsp;&emsp;另外为了配合这个面板的按钮，也对点击事件进行了一定程度的优化。 第三版&emsp;&emsp;今天（2018-07-27)晚上才做好，有了很重大的更新。 加入了拖拽插件，bootstrap面板可以在窗口任意移动了。 为了配合后期的json数据，修改了模型加载方法，改用数组循环的方式加载。 修改了点击触发的switch，改用循环配合if来批量处理后台数据。 经过不懈的努力，完成了模型合并效果的开发，只需要将模型名称数据用空格间隔开就可以完美匹配。 修改了点击面板影响点击判断的BUG 修改了面板收缩但是div大小不变影响移动的BUG &emsp;&emsp;现在的基本框架已经搞定了，后面就是导入广州塔模型去测试。 &emsp;&emsp;另外还有不少东西要做好预备。 通过模型对特定铺位的控制优化。 第一人称视图控制的优化。 模型异步加载规划。 第四版&emsp;&emsp;这次和第三版完全不一样了，加入了南沙的模型 加入了南沙的模型，并且对模型整体进行全面优化，每一层都在20万面以内 加入了html标签，更具bounding box计算标签的位置（这个和模型输出的坐标有关，这里也踩了很多坑最后生成的标签高度有所偏差，需要手动去修正） 加入第一层、第二层的按钮实现透明过渡的变化（这个功能需要递归所有的材质，实现也特别不易）]]></content>
      <categories>
        <category>大学</category>
        <category>我的作品</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js - 学习之路（一）]]></title>
    <url>%2Fposts%2F733.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;Three.js 的学习非常简单，一旦你懂了基础之后，后面的代码都会变得越来越容易，或许对于前端工程师来说，学习路线会变得比较陡峭，但是我认为，Three.js比起WebGL的晦涩难懂已经好了太多太多。（当然会底层的人就更加牛逼了） &emsp;&emsp;在学习Three.js之前，比较推荐先了解接触一些三维软件，诸如Maya、Blender、Unity等，对三维有个基础的了解，这样去理解WebGL实现的效果将会事半功倍。 &emsp;&emsp;另外相较于我们传统的三维软件，WebGL提供的功能更像是个游戏引擎，毕竟更多地涉及编程，所以如果有unity的开发经验，将能大大帮助Three.js的学习。 &emsp;&emsp;学习WebGL的另一道门槛就是对渲染的认识，如果你接触过Unity的实时渲染、亦或是Maya中Arnold之类的渲染器渲染，那这将是非常有帮助的，因为WebGL中的材质将不可避免涉及到传统CG行业的许多术语。 &emsp;&emsp;如果你是小白，也不必惊慌，上面的知识并不是学习Three.js所必须，不过有所涉猎将会对你深入学习WebGL有极大的帮助。 初学者入门网站 Three.js官网 threejs.org 初学必看 davidscottlyons.com Google开发人员 aerotwist.com THREEx开发者的个人网站learningthreejs.com 学习视频 pluralsight.com的教程 WebGL and Three.js Fundamentals Lynda.com的教程 Learning 3D Graphics on the Web with Three.js udemy.com的教程Three.js &amp; WebGL 3D Programming Crash Course (VR, OpenGL) 资源库 threejs.org 官方案例库 stemkoski 案例库 callumprentice 案例库 2pha 材质库]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Three.js-学习之路（零）]]></title>
    <url>%2Fposts%2F24239.html</url>
    <content type="text"><![CDATA[WebGL是什么 WebGL是2010年开发完成公布的用于网络三维呈现的三维库。WebGL本身就是源于著名的三维库openGL，与OpenGL ES 2.0绑定WebGL百度百科 WebGL是的优点 网页上现有的技术（Canvas、SVG）并不能完美地实现三维效果 不需要任何插件（相较于传统的Flash和Silverlight插件） 支持所有的流行的浏览器 支持移动设备 你可以自己编写shader 你可以通过DOM来管理它 架构非常新（机遇） WebGL的JS库使用原生的WebGL需要计算机图形学、线性代数等知识，而且即便执行很简单的功能也需要大量的代码进行支持，门槛很高。因此需要更加强大且完善的框架来简化难度以及减少代码量。下面是一些对WebGl封装的JS库 Three.JS Babylon.JS PhiloGL O3D GlGE Three.js我们采用 Three.js因为这个JS库更为知名，使用者也更多，功能也更全。 基于WebGL的编辑器 Threejs Editor Three.js 官方开发的 基于Three.js的 网上三维编辑器 Threejs Editor webglstudio 基于WebGL 开发的网上三维编辑器 webglstudio SculptGL（需要翻墙） 基于WebGL 开发的网上雕刻系统 SculptGL（已经通过electron完成电脑端的移植） playCanvas 基于WebGL 开发的网上游戏制作系统 playCanvas pixijs 基于WebGL 开发的网上2D游戏系统 pixijs WebGL&amp;Three.js 的优秀案例 BMW i8 汽车 2D湖面 jellyfish webgl example]]></content>
      <categories>
        <category>前端</category>
        <category>three.js</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
        <tag>ࡄThreejs</tag>
        <tag>ࡅOpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Houdini-zplus 教程系列（二）]]></title>
    <url>%2Fposts%2F35326.html</url>
    <content type="text"><![CDATA[8：文字特效：程序化动画 观看笔记 通过attributecreate 可以创建自定义变量，通过大写在Hscript中调用 本章节主要讲解属性的作用、运作思路 9：属性的概念以及属性和本地变量的关联 观看笔记 使用divide节点可以给面片重新布线，勾选Convex Polyogn可以三角化布线 facet节点可以添加点的法线 primitive节点可以对面进行移动（勾选Do transformation） 可以通过measure节点来测量一些参数，教程通过这个方法计算面积 当相乘结果与自己要的结果相反可以试着用除法 当区域值的范围很小的时候，可以重新建立新的区域（fit函数） 操作逻辑 创建Font节点来创建字体，可以通过Level of detail 来调控字体的精度 divide节点来重新给面片布线（使用bricker polygons 来创建网格式布线） facet节点勾选unique point可以将点分离 measure节点可以计算各个面的面积 attributeCreate 给area属性重新赋予范围 primitive节点勾选do transformation可以单独对各个面进行位移操作，移动可以根据当前帧\$F/\$AREA实现小面先移动，大面后移动 10：属性和函数在SOP节点的常用情况 观看笔记 \$PR 是面的序号 通过颜色属性可以辅助效果制作 操作逻辑 添加rand(\$PR)来增加移动的随机性 添加多一个primitive节点来增加颜色信息，颜色信息可以通过坐标信息基于区分，从而实现中间慢左右快等效果。 将颜色信息变量加入到移动表达式中 添加颜色节点清理掉之前的颜色信息 11：飘动线条：属性配合程序化建模 观看笔记 可以将一些动作用abc文件导入到Houdini中 导入abc要确保导入完整的模型方可进行SOP操作 在运动物体上撒点，点都不会不断运动，需要获取一个恒定的属性来确保撒点不动 trail节点可以根据时间生成一连串的点 add节点生成多边形可以根据属性生成 操作逻辑 添加alembic节点来加载abc模型 节点设置要load as Unpack Alembic Delayed Load Primitives这样才可以加载出模型的点 Poly Soup Primitives 要使用No Poly Soup Primitives才可以加载模型的面 要确保模型有一个不会不停变化的属性方可根据该属性进行撒点 使用time shift 节点从而只获取第一帧的值 使用measure计算面积 使用attribute copy将计算的面积赋值给原模型，完成不变值的创建 使用scatter节点撒点（调节根据属性撒点，并且将relax iteration 关掉放置平滑造成点的挪动） attribute create根据点序号创建一个新的属性变量num（为后面连线做准备） 使用trail节点生成运动路径上的点 add节点根据上面的属性变量进行连接（Polygon-&gt;By Group-&gt;By Attribute) 使用merge节点将模型和曲线连接到一起 12：重要节点foreach的初级使用 观看笔记 \$NPT可以获取当前点的数量 for each节点在Houdini 16 已经改版（我参考的是pluralsight 的教程来用新版） for each 使用Primitive属性 attribute promote 可以将属性转移，转换过程可以取平均值、最大值、最小值等等操作，这里因为每条曲线上的num值都是一样的，所以什么操作都不影响。 ratio自定义属性\$PT/(\$NPT-1) 通过这个方法可以算出每个点占曲线的百分比(\$NPT是点的总数) 操作逻辑 使用convert节点生成NURBS curve完成平滑效果 resample节点对曲线重新采样加点 添加attribute promote节点将前面生成的自动以num变量装换为Primitive类别 （如果上面不转换，for each改为对点操作也是可以的，但是连线就没有了，循环之后只有点） 添加for each 节点对num属性进行循环（实现每一根曲线的提取） 在循环中添加attribute create 通过\$PT/(\$NPT-1)表达式创建ratio变量 根据ratio的值随机删除曲线的一部分（delete加入表达式判断） 13：初识VOPSOP 观看笔记 在Houdini 16中 vop sop 节点已经转换为 vop 节点 通过噪波 turbulence Noise 节点来实现曲线的变化 直接连接 Noise 会使所有的点偏移到原点处，需要添加add节点来实现在原位置上的偏移。 frequency 频率实现波段的密集程度 roughness 在特定波段中的小噪波大小 offset 整体偏移噪波效果 操作逻辑 添加vop节点 加入turbulence Noise节点 添加add节点让turbulence Noise的效果在原基础上进行偏移 通过bind节点获取num属性，从而实现没一条曲线的偏移值都不相同 通过multiply节点和获取ratio属性，实现曲线头部无噪波，不移位效果 14：渲染设置及几何体灯光 观看笔记 Houdini的曲线是默认有宽度的，如果要修改的话，可以加入width属性进行修改 操作逻辑 打灯，聚光灯可以调节成grid，调大大小可以柔和阴影效果 调节材质 添加曲线的宽度 IPR渲染查看渲染效果调节参数 渲染序列 15：vopsop讲解 观看笔记 vectofloat节点可以将向量转浮点 fit节点和fit函数一致 subdivide才是细分，houdini的smooth节点只是添加平滑没有细分总结：更具模型的高度对模型进行相应的偏移 操作逻辑 第一个vop 获取高度（vector to float) fit修改值的范围 将position拆分（vector to float) 保留Y轴不变（高度相关的信息）在X轴Z轴通过multiply节点与高度的范围进行相乘 这样就可以实现上高下矮的效果 最后加入ramp parameter 节点实现更强的操控 第二个vop 获取高度（vector to float) fit修改值的范围 将fit的范围修改为vector 将vector属性传到transform的rot中，实现扭转的偏移 第三个vop个第二个的思路是一样的，只是修改不同的轴向而已 获取高度（vector to float) fit修改值的范围 将fit的范围修改为vector 将vector属性传到transform的rot中，实现扭转的偏移 第四个vop 通过法线实现Houdini的peak节点的效果 16：多边形模型的躁波破碎 观看笔记 不封口的模型在使用isooffset的时候禁用laser scan才能减少烟雾溢出的问题 制作破碎的噪波可以反其道行之，先在噪波的模型上切，然后再将模型复原 rest节点可以储存当前模型的点坐标信息，到那时在偏移会原来位置的时候，内部细节会丢失 所以可以通过VOP记录模型变形的值，从而实现内部细节不丢失 操作逻辑 导入模型，根据模型的情况加入remesh节点重新布线（一般是减少面数） 加入VOP节点，通过turbulence对模型进行变形 传统破碎流程 添加isooffset节点，在加入scatter节点撒点，在添加voronoi fracture进行破碎 使用point节点将偏移的模型复原 注：在这个过程中，可以在VOP中通过 bind export节点输出偏移值，也可以通过attribute wrangle以及rest节点记录的信息，通过VEX计算出偏移值。注：这种方法不适用与带贴图的模型，裂缝会暴露出来。 17：躁波破碎的内部细节及随机大小改进 观看笔记 通过是点的分布不均实现大块小块 操作逻辑 撒点之后加入通过attribute vop为点上颜色 加入turbulence节点让点的值混乱分布 通过fit 节点将区间调小，就可以实现黑白分明的效果 更具调整颜色删除点 18：地面裂缝 观看笔记 通过set vector 可以将一个矢量的一部分进行修改，默认为零 fit(\$PT,(\$NPT-11),(\$NPT-1),1,0) 这样设置width属性那么属性值会根据点的序号进行范围映射，倒数第10个以前都为1，后面会逐渐地变为0。 操作逻辑 画一条曲线 加入vop的turbulence效果给曲线添加随机性 加入resample节点对曲线重新采样 再次加入vop增强随机效果 添加carve节点选择Second U实现从0到1的过渡，设置关键帧 添加width属性，属性根据点的值设置范围值 添加polywire节点从曲线上生成多边形 创建一个方块并调整方块的大小和细分 移动方块到合适的未知 添加boolean节点实现布尔裂缝。 总结 &emsp;&emsp;看过了RBD的教程之后，重新去看这里的SOP教程，感觉非常简单，理解起来也非常快。&emsp;&emsp;我第一次看的时候完整地只是看到这里，后面电线的部分已经抓狂到不想看了，现在看来可能是自己心太急了，这个部分并没有那么神秘和复杂。&emsp;&emsp;后面的内容基本上就属于第一次看的范畴了，不过我相信just so so &lt;(￣ˇ￣)/]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
        <category>zplus 教程系列</category>
      </categories>
      <tags>
        <tag>ࠒ视频教程/zplus</tag>
        <tag>ࠁHoudini/SOP</tag>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Houdini-zplus 教程系列（一）]]></title>
    <url>%2Fposts%2F6532.html</url>
    <content type="text"><![CDATA[2：苹果程序化建模实例，sop节点初识 首先创建一条曲线,画出苹果的轮廓，并且将曲线转换成NURBS进行平滑 操作逻辑 curve节点画出轮廓曲线 revolve节点将曲线旋转产生曲面 convert节点转换成polygon fuse节点将polygon的点合并 twist节点调节为bend命令对苹果杆 transform节点将苹果杆移动到苹果上面 merge极点将两者合并到一起 备注：这里的操作逻辑和Maya的NURBS建模转polygon完全一致。 3：重要节点copy的使用，复制几何体 观看笔记 copy节点复制重叠可以通过显示ptnum来发现问题 copy节点会将点的发现信息与复制物体的Z轴信息匹配到一起 按住ctrl点击相机可以在当前视图创建摄像机，按住锁定方可移动摄像机 rand(ptnum)*0.4 + 0.6 通过这方法可以让随机数生成限制在0.4，让苹果的最小值保持在0.6 操作逻辑 生成多个点来让苹果进行复制（其实曲线只是其中一种易用控制方法，多边形、add节点都可以生成点） point节点为生成点添加法线信息（用于控制苹果的方向）添加pscale（用于控制苹果的大小） 4：部分常用函数以及group组的概念和使用介绍 观看笔记 copy节点的stamp是为了将右边的点信息传递到左边的复制物体上来使用的 使用stamp记得勾选copy节点的stamp inputs Hscript的函数忘记了可以使用textport 通过exhelp命令来寻找用法 操作逻辑 通过stamp函数将rand(@ptnum)的数值乘以特定倍数赋值到苹果的X轴、Y轴旋转 苹果表面的moutain节点起伏 苹果杆的弯曲 通过bbox函数的D_YMIN获取物体Y轴最低点到原点的距离，通过transform节点来消除这段距离从而实现所有的苹果都在平面上 5：stamp函数的使用，生成不同尺寸，形状，色彩，方向等 观看笔记 布尔运算必须是polygon类型才可以执行 pscale控制大小实在右边完成的，实际上也可以用stamp来完成，但是右边的运行效率会更高 操作逻辑 通过boolean节点（教程是旧版的cookie节点）给苹果弄出开口 给布尔用的球提高细分（frequency）提高细节 并且 加入mountain节点来实现不同（和苹果的起伏操作一致） 加入switch节点来实现部分苹果有开口的效果（需要使用HScript的if函数） 在point节点中加入Cd 属性 在copy节点中启用点属性的传递 6：基础灯光材质介绍 观看笔记 推荐使用PBR渲染模式 在没有渲染节点的情况下，Houdini会自动生成mantra节点进行渲染 默认情况下模型都没有UV，Houdini会将贴图贴到每一个面上 目前我的手提电脑一渲染 程序就停止运作 还没有好的解决方案 操作逻辑 设置好摄像机的渲染窗口 设置好灯光（添加HDR光照贴图、Arealight的大小调大从而模糊阴影的轮廓） 添加桌子材质和苹果材质 为材质添加贴图 添加展UV的节点来添加UV信息 设置渲染的参数调试渲染 备注：mantra的渲染逻辑和Arnold5几乎一样，应该说是Arnold5仿照了它，学习起来毫无压力 7：基础渲染流程 观看笔记 specular angle 可以模糊高光 布尔的部分获取的UV是贴图最左下角的颜色 Houdini对单问题的多重材质需要用group节点进行分组 总结 zplus 张鹏老师的第一个案例，其实相对简单，适合初学Houdini，特别是有Maya和Max基础的同学（比如我）就很好接受。第一个案例将Houdini的整个流程走了一遍，把逻辑整理清楚之后还是很好接受的。]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
        <category>zplus 教程系列</category>
      </categories>
      <tags>
        <tag>ࠒ视频教程/zplus</tag>
        <tag>ࠁHoudini/SOP</tag>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstrap 学习感悟]]></title>
    <url>%2Fposts%2F6507.html</url>
    <content type="text"><![CDATA[入坑缘由&emsp;&emsp;其实bootstrap 我是早有耳闻了，运用也非常广泛，但是一直没有怎么接触，毕竟这半年一直在研究three.js，和传统网页没有太大的关系。 &emsp;&emsp;今天开始研究bootstrap主要是因为自己写的原生CSS太丑了，想找些可以轻松解决问题的框架，最先是找到了Semantic UI，经过研究发现bootstrap似乎也可以胜任这些工作，所以我就去研究了一下bootstrap是怎么弄的 &emsp;&emsp;一看就不得了，原来我早就看过了，之前就在一些网页上面看到这些莫名其妙的class定义，原来它们都是用了bootstrap的缘故，不过bootstrap也确实方便，以至于一直都是前端最最最热门的框架。 使用方法&emsp;&emsp;bootstrap相当简单易用，当然这种东西我觉得也是熟能生巧的，反正不懂就看说明书得了，简单直白，将需要的代码嵌套到class里面即可完成工作，这种操作比three.js、前端三大架构简单多了。 &emsp;&emsp;所以这里我就不做使用介绍了，估计正是这种操作理念，摒弃CSS，非必要时刻完全放下js。 总结&emsp;&emsp;简单易用就是bootstrap的强大之处，目前我用得还不是很深，做一个简单的记录。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渔村苏维埃政府旧址-数字博物馆]]></title>
    <url>%2Fposts%2F6250.html</url>
    <content type="text"><![CDATA[（成果展示： 渔村苏维埃政府旧址-数字博物馆） 前言&emsp;&emsp;前几天（7月16号-18号），我去到了清远雅堂村开启我们团队的扶贫项目，我们的任务是为当地博物馆扫描制作三维的数字博物馆，这个项目隶属于物联网+比赛中，由各个高校自行主持举办。清远雅堂村是广东工业大学指定的扶贫村，学校希望我们学生能够发挥特长，在雅堂村中制作一些别具特色的东西。 &emsp;&emsp;这次活动每支团队都有1000元的经费，墙绘团队因为有其他任务，所以他们有6000元的经费（当然颜料就是一笔不少的开销） &emsp;&emsp;雅堂村并没有博物馆，所以我们分配去了鱼湾的苏维埃政府旧址博物馆，距离雅堂村大概半小时的车程，我们三天的吃住就在鱼湾村的好世界宾馆中。（每天每间房90元，我们开了两间房，经费在燃烧，加上饭钱各个开销，最后我们只能尽快回来，否则本来要住一个星期的） 坑爹状况&emsp;&emsp;在之前我们并没有来过这个博物馆，也不清楚会遇到什么样的情况，所以我们为三维扫描做了全方位的探索，探索的成果可以关注我Photogrammetry-学习之路系列。 &emsp;&emsp;去到当地才发现，完完全全坑爹了。 博物馆很破旧（这个其实是意料之中的） 展览时间很短（早上9点半到下午4点半） 文物全部在玻璃里面不能拿出来（最坑爹的） &emsp;&emsp;这些突如其来的状况，真的让我们乱了手脚，不过当即想到了全景博物馆的方案，毕竟之前也看到过类似的效果，再加上之前张家荣制作的threejs全景丝绸之路给了我启发。 &emsp;&emsp;我觉得全景博物馆未必不能做，只是还需要攻克两个难点。 如何实现全景图的坐标定位，点击事件 如何完成全景图的制作 &emsp;&emsp;猛然回头，我发现自己都掌握了解决方法的钥匙 &emsp;&emsp;张家荣的大作业是解决第一个问题的钥匙。 &emsp;&emsp;而第二个难点的钥匙真的是多亏了以前看高中电脑书的记忆象，我记得有软件可以将摄像机的照片拼接起来，制作出全景图。 死马当活马医&emsp;&emsp;我确定了方案之后，就立马开始研究了。 &emsp;&emsp;聪哥还提出全三维的方案，真是想让我们累到半死不活呀，之前搭建南沙政务大厅还嫌不够累吗？ &emsp;&emsp;首先要解决的是全景照片的问题，因为前者问题即使没有解决方案也没关系，至少我可以用最原始的three.js来完成全景图观察，完整度至少还可以接受。 &emsp;&emsp;所以第一步想到的当然还是百度一下，毕竟不知道什么软件比较适合。 &emsp;&emsp;后面再百度的推荐下找到了ptgui软件 &emsp;&emsp;后面还是多亏了ghostxx.com，我在上面发现了更多的全景图制作软件，我一个一个下载下来测试（当然我测试的标准是最新更新版本为主） &emsp;&emsp;最后我觉得Kolor Autopano Giga 4.4 这款软件是最好用的全景图软件。 &emsp;&emsp;那个时候刚好研究到了接近晚上，基本把最大的难关解决了，我让建模团队帮忙拍一圈试试全景图的制作。 &emsp;&emsp;后面在回去宾馆之后，成功的制作出完美的全景图（除了地面和天花板） &emsp;&emsp;第一个难点就顺利被解决了。 &emsp;&emsp;回去宾馆只有，下一个难点接踵而至，我把张家荣的github文件下载下来，进行研究。 &emsp;&emsp;原来是基于three.js实现的photo sphere viewer 插件，因崔思婷。 &emsp;&emsp;后面去找photo sphere viewer（后面简称为PSV）的具体使用方法，想不到原制作者的github仓库已经丢弃了，我拿了个很久很久的版本，死活不知道同学怎么额外加入那么多其他脚本的。 &emsp;&emsp;后面才发现，原来插件是有官网的，而且官网上有API文档，真是新大陆。 &emsp;&emsp;有了方向之后，后面的工作就好办了，主要就是在家荣的大作业上面进行魔改测试PSV的用法。 PSV难点&emsp;&emsp;其实PSV的难点也还好啦，基于three.js的针对全景图的插件，学过three.js的我来说难度不大。 &emsp;&emsp;家荣的丝绸之路实训 &emsp;&emsp;官方API文档地址 &emsp;&emsp;主要是摸清楚以下几点 PSV参数设置 实现窗口大小的实时更新 如何添加自定义标记 如何实现全景图跳转 全局地图显示 如何实现标记点击出现嵌套html PSV参数设置 panorama - 全景图路径 container - 嵌套的html标签 （无视后两个参数） navbar - 下面导航栏的参数设置 size - 设置大小为浏览器窗口大小（three.js偷学过来的） transition - 全景图过渡用的参数 latitude_range - 限制镜头移动范围 lang - 按钮提示 &emsp;&emsp;很多参数官方都有给了，API文档里面也有详细的参数设置。 &emsp;&emsp;再初始化的阶段涉及导航栏的参数，通过导航栏可以制作出自定义的按钮，从而实现全局地图的显示。这个后面涉及再详细讲解 实现窗口大小的实时更新 &emsp;&emsp;这里最大的难点是理解resize传入的参数CSSsize，这个不是单纯传数字而是传入字符串，对于动态窗口的字符串设置也是搞了好久才终于搞懂原理。 &emsp;&emsp;不过弄好了之后其实也是令人意外的简单。 如何添加自定义标记&emsp;&emsp;自定义标记看了官方文档之后就知道是addMarker函数，鉴于每一个全景图都需要制作多个标记，我想到了用for循环遍历数组的方式来生成对应全景图的标记。 &emsp;&emsp;这样我就可以将参数存储到对应数组元素当中。 &emsp;&emsp;传入的参数大概是这样子的，所以数组中的每一个对象也是一个类。 &emsp;&emsp;因为标记也分为两种，一种是跳转全景图的，另一种是用于点击显示嵌套html的 &emsp;&emsp;通过 new 来声明对象的各种相关的参数。 &emsp;&emsp;然后将所有的元素统一放进一个数组里面。 &emsp;&emsp;这就是我对自定义标记的数据管理。 &emsp;&emsp;在实现这个结构的过程中除了输入数据很繁琐之外，最痛苦的莫过与坐标的输入，一开始没有弄清楚的坐标返回函数，导致所有的坐标都错误地在控制台输入，弄了一轮才发现问题。 &emsp;&emsp;后面为了方便输入，我专门将这种格式封装成一个js字符串输出到控制台，然后复制粘贴批量制作出我想要的变量字符串。 如何实现全景图跳转 &emsp;&emsp;全景图跳转官方也有一套模板的，我本来没有封装的，但是后面因为跳转的标记太多了，我将它封装一个函数了。 &emsp;&emsp;跳转标记最多的区域有两个，所以针对这两个庭院内侧和外侧的区域都针对做了函数封装。同时也有往庭院跳（第一张图）和庭院往外跳（第二张图）区别 &emsp;&emsp;主要的核心代码就是PSV.setPanoram(url,true) &emsp;&emsp;这里的运行逻辑： 跳转全景图 清理当前的标记 然后设置当前的全景图状态为False 将跳转的全景图设置为True 添加跳转全景图的标记 随机将镜头移动到标记中 &emsp;&emsp;这里的去全景图状态是用来判断当前是哪一个全景图在观察，在后面的地图制作非常有用。 全局地图显示&emsp;&emsp;全局地图就是导航栏下面的地图按钮 &emsp;&emsp;实现点击地图对应按钮进行跳转 &emsp;&emsp;这里的操作涉及到导航栏的自定义按钮制作，上面的参数是官方提供用来设置按钮的基本属性。 &emsp;&emsp;clickEvent是封装好的按钮跳转函数，跳转逻辑和标记的跳转基本一致。 &emsp;&emsp;最后一行加多了按钮图标刷新的函数。 &emsp;&emsp;通过这些方法实现全局地图跳转的功能。 &emsp;&emsp;在制作的过程中我还加入了html5tooltip插件，实现图标上方的提示标签，我以前些three.js有封装过相应的函数，直接拿来用了。 标记点击出现嵌套html&emsp;&emsp;普通标记的嵌套Html我也封装了函数 &emsp;&emsp;通过markerInfo函数将按钮的所有信息整合到一起，其中倒数第二个参数content是实现嵌套html的关键 &emsp;&emsp;通过addMarker函数将content嵌套进去，PSV就会自动完成右侧的弹出菜单,简单快捷。 &emsp;&emsp;嵌套的html的内容和id需要提前定义好。 全屏按钮BUG&emsp;&emsp;上面是已知问题的解决方案，然而在测试的过程中，我发现PSV自带的全屏效果和地图按钮的窗口冲突了，只要全屏就看不见地图。 &emsp;&emsp;经过调试，我也不知道是哪里的问题，最开始以为是z-index的问题，但是我调试的时候吧PSV的style都设为透明了，还是看不见弹出窗口。 &emsp;&emsp;最后我只能重做全屏窗口。 &emsp;&emsp;重做其实也并没有那么难，以前写three.js的时候有写过相关的函数，这里也是直接复制套用了。效果也是立竿见影，很不错。 &emsp;&emsp;同时我也想将PSV自带的全屏图标转换弄到自定义按钮当中，实现是这样子的。 &emsp;&emsp;PSV用的图标是SVG来的，我用Jquery把它加进去。 手机自适应问题&emsp;&emsp;在手机上Chrome浏览器会出现鼠标浮动的问题，需要在头部加入以下代码 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 制作总结&emsp;&emsp;以上就是PSV使用过程中的全部技术难点，也并没有那么复杂，最难受的是数据输入，大量的数据等着我，这个过程非常繁琐，所以后面经常是生成代码，复制粘贴进去修改的。 总结&emsp;&emsp;这次清远之行也还好，虽然突发状况让我们很慌，最后也还是有个明确方案解决问题。比起其他团队，我们的待遇好很多，博物馆的影音室有空调，平时工作都可以叹空调，虽然拍全景的时候在房间里面拍照，很闷很热，不过还可以回到影音室休息。 &emsp;&emsp;最想吐槽的是聪哥，他带队，没对接好，然后也没怎么帮我们干活……&emsp;&emsp;方案是我想的，代码是我去研究的，拍照基本上都是我和建模团队一起完成的┗|｀O′|┛ 嗷~~ &emsp;&emsp;目前所有的数据录入已经完成，等建模团队把模型弄好基本就可以完成任务了。 $("#processImg").hide(); $('#总结').click(function(){ $("#processImg").slideToggle(1000); });]]></content>
      <categories>
        <category>大学</category>
        <category>我的作品</category>
      </categories>
      <tags>
        <tag>࠴编程/前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyMel 学习之路（一）]]></title>
    <url>%2Fposts%2F24028.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;大一的时候玩过MEL，感觉MEL还是比较好学，毕竟所有的命令都可以通过Script Editor回显，即使没有扎实的编程基础，复制粘贴总该是会的。 &emsp;&emsp;那个时候看了DT的履带教程，看到它用表达式做出了自动履带，所有的表达式都是通过Expression Editor获取场景存在的物体搭建起来，那个时候我就在想，与其这样子获取，还不如将获取的物体制作成变量，这样不就可以利用插件对任意物体制作履带吗？ &emsp;&emsp;靠着这样的想法，我的速制履带插件诞生了，MEL的编程教程不多，主要都是看我收藏夹里面的Maya编程入门到放弃系列. &emsp;&emsp;写插件，前期可以看看教程入门，后面就要靠自己去看API文档了，这是编程必不可少的。想到后来自己学习 three.js 和 SFML 的经历简直是如出一辙。 &emsp;&emsp;现在想起来，才发现自己为什么会去看那个履带教程，因为大一的暑假要制作喏比动画呀，机器人绑定确实复杂，嘉杭师兄让我去看绑定相关教程，看完履带教程之后，自己又想要改进一下吧，才促使自己的第一款插件诞生。 &emsp;&emsp;后来也真是沮丧，Maya2017内置了MASH，MASH可以轻易做出这样的履带效果，刚开发完成，我的插件就宣布了死刑。不过也不至于那么糟糕，我的插件起码还可以对Maya版本向下兼容(:з」∠) &emsp;&emsp;回到现在，也已经好长时间没有碰Maya编程了，MEL也忘记得差不多了。现在怎么就去开PyMel的坑呢？ &emsp;&emsp;其实Python一直想学，可能是因为自己懒以及各种情况吧，最后还是拖到了大二的暑假…… &emsp;&emsp;接触了CG师兄之后，他让我去学习PyMel，那个时候我也略有耳闻过PyMel，但我还不清楚它和Maya的Python有什么区别。 &emsp;&emsp;看了DT-Python教程三部曲的前两部之后，才真正明白什么是Maya的Python编程，就是Mel换个语言包装呀( ⊙ o ⊙ ) &emsp;&emsp;后面才接触了PyMel，嗯嗯，看过之后才发现，真香。（卧槽，这不就是C++面向对象的写法吗？这和我学SFML的时候简直是一毛一样啊@_@） PyMel 入门 官方API文档 通常API文档都有Getting Start 、 introduction 的部分，即使没有教程也可以学习。]]></content>
      <categories>
        <category>CG</category>
        <category>Maya</category>
        <category>Maya 脚本</category>
      </categories>
      <tags>
        <tag>ࠀMaya</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photogrammetry-学习之路（四）]]></title>
    <url>%2Fposts%2F30435.html</url>
    <content type="text"><![CDATA[标记（marker）什么是标记？ 标记是一些特定标识图案 为什么使用标记？ 使用标记可以更好识别摄像机位置 如何生成标记 参数说明 Marker Type（标记类型）—— 使用默认即可 Center Point Radius（中心点半径） —— 根据实际环境填写大小 Target Per Page —— 每一页生成多少标记，建议用6，不浪费纸张 确认参数之后点击确定就会生成一个PDF文档 打开PDF文档 传说中的标记出现了你可以将标记拿去打印然后将标记裁剪下来贴到相应的位置上 如何识别标记 导入图片就可以选择Dectect Markers（检测标记） 检测参数使用默认即可 检测速度一般比较快 检测完成之后就可以看到标记点 标记点检测不全可能是因为照片模糊、亮度不够等原因造成这样在进行Align Photos就会自动参考标记点去识别照相机的位置 遮罩蒙版（Mask）什么是遮罩？ 遮罩顾名思义和PS、AE的遮罩一致用于抠出特定区域 为什么使用遮罩？ 使用遮罩可以限制识别区域和生成区域加快生成效率提高检测准确性 如何使用遮罩？ Photoscan 提供了基础的抠图工具 操作原理和PS一致只是功能有点少不大好用 框出区域右键可以看到相应的快捷键操作 导入遮罩 因为软件自带的抠图比较垃圾所以软件提供了导入遮罩的方案 除了Method 和 Filename Template其他参数均用默认即可 Agisoft Photoscan 提供了四种遮罩方案 From Alpha 通过图片的Alpha通道导入遮罩可以使用PS抠出遮罩保存到Alpha通道中Photoscan识别图片Alpha通道完成通道导入 From File 通过文件导入遮罩这个需要制作出遮罩的黑白图 使用这种方案需要注意Filename Template要使用宏定义{filename}来识别每一个文件名 From Background 通过背景生成遮罩这个需要拍摄有背景和没有背景的图片软件会自动匹配两者的区别来生成遮罩 这种方案非常适合顶点拍摄在统一环境当中背景也是固定只需要1张背景就可以为每张图片抠出相对准确的遮罩 From Model 这个操纵需要生成的模型来抠图但是抠模型只需要1次根据抠出的模型可以自动匹配到每一张图片上速度快，效果也非常好 遮罩操作 使用了遮罩之后 Apply Mask to 选项就可以选择了Key Point 限制识别的范围Tie Point 限制生成的范围 总结 标记可以让摄像机识别更精确 遮罩可以优化生成效果、生成更精确]]></content>
      <categories>
        <category>Photogrammetry</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/Photogrammetry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photogrammetry 学习之路（三）]]></title>
    <url>%2Fposts%2F33086.html</url>
    <content type="text"><![CDATA[拍照设备 Photogrammetry照片建模看重的是照片的成像质量好的设备当然能够事半功倍但是简单的手机设备也未尝不可 我并不是专业的摄影师对照相机的研究并不多但是从目前我的接触来看只要拍照质量过硬手机不比相机差 拍照参数 Photogrammetry 拍照和普通照相还是有几点不相同的 所有的设置都尽量不用自动（让图片保持一致） ISO要尽可能低（降低噪点） F-stop不能调太低（减少背景虚化） 快门速度要尽可能的小（降低重影效果） 聚焦清晰（聚焦模糊会影响贴图效果） 白平衡要一致（通常采用贴近真实的风格） 单一物体拍照方案以物体为中心 摄像机围绕物体进行拍照适用于比较大的物体 注意事项 移动之后一定要稳定摄像机再进行拍摄 移动的弧度不要太大，每张图片的间隔最好相互覆盖50%以上 拍摄时最好采用多角度（上中下角度） 优点 结合背景，摄像机位置识别相对准确 拍照灵活 成本低 缺点 拍照繁琐消耗体力（可以用三脚架固定但是麻烦） 自然光难以调控，光照不均匀 抠图困难，需要后期处理 以摄像机为中心 摄像机固定拍摄旋转物体适用于比较小的物体 注意事项（以物体为中心的注意事项在这里也一致） 需要配备三角架固定摄像机 需要配备关照环境均匀布光 需要配备转台转动物体 优点 拍照方便简单 光线统一均匀 背景统一方便生成遮罩 缺点 以物体识别为主，容易造成识别混乱 需要设备配合，成本较高 环境拍照方案 大环境拍摄难以采用固定摄像机的方案固定摄像机会导致图片扭曲以及细节不足的问题拍照注意可以参照以物体为中心的拍照方案 总结 Photogrammetry的拍照参数要设置好，切勿使用自动参数 拍照的时候追求稳定清晰，亮度也要适中 拍照要均匀围绕物体]]></content>
      <categories>
        <category>Photogrammetry</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/Photogrammetry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客搭建遇到的坑]]></title>
    <url>%2Fposts%2F63727.html</url>
    <content type="text"><![CDATA[基本上百度一下就有了，大神的介绍都非常详细，我就不再赘述。 搭建遇到的坑主题配置 我本来也是使用NEXT主题但是NEXT在手机端没有目录强迫症感的我到非常的不舒服最后我换成了如今的主题Black Blue 主题地址：https://github.com/maochunguang/black-blue 这个主题是有动画的但是如果删除了文章的话动画生成就会错乱解决方案： 在配置文件里面关闭动画，生成一个版本 然后重新开启，在覆盖之前的版本 baidushare插件 这个主题自带了BaiduShare的js链接这样大家分享文章的时候就会很方便 然而baiduShare已经被百度放弃维护了旧版本的js脚本的挂载在http服务器上这就导致了https嵌入http的报错问题已经解决了所以截图失败 解决方案https://github.com/hrwhisper/baiduShare将 baiduShare的Staic文件夹 放在主题的Source文件夹里面进行调用从而避开外链http的问题 gitment 弄这个着实被彻彻底底地坑了一把7号的时候按着官方的说法弄了一遍gitment遇到的问题都踩了 gitment常见问题 Error：NOT FOUND 这个问题源于github网址是没有大小写的我直接将github的网址复制进去修改没想到这样是不行的我的用户名是有大小写的坑了后就才发现问题的原因 Error: Comments Not Initialized 这个非常坑爹当时按着官方的套路走7号的时候我已经成功设置好了于是我把用于测试的博文删除后面我发了几篇博文更新了之后我发现这个问题又双叒叕回来了于是我按着套路走了一遍这一次不奏效了点击头像登录之后跳转到了github页面github返回的是404 找不到页面我又重复试了好多遍最后我将gitment禁用了MDZZ花了3、4天时间也没有解决最后最后还是舍不得不知道怎么就想到可能是中文字符导致无法初始化因为之前测试成功的时候就是用英文做标题的博文（public里面会根据博文的Title生成文件夹）于是我测试了一下谢天谢地，我成功了初始化成功之后其他中文标题的博文也不需要改英文都可以初始化了 总结 感觉自己在微不足道的地方浪费了大量的时间希望自己能用心看教程学习暑假很快就过半了 (:з」∠)]]></content>
      <categories>
        <category>前端</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>࠹Hexo</tag>
        <tag>✒博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photogrammetry 学习之路（二）]]></title>
    <url>%2Fposts%2F36167.html</url>
    <content type="text"><![CDATA[Build Mesh （生成网格） 参数说明 Surface Type（表面类型) —— 使用默认的Arbitrary 3D Source Data（源数据） —— 务必使用Dense Cloud 密集点云，稀疏点云数据太少，无法生成完整的模型 Face Count（面数） —— 通常都使用最高，确保模型的精细度，后期可以减面 Interpolation（差值） —— 使用默认或者选择Aggressive，目前我发现影响不大 Calculate vertex colors（计算顶点信息） —— 这个不勾选，生成模型就没有颜色 参数调整之后即可点击OK 执行运算 计算完毕之后可以看到模型了 你可以点击这些按钮来切换模型的观察方案 如果模型没有太大的问题就可以进行下一步 Build Map （生成贴图） 参数说明 Mapping Mode（映射类型) —— 选择默认的Generic方式，这里涉及的是UV的展开方式 Blending Mode（混合模式） —— 这里也是使用默认的Mosaic即可，当然也可以选择Average来柔化贴图 Texture Size/Count（贴图大小） —— 默认4K已经够大了 Enable Hole Filling（开启填充洞） —— 默认开启，用来优化模型的破洞 Enable Ghosting Filter（开启重像滤波器） —— 重像就是俗称的画面糊成一团，这可以可以优化贴图效果 确认过参数之后就可以去生成贴图了 生成贴图完毕之后 点击上面的按钮查看贴图生成的效果 我觉得生成的纹理还是非常的不错的 导出模型 导出模型需要对模型右键 选择Export Model… 选择保存的路径 这里会弹出导出设置窗口 参数功能就不一一赘述了，基本上关注一下导出的图片格式即可。另外，比较可惜的是只支持OBJ格式 Maya查看导出的模型 将模型导入Maya当中 可以开启Flat Lighting 获取更好的观感基本上完美还原了模型的细节，达到了真实可靠的效果 从面数上也是挺多的 总结 Photogrammetry软件操作基本流程 通过照片生成稀疏点云 通过稀疏点云计算Depth Map，生成密集点云 通过密集点云计算生成模型 生成贴图 导出模型和贴图 这些操作不适用Agisoft Photoscan，其他照片扫描软件也是一致的。 后记 针对扫描的流程，后面我会再出博文讲解，敬请期待。]]></content>
      <categories>
        <category>Photogrammetry</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/Photogrammetry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Houdini-zplus 教程系列(零)]]></title>
    <url>%2Fposts%2F24208.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;大一的时候我不确定自己能够胜任什么样的CG岗位，所以各个方面都去摸索，探索自己的发展空间。经历一年的磨炼，我发现自己比较适合绑定、特效这些程序化比较偏重的岗位。（说来也是美术不行，又不是美术专业出身，建模、渲染流程会被人吊打） &emsp;&emsp;那个时候群里有从业人员也问过我想要从事的方向，也向我提过学习特效一定一定要学习Houdini，但是自己就跟Maya耗上了，毕竟那个时候是去年10月份左右，工作室还想做一部动画的，需要做烟雾效果，从零开始学Houdini烟雾不太现实，结果快到11月份工作室就解散了，Maya特效做好了收藏夹归类最后也没有看。 &emsp;&emsp;没了工作室真的让我非常沮丧，所以我马不停蹄地去找工作室，恰逢10月份Iseven工作室（师兄和专业老师搭建的工作室）开始招人，虽然我报名截至了，但我还是赶上了末班车。 &emsp;&emsp;在那里，我知道了浩宏他们有个工作坊，专业师兄建议我去他们那里，毕竟他们那边人手不足。 &emsp;&emsp;所以很快，我又有了新的落脚地方。 &emsp;&emsp;安顿好不久后，在特效岗位任职的仲予师兄就在去年12月份的时候回校开了讨论会，这让我很是激动，他的岗位就是我的dream job。 &emsp;&emsp;他当时分享的行业就业分析，就业指导都是满满的干货，但是我却自己却有点束手束脚 (︶︹︺) 。 &emsp;&emsp;那个时候聪哥联系我，让我去研究WebGL，然后我就真的去Lynda和Pluralsight去看教程了，哎，现在想起来这的是个错误，开了坑，渐渐确定WebGL要学习three.js之后，就开始专心专研它，总之后面整个寒假过年前都在聪哥家里研究Three.js去了。 &emsp;&emsp;我真正开始学Houdini是大年三十，那时终于从聪哥家里解脱出来，可以该干嘛干嘛了。 &emsp;&emsp;我又在B站的收藏夹里定了Houdini学习路线，希望通过DT的学习路径来全面了解Houdini。其实这和师兄定的学习计划大相径庭，当然师兄的出发点是好的，第一部教程是中文教程，入门学习sop就和入门学习Maya建模差不多，但是软件的版本差太远了，我学得有点难受，于是我还是坚持自己的判断。 &emsp;&emsp;我安装的Houdini是最新版16.5，DT的教程是15，有点落后，我受不了，所以有找到了Lynda的最新入门教程，所以DT和Lynda的入门都看了一遍。Lynda教程讲得太过宽泛了，毕竟只有一个入门课程，把所有的模块过一遍，对于我这个新手来说，不是特别友好。最后还是DT教程妙啊。 &emsp;&emsp;看了DT教程的前三个系列，入门、RBD、FLIP，过了一遍教程就差不多开学了，后面师兄提到说不要学习太泛，先精通一些部分，再加上师弟学习进度对自己的刺激，最后还是老老实实按照师兄给的进度去学习。 &emsp;&emsp;Sop教程看得我也有点难受，可能自己经历了Maya入门的痛苦吧，以为Houdini也可以像Maya的教程那样看，什么都求快，但是这一次Houdini是快不起来了，基础还不扎实就想飞呀。加上版本落后的问题，看到闪电的部分就退坑了。 &emsp;&emsp;刚好那个时候大家都进入RBD的学习了，我也果断选择跟上进度跳过了好几个教程。 &emsp;&emsp;RBD模块真的是Houdini基础中的基础，师兄的说法是行业70、80%的项目都涉及RBD，RBD教程也比较新，学起来也比较舒服，感觉那个时候学Houdini有点以前学习Maya的感觉了，狂热而兴奋。 &emsp;&emsp;那个看了Applied RBD教程前两季，对RBD有了初始的认识，又看了CGS - Destruction in Houdini 的前面几周，做出了一个带有cone constraint的破碎效果，可能自己也有点飘飘然吧，认为不过如此尔尔。 &emsp;&emsp;再到后面省赛横空出世，把这样的学习状态打断了，为了准备省赛，重心变得模凌两可，最后基本就停了Houdini的学习，专心备赛，毕竟自己也是要上台演讲的。（想不到后面学校还拨经费买了1500+的西装） &emsp;&emsp;想起那个时候也是够忙的，幸亏也没什么重要的课程，就是体育课要请假（害得我太极拳不会打，最后老师给了60多分…..），三维课程上机可以不去，Java课也没上，刚好省赛前天又要考Java，害得我得穿西装去考试，幸好考试还算简单，有C++的基础，加上考前的突击，没啥压力。 &emsp;&emsp;然而最后省赛也只是拿到了银奖，回想起来感觉很可惜，可能自己说得太真实了，把所有的技术都说成了开源的，给评委留下了技术不足的印象吧。没能备战国赛，真的是个遗憾。 &emsp;&emsp;比赛结束之后就开始期末了，陷入了不断赶作业的状态，也确实花了不少时间去弄，比如说数据结构的大作业，当时数据结构考试觉得自己凉凉了，挂科很麻烦，所以就希望通过大作业搬回脸面，但是C++太难学了，有什么好的东西可以通过C++制作出酷炫的数据结构大作业呢？ &emsp;&emsp;我在Lynda上找到了答案，（卧槽，C++游戏制作，卧槽，SFML架构，卧槽,是结合OPENGL的快速框架）图形化界面不是梦啊！ &emsp;&emsp;于是乎那段时间就一个人在新申请的工作室场地里面努力研究SFML，最后还是做出了一个相对完整，自己也比较满意的程序的，课程设计也拿到了A &emsp;&emsp;但是看到同学用QT去做，瞬间觉得自己就是个SB，CG也要用QT开发的，MDZZ，错过了一个极佳的学习机会，不过也算是全面认识了C++面向对象开发的方法吧。 &emsp;&emsp;课程结束之后，又开始张罗工作室的场地，以及后续比赛的一些准备，招募前端团队、准备扫描技术研究，聪哥把各种各样的事情交代给我去弄了，Houdini的事情一拖再拖，学习状态消失了，之前积累的经验也不断忘记。 &emsp;&emsp;现在我猛然回头发现自己竟然开始逃避Houdini了，Houdini学过了RBD但是却忘记得差不多了，又不想从头开一遍教程，于是乎就在这种纠结的状态下，Houdini变得越来越难啃，痛苦呀…… &emsp;&emsp;暑假这段时间是学习的黄金时间，但是最近都在研究Photogrammetry的技术，各种拍照各种测试，没有心情去研究Houdini，晚上回宿舍也是逛逛B站，看看视频，了解一下最新手机、逗鱼时刻之类的，这种状态也不知道怎么形容。 &emsp;&emsp;聪哥的发展路线明显已经和我心中所想要的不一致了，但是在创业和梦想面前，自己始终摇摆不定，立场不够坚定，前段时间建模团队还没有过来的时候，自己研究Photogrammetry 卡住了，有些东西没有办法解决，也没有人来帮我，就很沮丧、很痛苦，所以就疯狂看CG的教程，可是houdini还是选择了逃避。 &emsp;&emsp;最后我选择去看各种CG教程，因为那个时候和仲予师兄讨论之后，得出我比较适合流程TD，所以我就开了Gnomon workshop 的Zbrush 4R8教程，虽然不打算深入学习Zbrush，但是至少要了解Zbrush有哪些好的功能值得自己去认识。 &emsp;&emsp;也确实从那个教程了解了很多东西，dynamesh、Nano、Spotlight、PolyPaint等等都是些非常实用的功能。 &emsp;&emsp;后面也看了Gnomon workshop 关于Maya2018 展UV的教程，这样的教程存在本身就是错误，MDZZ，讲师都解决不了问题，用最傻的方案去测到底哪里出问题了，简直是让人弃坑的最佳教程。 &emsp;&emsp;再到后面又和仲予师兄讨论之后，得出还是绑定TD比较适合我，毕竟自己大一有了不错的基础了。所以后面我又去补了Python的基础，因为之前有编程经验，学习也很快。 &emsp;&emsp;在后面，建模团队终于来了，Photogrammetry的进度突飞猛进，然后我的重心又变了。 &emsp;&emsp;这几天不断弄博客，记录Photogrammetry踩的坑和流程，也是因为研究这个没有时间和精力（还有因为自己懒）去看CG教程了。 &emsp;&emsp;明天就要去清远雅堂村去扫描文物了，自己一个人在工作室不学习，写博客，心情真的有点复杂，前几天还是努力让自己重看了Applied RBD教程第一季，本来想把总结写在这篇博文里面的，殊不知这篇博文就差不都成了我大二生活的全程回顾了。 &emsp;&emsp;创业和梦想的冲突，脚踏两条船的我感觉很难受啊！~ &emsp;&emsp;自己的内心还是向往着梦想的工作的，毕竟快乐才是首要的前提，但是在人生的分叉路口面前，真的是一步差之毫厘，失之千里，自己仍然在犹豫，在权衡。 &emsp;&emsp;但是这种情况不能再继续下去了，否则后果很严重，目前还是没有想好如何向聪哥开口…… &emsp;&emsp;有种船到桥头自然直的心态吧……]]></content>
      <categories>
        <category>CG</category>
        <category>Houdini</category>
        <category>教程笔记</category>
        <category>zplus 教程系列</category>
      </categories>
      <tags>
        <tag>🧐回顾</tag>
        <tag>ࠁHoudini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Photogrammetry 学习之路（一）]]></title>
    <url>%2Fposts%2F7485.html</url>
    <content type="text"><![CDATA[&emsp;&emsp;今年3月份的时候，正是我大二的寒假，师兄让我去研究照片扫描技术，并且推荐了一款软件3DF Zephyr，但是这款软件的教程太少了，经过我的调查，我发现Agisoft Photoscan是目前比较成熟的软件，就这样我就进了Photogrammetry的大坑。 &emsp;&emsp; Photogrammetry是什么呢？正如上面的软件介绍一样，它是一种通过一系列的照片还原三维模型的技术。 &emsp;&emsp; 那Photogrammetry有什么优点，对比目前市场上的其他扫描技术又有什么优势和劣势呢？ Photogrammetry的优点 通过照片生成模型和纹理，细节丰富到令人发指，模型细腻 生成速度快，操作相对简单 制作成本低，甚至可以用手机拍照完成流程 支持扫描大型物体，甚至是航拍地图 Photogrammetry的缺点 无法处理颜色大规模统一的物体（影响图片识别） 无法处理随着角度变化的强烈高光（影响图片识别） 无法处理透明材质（影响图片识别） 无法处理多重相似的图案（影响图片识别） 细小的物体难以生成高质量的模型 不均匀的光线分布会影响扫描的效果 拍摄多角度扫描素材比较繁琐 Photogrammetry与激光扫描的技术对比 激光扫描的模型精度与Photogrammetry不相上下 激光扫描可以解决Photogrammetry因为图片识别而无法扫描的硬伤 高规格的激光扫描方可识别颜色，成本很高 激光扫描难以胜任大型物体扫描，特别是航拍 软件下载3DF Zephyr 链接: https://pan.baidu.com/s/1Rz66Ui1VNWtKZeVh55scmg 密码: xnwn Agisoft Photoscan 链接: https://pan.baidu.com/s/1eZlWmDIxRNGhM0ZVnpWAQQ 密码: g3ne Photogrammetry软件操作前期基本流程软件安装 打开软件安装包，直接安装。然后将破解文件覆盖快捷方式的启动程序。 启动程序即可看到软件界面 正式使用之前务必先打开首选项 首选项这里可以修改语言模式 不习惯英语的可以修改为中文，在下还是依然使用英文。 另外去到GPU的标签 务必开启CUDA显卡加速 开启之后你就能体验飞一样的感觉（GPU运算速度是CPU的好几倍） 原谅我的垃圾手提电脑，N卡940M太低端无法识别 基本流程点击打开workflow 截图上的操作就是Photogrammetry的基本流程 我们需要一步一步去完成操作 Align Photos (对齐照片) 这里有几个参数需要注意 Acurray（识别精度） —— 不建议太高，太高会很慢。我一般选择Medium Generic Preselection（常用预选） —— 对图片序列识别进行优化，通常都勾选 Key Point Limit（关键点上限）—— 建议为0，就是不设上限 Tie Point Limit（点云上限） —— 同样建议为0，就是不设上限 Adapt Camera model fitting（适应摄像机的位置）—— 一般都要勾选，特别是应用蒙版的情况 设置完成即可运行操作 识别完成之后会生成sparse cloud（稀疏点云） 比较成功的识别结果（图片识别规整) 比较失败的识别结果（图片错位) 图片错位的原因 Align Photos 的识别精度太低了或太高了 照片存在模糊、距离不一、角度偏移等问题 物体上存在Photogrammetry无法解决的硬伤 Build Dense Cloud （生成密集点云） 参数说明 Quality（质量） —— 不建议太高，太高会很慢。我一般选择Medium Depth filtering（深度过滤） —— 一般为Aggressive或者默认参数 Calculate point colors（计算顶点颜色） —— 这个务必要勾选，否则生成模型没有颜色 只要一开始的 sparse cloud 没有太大问题，那么密集点云的步骤也比较顺利这个步骤需要比较长的运算时间 在生成的过程中软件会生成Depth Map来重新构建照片的深度，从而奠定立体生成的基础（这个需要中断生成步骤才可以看到） 根据流程生成完毕是这样子的（这个效果是建立在Sparse Cloud的基础上的） 总结 Photogrammetry软件操作前期流程 通过照片生成稀疏点云 通过稀疏点云计算Depth Map，生成密集点云]]></content>
      <categories>
        <category>Photogrammetry</category>
      </categories>
      <tags>
        <tag>🇨🇬CG/Photogrammetry</tag>
      </tags>
  </entry>
</search>
